"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./components/Starfield.jsx":
/*!**********************************!*\
  !*** ./components/Starfield.jsx ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar _s = $RefreshSig$();\n\n\nconst Starfield = ()=>{\n    _s();\n    const mountRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const mount = mountRef.current;\n        mount.style.position = \"fixed\";\n        mount.style.top = \"0\";\n        mount.style.left = \"0\";\n        mount.style.width = \"100%\";\n        mount.style.height = \"100%\";\n        mount.style.zIndex = \"-1\";\n        // Scene & Renderer\n        const scene = new three__WEBPACK_IMPORTED_MODULE_2__.Scene();\n        const camera = new three__WEBPACK_IMPORTED_MODULE_2__.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);\n        const renderer = new three__WEBPACK_IMPORTED_MODULE_2__.WebGLRenderer({\n            antialias: true\n        });\n        renderer.setPixelRatio(window.devicePixelRatio);\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        mount.appendChild(renderer.domElement);\n        // Starfield\n        const starCount = 10000;\n        const starMaxDistance = 1000;\n        const starSpeed = 1;\n        const geometry = new three__WEBPACK_IMPORTED_MODULE_2__.BufferGeometry();\n        const positions = [];\n        for(let i = 0; i < starCount; i++){\n            const theta = Math.random() * 2 * Math.PI;\n            const phi = Math.acos(2 * Math.random() - 1);\n            const r = Math.random() * starMaxDistance;\n            positions.push(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));\n        }\n        geometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_2__.Float32BufferAttribute(positions, 3));\n        const palette = [\n            [\n                1.0,\n                0.5,\n                0.5\n            ],\n            [\n                1.0,\n                0.75,\n                0.4\n            ],\n            [\n                1.0,\n                1.0,\n                0.9\n            ],\n            [\n                1.0,\n                1.0,\n                1.0\n            ],\n            [\n                0.4,\n                0.5,\n                1.0\n            ]\n        ];\n        const colors = [];\n        for(let i = 0; i < starCount; i++){\n            const c = palette[Math.floor(Math.random() * palette.length)];\n            colors.push(...c);\n        }\n        geometry.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_2__.Float32BufferAttribute(colors, 3));\n        const originalColors = geometry.attributes.color.array.slice();\n        const timers = new Float32Array(starCount);\n        const sparkColors = new Float32Array(starCount * 3);\n        const sparkleDuration = 180;\n        const material = new three__WEBPACK_IMPORTED_MODULE_2__.PointsMaterial({\n            size: 1,\n            sizeAttenuation: true,\n            vertexColors: true\n        });\n        const stars = new three__WEBPACK_IMPORTED_MODULE_2__.Points(geometry, material);\n        scene.add(stars);\n        let targetY = 0;\n        const damping = 0.05;\n        const onScroll = ()=>{\n            const pct = window.scrollY / (document.body.scrollHeight - window.innerHeight);\n            targetY = pct * Math.PI * 2;\n        };\n        window.addEventListener(\"scroll\", onScroll);\n        const tailLength = 50;\n        const shootingStars = [];\n        let shootingStarCooldown = 0; // Prevent too many at once\n        // Enhanced shooting star effect\n        function spawnShootingStar() {\n            // Spawn farther away from camera, in the distance\n            const distance = starMaxDistance * 0.8 + Math.random() * starMaxDistance * 0.2;\n            const theta = Math.random() * 2 * Math.PI;\n            const phi = Math.acos(2 * Math.random() - 1);\n            const startPos = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(distance * Math.sin(phi) * Math.cos(theta), distance * Math.sin(phi) * Math.sin(theta), distance * Math.cos(phi));\n            // Ensure direction is always away from camera\n            // Direction = (startPos - camera.position) + some random perpendicular jitter\n            const away = startPos.clone().sub(camera.position).normalize();\n            // Add a small random perpendicular component for variety\n            let perp = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1);\n            perp = perp.sub(perp.clone().projectOnVector(away)).normalize();\n            const dir = away.clone().add(perp.multiplyScalar(Math.random() * 0.5)).normalize();\n            // Make the speed much slower\n            const speed = starSpeed * (10 + Math.random() * 10); // 10-20 units per frame\n            const geo = new three__WEBPACK_IMPORTED_MODULE_2__.SphereGeometry(1, 8, 8); // Smaller, more distant\n            const mat = new three__WEBPACK_IMPORTED_MODULE_2__.MeshBasicMaterial({\n                color: 0xffffee,\n                emissive: 0xffffee,\n                emissiveIntensity: 2\n            });\n            const star = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(geo, mat);\n            star.position.copy(startPos);\n            star.velocity = dir.clone().multiplyScalar(speed);\n            star.life = 1.0;\n            // Pretty, glowing tail using points (sprites) instead of a line\n            const tailLen = 200 + Math.random() * 100;\n            const tailSegments = 24;\n            const tailPoints = [];\n            const tailColors = [];\n            for(let i = 0; i < tailSegments; i++){\n                // Position along the tail\n                const t = i / (tailSegments - 1);\n                // Position fades away from the star\n                tailPoints.push(dir.clone().negate().multiplyScalar(tailLen * t));\n                // Color/alpha: bright at head, fades at tail\n                const alpha = (1 - t) * 0.7;\n                // Soft yellow-white gradient\n                tailColors.push(1.0, 1.0, 0.85, alpha);\n            }\n            const tailGeo = new three__WEBPACK_IMPORTED_MODULE_2__.BufferGeometry();\n            tailGeo.setFromPoints(tailPoints);\n            tailGeo.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_2__.Float32BufferAttribute(tailColors, 4));\n            // Use a round sprite for each point\n            const sprite = new three__WEBPACK_IMPORTED_MODULE_2__.TextureLoader().load(\"https://cdn.jsdelivr.net/gh/mrdoob/three.js@master/examples/textures/sprites/circle.png\");\n            const tailMat = new three__WEBPACK_IMPORTED_MODULE_2__.PointsMaterial({\n                size: 16,\n                map: sprite,\n                vertexColors: true,\n                transparent: true,\n                depthWrite: false,\n                blending: three__WEBPACK_IMPORTED_MODULE_2__.AdditiveBlending\n            });\n            const tail = new three__WEBPACK_IMPORTED_MODULE_2__.Points(tailGeo, tailMat);\n            tail.position.copy(star.position);\n            tail.life = 1.0;\n            scene.add(star);\n            scene.add(tail);\n            shootingStars.push({\n                mesh: star,\n                tail,\n                velocity: star.velocity,\n                dir,\n                fade: false,\n                tailPoints\n            });\n        }\n        const animate = ()=>{\n            requestAnimationFrame(animate);\n            camera.rotation.y += (targetY - camera.rotation.y) * damping;\n            camera.translateZ(-starSpeed);\n            // Spawn shooting star occasionally, but not too frequently\n            // Decrease shooting star frequency for a more subtle effect\n            if (shootingStarCooldown <= 0 && Math.random() < 0.05) {\n                spawnShootingStar();\n                shootingStarCooldown = 30 + Math.random() * 40; // 0.5-1.2 seconds\n            } else if (shootingStarCooldown > 0) {\n                shootingStarCooldown--;\n            }\n            const posArr = geometry.attributes.position.array;\n            const sqDist = starMaxDistance * starMaxDistance;\n            for(let i = 0; i < posArr.length; i += 3){\n                const dx = posArr[i] - camera.position.x;\n                const dy = posArr[i + 1] - camera.position.y;\n                const dz = posArr[i + 2] - camera.position.z;\n                if (dx * dx + dy * dy + dz * dz > sqDist) {\n                    const theta = Math.random() * 2 * Math.PI;\n                    const phi = Math.acos(2 * Math.random() - 1);\n                    posArr[i] = camera.position.x + starMaxDistance * Math.sin(phi) * Math.cos(theta);\n                    posArr[i + 1] = camera.position.y + starMaxDistance * Math.sin(phi) * Math.sin(theta);\n                    posArr[i + 2] = camera.position.z + starMaxDistance * Math.cos(phi);\n                }\n            }\n            geometry.attributes.position.needsUpdate = true;\n            const colArr = geometry.attributes.color.array;\n            for(let i = 0; i < posArr.length; i += 3){\n                const idx = i / 3;\n                const dist = Math.sqrt(posArr[i] * posArr[i] + posArr[i + 1] * posArr[i + 1] + posArr[i + 2] * posArr[i + 2]);\n                if (timers[idx] > 0) timers[idx]--;\n                else if (dist > starMaxDistance * 0.3 && Math.random() < 0.05) {\n                    timers[idx] = sparkleDuration;\n                    const c = palette[Math.floor(Math.random() * palette.length)];\n                    sparkColors[i] = c[0];\n                    sparkColors[i + 1] = c[1];\n                    sparkColors[i + 2] = c[2];\n                }\n                if (timers[idx] > 0) {\n                    colArr[i] = sparkColors[i];\n                    colArr[i + 1] = sparkColors[i + 1];\n                    colArr[i + 2] = sparkColors[i + 2];\n                } else {\n                    colArr[i] = originalColors[i];\n                    colArr[i + 1] = originalColors[i + 1];\n                    colArr[i + 2] = originalColors[i + 2];\n                }\n            }\n            geometry.attributes.color.needsUpdate = true;\n            stars.rotation.x += 0.0001;\n            stars.rotation.y += 0.00015;\n            // Remove extra random spawn for shooting stars\n            // (no additional random spawns, only above logic)\n            for(let i = shootingStars.length - 1; i >= 0; i--){\n                const obj = shootingStars[i];\n                // Move shooting star in world space, independent of camera\n                obj.mesh.position.add(obj.velocity);\n                // Update tail points to follow star's path in world space\n                for(let j = obj.tailPoints.length - 1; j > 0; j--){\n                    obj.tailPoints[j].copy(obj.tailPoints[j - 1]);\n                }\n                obj.tailPoints[0] = obj.mesh.position.clone();\n                obj.tail.geometry.setFromPoints(obj.tailPoints);\n                // Update tail alpha gradient\n                const colors = obj.tail.geometry.attributes.color.array;\n                for(let j = 0; j < obj.tailPoints.length; j++){\n                    // Alpha fades out with both tail position and star life\n                    colors[j * 4 + 3] = (1 - j / (obj.tailPoints.length - 1)) * 0.7 * Math.max(0, obj.mesh.life);\n                }\n                obj.tail.geometry.attributes.color.needsUpdate = true;\n                obj.tail.position.set(0, 0, 0); // tail points are absolute\n                obj.tail.life -= 0.01;\n                obj.mesh.life -= 0.01;\n                // Fade the tail smoothly based on life\n                obj.tail.material.opacity = 1.0;\n                if (obj.mesh.life <= 0) {\n                    scene.remove(obj.mesh);\n                    scene.remove(obj.tail);\n                    shootingStars.splice(i, 1);\n                }\n            }\n            const cam = camera.position.clone();\n            for(let i = 0; i < posArr.length; i += 3){\n                posArr[i] -= cam.x;\n                posArr[i + 1] -= cam.y;\n                posArr[i + 2] -= cam.z;\n            }\n            geometry.attributes.position.needsUpdate = true;\n            shootingStars.forEach((obj)=>{\n                obj.mesh.position.sub(cam);\n                obj.tail.position.sub(cam);\n            });\n            camera.position.set(0, 0, 0);\n            renderer.render(scene, camera);\n        };\n        animate();\n        const onResize = ()=>{\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        };\n        window.addEventListener(\"resize\", onResize);\n        return ()=>{\n            window.removeEventListener(\"scroll\", onScroll);\n            window.removeEventListener(\"resize\", onResize);\n            mount.removeChild(renderer.domElement);\n        };\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: mountRef\n    }, void 0, false, {\n        fileName: \"/home/kayosdev/Websites/Portfolio/components/Starfield.jsx\",\n        lineNumber: 249,\n        columnNumber: 10\n    }, undefined);\n};\n_s(Starfield, \"V9/qkEdV8GfsDZk7lMTA1T8g5Ps=\");\n_c = Starfield;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Starfield);\nvar _c;\n$RefreshReg$(_c, \"Starfield\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Y2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9TdGFyZmllbGQuanN4P2YxYTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSdcblxuY29uc3QgU3RhcmZpZWxkID0gKCkgPT4ge1xuICBjb25zdCBtb3VudFJlZiA9IHVzZVJlZihudWxsKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgbW91bnQgPSBtb3VudFJlZi5jdXJyZW50XG4gICAgbW91bnQuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnXG4gICAgbW91bnQuc3R5bGUudG9wID0gJzAnXG4gICAgbW91bnQuc3R5bGUubGVmdCA9ICcwJ1xuICAgIG1vdW50LnN0eWxlLndpZHRoID0gJzEwMCUnXG4gICAgbW91bnQuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnXG4gICAgbW91bnQuc3R5bGUuekluZGV4ID0gJy0xJ1xuXG4gICAgLy8gU2NlbmUgJiBSZW5kZXJlclxuICAgIGNvbnN0IHNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKClcbiAgICBjb25zdCBjYW1lcmEgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoNzUsIHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmlubmVySGVpZ2h0LCAwLjEsIDUwMDApXG4gICAgY29uc3QgcmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcih7IGFudGlhbGlhczogdHJ1ZSB9KVxuICAgIHJlbmRlcmVyLnNldFBpeGVsUmF0aW8od2luZG93LmRldmljZVBpeGVsUmF0aW8pXG4gICAgcmVuZGVyZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KVxuICAgIG1vdW50LmFwcGVuZENoaWxkKHJlbmRlcmVyLmRvbUVsZW1lbnQpXG5cbiAgICAvLyBTdGFyZmllbGRcbiAgICBjb25zdCBzdGFyQ291bnQgPSAxMDAwMFxuICAgIGNvbnN0IHN0YXJNYXhEaXN0YW5jZSA9IDEwMDBcbiAgICBjb25zdCBzdGFyU3BlZWQgPSAxXG4gICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKVxuICAgIGNvbnN0IHBvc2l0aW9ucyA9IFtdXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFyQ291bnQ7IGkrKykge1xuICAgICAgY29uc3QgdGhldGEgPSBNYXRoLnJhbmRvbSgpICogMiAqIE1hdGguUElcbiAgICAgIGNvbnN0IHBoaSA9IE1hdGguYWNvcygyICogTWF0aC5yYW5kb20oKSAtIDEpXG4gICAgICBjb25zdCByID0gTWF0aC5yYW5kb20oKSAqIHN0YXJNYXhEaXN0YW5jZVxuICAgICAgcG9zaXRpb25zLnB1c2goXG4gICAgICAgIHIgKiBNYXRoLnNpbihwaGkpICogTWF0aC5jb3ModGhldGEpLFxuICAgICAgICByICogTWF0aC5zaW4ocGhpKSAqIE1hdGguc2luKHRoZXRhKSxcbiAgICAgICAgciAqIE1hdGguY29zKHBoaSlcbiAgICAgIClcbiAgICB9XG4gICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBUSFJFRS5GbG9hdDMyQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9ucywgMykpXG5cbiAgICBjb25zdCBwYWxldHRlID0gW1xuICAgICAgWzEuMCwgMC41LCAwLjVdLFxuICAgICAgWzEuMCwgMC43NSwgMC40XSxcbiAgICAgIFsxLjAsIDEuMCwgMC45XSxcbiAgICAgIFsxLjAsIDEuMCwgMS4wXSxcbiAgICAgIFswLjQsIDAuNSwgMS4wXSxcbiAgICBdXG4gICAgY29uc3QgY29sb3JzID0gW11cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXJDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBjID0gcGFsZXR0ZVtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBwYWxldHRlLmxlbmd0aCldXG4gICAgICBjb2xvcnMucHVzaCguLi5jKVxuICAgIH1cbiAgICBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2NvbG9yJywgbmV3IFRIUkVFLkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoY29sb3JzLCAzKSlcblxuICAgIGNvbnN0IG9yaWdpbmFsQ29sb3JzID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvci5hcnJheS5zbGljZSgpXG4gICAgY29uc3QgdGltZXJzID0gbmV3IEZsb2F0MzJBcnJheShzdGFyQ291bnQpXG4gICAgY29uc3Qgc3BhcmtDb2xvcnMgPSBuZXcgRmxvYXQzMkFycmF5KHN0YXJDb3VudCAqIDMpXG4gICAgY29uc3Qgc3BhcmtsZUR1cmF0aW9uID0gMTgwXG5cbiAgICBjb25zdCBtYXRlcmlhbCA9IG5ldyBUSFJFRS5Qb2ludHNNYXRlcmlhbCh7IHNpemU6IDEsIHNpemVBdHRlbnVhdGlvbjogdHJ1ZSwgdmVydGV4Q29sb3JzOiB0cnVlIH0pXG4gICAgY29uc3Qgc3RhcnMgPSBuZXcgVEhSRUUuUG9pbnRzKGdlb21ldHJ5LCBtYXRlcmlhbClcbiAgICBzY2VuZS5hZGQoc3RhcnMpXG5cbiAgICBsZXQgdGFyZ2V0WSA9IDBcbiAgICBjb25zdCBkYW1waW5nID0gMC4wNVxuICAgIGNvbnN0IG9uU2Nyb2xsID0gKCkgPT4ge1xuICAgICAgY29uc3QgcGN0ID0gd2luZG93LnNjcm9sbFkgLyAoZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQgLSB3aW5kb3cuaW5uZXJIZWlnaHQpXG4gICAgICB0YXJnZXRZID0gcGN0ICogTWF0aC5QSSAqIDJcbiAgICB9XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIG9uU2Nyb2xsKVxuXG4gICAgY29uc3QgdGFpbExlbmd0aCA9IDUwXG4gICAgY29uc3Qgc2hvb3RpbmdTdGFycyA9IFtdXG4gICAgbGV0IHNob290aW5nU3RhckNvb2xkb3duID0gMDsgLy8gUHJldmVudCB0b28gbWFueSBhdCBvbmNlXG4gICAgLy8gRW5oYW5jZWQgc2hvb3Rpbmcgc3RhciBlZmZlY3RcbiAgICBmdW5jdGlvbiBzcGF3blNob290aW5nU3RhcigpIHtcbiAgICAgIC8vIFNwYXduIGZhcnRoZXIgYXdheSBmcm9tIGNhbWVyYSwgaW4gdGhlIGRpc3RhbmNlXG4gICAgICBjb25zdCBkaXN0YW5jZSA9IHN0YXJNYXhEaXN0YW5jZSAqIDAuOCArIE1hdGgucmFuZG9tKCkgKiBzdGFyTWF4RGlzdGFuY2UgKiAwLjI7XG4gICAgICBjb25zdCB0aGV0YSA9IE1hdGgucmFuZG9tKCkgKiAyICogTWF0aC5QSTtcbiAgICAgIGNvbnN0IHBoaSA9IE1hdGguYWNvcygyICogTWF0aC5yYW5kb20oKSAtIDEpO1xuICAgICAgY29uc3Qgc3RhcnRQb3MgPSBuZXcgVEhSRUUuVmVjdG9yMyhcbiAgICAgICAgZGlzdGFuY2UgKiBNYXRoLnNpbihwaGkpICogTWF0aC5jb3ModGhldGEpLFxuICAgICAgICBkaXN0YW5jZSAqIE1hdGguc2luKHBoaSkgKiBNYXRoLnNpbih0aGV0YSksXG4gICAgICAgIGRpc3RhbmNlICogTWF0aC5jb3MocGhpKVxuICAgICAgKTtcbiAgICAgIC8vIEVuc3VyZSBkaXJlY3Rpb24gaXMgYWx3YXlzIGF3YXkgZnJvbSBjYW1lcmFcbiAgICAgIC8vIERpcmVjdGlvbiA9IChzdGFydFBvcyAtIGNhbWVyYS5wb3NpdGlvbikgKyBzb21lIHJhbmRvbSBwZXJwZW5kaWN1bGFyIGppdHRlclxuICAgICAgY29uc3QgYXdheSA9IHN0YXJ0UG9zLmNsb25lKCkuc3ViKGNhbWVyYS5wb3NpdGlvbikubm9ybWFsaXplKCk7XG4gICAgICAvLyBBZGQgYSBzbWFsbCByYW5kb20gcGVycGVuZGljdWxhciBjb21wb25lbnQgZm9yIHZhcmlldHlcbiAgICAgIGxldCBwZXJwID0gbmV3IFRIUkVFLlZlY3RvcjMoTWF0aC5yYW5kb20oKSoyLTEsIE1hdGgucmFuZG9tKCkqMi0xLCBNYXRoLnJhbmRvbSgpKjItMSk7XG4gICAgICBwZXJwID0gcGVycC5zdWIocGVycC5jbG9uZSgpLnByb2plY3RPblZlY3Rvcihhd2F5KSkubm9ybWFsaXplKCk7XG4gICAgICBjb25zdCBkaXIgPSBhd2F5LmNsb25lKCkuYWRkKHBlcnAubXVsdGlwbHlTY2FsYXIoTWF0aC5yYW5kb20oKSAqIDAuNSkpLm5vcm1hbGl6ZSgpO1xuICAgICAgLy8gTWFrZSB0aGUgc3BlZWQgbXVjaCBzbG93ZXJcbiAgICAgIGNvbnN0IHNwZWVkID0gc3RhclNwZWVkICogKDEwICsgTWF0aC5yYW5kb20oKSAqIDEwKTsgLy8gMTAtMjAgdW5pdHMgcGVyIGZyYW1lXG4gICAgICBjb25zdCBnZW8gPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoMSwgOCwgOCk7IC8vIFNtYWxsZXIsIG1vcmUgZGlzdGFudFxuICAgICAgY29uc3QgbWF0ID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHsgY29sb3I6IDB4ZmZmZmVlLCBlbWlzc2l2ZTogMHhmZmZmZWUsIGVtaXNzaXZlSW50ZW5zaXR5OiAyIH0pO1xuICAgICAgY29uc3Qgc3RhciA9IG5ldyBUSFJFRS5NZXNoKGdlbywgbWF0KTtcbiAgICAgIHN0YXIucG9zaXRpb24uY29weShzdGFydFBvcyk7XG4gICAgICBzdGFyLnZlbG9jaXR5ID0gZGlyLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoc3BlZWQpO1xuICAgICAgc3Rhci5saWZlID0gMS4wO1xuXG4gICAgICAvLyBQcmV0dHksIGdsb3dpbmcgdGFpbCB1c2luZyBwb2ludHMgKHNwcml0ZXMpIGluc3RlYWQgb2YgYSBsaW5lXG4gICAgICBjb25zdCB0YWlsTGVuID0gMjAwICsgTWF0aC5yYW5kb20oKSAqIDEwMDtcbiAgICAgIGNvbnN0IHRhaWxTZWdtZW50cyA9IDI0O1xuICAgICAgY29uc3QgdGFpbFBvaW50cyA9IFtdO1xuICAgICAgY29uc3QgdGFpbENvbG9ycyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWlsU2VnbWVudHM7IGkrKykge1xuICAgICAgICAvLyBQb3NpdGlvbiBhbG9uZyB0aGUgdGFpbFxuICAgICAgICBjb25zdCB0ID0gaSAvICh0YWlsU2VnbWVudHMgLSAxKTtcbiAgICAgICAgLy8gUG9zaXRpb24gZmFkZXMgYXdheSBmcm9tIHRoZSBzdGFyXG4gICAgICAgIHRhaWxQb2ludHMucHVzaChkaXIuY2xvbmUoKS5uZWdhdGUoKS5tdWx0aXBseVNjYWxhcih0YWlsTGVuICogdCkpO1xuICAgICAgICAvLyBDb2xvci9hbHBoYTogYnJpZ2h0IGF0IGhlYWQsIGZhZGVzIGF0IHRhaWxcbiAgICAgICAgY29uc3QgYWxwaGEgPSAoMSAtIHQpICogMC43O1xuICAgICAgICAvLyBTb2Z0IHllbGxvdy13aGl0ZSBncmFkaWVudFxuICAgICAgICB0YWlsQ29sb3JzLnB1c2goMS4wLCAxLjAsIDAuODUsIGFscGhhKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhaWxHZW8gPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcbiAgICAgIHRhaWxHZW8uc2V0RnJvbVBvaW50cyh0YWlsUG9pbnRzKTtcbiAgICAgIHRhaWxHZW8uc2V0QXR0cmlidXRlKCdjb2xvcicsIG5ldyBUSFJFRS5GbG9hdDMyQnVmZmVyQXR0cmlidXRlKHRhaWxDb2xvcnMsIDQpKTtcbiAgICAgIC8vIFVzZSBhIHJvdW5kIHNwcml0ZSBmb3IgZWFjaCBwb2ludFxuICAgICAgY29uc3Qgc3ByaXRlID0gbmV3IFRIUkVFLlRleHR1cmVMb2FkZXIoKS5sb2FkKCdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvZ2gvbXJkb29iL3RocmVlLmpzQG1hc3Rlci9leGFtcGxlcy90ZXh0dXJlcy9zcHJpdGVzL2NpcmNsZS5wbmcnKTtcbiAgICAgIGNvbnN0IHRhaWxNYXQgPSBuZXcgVEhSRUUuUG9pbnRzTWF0ZXJpYWwoe1xuICAgICAgICBzaXplOiAxNixcbiAgICAgICAgbWFwOiBzcHJpdGUsXG4gICAgICAgIHZlcnRleENvbG9yczogdHJ1ZSxcbiAgICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXG4gICAgICAgIGRlcHRoV3JpdGU6IGZhbHNlLFxuICAgICAgICBibGVuZGluZzogVEhSRUUuQWRkaXRpdmVCbGVuZGluZyxcbiAgICAgIH0pO1xuICAgICAgY29uc3QgdGFpbCA9IG5ldyBUSFJFRS5Qb2ludHModGFpbEdlbywgdGFpbE1hdCk7XG4gICAgICB0YWlsLnBvc2l0aW9uLmNvcHkoc3Rhci5wb3NpdGlvbik7XG4gICAgICB0YWlsLmxpZmUgPSAxLjA7XG4gICAgICBzY2VuZS5hZGQoc3Rhcik7XG4gICAgICBzY2VuZS5hZGQodGFpbCk7XG4gICAgICBzaG9vdGluZ1N0YXJzLnB1c2goeyBtZXNoOiBzdGFyLCB0YWlsLCB2ZWxvY2l0eTogc3Rhci52ZWxvY2l0eSwgZGlyLCBmYWRlOiBmYWxzZSwgdGFpbFBvaW50cyB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBhbmltYXRlID0gKCkgPT4ge1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpXG4gICAgICBjYW1lcmEucm90YXRpb24ueSArPSAodGFyZ2V0WSAtIGNhbWVyYS5yb3RhdGlvbi55KSAqIGRhbXBpbmdcbiAgICAgIGNhbWVyYS50cmFuc2xhdGVaKC1zdGFyU3BlZWQpXG5cbiAgICAgIC8vIFNwYXduIHNob290aW5nIHN0YXIgb2NjYXNpb25hbGx5LCBidXQgbm90IHRvbyBmcmVxdWVudGx5XG4gICAgICAvLyBEZWNyZWFzZSBzaG9vdGluZyBzdGFyIGZyZXF1ZW5jeSBmb3IgYSBtb3JlIHN1YnRsZSBlZmZlY3RcbiAgICAgIGlmIChzaG9vdGluZ1N0YXJDb29sZG93biA8PSAwICYmIE1hdGgucmFuZG9tKCkgPCAwLjA1KSB7IC8vIDUlIGNoYW5jZSBwZXIgZnJhbWVcbiAgICAgICAgc3Bhd25TaG9vdGluZ1N0YXIoKTtcbiAgICAgICAgc2hvb3RpbmdTdGFyQ29vbGRvd24gPSAzMCArIE1hdGgucmFuZG9tKCkgKiA0MDsgLy8gMC41LTEuMiBzZWNvbmRzXG4gICAgICB9IGVsc2UgaWYgKHNob290aW5nU3RhckNvb2xkb3duID4gMCkge1xuICAgICAgICBzaG9vdGluZ1N0YXJDb29sZG93bi0tO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwb3NBcnIgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5XG4gICAgICBjb25zdCBzcURpc3QgPSBzdGFyTWF4RGlzdGFuY2UgKiBzdGFyTWF4RGlzdGFuY2VcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zQXJyLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIGNvbnN0IGR4ID0gcG9zQXJyW2ldIC0gY2FtZXJhLnBvc2l0aW9uLnhcbiAgICAgICAgY29uc3QgZHkgPSBwb3NBcnJbaSArIDFdIC0gY2FtZXJhLnBvc2l0aW9uLnlcbiAgICAgICAgY29uc3QgZHogPSBwb3NBcnJbaSArIDJdIC0gY2FtZXJhLnBvc2l0aW9uLnpcbiAgICAgICAgaWYgKGR4KmR4ICsgZHkqZHkgKyBkeipkeiA+IHNxRGlzdCkge1xuICAgICAgICAgIGNvbnN0IHRoZXRhID0gTWF0aC5yYW5kb20oKSAqIDIgKiBNYXRoLlBJXG4gICAgICAgICAgY29uc3QgcGhpID0gTWF0aC5hY29zKDIgKiBNYXRoLnJhbmRvbSgpIC0gMSlcbiAgICAgICAgICBwb3NBcnJbaV0gPSBjYW1lcmEucG9zaXRpb24ueCArIHN0YXJNYXhEaXN0YW5jZSAqIE1hdGguc2luKHBoaSkgKiBNYXRoLmNvcyh0aGV0YSlcbiAgICAgICAgICBwb3NBcnJbaSsxXSA9IGNhbWVyYS5wb3NpdGlvbi55ICsgc3Rhck1heERpc3RhbmNlICogTWF0aC5zaW4ocGhpKSAqIE1hdGguc2luKHRoZXRhKVxuICAgICAgICAgIHBvc0FycltpKzJdID0gY2FtZXJhLnBvc2l0aW9uLnogKyBzdGFyTWF4RGlzdGFuY2UgKiBNYXRoLmNvcyhwaGkpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlXG5cbiAgICAgIGNvbnN0IGNvbEFyciA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3IuYXJyYXlcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zQXJyLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IGkvM1xuICAgICAgICBjb25zdCBkaXN0ID0gTWF0aC5zcXJ0KHBvc0FycltpXSpwb3NBcnJbaV0gKyBwb3NBcnJbaSsxXSpwb3NBcnJbaSsxXSArIHBvc0FycltpKzJdKnBvc0FycltpKzJdKVxuICAgICAgICBpZiAodGltZXJzW2lkeF0gPiAwKSB0aW1lcnNbaWR4XS0tXG4gICAgICAgIGVsc2UgaWYgKGRpc3QgPiBzdGFyTWF4RGlzdGFuY2UqMC4zICYmIE1hdGgucmFuZG9tKCkgPCAwLjA1KSB7XG4gICAgICAgICAgdGltZXJzW2lkeF0gPSBzcGFya2xlRHVyYXRpb25cbiAgICAgICAgICBjb25zdCBjID0gcGFsZXR0ZVtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqcGFsZXR0ZS5sZW5ndGgpXVxuICAgICAgICAgIHNwYXJrQ29sb3JzW2ldID0gY1swXTsgc3BhcmtDb2xvcnNbaSsxXSA9IGNbMV07IHNwYXJrQ29sb3JzW2krMl0gPSBjWzJdXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpbWVyc1tpZHhdID4gMCkge1xuICAgICAgICAgIGNvbEFycltpXSA9IHNwYXJrQ29sb3JzW2ldOyBjb2xBcnJbaSsxXSA9IHNwYXJrQ29sb3JzW2krMV07IGNvbEFycltpKzJdID0gc3BhcmtDb2xvcnNbaSsyXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbEFycltpXSA9IG9yaWdpbmFsQ29sb3JzW2ldOyBjb2xBcnJbaSsxXSA9IG9yaWdpbmFsQ29sb3JzW2krMV07IGNvbEFycltpKzJdID0gb3JpZ2luYWxDb2xvcnNbaSsyXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBnZW9tZXRyeS5hdHRyaWJ1dGVzLmNvbG9yLm5lZWRzVXBkYXRlID0gdHJ1ZVxuXG4gICAgICBzdGFycy5yb3RhdGlvbi54ICs9IDAuMDAwMVxuICAgICAgc3RhcnMucm90YXRpb24ueSArPSAwLjAwMDE1XG5cbiAgICAgIC8vIFJlbW92ZSBleHRyYSByYW5kb20gc3Bhd24gZm9yIHNob290aW5nIHN0YXJzXG4gICAgICAvLyAobm8gYWRkaXRpb25hbCByYW5kb20gc3Bhd25zLCBvbmx5IGFib3ZlIGxvZ2ljKVxuICAgICAgZm9yIChsZXQgaSA9IHNob290aW5nU3RhcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3Qgb2JqID0gc2hvb3RpbmdTdGFyc1tpXTtcbiAgICAgICAgLy8gTW92ZSBzaG9vdGluZyBzdGFyIGluIHdvcmxkIHNwYWNlLCBpbmRlcGVuZGVudCBvZiBjYW1lcmFcbiAgICAgICAgb2JqLm1lc2gucG9zaXRpb24uYWRkKG9iai52ZWxvY2l0eSk7XG4gICAgICAgIC8vIFVwZGF0ZSB0YWlsIHBvaW50cyB0byBmb2xsb3cgc3RhcidzIHBhdGggaW4gd29ybGQgc3BhY2VcbiAgICAgICAgZm9yIChsZXQgaiA9IG9iai50YWlsUG9pbnRzLmxlbmd0aCAtIDE7IGogPiAwOyBqLS0pIHtcbiAgICAgICAgICBvYmoudGFpbFBvaW50c1tqXS5jb3B5KG9iai50YWlsUG9pbnRzW2ogLSAxXSk7XG4gICAgICAgIH1cbiAgICAgICAgb2JqLnRhaWxQb2ludHNbMF0gPSBvYmoubWVzaC5wb3NpdGlvbi5jbG9uZSgpO1xuICAgICAgICBvYmoudGFpbC5nZW9tZXRyeS5zZXRGcm9tUG9pbnRzKG9iai50YWlsUG9pbnRzKTtcbiAgICAgICAgLy8gVXBkYXRlIHRhaWwgYWxwaGEgZ3JhZGllbnRcbiAgICAgICAgY29uc3QgY29sb3JzID0gb2JqLnRhaWwuZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvci5hcnJheTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBvYmoudGFpbFBvaW50cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIC8vIEFscGhhIGZhZGVzIG91dCB3aXRoIGJvdGggdGFpbCBwb3NpdGlvbiBhbmQgc3RhciBsaWZlXG4gICAgICAgICAgY29sb3JzW2ogKiA0ICsgM10gPSAoMSAtIGogLyAob2JqLnRhaWxQb2ludHMubGVuZ3RoIC0gMSkpICogMC43ICogTWF0aC5tYXgoMCwgb2JqLm1lc2gubGlmZSk7XG4gICAgICAgIH1cbiAgICAgICAgb2JqLnRhaWwuZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvci5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIG9iai50YWlsLnBvc2l0aW9uLnNldCgwLCAwLCAwKTsgLy8gdGFpbCBwb2ludHMgYXJlIGFic29sdXRlXG4gICAgICAgIG9iai50YWlsLmxpZmUgLT0gMC4wMTtcbiAgICAgICAgb2JqLm1lc2gubGlmZSAtPSAwLjAxO1xuICAgICAgICAvLyBGYWRlIHRoZSB0YWlsIHNtb290aGx5IGJhc2VkIG9uIGxpZmVcbiAgICAgICAgb2JqLnRhaWwubWF0ZXJpYWwub3BhY2l0eSA9IDEuMDtcbiAgICAgICAgaWYgKG9iai5tZXNoLmxpZmUgPD0gMCkge1xuICAgICAgICAgIHNjZW5lLnJlbW92ZShvYmoubWVzaCk7XG4gICAgICAgICAgc2NlbmUucmVtb3ZlKG9iai50YWlsKTtcbiAgICAgICAgICBzaG9vdGluZ1N0YXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBjYW0gPSBjYW1lcmEucG9zaXRpb24uY2xvbmUoKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3NBcnIubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgcG9zQXJyW2ldIC09IGNhbS54OyBwb3NBcnJbaSsxXSAtPSBjYW0ueTsgcG9zQXJyW2krMl0gLT0gY2FtLnpcbiAgICAgIH1cbiAgICAgIGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlXG4gICAgICBzaG9vdGluZ1N0YXJzLmZvckVhY2gob2JqID0+IHtcbiAgICAgICAgb2JqLm1lc2gucG9zaXRpb24uc3ViKGNhbSk7XG4gICAgICAgIG9iai50YWlsLnBvc2l0aW9uLnN1YihjYW0pO1xuICAgICAgfSlcbiAgICAgIGNhbWVyYS5wb3NpdGlvbi5zZXQoMCwgMCwgMClcbiAgICAgIHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhKVxuICAgIH1cbiAgICBhbmltYXRlKClcblxuICAgIGNvbnN0IG9uUmVzaXplID0gKCkgPT4ge1xuICAgICAgY2FtZXJhLmFzcGVjdCA9IHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmlubmVySGVpZ2h0XG4gICAgICBjYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpXG4gICAgICByZW5kZXJlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpXG4gICAgfVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvblJlc2l6ZSlcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25TY3JvbGwpXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25SZXNpemUpXG4gICAgICBtb3VudC5yZW1vdmVDaGlsZChyZW5kZXJlci5kb21FbGVtZW50KVxuICAgIH1cbiAgfSwgW10pXG5cbiAgcmV0dXJuIDxkaXYgcmVmPXttb3VudFJlZn0gLz5cbn1cblxuZXhwb3J0IGRlZmF1bHQgU3RhcmZpZWxkXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJUSFJFRSIsIlN0YXJmaWVsZCIsIm1vdW50UmVmIiwibW91bnQiLCJjdXJyZW50Iiwic3R5bGUiLCJwb3NpdGlvbiIsInRvcCIsImxlZnQiLCJ3aWR0aCIsImhlaWdodCIsInpJbmRleCIsInNjZW5lIiwiU2NlbmUiLCJjYW1lcmEiLCJQZXJzcGVjdGl2ZUNhbWVyYSIsIndpbmRvdyIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsInJlbmRlcmVyIiwiV2ViR0xSZW5kZXJlciIsImFudGlhbGlhcyIsInNldFBpeGVsUmF0aW8iLCJkZXZpY2VQaXhlbFJhdGlvIiwic2V0U2l6ZSIsImFwcGVuZENoaWxkIiwiZG9tRWxlbWVudCIsInN0YXJDb3VudCIsInN0YXJNYXhEaXN0YW5jZSIsInN0YXJTcGVlZCIsImdlb21ldHJ5IiwiQnVmZmVyR2VvbWV0cnkiLCJwb3NpdGlvbnMiLCJpIiwidGhldGEiLCJNYXRoIiwicmFuZG9tIiwiUEkiLCJwaGkiLCJhY29zIiwiciIsInB1c2giLCJzaW4iLCJjb3MiLCJzZXRBdHRyaWJ1dGUiLCJGbG9hdDMyQnVmZmVyQXR0cmlidXRlIiwicGFsZXR0ZSIsImNvbG9ycyIsImMiLCJmbG9vciIsImxlbmd0aCIsIm9yaWdpbmFsQ29sb3JzIiwiYXR0cmlidXRlcyIsImNvbG9yIiwiYXJyYXkiLCJzbGljZSIsInRpbWVycyIsIkZsb2F0MzJBcnJheSIsInNwYXJrQ29sb3JzIiwic3BhcmtsZUR1cmF0aW9uIiwibWF0ZXJpYWwiLCJQb2ludHNNYXRlcmlhbCIsInNpemUiLCJzaXplQXR0ZW51YXRpb24iLCJ2ZXJ0ZXhDb2xvcnMiLCJzdGFycyIsIlBvaW50cyIsImFkZCIsInRhcmdldFkiLCJkYW1waW5nIiwib25TY3JvbGwiLCJwY3QiLCJzY3JvbGxZIiwiZG9jdW1lbnQiLCJib2R5Iiwic2Nyb2xsSGVpZ2h0IiwiYWRkRXZlbnRMaXN0ZW5lciIsInRhaWxMZW5ndGgiLCJzaG9vdGluZ1N0YXJzIiwic2hvb3RpbmdTdGFyQ29vbGRvd24iLCJzcGF3blNob290aW5nU3RhciIsImRpc3RhbmNlIiwic3RhcnRQb3MiLCJWZWN0b3IzIiwiYXdheSIsImNsb25lIiwic3ViIiwibm9ybWFsaXplIiwicGVycCIsInByb2plY3RPblZlY3RvciIsImRpciIsIm11bHRpcGx5U2NhbGFyIiwic3BlZWQiLCJnZW8iLCJTcGhlcmVHZW9tZXRyeSIsIm1hdCIsIk1lc2hCYXNpY01hdGVyaWFsIiwiZW1pc3NpdmUiLCJlbWlzc2l2ZUludGVuc2l0eSIsInN0YXIiLCJNZXNoIiwiY29weSIsInZlbG9jaXR5IiwibGlmZSIsInRhaWxMZW4iLCJ0YWlsU2VnbWVudHMiLCJ0YWlsUG9pbnRzIiwidGFpbENvbG9ycyIsInQiLCJuZWdhdGUiLCJhbHBoYSIsInRhaWxHZW8iLCJzZXRGcm9tUG9pbnRzIiwic3ByaXRlIiwiVGV4dHVyZUxvYWRlciIsImxvYWQiLCJ0YWlsTWF0IiwibWFwIiwidHJhbnNwYXJlbnQiLCJkZXB0aFdyaXRlIiwiYmxlbmRpbmciLCJBZGRpdGl2ZUJsZW5kaW5nIiwidGFpbCIsIm1lc2giLCJmYWRlIiwiYW5pbWF0ZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInJvdGF0aW9uIiwieSIsInRyYW5zbGF0ZVoiLCJwb3NBcnIiLCJzcURpc3QiLCJkeCIsIngiLCJkeSIsImR6IiwieiIsIm5lZWRzVXBkYXRlIiwiY29sQXJyIiwiaWR4IiwiZGlzdCIsInNxcnQiLCJvYmoiLCJqIiwibWF4Iiwic2V0Iiwib3BhY2l0eSIsInJlbW92ZSIsInNwbGljZSIsImNhbSIsImZvckVhY2giLCJyZW5kZXIiLCJvblJlc2l6ZSIsImFzcGVjdCIsInVwZGF0ZVByb2plY3Rpb25NYXRyaXgiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVtb3ZlQ2hpbGQiLCJkaXYiLCJyZWYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/Starfield.jsx\n"));

/***/ })

});