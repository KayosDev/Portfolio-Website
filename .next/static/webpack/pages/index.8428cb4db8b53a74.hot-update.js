"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./components/Starfield.jsx":
/*!**********************************!*\
  !*** ./components/Starfield.jsx ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var three_examples_jsm_postprocessing_EffectComposer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three/examples/jsm/postprocessing/EffectComposer */ \"./node_modules/three/examples/jsm/postprocessing/EffectComposer.js\");\n/* harmony import */ var three_examples_jsm_postprocessing_UnrealBloomPass__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three/examples/jsm/postprocessing/UnrealBloomPass */ \"./node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js\");\n/* harmony import */ var three_examples_jsm_postprocessing_RenderPass__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three/examples/jsm/postprocessing/RenderPass */ \"./node_modules/three/examples/jsm/postprocessing/RenderPass.js\");\n/* harmony import */ var three_examples_jsm_postprocessing_ShaderPass__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! three/examples/jsm/postprocessing/ShaderPass */ \"./node_modules/three/examples/jsm/postprocessing/ShaderPass.js\");\n/* harmony import */ var three_examples_jsm_shaders_FXAAShader__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! three/examples/jsm/shaders/FXAAShader */ \"./node_modules/three/examples/jsm/shaders/FXAAShader.js\");\n/* harmony import */ var three_examples_jsm_postprocessing_FilmPass__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! three/examples/jsm/postprocessing/FilmPass */ \"./node_modules/three/examples/jsm/postprocessing/FilmPass.js\");\n/* harmony import */ var _ChromaticAberrationPass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ChromaticAberrationPass */ \"./components/ChromaticAberrationPass.js\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\n\nconst Starfield = ()=>{\n    _s();\n    const mountRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // Defensive: always use .current for refs\n        if (!mountRef.current) return;\n        const mount = mountRef.current;\n        mount.style.position = \"fixed\";\n        mount.style.top = \"0\";\n        mount.style.left = \"0\";\n        mount.style.width = \"100%\";\n        mount.style.height = \"100%\";\n        mount.style.zIndex = \"0\";\n        // Scene & Renderer\n        const scene = new three__WEBPACK_IMPORTED_MODULE_3__.Scene();\n        const camera = new three__WEBPACK_IMPORTED_MODULE_3__.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);\n        camera.position.set(0, 0, 0);\n        // Virtual position to simulate infinite travel\n        let virtualCameraPos = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(0, 0, 0);\n        const renderer = new three__WEBPACK_IMPORTED_MODULE_3__.WebGLRenderer({\n            antialias: false\n        }) // We'll use FXAA instead\n        ;\n        renderer.setPixelRatio(window.devicePixelRatio);\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        renderer.setClearColor(0x000000, 1);\n        if (\"outputColorSpace\" in renderer) {\n            renderer.outputColorSpace = three__WEBPACK_IMPORTED_MODULE_3__.SRGBColorSpace;\n        }\n        // Create a render target for the composer with correct color space\n        const renderTarget = new three__WEBPACK_IMPORTED_MODULE_3__.WebGLRenderTarget(window.innerWidth, window.innerHeight, {\n            colorSpace: three__WEBPACK_IMPORTED_MODULE_3__.SRGBColorSpace,\n            type: three__WEBPACK_IMPORTED_MODULE_3__.UnsignedByteType\n        });\n        renderer.toneMapping = three__WEBPACK_IMPORTED_MODULE_3__.NoToneMapping;\n        renderer.autoClear = true;\n        mount.appendChild(renderer.domElement);\n        // --- MAIN STARFIELD POST-PROCESSING ---\n        const composer = new three_examples_jsm_postprocessing_EffectComposer__WEBPACK_IMPORTED_MODULE_4__.EffectComposer(renderer, renderTarget);\n        composer.setSize(window.innerWidth, window.innerHeight);\n        const renderPass = new three_examples_jsm_postprocessing_RenderPass__WEBPACK_IMPORTED_MODULE_5__.RenderPass(scene, camera);\n        renderPass.clear = true;\n        composer.addPass(renderPass);\n        // UnrealBloomPass: \"crazy\" bloom\n        const bloomPass = new three_examples_jsm_postprocessing_UnrealBloomPass__WEBPACK_IMPORTED_MODULE_6__.UnrealBloomPass(new three__WEBPACK_IMPORTED_MODULE_3__.Vector2(window.innerWidth, window.innerHeight), 3.5, 1.6, 0.01 // threshold\n        );\n        composer.addPass(bloomPass);\n        // FXAA Pass\n        const fxaaPass = new three_examples_jsm_postprocessing_ShaderPass__WEBPACK_IMPORTED_MODULE_7__.ShaderPass(three_examples_jsm_shaders_FXAAShader__WEBPACK_IMPORTED_MODULE_8__.FXAAShader);\n        fxaaPass.material.uniforms[\"resolution\"].value.x = 1 / window.innerWidth;\n        fxaaPass.material.uniforms[\"resolution\"].value.y = 1 / window.innerHeight;\n        composer.addPass(fxaaPass);\n        // FilmPass\n        const filmPass = new three_examples_jsm_postprocessing_FilmPass__WEBPACK_IMPORTED_MODULE_9__.FilmPass(0.0, 0.0, 648, false // grayscale\n        );\n        composer.addPass(filmPass);\n        // --- SHOOTING STAR POST-PROCESSING ONLY ---\n        // Separate scene and composer for shooting stars\n        const shootingStarScene = new three__WEBPACK_IMPORTED_MODULE_3__.Scene();\n        const shootingStarComposer = new three_examples_jsm_postprocessing_EffectComposer__WEBPACK_IMPORTED_MODULE_4__.EffectComposer(renderer);\n        shootingStarComposer.setSize(window.innerWidth, window.innerHeight);\n        const shootingStarRenderPass = new three_examples_jsm_postprocessing_RenderPass__WEBPACK_IMPORTED_MODULE_5__.RenderPass(shootingStarScene, camera);\n        shootingStarComposer.addPass(shootingStarRenderPass);\n        // Intense bloom for shooting stars\n        const shootingStarBloomPass = new three_examples_jsm_postprocessing_UnrealBloomPass__WEBPACK_IMPORTED_MODULE_6__.UnrealBloomPass(new three__WEBPACK_IMPORTED_MODULE_3__.Vector2(window.innerWidth, window.innerHeight), 4.0, 2.0, 0.0 // all bright\n        );\n        shootingStarComposer.addPass(shootingStarBloomPass);\n        // --- CLOSE STARS: Separate Scene for Chromatic Aberration ---\n        const closeStarsScene = new three__WEBPACK_IMPORTED_MODULE_3__.Scene();\n        const caPass = new _ChromaticAberrationPass__WEBPACK_IMPORTED_MODULE_2__.ChromaticAberrationPass(new three__WEBPACK_IMPORTED_MODULE_3__.Vector2(0.0002, 0.0002)); // barely visible\n        const caComposer = new three_examples_jsm_postprocessing_EffectComposer__WEBPACK_IMPORTED_MODULE_4__.EffectComposer(renderer);\n        caComposer.setSize(window.innerWidth, window.innerHeight);\n        const caRenderPass = new three_examples_jsm_postprocessing_RenderPass__WEBPACK_IMPORTED_MODULE_5__.RenderPass(closeStarsScene, camera);\n        caComposer.addPass(caRenderPass);\n        caComposer.addPass(caPass);\n        // --- HANDLE RESIZE AND FULLSCREEN ---\n        function resizeAll() {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n            // Main composer\n            composer.setSize(window.innerWidth, window.innerHeight);\n            // FXAA resolution\n            fxaaPass.material.uniforms[\"resolution\"].value.x = 1 / window.innerWidth;\n            fxaaPass.material.uniforms[\"resolution\"].value.y = 1 / window.innerHeight;\n            // Other composers\n            shootingStarComposer.setSize(window.innerWidth, window.innerHeight);\n            caComposer.setSize(window.innerWidth, window.innerHeight);\n        }\n        window.addEventListener(\"resize\", resizeAll);\n        window.addEventListener(\"fullscreenchange\", resizeAll);\n        // Starfield\n        const starCount = 5000;\n        const starMaxDistance = 2000;\n        const starSpeed = 1;\n        const geometry = new three__WEBPACK_IMPORTED_MODULE_3__.BufferGeometry();\n        const closeGeometry = new three__WEBPACK_IMPORTED_MODULE_3__.BufferGeometry();\n        const positions = [];\n        const closePositions = [];\n        let starsPlaced = 0;\n        while(starsPlaced < starCount){\n            // With 1% chance, spawn a star cluster (10-30 stars)\n            if (Math.random() < 0.01 && starsPlaced < starCount - 10) {\n                const clusterTheta = Math.random() * 2 * Math.PI;\n                const clusterPhi = Math.acos(2 * Math.random() - 1);\n                const clusterR = Math.random() * starMaxDistance;\n                const clusterCenter = [\n                    clusterR * Math.sin(clusterPhi) * Math.cos(clusterTheta),\n                    clusterR * Math.sin(clusterPhi) * Math.sin(clusterTheta),\n                    clusterR * Math.cos(clusterPhi)\n                ];\n                const clusterSize = 10 + Math.floor(Math.random() * 20); // 10-30 stars\n                for(let c = 0; c < clusterSize && starsPlaced < starCount; c++){\n                    // Each star in cluster is within 30 units of center\n                    const offsetTheta = Math.random() * 2 * Math.PI;\n                    const offsetPhi = Math.acos(2 * Math.random() - 1);\n                    const offsetR = Math.random() * 30; // cluster radius\n                    positions.push(clusterCenter[0] + offsetR * Math.sin(offsetPhi) * Math.cos(offsetTheta), clusterCenter[1] + offsetR * Math.sin(offsetPhi) * Math.sin(offsetTheta), clusterCenter[2] + offsetR * Math.cos(offsetPhi));\n                    starsPlaced++;\n                }\n            } else {\n                // Normal single star\n                const theta = Math.random() * 2 * Math.PI;\n                const phi = Math.acos(2 * Math.random() - 1);\n                const r = Math.random() * starMaxDistance;\n                const x = r * Math.sin(phi) * Math.cos(theta);\n                const y = r * Math.sin(phi) * Math.sin(theta);\n                const z = r * Math.cos(phi);\n                positions.push(x, y, z);\n                // If close, also add to closePositions\n                if (r < 400) {\n                    closePositions.push(x, y, z);\n                }\n                starsPlaced++;\n            }\n        }\n        geometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_3__.Float32BufferAttribute(positions, 3));\n        if (closePositions.length > 0) {\n            closeGeometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_3__.Float32BufferAttribute(closePositions, 3));\n        }\n        // CRAZY BLOOM: All stars are extremely bright (color intensity >1)\n        const palette = [\n            [\n                1.0,\n                0.5,\n                0.5\n            ],\n            [\n                1.0,\n                0.75,\n                0.4\n            ],\n            [\n                1.0,\n                1.0,\n                0.9\n            ],\n            [\n                1.0,\n                1.0,\n                1.0\n            ],\n            [\n                0.4,\n                0.5,\n                1.0\n            ]\n        ];\n        const colors = [];\n        for(let i = 0; i < starCount; i++){\n            const c = palette[Math.floor(Math.random() * palette.length)];\n            colors.push(...c);\n        }\n        geometry.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_3__.Float32BufferAttribute(colors, 3));\n        const originalColors = geometry.attributes.color.array.slice();\n        const timers = new Float32Array(starCount);\n        const sparkColors = new Float32Array(starCount * 3);\n        const sparkleDuration = 180;\n        // --- SQUARE STARS USING POINTS ---\n        const material = new three__WEBPACK_IMPORTED_MODULE_3__.PointsMaterial({\n            size: 10,\n            sizeAttenuation: false,\n            vertexColors: true\n        });\n        const stars = new three__WEBPACK_IMPORTED_MODULE_3__.Points(geometry, material);\n        scene.add(stars);\n        // Add glow sprites to each star and animate them based on distance\n        const glowMap = new three__WEBPACK_IMPORTED_MODULE_3__.TextureLoader().load(\"/glow.png\");\n        const glowSprites = [];\n        const glowMaterial = new three__WEBPACK_IMPORTED_MODULE_3__.SpriteMaterial({\n            map: glowMap,\n            color: 0xffffff,\n            opacity: 0.18,\n            blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending,\n            depthWrite: false\n        });\n        for(let i = 0; i < starCount; i++){\n            const glow = new three__WEBPACK_IMPORTED_MODULE_3__.Sprite(glowMaterial.clone());\n            glow.position.set(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2]);\n            glow.scale.set(10, 10, 1);\n            scene.add(glow);\n            glowSprites.push(glow);\n        }\n        // Add close stars to separate scene\n        let closeStars;\n        if (closePositions.length > 0) {\n            closeStars = new three__WEBPACK_IMPORTED_MODULE_3__.Points(closeGeometry, material.clone());\n            closeStarsScene.add(closeStars);\n        }\n        let targetY = 0;\n        const damping = 0.05;\n        const onScroll = ()=>{\n            const pct = window.scrollY / (document.body.scrollHeight - window.innerHeight);\n            targetY = pct * Math.PI * 2;\n        };\n        window.addEventListener(\"scroll\", onScroll);\n        // --- Shooting Stars ---\n        const tailLength = 32; // Increase for longer tails\n        const shootingStars = [];\n        let shootingStarCooldown = 0;\n        // Spawn a shooting star with a stunning glowing tail\n        function spawnShootingStar() {\n            // Pick a random direction on the sphere for the spawn location\n            const dir = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();\n            // Ensure shooting stars never spawn close to the camera (at least 70% of max distance)\n            const minDist = starMaxDistance * 0.7;\n            const maxDist = starMaxDistance * 1.0;\n            const dist = minDist + Math.random() * (maxDist - minDist);\n            const spawnPos = dir.clone().multiplyScalar(dist);\n            // Tangential velocity: perpendicular to dir\n            let tangent = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1);\n            tangent = tangent.sub(tangent.clone().projectOnVector(dir)).normalize();\n            // Mix in a small radial component (inward or outward)\n            const tangentialSpeed = starSpeed * (2.5 + Math.random() * 2.5); // much faster\n            const radialSpeed = starSpeed * (Math.random() - 0.5) * 0.3; // more dramatic\n            const velocity = tangent.multiplyScalar(tangentialSpeed).add(dir.clone().multiplyScalar(radialSpeed));\n            // Stunning color gradient for the head\n            const vibrantColors = [\n                0xffe066,\n                0xff66cc,\n                0x66ccff,\n                0xffffff,\n                0x80ffea,\n                0xfff2cc,\n                0xffc080,\n                0x80c0ff,\n                0xff80b3\n            ];\n            const color = vibrantColors[Math.floor(Math.random() * vibrantColors.length)];\n            // Star brightness and size (always small and subtle)\n            const brightness = 2.5 + Math.random() * 1.5;\n            const geo = new three__WEBPACK_IMPORTED_MODULE_3__.SphereGeometry(0.7 + Math.random() * 0.5, 16, 16); // Small sphere\n            const mat = new three__WEBPACK_IMPORTED_MODULE_3__.MeshPhysicalMaterial({\n                color: color,\n                emissive: color,\n                emissiveIntensity: 14.0,\n                metalness: 0.7,\n                roughness: 0.3,\n                transmission: 0.7,\n                opacity: 0.98,\n                transparent: true,\n                clearcoat: 0.8,\n                clearcoatRoughness: 0.2\n            });\n            const star = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(geo, mat);\n            // Add a large, intense bloom sprite for extra bloom\n            const spriteMap = new three__WEBPACK_IMPORTED_MODULE_3__.TextureLoader().load(\"/glow.png\");\n            const spriteMaterial = new three__WEBPACK_IMPORTED_MODULE_3__.SpriteMaterial({\n                map: spriteMap,\n                color: 0xffffff,\n                opacity: 1.0,\n                blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n            });\n            const sprite = new three__WEBPACK_IMPORTED_MODULE_3__.Sprite(spriteMaterial);\n            sprite.scale.set(70, 70, 1); // Large for bloom\n            sprite.position.copy(star.position);\n            star.add(sprite);\n            // Add a colored sprite for color pop\n            const colorSpriteMaterial = new three__WEBPACK_IMPORTED_MODULE_3__.SpriteMaterial({\n                map: spriteMap,\n                color: color,\n                opacity: 0.6,\n                blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n            });\n            const colorSprite = new three__WEBPACK_IMPORTED_MODULE_3__.Sprite(colorSpriteMaterial);\n            colorSprite.scale.set(34, 34, 1);\n            colorSprite.position.copy(star.position);\n            star.add(colorSprite);\n            // Add to both main scene and shootingStarScene\n            scene.add(star);\n            shootingStarScene.add(star);\n            // Add dynamic spark burst at the head\n            const sparkCount = 18 + Math.floor(Math.random() * 8);\n            const sparkGroup = new three__WEBPACK_IMPORTED_MODULE_3__.Group();\n            for(let i = 0; i < sparkCount; i++){\n                const sparkMat = new three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial({\n                    color: vibrantColors[Math.floor(Math.random() * vibrantColors.length)],\n                    transparent: true,\n                    opacity: 0.8\n                });\n                const sparkGeo = new three__WEBPACK_IMPORTED_MODULE_3__.SphereGeometry(0.07 + Math.random() * 0.06, 8, 8);\n                const spark = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(sparkGeo, sparkMat);\n                const angle = i / sparkCount * Math.PI * 2;\n                spark.position.set(Math.cos(angle) * 1.2, Math.sin(angle) * 1.2, Math.random() * 0.4 - 0.2);\n                sparkGroup.add(spark);\n            }\n            sparkGroup.name = \"sparkBurst\";\n            star.add(sparkGroup);\n            star.position.copy(spawnPos);\n            star.velocity = velocity;\n            star.normalizedLife = 0.0;\n            star.normalizedLifetime = 80 + Math.random() * 80; // Longer, more dramatic\n            star.age = 0;\n            // --- Stunning Meteor Tail (very long, multi-color, glowing, fading, and 3D curve) ---\n            const trailSegments = tailLength * 3;\n            const trailPoints = [];\n            for(let i = 0; i < trailSegments; i++){\n                // Add a 3D spiral/curve for more depth\n                const spiral = Math.sin(i * 0.25) * 8;\n                const curve = Math.cos(i * 0.15) * 4;\n                const pt = star.position.clone().add(new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(spiral, curve, -i * 3));\n                trailPoints.push(pt);\n            }\n            const tailGeo = new three__WEBPACK_IMPORTED_MODULE_3__.BufferGeometry().setFromPoints(trailPoints);\n            // Per-vertex color (multi-color rainbow gradient)\n            const tailColors = [];\n            for(let i = 0; i < trailSegments; i++){\n                // Alpha fades out along the tail\n                const alpha = (1 - i / (trailSegments - 1)) * 0.99;\n                // Rainbow gradient\n                const rainbow = [\n                    0xffe066,\n                    0xff66cc,\n                    0x66ccff,\n                    0xffffff,\n                    0x80ffea,\n                    0xfff2cc,\n                    0xffc080,\n                    0x80c0ff,\n                    0xff80b3\n                ];\n                const gradColor = rainbow[Math.floor(i / trailSegments * rainbow.length)];\n                tailColors.push((gradColor >> 16 & 255) / 255, (gradColor >> 8 & 255) / 255, (gradColor & 255) / 255, alpha);\n            }\n            tailGeo.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_3__.Float32BufferAttribute(tailColors, 4));\n            // Additive blending for glow + BLOOMED TAIL\n            const tailMat = new three__WEBPACK_IMPORTED_MODULE_3__.LineBasicMaterial({\n                vertexColors: true,\n                transparent: true,\n                opacity: 1.0,\n                blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n            });\n            // --- TAILS ---\n            // 1. Crisp tail for main scene\n            const tailMatMain = new three__WEBPACK_IMPORTED_MODULE_3__.LineBasicMaterial({\n                vertexColors: true,\n                transparent: true,\n                opacity: 1.0,\n                blending: three__WEBPACK_IMPORTED_MODULE_3__.NormalBlending\n            });\n            const tailMain = new three__WEBPACK_IMPORTED_MODULE_3__.Line(tailGeo.clone(), tailMatMain);\n            tailMain.position.copy(star.position);\n            scene.add(tailMain);\n            // 2. Intense bloom tail for shootingStarScene\n            const tailMatBloom = new three__WEBPACK_IMPORTED_MODULE_3__.LineBasicMaterial({\n                vertexColors: true,\n                transparent: true,\n                opacity: 1.0,\n                blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n            });\n            const tailBloom = new three__WEBPACK_IMPORTED_MODULE_3__.Line(tailGeo, tailMatBloom);\n            tailBloom.position.copy(star.position);\n            // Add a bloom sprite to the tail's head for extra glow\n            const tailGlowMap = new three__WEBPACK_IMPORTED_MODULE_3__.TextureLoader().load(\"/glow.png\");\n            const tailGlowMat = new three__WEBPACK_IMPORTED_MODULE_3__.SpriteMaterial({\n                map: tailGlowMap,\n                color: 0xffffff,\n                opacity: 0.88,\n                blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n            });\n            const tailGlow = new three__WEBPACK_IMPORTED_MODULE_3__.Sprite(tailGlowMat);\n            tailGlow.scale.set(50, 50, 1); // Larger for more bloom\n            tailGlow.position.copy(star.position);\n            tailBloom.add(tailGlow);\n            shootingStarScene.add(tailBloom);\n            // Add star to both scenes\n            scene.add(star);\n            shootingStarScene.add(star);\n            shootingStars.push({\n                mesh: star,\n                tail: tailMain,\n                tailBloom,\n                velocity: star.velocity,\n                dir,\n                age: 0,\n                normalizedLifetime: star.normalizedLifetime,\n                trailPoints,\n                color,\n                brightness,\n                hasFragmented: false\n            });\n        }\n        // Create an animation ID reference for cleanup\n        let animationId;\n        const animate = ()=>{\n            // Store the animation ID for cleanup\n            animationId = requestAnimationFrame(animate);\n            // Update star positions relative to virtual camera\n            for(let i = 0; i < positions.length; i += 3){\n                geometry.attributes.position.array[i] = positions[i] - virtualCameraPos.x;\n                geometry.attributes.position.array[i + 1] = positions[i + 1] - virtualCameraPos.y;\n                geometry.attributes.position.array[i + 2] = positions[i + 2] - virtualCameraPos.z;\n            }\n            geometry.attributes.position.needsUpdate = true;\n            // Update glow sprite positions\n            for(let i = 0; i < glowSprites.length; i++){\n                const idx = i * 3;\n                glowSprites[i].position.set(positions[idx] - virtualCameraPos.x, positions[idx + 1] - virtualCameraPos.y, positions[idx + 2] - virtualCameraPos.z);\n            }\n            // --- POST-PROCESSING PIPELINE ---\n            // --- POST-PROCESSING PIPELINE ---\n            composer.render(); // Only RenderPass enabled for debugging\n            // (bloom, FXAA, FilmPass are NOT added)\n            // shootingStarComposer, caComposer remain disabled for now\n            camera.rotation.y += (targetY - camera.rotation.y) * damping;\n            // Move the virtual camera position in the direction the camera is facing\n            const forward = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();\n            camera.getWorldDirection(forward);\n            virtualCameraPos.add(forward.multiplyScalar(starSpeed));\n            // Intense color (oversaturated, brightened) -- must be inside the for loop over stars\n            const colorAttr = geometry.attributes.color;\n            for(let i = 0; i < positions.length; i += 3){\n                const origR = colorAttr.array[i];\n                const origG = colorAttr.array[i + 1];\n                const origB = colorAttr.array[i + 2];\n                const dist = Math.sqrt(Math.pow(positions[i] - virtualCameraPos.x, 2) + Math.pow(positions[i + 1] - virtualCameraPos.y, 2) + Math.pow(positions[i + 2] - virtualCameraPos.z, 2));\n                const intenseR = Math.min(origR * 2.5, 1.0), intenseG = Math.min(origG * 2.5, 1.0), intenseB = Math.min(origB * 2.5, 1.0);\n                // Fade factor: 0 = close, 1 = far\n                let fadeT = (dist - 200) / (starMaxDistance * 0.9 - 200);\n                fadeT = Math.max(0, Math.min(1, fadeT));\n                // Ease for smoothness\n                fadeT = Math.pow(fadeT, 1.5);\n                // Lerp between original and intense color\n                colorAttr.array[i] = origR * (1 - fadeT) + intenseR * fadeT;\n                colorAttr.array[i + 1] = origG * (1 - fadeT) + intenseG * fadeT;\n                colorAttr.array[i + 2] = origB * (1 - fadeT) + intenseB * fadeT;\n            }\n            colorAttr.needsUpdate = true;\n            // If you have glow logic per-star, move that inside the loop as well, or handle after\n            if (closeStars && closeGeometry && closePositions.length > 0) {\n                for(let i = 0; i < closePositions.length; i += 3){\n                    closeGeometry.attributes.position.array[i] = closePositions[i] - virtualCameraPos.x;\n                    closeGeometry.attributes.position.array[i + 1] = closePositions[i + 1] - virtualCameraPos.y;\n                    closeGeometry.attributes.position.array[i + 2] = closePositions[i + 2] - virtualCameraPos.z;\n                }\n                closeGeometry.attributes.position.needsUpdate = true;\n            }\n            geometry.attributes.position.needsUpdate = true;\n            // Update shooting star cooldown\n            if (shootingStarCooldown <= 0 && Math.random() < 0.02) {\n                spawnShootingStar();\n                shootingStarCooldown = 30 + Math.random() * 60;\n            } else if (shootingStarCooldown > 0) {\n                shootingStarCooldown--;\n            }\n            // --- Shooting star spawning ---\n            if (shootingStarCooldown <= 0 && Math.random() < 0.1) {\n                spawnShootingStar();\n                if (camera) {\n                    const shakeStrength = 0.06 + Math.random() * 0.04;\n                    camera.position.x += (Math.random() - 0.5) * shakeStrength;\n                    camera.position.y += (Math.random() - 0.5) * shakeStrength;\n                }\n                shootingStarCooldown = 10 + Math.random() * 10;\n            } else if (shootingStarCooldown > 0) {\n                shootingStarCooldown--;\n            }\n            // Animate and clean up shooting stars\n            for(let i = shootingStars.length - 1; i >= 0; i--){\n                const obj = shootingStars[i];\n                // Animate spark burst (fade and expand)\n                if (obj.mesh.children) {\n                    const sparks = obj.mesh.children.find((child)=>child.name === \"sparkBurst\");\n                    if (sparks) {\n                        for(let j = 0; j < sparks.children.length; j++){\n                            const spark = sparks.children[j];\n                            spark.material.opacity *= 0.96; // Fade\n                            spark.scale.multiplyScalar(1.03); // Expand\n                        }\n                    }\n                }\n                // Animate tail shimmer and color cycling\n                if (obj.tail && obj.trailPoints) {\n                    const time = performance.now() * 0.001;\n                    const tailGeo = obj.tail.geometry;\n                    const tailColors = tailGeo.getAttribute(\"color\");\n                    for(let k = 0; k < tailColors.count; k++){\n                        // Cycle hue\n                        let r = tailColors.getX(k), g = tailColors.getY(k), b = tailColors.getZ(k);\n                        // Convert to HSL\n                        const max = Math.max(r, g, b), min = Math.min(r, g, b);\n                        let h, s, l;\n                        l = (max + min) / 2;\n                        if (max === min) {\n                            h = s = 0;\n                        } else {\n                            const d = max - min;\n                            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n                            switch(max){\n                                case r:\n                                    h = (g - b) / d + (g < b ? 6 : 0);\n                                    break;\n                                case g:\n                                    h = (b - r) / d + 2;\n                                    break;\n                                case b:\n                                    h = (r - g) / d + 4;\n                                    break;\n                            }\n                            h /= 6;\n                        }\n                        h = (h + 0.25 * Math.sin(time + k * 0.2)) % 1.0; // Animate hue\n                        // Convert back to RGB\n                        let q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n                        let p = 2 * l - q;\n                        let tr = h + 1 / 3, tg = h, tb = h - 1 / 3;\n                        const hue2rgb = (p, q, t)=>{\n                            if (t < 0) t += 1;\n                            if (t > 1) t -= 1;\n                            if (t < 1 / 6) return p + (q - p) * 6 * t;\n                            if (t < 1 / 2) return q;\n                            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n                            return p;\n                        };\n                        tailColors.setX(k, hue2rgb(p, q, tr));\n                        tailColors.setY(k, hue2rgb(p, q, tg));\n                        tailColors.setZ(k, hue2rgb(p, q, tb));\n                        // Shimmer: modulate alpha\n                        tailColors.setW(k, tailColors.getW(k) * (0.97 + 0.03 * Math.sin(time * 8 + k)));\n                    }\n                    tailColors.needsUpdate = true;\n                }\n                // Straight-line trajectory\n                obj.mesh.position.add(obj.velocity);\n                obj.tail.position.copy(obj.mesh.position);\n                if (obj.tailBloom) obj.tailBloom.position.copy(obj.mesh.position);\n                // Animate tail (no lerp, just drag)\n                // COMPLETE MESS VERY HACKY FIX LATER OR DONT?????\n                obj.age++;\n                const normalizedLife = obj.age / obj.normalizedLifetime;\n                obj.trailPoints.unshift(obj.mesh.position.clone());\n                if (obj.trailPoints.length > tailLength * 3) obj.trailPoints.pop();\n                let tailGrow = Math.min(1, normalizedLife / 0.3);\n                let activeSegments = Math.floor(obj.trailPoints.length * tailGrow);\n                if (activeSegments < 2) activeSegments = 2;\n                const visibleTrail = obj.trailPoints.slice(0, activeSegments);\n                obj.tail.geometry.setFromPoints(visibleTrail);\n                if (obj.tailBloom) obj.tailBloom.geometry.setFromPoints(visibleTrail);\n                const tailColors = obj.tail.geometry.getAttribute(\"color\");\n                let tailColorsBloom = obj.tailBloom ? obj.tailBloom.geometry.getAttribute(\"color\") : null;\n                for(let j = 0; j < visibleTrail.length; j++){\n                    let alpha = (1 - j / (visibleTrail.length - 1)) * 0.95;\n                    alpha *= 0.92 + 0.08 * Math.sin(Date.now() * 0.015 + j * 0.5);\n                    let rainbow = [\n                        0xffc080,\n                        0xffe080,\n                        0xffff80,\n                        0x80ffe6,\n                        0x80c0ff,\n                        0xc080ff\n                    ];\n                    let gradColor = rainbow[j % rainbow.length];\n                    if (normalizedLife > 0.7) alpha *= Math.max(0, 1 - (normalizedLife - 0.7 - 0.2) / 0.3);\n                    tailColors.setXYZW(j, (gradColor >> 16 & 255) / 255, (gradColor >> 8 & 255) / 255, (gradColor & 255) / 255, alpha);\n                    if (tailColorsBloom) tailColorsBloom.setXYZW(j, (gradColor >> 16 & 255) / 255, (gradColor >> 8 & 255) / 255, (gradColor & 255) / 255, alpha);\n                }\n                tailColors.needsUpdate = true;\n                // Animate head\n                let headColor;\n                if (normalizedLife < 0.5) {\n                    headColor = new three__WEBPACK_IMPORTED_MODULE_3__.Color(obj.color).lerp(new three__WEBPACK_IMPORTED_MODULE_3__.Color(0xffc080), normalizedLife * 2);\n                } else {\n                    headColor = new three__WEBPACK_IMPORTED_MODULE_3__.Color(0xffc080).lerp(new three__WEBPACK_IMPORTED_MODULE_3__.Color(0xff4000), (normalizedLife - 0.5) * 2);\n                }\n                let flicker = 0.95 + 0.13 * Math.sin(Date.now() * 0.07 + Math.random() * 10);\n                headColor.multiplyScalar(flicker);\n                obj.mesh.material.color.copy(headColor);\n                let scale = 1 + 2.2 * Math.sin(Math.PI * normalizedLife);\n                let distToCam = obj.mesh.position.length();\n                let dofBlur = distToCam < starMaxDistance * 0.7 ? 0.7 : 1.0;\n                obj.mesh.scale.set(scale * dofBlur, scale * dofBlur, scale * dofBlur);\n                // Sparkle burst\n                if (normalizedLife >= 1 && !obj.hasFragmented) {\n                    // --- SPECTACULAR EXPLOSION (very rare) ---\n                    const spectacular = Math.random() < 0.02; // 2% chance\n                    const burstCount = spectacular ? 120 + Math.floor(Math.random() * 60) : 18 + Math.floor(Math.random() * 8);\n                    const palette = spectacular ? [\n                        0xffe066,\n                        0xff66cc,\n                        0x66ccff,\n                        0xffffff,\n                        0x80ffea,\n                        0xfff2cc,\n                        0xffc080,\n                        0x80c0ff,\n                        0xff80b3,\n                        0xff0000,\n                        0x00ff00,\n                        0x0000ff,\n                        0xffff00,\n                        0x00ffff,\n                        0xff00ff,\n                        0xff8800,\n                        0x00ff88,\n                        0x8800ff\n                    ] : [\n                        0xffffff,\n                        0xfff6c0,\n                        0xffe066,\n                        0xffc080,\n                        0x80c0ff\n                    ];\n                    for(let s = 0; s < burstCount; s++){\n                        const color = palette[Math.floor(Math.random() * palette.length)];\n                        const size = spectacular ? 1.2 + Math.random() * 2.2 : 0.7 + Math.random() * 0.8;\n                        const sparkleGeo = new three__WEBPACK_IMPORTED_MODULE_3__.SphereGeometry(size, 8, 8);\n                        const sparkleMat = new three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial({\n                            color,\n                            transparent: true,\n                            opacity: spectacular ? 0.92 : 0.7,\n                            blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n                        });\n                        const sparkle = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(sparkleGeo, sparkleMat);\n                        sparkle.position.copy(obj.mesh.position);\n                        // Spectacular: huge, fast, random directions; normal: moderate\n                        const spd = spectacular ? 4 + Math.random() * 8 : 2 + Math.random() * 2;\n                        const sparkleVel = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize().multiplyScalar(spd);\n                        sparkle.userData = {\n                            velocity: sparkleVel,\n                            age: 0,\n                            spectacular,\n                            maxAge: spectacular ? 80 + Math.random() * 40 : 40 + Math.random() * 20\n                        }; // <-- LONGER LIFE\n                        scene.add(sparkle);\n                        if (!window._sparkles) window._sparkles = [];\n                        window._sparkles.push(sparkle);\n                    }\n                    if (spectacular) {\n                        // Add a big flash\n                        const flashGeo = new three__WEBPACK_IMPORTED_MODULE_3__.SphereGeometry(6, 24, 24);\n                        const flashMat = new three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial({\n                            color: 0xffffff,\n                            transparent: true,\n                            opacity: 0.8,\n                            blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n                        });\n                        const flash = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(flashGeo, flashMat);\n                        flash.position.copy(obj.mesh.position);\n                        scene.add(flash);\n                        if (!window._starFlashes) window._starFlashes = [];\n                        window._starFlashes.push({\n                            mesh: flash,\n                            age: 0\n                        });\n                    }\n                    // Fragmented trail logic (keep as before)\n                    const fragVel = obj.velocity.clone().applyAxisAngle(new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(0, 1, 0), (Math.random() - 0.5) * 0.3);\n                    const fragStar = obj.mesh.clone();\n                    fragStar.position.copy(obj.mesh.position);\n                    fragStar.velocity = fragVel;\n                    fragStar.normalizedLife = normalizedLife;\n                    fragStar.normalizedLifetime = obj.normalizedLifetime * (0.5 + Math.random() * 0.5);\n                    fragStar.age = obj.age;\n                    fragStar.material = obj.mesh.material.clone();\n                    const fragTrailPoints = obj.trailPoints.slice();\n                    const fragTailGeo = new three__WEBPACK_IMPORTED_MODULE_3__.BufferGeometry().setFromPoints(fragTrailPoints);\n                    fragTailGeo.setAttribute(\"color\", obj.tail.geometry.getAttribute(\"color\").clone());\n                    const fragTailMat = obj.tail.material.clone();\n                    const fragTail = new three__WEBPACK_IMPORTED_MODULE_3__.Line(fragTailGeo, fragTailMat);\n                    fragTail.position.copy(fragStar.position);\n                    scene.add(fragStar);\n                    scene.add(fragTail);\n                    shootingStars.push({\n                        mesh: fragStar,\n                        tail: fragTail,\n                        velocity: fragStar.velocity,\n                        dir: obj.dir,\n                        age: fragStar.age,\n                        normalizedLifetime: fragStar.normalizedLifetime,\n                        trailPoints: fragTrailPoints,\n                        color: obj.color,\n                        brightness: obj.brightness,\n                        hasFragmented: true\n                    });\n                    obj.hasFragmented = true;\n                }\n                // Spark burst\n                if (!obj.hasSparked && normalizedLife > 0.95 && Math.random() < 0.1) {\n                    for(let s = 0; s < 8 + Math.floor(Math.random() * 8); s++){\n                        const sparkGeo = new three__WEBPACK_IMPORTED_MODULE_3__.SphereGeometry(0.5 + Math.random() * 0.5, 8, 8);\n                        const sparkMat = new three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial({\n                            color: 0xfff6c0,\n                            transparent: true,\n                            opacity: 1,\n                            blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n                        });\n                        const spark = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(sparkGeo, sparkMat);\n                        spark.position.copy(obj.mesh.position);\n                        spark.sparkVel = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize().multiplyScalar(0.5 + Math.random() * 1.2);\n                        spark.sparkLife = 12 + Math.random() * 10;\n                        spark.sparkAge = 0;\n                        scene.add(spark);\n                        if (!window._starSparks) window._starSparks = [];\n                        window._starSparks.push(spark);\n                    }\n                    obj.hasSparked = true;\n                }\n                // Flash\n                if (!obj.hasFlashed && normalizedLife > 0.98 && Math.random() < 0.2) {\n                    const flashGeo = new three__WEBPACK_IMPORTED_MODULE_3__.SphereGeometry(1, 16, 16);\n                    const flashMat = new three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial({\n                        color: 0xffffee,\n                        transparent: true,\n                        opacity: 0.8,\n                        blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n                    });\n                    const flash = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(flashGeo, flashMat);\n                    flash.position.copy(obj.mesh.position);\n                    scene.add(flash);\n                    if (!window._starFlashes) window._starFlashes = [];\n                    window._starFlashes.push({\n                        mesh: flash,\n                        age: 0\n                    });\n                    obj.hasFlashed = true;\n                }\n                // Fade out as it gets far away\n                const dist = obj.mesh.position.distanceTo(camera.position);\n                const fadeStart = starMaxDistance * 0.5;\n                if (dist > fadeStart) {\n                    const fade = 1 - (dist - fadeStart) / (starMaxDistance - fadeStart);\n                    obj.mesh.material.opacity = Math.max(0, fade);\n                    obj.mesh.material.transparent = true;\n                    obj.tail.material.opacity = Math.max(0, fade * 0.8);\n                    obj.tail.material.transparent = true;\n                }\n                // Remove when out of bounds or fully faded or life ended\n                // Fade tail after explosion\n                if ((normalizedLife >= 1.0 || dist > starMaxDistance || obj.mesh.material.opacity <= 0.01) && !obj.tailFading) {\n                    scene.remove(obj.mesh);\n                    // Start tail fade-out ghost\n                    obj.tailFading = true;\n                    obj.tailFadeAge = 0;\n                    if (!window._fadingTails) window._fadingTails = [];\n                    window._fadingTails.push({\n                        tail: obj.tail,\n                        tailBloom: obj.tailBloom,\n                        age: 0\n                    });\n                    shootingStars.splice(i, 1);\n                }\n            }\n            // Animate sparks\n            if (window._starSparks) {\n                for(let i = window._starSparks.length - 1; i >= 0; i--){\n                    const spark = window._starSparks[i];\n                    spark.position.add(spark.sparkVel);\n                    spark.sparkAge++;\n                    spark.material.opacity *= 0.92;\n                    if (spark.sparkAge > spark.sparkLife) {\n                        scene.remove(spark);\n                        window._starSparks.splice(i, 1);\n                    }\n                }\n            }\n            // Animate explosion particles (sparkles)\n            if (window._sparkles) {\n                for(let i = window._sparkles.length - 1; i >= 0; i--){\n                    const sparkle = window._sparkles[i];\n                    sparkle.position.add(sparkle.userData.velocity);\n                    sparkle.userData.age++;\n                    sparkle.material.opacity *= 0.97;\n                    if (sparkle.userData.age > (sparkle.userData.maxAge || 40)) {\n                        scene.remove(sparkle);\n                        window._sparkles.splice(i, 1);\n                    }\n                }\n            }\n            // Animate fading tails (ghosts)\n            if (window._fadingTails) {\n                for(let i = window._fadingTails.length - 1; i >= 0; i--){\n                    const ghost = window._fadingTails[i];\n                    if (ghost.tail) {\n                        ghost.tail.material.opacity *= 0.92;\n                        if (ghost.tail.material.opacity < 0.01) {\n                            scene.remove(ghost.tail);\n                            window._fadingTails.splice(i, 1);\n                            continue;\n                        }\n                    }\n                    if (ghost.tailBloom) {\n                        ghost.tailBloom.material.opacity *= 0.92;\n                        if (ghost.tailBloom.material.opacity < 0.01) {\n                            shootingStarScene.remove(ghost.tailBloom);\n                            ghost.tailBloom = null;\n                        }\n                    }\n                    ghost.age++;\n                }\n            }\n            // Animate flashes\n            if (window._starFlashes) {\n                for(let i = window._starFlashes.length - 1; i >= 0; i--){\n                    const flash = window._starFlashes[i];\n                    flash.mesh.scale.multiplyScalar(1.15);\n                    flash.mesh.material.opacity *= 0.85;\n                    flash.age++;\n                    if (flash.age > 10) {\n                        scene.remove(flash.mesh);\n                        window._starFlashes.splice(i, 1);\n                    }\n                }\n            }\n            // --- Starfield logic ---\n            const sqDist = starMaxDistance * starMaxDistance;\n            for(let i = 0; i < positions.length; i += 3){\n                const dx = positions[i] - virtualCameraPos.x;\n                const dy = positions[i + 1] - virtualCameraPos.y;\n                const dz = positions[i + 2] - virtualCameraPos.z;\n                if (dx * dx + dy * dy + dz * dz > sqDist) {\n                    // Place in a thick spherical shell around the virtual camera, never too close\n                    const minRadius = starMaxDistance * 0.8;\n                    const maxRadius = starMaxDistance;\n                    const r = minRadius + Math.random() * (maxRadius - minRadius);\n                    const theta = Math.random() * 2 * Math.PI;\n                    const phi = Math.acos(2 * Math.random() - 1);\n                    positions[i] = virtualCameraPos.x + r * Math.sin(phi) * Math.cos(theta);\n                    positions[i + 1] = virtualCameraPos.y + r * Math.sin(phi) * Math.sin(theta);\n                    positions[i + 2] = virtualCameraPos.z + r * Math.cos(phi);\n                }\n            }\n            // geometry.attributes.position.needsUpdate = true; // Already set above\n            // Robust starfield color update to prevent stuck white dots\n            // This works NO TOUCHY\n            const colArr = geometry.attributes.color.array;\n            for(let i = 0; i < positions.length; i += 3){\n                const idx = i / 3;\n                const dx = positions[i] - virtualCameraPos.x;\n                const dy = positions[i + 1] - virtualCameraPos.y;\n                const dz = positions[i + 2] - virtualCameraPos.z;\n                const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);\n                if (timers[idx] > 0) {\n                    timers[idx]--;\n                    if (timers[idx] === 0) {\n                        // Timer expired, restore color\n                        sparkColors[i] = originalColors[i];\n                        sparkColors[i + 1] = originalColors[i + 1];\n                        sparkColors[i + 2] = originalColors[i + 2];\n                        colArr[i] = originalColors[i];\n                        colArr[i + 1] = originalColors[i + 1];\n                        colArr[i + 2] = originalColors[i + 2];\n                    } else {\n                        colArr[i] = sparkColors[i];\n                        colArr[i + 1] = sparkColors[i + 1];\n                        colArr[i + 2] = sparkColors[i + 2];\n                    }\n                } else if (dist > starMaxDistance * 0.3 && Math.random() < 0.05) {\n                    timers[idx] = sparkleDuration;\n                    const c = palette[Math.floor(Math.random() * palette.length)];\n                    sparkColors[i] = c[0];\n                    sparkColors[i + 1] = c[1];\n                    sparkColors[i + 2] = c[2];\n                    colArr[i] = sparkColors[i];\n                    colArr[i + 1] = sparkColors[i + 1];\n                    colArr[i + 2] = sparkColors[i + 2];\n                } else {\n                    sparkColors[i] = originalColors[i];\n                    sparkColors[i + 1] = originalColors[i + 1];\n                    sparkColors[i + 2] = originalColors[i + 2];\n                    colArr[i] = originalColors[i];\n                    colArr[i + 1] = originalColors[i + 1];\n                    colArr[i + 2] = originalColors[i + 2];\n                }\n            }\n            geometry.attributes.color.needsUpdate = true;\n        };\n        // Start the animation loop\n        animate();\n        // Handle window resize\n        const onResize = ()=>{\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n            shootingStarComposer.setSize(window.innerWidth, window.innerHeight);\n            caComposer.setSize(window.innerWidth, window.innerHeight);\n        };\n        // Add event listener for resize\n        window.addEventListener(\"resize\", onResize);\n        // Clean up function\n        return ()=>{\n            window.removeEventListener(\"resize\", onResize);\n            window.removeEventListener(\"resize\", resizeAll);\n            window.removeEventListener(\"fullscreenchange\", resizeAll);\n            window.removeEventListener(\"scroll\", onScroll);\n            // Cancel the animation frame using the stored ID\n            if (animationId) {\n                cancelAnimationFrame(animationId);\n            }\n            // Dispose composers\n            if (composer) composer.dispose();\n            if (shootingStarComposer) shootingStarComposer.dispose();\n            if (caComposer) caComposer.dispose();\n            // Clean up Three.js resources\n            if (renderer) {\n                renderer.dispose();\n                if (mount && mount.contains(renderer.domElement)) {\n                    mount.removeChild(renderer.domElement);\n                }\n            }\n        };\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: mountRef\n    }, void 0, false, {\n        fileName: \"/home/kayosdev/Websites/Portfolio/components/Starfield.jsx\",\n        lineNumber: 805,\n        columnNumber: 10\n    }, undefined);\n};\n_s(Starfield, \"V9/qkEdV8GfsDZk7lMTA1T8g5Ps=\");\n_c = Starfield;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Starfield);\nvar _c;\n$RefreshReg$(_c, \"Starfield\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL1N0YXJmaWVsZC5qc3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQWlEO0FBQ2xCO0FBQ21EO0FBQ0U7QUFDVjtBQUNBO0FBQ1A7QUFDRztBQUNGO0FBRXBFLE1BQU1XLFlBQVk7O0lBQ2hCLE1BQU1DLFdBQVdWLDZDQUFNQSxDQUFDO0lBRXhCRCxnREFBU0EsQ0FBQztRQUNSLDBDQUEwQztRQUMxQyxJQUFJLENBQUNXLFNBQVNDLE9BQU8sRUFBRTtRQUN2QixNQUFNQyxRQUFRRixTQUFTQyxPQUFPO1FBQzlCQyxNQUFNQyxLQUFLLENBQUNDLFFBQVEsR0FBRztRQUN2QkYsTUFBTUMsS0FBSyxDQUFDRSxHQUFHLEdBQUc7UUFDbEJILE1BQU1DLEtBQUssQ0FBQ0csSUFBSSxHQUFHO1FBQ25CSixNQUFNQyxLQUFLLENBQUNJLEtBQUssR0FBRztRQUNwQkwsTUFBTUMsS0FBSyxDQUFDSyxNQUFNLEdBQUc7UUFDckJOLE1BQU1DLEtBQUssQ0FBQ00sTUFBTSxHQUFHO1FBRXJCLG1CQUFtQjtRQUNuQixNQUFNQyxRQUFRLElBQUluQix3Q0FBVztRQUM3QixNQUFNcUIsU0FBUyxJQUFJckIsb0RBQXVCLENBQUMsSUFBSXVCLE9BQU9DLFVBQVUsR0FBR0QsT0FBT0UsV0FBVyxFQUFFLEtBQUs7UUFDNUZKLE9BQU9SLFFBQVEsQ0FBQ2EsR0FBRyxDQUFDLEdBQUcsR0FBRztRQUMxQiwrQ0FBK0M7UUFDL0MsSUFBSUMsbUJBQW1CLElBQUkzQiwwQ0FBYSxDQUFDLEdBQUcsR0FBRztRQUMvQyxNQUFNNkIsV0FBVyxJQUFJN0IsZ0RBQW1CLENBQUM7WUFBRStCLFdBQVc7UUFBTSxHQUFHLHlCQUF5Qjs7UUFDeEZGLFNBQVNHLGFBQWEsQ0FBQ1QsT0FBT1UsZ0JBQWdCO1FBQzlDSixTQUFTSyxPQUFPLENBQUNYLE9BQU9DLFVBQVUsRUFBRUQsT0FBT0UsV0FBVztRQUN0REksU0FBU00sYUFBYSxDQUFDLFVBQVU7UUFDakMsSUFBSSxzQkFBc0JOLFVBQVU7WUFDbENBLFNBQVNPLGdCQUFnQixHQUFHcEMsaURBQW9CO1FBQ2xEO1FBQ0EsbUVBQW1FO1FBQ25FLE1BQU1zQyxlQUFlLElBQUl0QyxvREFBdUIsQ0FBQ3VCLE9BQU9DLFVBQVUsRUFBRUQsT0FBT0UsV0FBVyxFQUFFO1lBQ3RGZSxZQUFZeEMsaURBQW9CO1lBQ2hDeUMsTUFBTXpDLG1EQUFzQjtRQUM5QjtRQUNBNkIsU0FBU2MsV0FBVyxHQUFHM0MsZ0RBQW1CO1FBQzFDNkIsU0FBU2dCLFNBQVMsR0FBRztRQUNyQmxDLE1BQU1tQyxXQUFXLENBQUNqQixTQUFTa0IsVUFBVTtRQUVyQyx5Q0FBeUM7UUFDekMsTUFBTUMsV0FBVyxJQUFJL0MsNEZBQWNBLENBQUM0QixVQUFVUztRQUM5Q1UsU0FBU2QsT0FBTyxDQUFDWCxPQUFPQyxVQUFVLEVBQUVELE9BQU9FLFdBQVc7UUFDdEQsTUFBTXdCLGFBQWEsSUFBSTlDLG9GQUFVQSxDQUFDZ0IsT0FBT0U7UUFDekM0QixXQUFXQyxLQUFLLEdBQUc7UUFDbkJGLFNBQVNHLE9BQU8sQ0FBQ0Y7UUFDakIsaUNBQWlDO1FBQ2pDLE1BQU1HLFlBQVksSUFBSWxELDhGQUFlQSxDQUNuQyxJQUFJRiwwQ0FBYSxDQUFDdUIsT0FBT0MsVUFBVSxFQUFFRCxPQUFPRSxXQUFXLEdBQ3ZELEtBQ0EsS0FDQSxLQUFLLFlBQVk7O1FBRW5CdUIsU0FBU0csT0FBTyxDQUFDQztRQUNqQixZQUFZO1FBQ1osTUFBTUUsV0FBVyxJQUFJbEQsb0ZBQVVBLENBQUNDLDZFQUFVQTtRQUMxQ2lELFNBQVNDLFFBQVEsQ0FBQ0MsUUFBUSxDQUFDLGFBQWEsQ0FBQ0MsS0FBSyxDQUFDQyxDQUFDLEdBQUcsSUFBSW5DLE9BQU9DLFVBQVU7UUFDeEU4QixTQUFTQyxRQUFRLENBQUNDLFFBQVEsQ0FBQyxhQUFhLENBQUNDLEtBQUssQ0FBQ0UsQ0FBQyxHQUFHLElBQUlwQyxPQUFPRSxXQUFXO1FBQ3pFdUIsU0FBU0csT0FBTyxDQUFDRztRQUNqQixXQUFXO1FBQ1gsTUFBTU0sV0FBVyxJQUFJdEQsZ0ZBQVFBLENBQzNCLEtBQ0EsS0FDQSxLQUNBLE1BQU0sWUFBWTs7UUFFcEIwQyxTQUFTRyxPQUFPLENBQUNTO1FBR2pCLDZDQUE2QztRQUM3QyxpREFBaUQ7UUFDakQsTUFBTUMsb0JBQW9CLElBQUk3RCx3Q0FBVztRQUN6QyxNQUFNOEQsdUJBQXVCLElBQUk3RCw0RkFBY0EsQ0FBQzRCO1FBQ2hEaUMscUJBQXFCNUIsT0FBTyxDQUFDWCxPQUFPQyxVQUFVLEVBQUVELE9BQU9FLFdBQVc7UUFDbEUsTUFBTXNDLHlCQUF5QixJQUFJNUQsb0ZBQVVBLENBQUMwRCxtQkFBbUJ4QztRQUNqRXlDLHFCQUFxQlgsT0FBTyxDQUFDWTtRQUM3QixtQ0FBbUM7UUFDbkMsTUFBTUMsd0JBQXdCLElBQUk5RCw4RkFBZUEsQ0FDL0MsSUFBSUYsMENBQWEsQ0FBQ3VCLE9BQU9DLFVBQVUsRUFBRUQsT0FBT0UsV0FBVyxHQUN2RCxLQUNBLEtBQ0EsSUFBSSxhQUFhOztRQUVuQnFDLHFCQUFxQlgsT0FBTyxDQUFDYTtRQUU3QiwrREFBK0Q7UUFDL0QsTUFBTUMsa0JBQWtCLElBQUlqRSx3Q0FBVztRQUN2QyxNQUFNa0UsU0FBUyxJQUFJM0QsNkVBQXVCQSxDQUFDLElBQUlQLDBDQUFhLENBQUMsUUFBUSxVQUFVLGlCQUFpQjtRQUNoRyxNQUFNbUUsYUFBYSxJQUFJbEUsNEZBQWNBLENBQUM0QjtRQUN0Q3NDLFdBQVdqQyxPQUFPLENBQUNYLE9BQU9DLFVBQVUsRUFBRUQsT0FBT0UsV0FBVztRQUN4RCxNQUFNMkMsZUFBZSxJQUFJakUsb0ZBQVVBLENBQUM4RCxpQkFBaUI1QztRQUNyRDhDLFdBQVdoQixPQUFPLENBQUNpQjtRQUNuQkQsV0FBV2hCLE9BQU8sQ0FBQ2U7UUFFbkIsdUNBQXVDO1FBQ3ZDLFNBQVNHO1lBQ1BoRCxPQUFPaUQsTUFBTSxHQUFHL0MsT0FBT0MsVUFBVSxHQUFHRCxPQUFPRSxXQUFXO1lBQ3RESixPQUFPa0Qsc0JBQXNCO1lBQzdCMUMsU0FBU0ssT0FBTyxDQUFDWCxPQUFPQyxVQUFVLEVBQUVELE9BQU9FLFdBQVc7WUFFdEQsZ0JBQWdCO1lBQ2hCdUIsU0FBU2QsT0FBTyxDQUFDWCxPQUFPQyxVQUFVLEVBQUVELE9BQU9FLFdBQVc7WUFDdEQsa0JBQWtCO1lBQ2xCNkIsU0FBU0MsUUFBUSxDQUFDQyxRQUFRLENBQUMsYUFBYSxDQUFDQyxLQUFLLENBQUNDLENBQUMsR0FBRyxJQUFJbkMsT0FBT0MsVUFBVTtZQUN4RThCLFNBQVNDLFFBQVEsQ0FBQ0MsUUFBUSxDQUFDLGFBQWEsQ0FBQ0MsS0FBSyxDQUFDRSxDQUFDLEdBQUcsSUFBSXBDLE9BQU9FLFdBQVc7WUFDekUsa0JBQWtCO1lBQ2xCcUMscUJBQXFCNUIsT0FBTyxDQUFDWCxPQUFPQyxVQUFVLEVBQUVELE9BQU9FLFdBQVc7WUFDbEUwQyxXQUFXakMsT0FBTyxDQUFDWCxPQUFPQyxVQUFVLEVBQUVELE9BQU9FLFdBQVc7UUFDMUQ7UUFDQUYsT0FBT2lELGdCQUFnQixDQUFDLFVBQVVIO1FBQ2xDOUMsT0FBT2lELGdCQUFnQixDQUFDLG9CQUFvQkg7UUFFNUMsWUFBWTtRQUNaLE1BQU1JLFlBQVk7UUFDbEIsTUFBTUMsa0JBQWtCO1FBQ3hCLE1BQU1DLFlBQVk7UUFDbEIsTUFBTUMsV0FBVyxJQUFJNUUsaURBQW9CO1FBQ3pDLE1BQU04RSxnQkFBZ0IsSUFBSTlFLGlEQUFvQjtRQUM5QyxNQUFNK0UsWUFBWSxFQUFFO1FBQ3BCLE1BQU1DLGlCQUFpQixFQUFFO1FBQ3pCLElBQUlDLGNBQWM7UUFDbEIsTUFBT0EsY0FBY1IsVUFBVztZQUM5QixxREFBcUQ7WUFDckQsSUFBSVMsS0FBS0MsTUFBTSxLQUFLLFFBQVFGLGNBQWNSLFlBQVksSUFBSTtnQkFDeEQsTUFBTVcsZUFBZUYsS0FBS0MsTUFBTSxLQUFLLElBQUlELEtBQUtHLEVBQUU7Z0JBQ2hELE1BQU1DLGFBQWFKLEtBQUtLLElBQUksQ0FBQyxJQUFJTCxLQUFLQyxNQUFNLEtBQUs7Z0JBQ2pELE1BQU1LLFdBQVdOLEtBQUtDLE1BQU0sS0FBS1Q7Z0JBQ2pDLE1BQU1lLGdCQUFnQjtvQkFDcEJELFdBQVdOLEtBQUtRLEdBQUcsQ0FBQ0osY0FBY0osS0FBS1MsR0FBRyxDQUFDUDtvQkFDM0NJLFdBQVdOLEtBQUtRLEdBQUcsQ0FBQ0osY0FBY0osS0FBS1EsR0FBRyxDQUFDTjtvQkFDM0NJLFdBQVdOLEtBQUtTLEdBQUcsQ0FBQ0w7aUJBQ3JCO2dCQUNELE1BQU1NLGNBQWMsS0FBS1YsS0FBS1csS0FBSyxDQUFDWCxLQUFLQyxNQUFNLEtBQUssS0FBSyxjQUFjO2dCQUN2RSxJQUFLLElBQUlXLElBQUksR0FBR0EsSUFBSUYsZUFBZVgsY0FBY1IsV0FBV3FCLElBQUs7b0JBQy9ELG9EQUFvRDtvQkFDcEQsTUFBTUMsY0FBY2IsS0FBS0MsTUFBTSxLQUFLLElBQUlELEtBQUtHLEVBQUU7b0JBQy9DLE1BQU1XLFlBQVlkLEtBQUtLLElBQUksQ0FBQyxJQUFJTCxLQUFLQyxNQUFNLEtBQUs7b0JBQ2hELE1BQU1jLFVBQVVmLEtBQUtDLE1BQU0sS0FBSyxJQUFJLGlCQUFpQjtvQkFDckRKLFVBQVVtQixJQUFJLENBQ1pULGFBQWEsQ0FBQyxFQUFFLEdBQUdRLFVBQVVmLEtBQUtRLEdBQUcsQ0FBQ00sYUFBYWQsS0FBS1MsR0FBRyxDQUFDSSxjQUM1RE4sYUFBYSxDQUFDLEVBQUUsR0FBR1EsVUFBVWYsS0FBS1EsR0FBRyxDQUFDTSxhQUFhZCxLQUFLUSxHQUFHLENBQUNLLGNBQzVETixhQUFhLENBQUMsRUFBRSxHQUFHUSxVQUFVZixLQUFLUyxHQUFHLENBQUNLO29CQUV4Q2Y7Z0JBQ0Y7WUFDRixPQUFPO2dCQUNMLHFCQUFxQjtnQkFDckIsTUFBTWtCLFFBQVFqQixLQUFLQyxNQUFNLEtBQUssSUFBSUQsS0FBS0csRUFBRTtnQkFDekMsTUFBTWUsTUFBTWxCLEtBQUtLLElBQUksQ0FBQyxJQUFJTCxLQUFLQyxNQUFNLEtBQUs7Z0JBQzFDLE1BQU1rQixJQUFJbkIsS0FBS0MsTUFBTSxLQUFLVDtnQkFDMUIsTUFBTWhCLElBQUkyQyxJQUFJbkIsS0FBS1EsR0FBRyxDQUFDVSxPQUFPbEIsS0FBS1MsR0FBRyxDQUFDUTtnQkFDdkMsTUFBTXhDLElBQUkwQyxJQUFJbkIsS0FBS1EsR0FBRyxDQUFDVSxPQUFPbEIsS0FBS1EsR0FBRyxDQUFDUztnQkFDdkMsTUFBTUcsSUFBSUQsSUFBSW5CLEtBQUtTLEdBQUcsQ0FBQ1M7Z0JBQ3ZCckIsVUFBVW1CLElBQUksQ0FBQ3hDLEdBQUdDLEdBQUcyQztnQkFDckIsdUNBQXVDO2dCQUN2QyxJQUFJRCxJQUFJLEtBQUs7b0JBQ1hyQixlQUFla0IsSUFBSSxDQUFDeEMsR0FBR0MsR0FBRzJDO2dCQUM1QjtnQkFDQXJCO1lBQ0Y7UUFDRjtRQUNBTCxTQUFTMkIsWUFBWSxDQUFDLFlBQVksSUFBSXZHLHlEQUE0QixDQUFDK0UsV0FBVztRQUM5RSxJQUFJQyxlQUFleUIsTUFBTSxHQUFHLEdBQUc7WUFDN0IzQixjQUFjeUIsWUFBWSxDQUFDLFlBQVksSUFBSXZHLHlEQUE0QixDQUFDZ0YsZ0JBQWdCO1FBQzFGO1FBRUEsbUVBQW1FO1FBQ25FLE1BQU0wQixVQUFVO1lBQ2Q7Z0JBQUM7Z0JBQUs7Z0JBQUs7YUFBSTtZQUNmO2dCQUFDO2dCQUFLO2dCQUFNO2FBQUk7WUFDaEI7Z0JBQUM7Z0JBQUs7Z0JBQUs7YUFBSTtZQUNmO2dCQUFDO2dCQUFLO2dCQUFLO2FBQUk7WUFDZjtnQkFBQztnQkFBSztnQkFBSzthQUFJO1NBQ2hCO1FBQ0QsTUFBTUMsU0FBUyxFQUFFO1FBQ2pCLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJbkMsV0FBV21DLElBQUs7WUFDbEMsTUFBTWQsSUFBSVksT0FBTyxDQUFDeEIsS0FBS1csS0FBSyxDQUFDWCxLQUFLQyxNQUFNLEtBQUt1QixRQUFRRCxNQUFNLEVBQUU7WUFDN0RFLE9BQU9ULElBQUksSUFBSUo7UUFDakI7UUFDQWxCLFNBQVMyQixZQUFZLENBQUMsU0FBUyxJQUFJdkcseURBQTRCLENBQUMyRyxRQUFRO1FBRXhFLE1BQU1FLGlCQUFpQmpDLFNBQVNrQyxVQUFVLENBQUNDLEtBQUssQ0FBQ0MsS0FBSyxDQUFDQyxLQUFLO1FBQzVELE1BQU1DLFNBQVMsSUFBSUMsYUFBYTFDO1FBQ2hDLE1BQU0yQyxjQUFjLElBQUlELGFBQWExQyxZQUFZO1FBQ2pELE1BQU00QyxrQkFBa0I7UUFFeEIsb0NBQW9DO1FBQ3hDLE1BQU05RCxXQUFXLElBQUl2RCxpREFBb0IsQ0FBQztZQUFFdUgsTUFBTTtZQUFJQyxpQkFBaUI7WUFBT0MsY0FBYztRQUFLO1FBQ2pHLE1BQU1DLFFBQVEsSUFBSTFILHlDQUFZLENBQUM0RSxVQUFVckI7UUFDekNwQyxNQUFNeUcsR0FBRyxDQUFDRjtRQUNWLG1FQUFtRTtRQUNuRSxNQUFNRyxVQUFVLElBQUk3SCxnREFBbUIsR0FBRytILElBQUksQ0FBQztRQUMvQyxNQUFNQyxjQUFjLEVBQUU7UUFDdEIsTUFBTUMsZUFBZSxJQUFJakksaURBQW9CLENBQUM7WUFBRW1JLEtBQUtOO1lBQVNkLE9BQU87WUFBVXFCLFNBQVM7WUFBTUMsVUFBVXJJLG1EQUFzQjtZQUFFdUksWUFBWTtRQUFNO1FBQ2xKLElBQUssSUFBSTNCLElBQUksR0FBR0EsSUFBSW5DLFdBQVdtQyxJQUFLO1lBQ2xDLE1BQU00QixPQUFPLElBQUl4SSx5Q0FBWSxDQUFDaUksYUFBYVMsS0FBSztZQUNoREYsS0FBSzNILFFBQVEsQ0FBQ2EsR0FBRyxDQUFDcUQsU0FBUyxDQUFDNkIsSUFBRSxFQUFFLEVBQUU3QixTQUFTLENBQUM2QixJQUFFLElBQUUsRUFBRSxFQUFFN0IsU0FBUyxDQUFDNkIsSUFBRSxJQUFFLEVBQUU7WUFDcEU0QixLQUFLRyxLQUFLLENBQUNqSCxHQUFHLENBQUMsSUFBSSxJQUFJO1lBQ3ZCUCxNQUFNeUcsR0FBRyxDQUFDWTtZQUNWUixZQUFZOUIsSUFBSSxDQUFDc0M7UUFDbkI7UUFDQSxvQ0FBb0M7UUFDcEMsSUFBSUk7UUFDSixJQUFJNUQsZUFBZXlCLE1BQU0sR0FBRyxHQUFHO1lBQzdCbUMsYUFBYSxJQUFJNUkseUNBQVksQ0FBQzhFLGVBQWV2QixTQUFTbUYsS0FBSztZQUMzRHpFLGdCQUFnQjJELEdBQUcsQ0FBQ2dCO1FBQ3RCO1FBRUksSUFBSUMsVUFBVTtRQUNkLE1BQU1DLFVBQVU7UUFDaEIsTUFBTUMsV0FBVztZQUNmLE1BQU1DLE1BQU16SCxPQUFPMEgsT0FBTyxHQUFJQyxDQUFBQSxTQUFTQyxJQUFJLENBQUNDLFlBQVksR0FBRzdILE9BQU9FLFdBQVc7WUFDN0VvSCxVQUFVRyxNQUFNOUQsS0FBS0csRUFBRSxHQUFHO1FBQzVCO1FBQ0E5RCxPQUFPaUQsZ0JBQWdCLENBQUMsVUFBVXVFO1FBR2xDLHlCQUF5QjtRQUN6QixNQUFNTSxhQUFhLElBQUksNEJBQTRCO1FBQ25ELE1BQU1DLGdCQUFnQixFQUFFO1FBQ3hCLElBQUlDLHVCQUF1QjtRQUMzQixxREFBcUQ7UUFDckQsU0FBU0M7WUFDUCwrREFBK0Q7WUFDL0QsTUFBTUMsTUFBTSxJQUFJekosMENBQWEsQ0FBQ2tGLEtBQUtDLE1BQU0sS0FBRyxJQUFFLEdBQUdELEtBQUtDLE1BQU0sS0FBRyxJQUFFLEdBQUdELEtBQUtDLE1BQU0sS0FBRyxJQUFFLEdBQUd1RSxTQUFTO1lBQ2hHLHVGQUF1RjtZQUN2RixNQUFNQyxVQUFVakYsa0JBQWtCO1lBQ2xDLE1BQU1rRixVQUFVbEYsa0JBQWtCO1lBQ2xDLE1BQU1tRixPQUFPRixVQUFVekUsS0FBS0MsTUFBTSxLQUFNeUUsQ0FBQUEsVUFBVUQsT0FBTTtZQUN4RCxNQUFNRyxXQUFXTCxJQUFJZixLQUFLLEdBQUdxQixjQUFjLENBQUNGO1lBQzVDLDRDQUE0QztZQUM1QyxJQUFJRyxVQUFVLElBQUloSywwQ0FBYSxDQUFDa0YsS0FBS0MsTUFBTSxLQUFHLElBQUUsR0FBR0QsS0FBS0MsTUFBTSxLQUFHLElBQUUsR0FBR0QsS0FBS0MsTUFBTSxLQUFHLElBQUU7WUFDdEY2RSxVQUFVQSxRQUFRQyxHQUFHLENBQUNELFFBQVF0QixLQUFLLEdBQUd3QixlQUFlLENBQUNULE1BQU1DLFNBQVM7WUFDckUsc0RBQXNEO1lBQ3RELE1BQU1TLGtCQUFrQnhGLFlBQWEsT0FBTU8sS0FBS0MsTUFBTSxLQUFLLEdBQUUsR0FBSSxjQUFjO1lBQy9FLE1BQU1pRixjQUFjekYsWUFBYU8sQ0FBQUEsS0FBS0MsTUFBTSxLQUFLLEdBQUUsSUFBSyxLQUFLLGdCQUFnQjtZQUM3RSxNQUFNa0YsV0FBV0wsUUFBUUQsY0FBYyxDQUFDSSxpQkFBaUJ2QyxHQUFHLENBQUM2QixJQUFJZixLQUFLLEdBQUdxQixjQUFjLENBQUNLO1lBRXhGLHVDQUF1QztZQUN2QyxNQUFNRSxnQkFBZ0I7Z0JBQUM7Z0JBQVU7Z0JBQVU7Z0JBQVU7Z0JBQVU7Z0JBQVU7Z0JBQVU7Z0JBQVU7Z0JBQVU7YUFBUztZQUNoSCxNQUFNdkQsUUFBUXVELGFBQWEsQ0FBQ3BGLEtBQUtXLEtBQUssQ0FBQ1gsS0FBS0MsTUFBTSxLQUFHbUYsY0FBYzdELE1BQU0sRUFBRTtZQUMzRSxxREFBcUQ7WUFDckQsTUFBTThELGFBQWEsTUFBTXJGLEtBQUtDLE1BQU0sS0FBRztZQUN2QyxNQUFNcUYsTUFBTSxJQUFJeEssaURBQW9CLENBQUMsTUFBTWtGLEtBQUtDLE1BQU0sS0FBRyxLQUFLLElBQUksS0FBSyxlQUFlO1lBQ3RGLE1BQU11RixNQUFNLElBQUkxSyx1REFBMEIsQ0FBQztnQkFDekMrRyxPQUFPQTtnQkFDUDZELFVBQVU3RDtnQkFDVjhELG1CQUFtQjtnQkFDbkJDLFdBQVc7Z0JBQ1hDLFdBQVc7Z0JBQ1hDLGNBQWM7Z0JBQ2Q1QyxTQUFTO2dCQUNUNkMsYUFBYTtnQkFDYkMsV0FBVztnQkFDWEMsb0JBQW9CO1lBQ3RCO1lBQ0EsTUFBTUMsT0FBTyxJQUFJcEwsdUNBQVUsQ0FBQ3dLLEtBQUtFO1lBQ2pDLG9EQUFvRDtZQUNwRCxNQUFNWSxZQUFZLElBQUl0TCxnREFBbUIsR0FBRytILElBQUksQ0FBQztZQUNqRCxNQUFNd0QsaUJBQWlCLElBQUl2TCxpREFBb0IsQ0FBQztnQkFBRW1JLEtBQUttRDtnQkFBV3ZFLE9BQU87Z0JBQVVxQixTQUFTO2dCQUFLQyxVQUFVckksbURBQXNCO1lBQUM7WUFDbEksTUFBTXdMLFNBQVMsSUFBSXhMLHlDQUFZLENBQUN1TDtZQUNoQ0MsT0FBTzdDLEtBQUssQ0FBQ2pILEdBQUcsQ0FBQyxJQUFJLElBQUksSUFBSSxrQkFBa0I7WUFDL0M4SixPQUFPM0ssUUFBUSxDQUFDNEssSUFBSSxDQUFDTCxLQUFLdkssUUFBUTtZQUNsQ3VLLEtBQUt4RCxHQUFHLENBQUM0RDtZQUNULHFDQUFxQztZQUNyQyxNQUFNRSxzQkFBc0IsSUFBSTFMLGlEQUFvQixDQUFDO2dCQUFFbUksS0FBS21EO2dCQUFXdkUsT0FBT0E7Z0JBQU9xQixTQUFTO2dCQUFLQyxVQUFVckksbURBQXNCO1lBQUM7WUFDcEksTUFBTTJMLGNBQWMsSUFBSTNMLHlDQUFZLENBQUMwTDtZQUNyQ0MsWUFBWWhELEtBQUssQ0FBQ2pILEdBQUcsQ0FBQyxJQUFJLElBQUk7WUFDOUJpSyxZQUFZOUssUUFBUSxDQUFDNEssSUFBSSxDQUFDTCxLQUFLdkssUUFBUTtZQUN2Q3VLLEtBQUt4RCxHQUFHLENBQUMrRDtZQUNULCtDQUErQztZQUMvQ3hLLE1BQU15RyxHQUFHLENBQUN3RDtZQUNWdkgsa0JBQWtCK0QsR0FBRyxDQUFDd0Q7WUFDdEIsc0NBQXNDO1lBQ3RDLE1BQU1RLGFBQWEsS0FBSzFHLEtBQUtXLEtBQUssQ0FBQ1gsS0FBS0MsTUFBTSxLQUFHO1lBQ2pELE1BQU0wRyxhQUFhLElBQUk3TCx3Q0FBVztZQUNsQyxJQUFLLElBQUk0RyxJQUFJLEdBQUdBLElBQUlnRixZQUFZaEYsSUFBSztnQkFDbkMsTUFBTW1GLFdBQVcsSUFBSS9MLG9EQUF1QixDQUFDO29CQUFFK0csT0FBT3VELGFBQWEsQ0FBQ3BGLEtBQUtXLEtBQUssQ0FBQ1gsS0FBS0MsTUFBTSxLQUFHbUYsY0FBYzdELE1BQU0sRUFBRTtvQkFBRXdFLGFBQWE7b0JBQU03QyxTQUFTO2dCQUFJO2dCQUNySixNQUFNNkQsV0FBVyxJQUFJak0saURBQW9CLENBQUMsT0FBT2tGLEtBQUtDLE1BQU0sS0FBRyxNQUFNLEdBQUc7Z0JBQ3hFLE1BQU0rRyxRQUFRLElBQUlsTSx1Q0FBVSxDQUFDaU0sVUFBVUY7Z0JBQ3ZDLE1BQU1JLFFBQVEsSUFBS1AsYUFBYzFHLEtBQUtHLEVBQUUsR0FBRztnQkFDM0M2RyxNQUFNckwsUUFBUSxDQUFDYSxHQUFHLENBQUN3RCxLQUFLUyxHQUFHLENBQUN3RyxTQUFPLEtBQUtqSCxLQUFLUSxHQUFHLENBQUN5RyxTQUFPLEtBQUtqSCxLQUFLQyxNQUFNLEtBQUcsTUFBSTtnQkFDL0UwRyxXQUFXakUsR0FBRyxDQUFDc0U7WUFDakI7WUFDQUwsV0FBV08sSUFBSSxHQUFHO1lBQ2xCaEIsS0FBS3hELEdBQUcsQ0FBQ2lFO1lBQ1RULEtBQUt2SyxRQUFRLENBQUM0SyxJQUFJLENBQUMzQjtZQUNuQnNCLEtBQUtmLFFBQVEsR0FBR0E7WUFDaEJlLEtBQUtpQixjQUFjLEdBQUc7WUFDdEJqQixLQUFLa0Isa0JBQWtCLEdBQUcsS0FBS3BILEtBQUtDLE1BQU0sS0FBSyxJQUFJLHdCQUF3QjtZQUMzRWlHLEtBQUttQixHQUFHLEdBQUc7WUFDWCx1RkFBdUY7WUFDdkYsTUFBTUMsZ0JBQWdCbkQsYUFBYTtZQUNuQyxNQUFNb0QsY0FBYyxFQUFFO1lBQ3RCLElBQUssSUFBSTdGLElBQUksR0FBR0EsSUFBSTRGLGVBQWU1RixJQUFLO2dCQUN0Qyx1Q0FBdUM7Z0JBQ3ZDLE1BQU04RixTQUFTeEgsS0FBS1EsR0FBRyxDQUFDa0IsSUFBSSxRQUFRO2dCQUNwQyxNQUFNK0YsUUFBUXpILEtBQUtTLEdBQUcsQ0FBQ2lCLElBQUksUUFBUTtnQkFDbkMsTUFBTWdHLEtBQUt4QixLQUFLdkssUUFBUSxDQUFDNkgsS0FBSyxHQUFHZCxHQUFHLENBQUMsSUFBSTVILDBDQUFhLENBQUMwTSxRQUFRQyxPQUFPLENBQUMvRixJQUFJO2dCQUMzRTZGLFlBQVl2RyxJQUFJLENBQUMwRztZQUNuQjtZQUNBLE1BQU1DLFVBQVUsSUFBSTdNLGlEQUFvQixHQUFHOE0sYUFBYSxDQUFDTDtZQUN6RCxrREFBa0Q7WUFDbEQsTUFBTU0sYUFBYSxFQUFFO1lBQ3JCLElBQUssSUFBSW5HLElBQUksR0FBR0EsSUFBSTRGLGVBQWU1RixJQUFLO2dCQUN0QyxpQ0FBaUM7Z0JBQ2pDLE1BQU1vRyxRQUFRLENBQUMsSUFBSXBHLElBQUs0RixDQUFBQSxnQkFBZ0IsRUFBQyxJQUFLO2dCQUM5QyxtQkFBbUI7Z0JBQ25CLE1BQU1TLFVBQVU7b0JBQUM7b0JBQVU7b0JBQVU7b0JBQVU7b0JBQVU7b0JBQVU7b0JBQVU7b0JBQVU7b0JBQVU7aUJBQVM7Z0JBQzFHLE1BQU1DLFlBQVlELE9BQU8sQ0FBQy9ILEtBQUtXLEtBQUssQ0FBQyxJQUFLMkcsZ0JBQWlCUyxRQUFReEcsTUFBTSxFQUFFO2dCQUMzRXNHLFdBQVc3RyxJQUFJLENBQUMsQ0FBQ2dILGFBQWEsS0FBSyxHQUFFLElBQUssS0FBSyxDQUFDQSxhQUFhLElBQUksR0FBRSxJQUFLLEtBQUssQ0FBQ0EsWUFBWSxHQUFFLElBQUssS0FBS0Y7WUFDeEc7WUFDQUgsUUFBUXRHLFlBQVksQ0FBQyxTQUFTLElBQUl2Ryx5REFBNEIsQ0FBQytNLFlBQVk7WUFDM0UsNENBQTRDO1lBQzVDLE1BQU1JLFVBQVUsSUFBSW5OLG9EQUF1QixDQUFDO2dCQUFFeUgsY0FBYztnQkFBTXdELGFBQWE7Z0JBQU03QyxTQUFTO2dCQUFLQyxVQUFVckksbURBQXNCO1lBQUM7WUFDcEksZ0JBQWdCO1lBQ2hCLCtCQUErQjtZQUMvQixNQUFNcU4sY0FBYyxJQUFJck4sb0RBQXVCLENBQUM7Z0JBQUV5SCxjQUFjO2dCQUFNd0QsYUFBYTtnQkFBTTdDLFNBQVM7Z0JBQUtDLFVBQVVySSxpREFBb0I7WUFBQztZQUN0SSxNQUFNdU4sV0FBVyxJQUFJdk4sdUNBQVUsQ0FBQzZNLFFBQVFuRSxLQUFLLElBQUkyRTtZQUNqREUsU0FBUzFNLFFBQVEsQ0FBQzRLLElBQUksQ0FBQ0wsS0FBS3ZLLFFBQVE7WUFDcENNLE1BQU15RyxHQUFHLENBQUMyRjtZQUNWLDhDQUE4QztZQUM5QyxNQUFNRSxlQUFlLElBQUl6TixvREFBdUIsQ0FBQztnQkFBRXlILGNBQWM7Z0JBQU13RCxhQUFhO2dCQUFNN0MsU0FBUztnQkFBS0MsVUFBVXJJLG1EQUFzQjtZQUFDO1lBQ3pJLE1BQU0wTixZQUFZLElBQUkxTix1Q0FBVSxDQUFDNk0sU0FBU1k7WUFDMUNDLFVBQVU3TSxRQUFRLENBQUM0SyxJQUFJLENBQUNMLEtBQUt2SyxRQUFRO1lBQ3JDLHVEQUF1RDtZQUN2RCxNQUFNOE0sY0FBYyxJQUFJM04sZ0RBQW1CLEdBQUcrSCxJQUFJLENBQUM7WUFDbkQsTUFBTTZGLGNBQWMsSUFBSTVOLGlEQUFvQixDQUFDO2dCQUFFbUksS0FBS3dGO2dCQUFhNUcsT0FBTztnQkFBVXFCLFNBQVM7Z0JBQU1DLFVBQVVySSxtREFBc0I7WUFBQztZQUNsSSxNQUFNNk4sV0FBVyxJQUFJN04seUNBQVksQ0FBQzROO1lBQ2xDQyxTQUFTbEYsS0FBSyxDQUFDakgsR0FBRyxDQUFDLElBQUksSUFBSSxJQUFJLHdCQUF3QjtZQUN2RG1NLFNBQVNoTixRQUFRLENBQUM0SyxJQUFJLENBQUNMLEtBQUt2SyxRQUFRO1lBQ3BDNk0sVUFBVTlGLEdBQUcsQ0FBQ2lHO1lBQ2RoSyxrQkFBa0IrRCxHQUFHLENBQUM4RjtZQUN0QiwwQkFBMEI7WUFDMUJ2TSxNQUFNeUcsR0FBRyxDQUFDd0Q7WUFDVnZILGtCQUFrQitELEdBQUcsQ0FBQ3dEO1lBQ3RCOUIsY0FBY3BELElBQUksQ0FBQztnQkFBRTRILE1BQU0xQztnQkFBTTJDLE1BQU1SO2dCQUFVRztnQkFBV3JELFVBQVVlLEtBQUtmLFFBQVE7Z0JBQUVaO2dCQUFLOEMsS0FBSztnQkFBR0Qsb0JBQW9CbEIsS0FBS2tCLGtCQUFrQjtnQkFBRUc7Z0JBQWExRjtnQkFBT3dEO2dCQUFZeUQsZUFBZTtZQUFNO1FBQ3RNO1FBRUEsK0NBQStDO1FBQy9DLElBQUlDO1FBRUosTUFBTUMsVUFBVTtZQUNkLHFDQUFxQztZQUNyQ0QsY0FBY0Usc0JBQXNCRDtZQUVwQyxtREFBbUQ7WUFDbkQsSUFBSyxJQUFJdEgsSUFBSSxHQUFHQSxJQUFJN0IsVUFBVTBCLE1BQU0sRUFBRUcsS0FBSyxFQUFHO2dCQUM1Q2hDLFNBQVNrQyxVQUFVLENBQUNqRyxRQUFRLENBQUNtRyxLQUFLLENBQUNKLEVBQUUsR0FBRzdCLFNBQVMsQ0FBQzZCLEVBQUUsR0FBR2pGLGlCQUFpQitCLENBQUM7Z0JBQ3pFa0IsU0FBU2tDLFVBQVUsQ0FBQ2pHLFFBQVEsQ0FBQ21HLEtBQUssQ0FBQ0osSUFBRSxFQUFFLEdBQUc3QixTQUFTLENBQUM2QixJQUFFLEVBQUUsR0FBR2pGLGlCQUFpQmdDLENBQUM7Z0JBQzdFaUIsU0FBU2tDLFVBQVUsQ0FBQ2pHLFFBQVEsQ0FBQ21HLEtBQUssQ0FBQ0osSUFBRSxFQUFFLEdBQUc3QixTQUFTLENBQUM2QixJQUFFLEVBQUUsR0FBR2pGLGlCQUFpQjJFLENBQUM7WUFDL0U7WUFDQTFCLFNBQVNrQyxVQUFVLENBQUNqRyxRQUFRLENBQUN1TixXQUFXLEdBQUc7WUFFM0MsK0JBQStCO1lBQy9CLElBQUssSUFBSXhILElBQUksR0FBR0EsSUFBSW9CLFlBQVl2QixNQUFNLEVBQUVHLElBQUs7Z0JBQzNDLE1BQU15SCxNQUFNekgsSUFBSTtnQkFDaEJvQixXQUFXLENBQUNwQixFQUFFLENBQUMvRixRQUFRLENBQUNhLEdBQUcsQ0FDekJxRCxTQUFTLENBQUNzSixJQUFJLEdBQUcxTSxpQkFBaUIrQixDQUFDLEVBQ25DcUIsU0FBUyxDQUFDc0osTUFBSSxFQUFFLEdBQUcxTSxpQkFBaUJnQyxDQUFDLEVBQ3JDb0IsU0FBUyxDQUFDc0osTUFBSSxFQUFFLEdBQUcxTSxpQkFBaUIyRSxDQUFDO1lBRXpDO1lBRUEsbUNBQW1DO1lBQ25DLG1DQUFtQztZQUNuQ3RELFNBQVNzTCxNQUFNLElBQUksd0NBQXdDO1lBQzNELHdDQUF3QztZQUN4QywyREFBMkQ7WUFFM0RqTixPQUFPa04sUUFBUSxDQUFDNUssQ0FBQyxJQUFJLENBQUNrRixVQUFVeEgsT0FBT2tOLFFBQVEsQ0FBQzVLLENBQUMsSUFBSW1GO1lBQ3JELHlFQUF5RTtZQUN6RSxNQUFNMEYsVUFBVSxJQUFJeE8sMENBQWE7WUFDakNxQixPQUFPb04saUJBQWlCLENBQUNEO1lBQ3pCN00saUJBQWlCaUcsR0FBRyxDQUFDNEcsUUFBUXpFLGNBQWMsQ0FBQ3BGO1lBRTVDLHNGQUFzRjtZQUN0RixNQUFNK0osWUFBWTlKLFNBQVNrQyxVQUFVLENBQUNDLEtBQUs7WUFDM0MsSUFBSyxJQUFJSCxJQUFJLEdBQUdBLElBQUk3QixVQUFVMEIsTUFBTSxFQUFFRyxLQUFLLEVBQUc7Z0JBQzVDLE1BQU0rSCxRQUFRRCxVQUFVMUgsS0FBSyxDQUFDSixFQUFFO2dCQUNoQyxNQUFNZ0ksUUFBUUYsVUFBVTFILEtBQUssQ0FBQ0osSUFBRSxFQUFFO2dCQUNsQyxNQUFNaUksUUFBUUgsVUFBVTFILEtBQUssQ0FBQ0osSUFBRSxFQUFFO2dCQUNsQyxNQUFNaUQsT0FBTzNFLEtBQUs0SixJQUFJLENBQ3BCNUosS0FBSzZKLEdBQUcsQ0FBQ2hLLFNBQVMsQ0FBQzZCLEVBQUUsR0FBR2pGLGlCQUFpQitCLENBQUMsRUFBRSxLQUM1Q3dCLEtBQUs2SixHQUFHLENBQUNoSyxTQUFTLENBQUM2QixJQUFFLEVBQUUsR0FBR2pGLGlCQUFpQmdDLENBQUMsRUFBRSxLQUM5Q3VCLEtBQUs2SixHQUFHLENBQUNoSyxTQUFTLENBQUM2QixJQUFFLEVBQUUsR0FBR2pGLGlCQUFpQjJFLENBQUMsRUFBRTtnQkFFaEQsTUFBTTBJLFdBQVc5SixLQUFLK0osR0FBRyxDQUFDTixRQUFRLEtBQUssTUFBTU8sV0FBV2hLLEtBQUsrSixHQUFHLENBQUNMLFFBQVEsS0FBSyxNQUFNTyxXQUFXakssS0FBSytKLEdBQUcsQ0FBQ0osUUFBUSxLQUFLO2dCQUNySCxrQ0FBa0M7Z0JBQ2xDLElBQUlPLFFBQVEsQ0FBQ3ZGLE9BQU8sR0FBRSxJQUFNbkYsQ0FBQUEsa0JBQWtCLE1BQU0sR0FBRTtnQkFDdEQwSyxRQUFRbEssS0FBS21LLEdBQUcsQ0FBQyxHQUFHbkssS0FBSytKLEdBQUcsQ0FBQyxHQUFHRztnQkFDaEMsc0JBQXNCO2dCQUN0QkEsUUFBUWxLLEtBQUs2SixHQUFHLENBQUNLLE9BQU87Z0JBQ3hCLDBDQUEwQztnQkFDMUNWLFVBQVUxSCxLQUFLLENBQUNKLEVBQUUsR0FBRytILFFBQVMsS0FBRVMsS0FBSSxJQUFLSixXQUFXSTtnQkFDcERWLFVBQVUxSCxLQUFLLENBQUNKLElBQUUsRUFBRSxHQUFHZ0ksUUFBUyxLQUFFUSxLQUFJLElBQUtGLFdBQVdFO2dCQUN0RFYsVUFBVTFILEtBQUssQ0FBQ0osSUFBRSxFQUFFLEdBQUdpSSxRQUFTLEtBQUVPLEtBQUksSUFBS0QsV0FBV0M7WUFDeEQ7WUFDQVYsVUFBVU4sV0FBVyxHQUFHO1lBQ3hCLHNGQUFzRjtZQUV0RixJQUFJeEYsY0FBYzlELGlCQUFpQkUsZUFBZXlCLE1BQU0sR0FBRyxHQUFHO2dCQUM1RCxJQUFLLElBQUlHLElBQUksR0FBR0EsSUFBSTVCLGVBQWV5QixNQUFNLEVBQUVHLEtBQUssRUFBRztvQkFDakQ5QixjQUFjZ0MsVUFBVSxDQUFDakcsUUFBUSxDQUFDbUcsS0FBSyxDQUFDSixFQUFFLEdBQUc1QixjQUFjLENBQUM0QixFQUFFLEdBQUdqRixpQkFBaUIrQixDQUFDO29CQUNuRm9CLGNBQWNnQyxVQUFVLENBQUNqRyxRQUFRLENBQUNtRyxLQUFLLENBQUNKLElBQUUsRUFBRSxHQUFHNUIsY0FBYyxDQUFDNEIsSUFBRSxFQUFFLEdBQUdqRixpQkFBaUJnQyxDQUFDO29CQUN2Rm1CLGNBQWNnQyxVQUFVLENBQUNqRyxRQUFRLENBQUNtRyxLQUFLLENBQUNKLElBQUUsRUFBRSxHQUFHNUIsY0FBYyxDQUFDNEIsSUFBRSxFQUFFLEdBQUdqRixpQkFBaUIyRSxDQUFDO2dCQUN6RjtnQkFDQXhCLGNBQWNnQyxVQUFVLENBQUNqRyxRQUFRLENBQUN1TixXQUFXLEdBQUc7WUFDbEQ7WUFDQXhKLFNBQVNrQyxVQUFVLENBQUNqRyxRQUFRLENBQUN1TixXQUFXLEdBQUc7WUFFM0MsZ0NBQWdDO1lBQ2hDLElBQUk3RSx3QkFBd0IsS0FBS3JFLEtBQUtDLE1BQU0sS0FBSyxNQUFNO2dCQUNyRHFFO2dCQUNBRCx1QkFBdUIsS0FBS3JFLEtBQUtDLE1BQU0sS0FBSztZQUM5QyxPQUFPLElBQUlvRSx1QkFBdUIsR0FBRztnQkFDbkNBO1lBQ0Y7WUFFQSxpQ0FBaUM7WUFDakMsSUFBSUEsd0JBQXdCLEtBQUtyRSxLQUFLQyxNQUFNLEtBQUssS0FBSztnQkFDcERxRTtnQkFDQSxJQUFJbkksUUFBUTtvQkFDVixNQUFNaU8sZ0JBQWdCLE9BQU9wSyxLQUFLQyxNQUFNLEtBQUc7b0JBQzNDOUQsT0FBT1IsUUFBUSxDQUFDNkMsQ0FBQyxJQUFJLENBQUN3QixLQUFLQyxNQUFNLEtBQUcsR0FBRSxJQUFHbUs7b0JBQ3pDak8sT0FBT1IsUUFBUSxDQUFDOEMsQ0FBQyxJQUFJLENBQUN1QixLQUFLQyxNQUFNLEtBQUcsR0FBRSxJQUFHbUs7Z0JBQzNDO2dCQUNBL0YsdUJBQXVCLEtBQUtyRSxLQUFLQyxNQUFNLEtBQUs7WUFDOUMsT0FBTyxJQUFJb0UsdUJBQXVCLEdBQUc7Z0JBQ25DQTtZQUNGO1lBQ0Esc0NBQXNDO1lBQ3RDLElBQUssSUFBSTNDLElBQUkwQyxjQUFjN0MsTUFBTSxHQUFHLEdBQUdHLEtBQUssR0FBR0EsSUFBSztnQkFDbEQsTUFBTTJJLE1BQU1qRyxhQUFhLENBQUMxQyxFQUFFO2dCQUM1Qix3Q0FBd0M7Z0JBQ3hDLElBQUkySSxJQUFJekIsSUFBSSxDQUFDMEIsUUFBUSxFQUFFO29CQUNyQixNQUFNQyxTQUFTRixJQUFJekIsSUFBSSxDQUFDMEIsUUFBUSxDQUFDRSxJQUFJLENBQUNDLENBQUFBLFFBQVNBLE1BQU12RCxJQUFJLEtBQUs7b0JBQzlELElBQUlxRCxRQUFRO3dCQUNWLElBQUssSUFBSUcsSUFBSSxHQUFHQSxJQUFJSCxPQUFPRCxRQUFRLENBQUMvSSxNQUFNLEVBQUVtSixJQUFLOzRCQUMvQyxNQUFNMUQsUUFBUXVELE9BQU9ELFFBQVEsQ0FBQ0ksRUFBRTs0QkFDaEMxRCxNQUFNM0ksUUFBUSxDQUFDNkUsT0FBTyxJQUFJLE1BQU0sT0FBTzs0QkFDdkM4RCxNQUFNdkQsS0FBSyxDQUFDb0IsY0FBYyxDQUFDLE9BQU8sU0FBUzt3QkFDN0M7b0JBQ0Y7Z0JBQ0Y7Z0JBQ0EseUNBQXlDO2dCQUN6QyxJQUFJd0YsSUFBSXhCLElBQUksSUFBSXdCLElBQUk5QyxXQUFXLEVBQUU7b0JBQy9CLE1BQU1vRCxPQUFPQyxZQUFZQyxHQUFHLEtBQUs7b0JBQ2pDLE1BQU1sRCxVQUFVMEMsSUFBSXhCLElBQUksQ0FBQ25KLFFBQVE7b0JBQ2pDLE1BQU1tSSxhQUFhRixRQUFRbUQsWUFBWSxDQUFDO29CQUN4QyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSWxELFdBQVdtRCxLQUFLLEVBQUVELElBQUs7d0JBQ3pDLFlBQVk7d0JBQ1osSUFBSTVKLElBQUkwRyxXQUFXb0QsSUFBSSxDQUFDRixJQUFJRyxJQUFJckQsV0FBV3NELElBQUksQ0FBQ0osSUFBSUssSUFBSXZELFdBQVd3RCxJQUFJLENBQUNOO3dCQUN4RSxpQkFBaUI7d0JBQ2pCLE1BQU1aLE1BQU1uSyxLQUFLbUssR0FBRyxDQUFDaEosR0FBRStKLEdBQUVFLElBQUlyQixNQUFNL0osS0FBSytKLEdBQUcsQ0FBQzVJLEdBQUUrSixHQUFFRTt3QkFDaEQsSUFBSUUsR0FBRUMsR0FBRUM7d0JBQ1JBLElBQUksQ0FBQ3JCLE1BQUlKLEdBQUUsSUFBRzt3QkFDZCxJQUFJSSxRQUFRSixLQUFLOzRCQUFDdUIsSUFBSUMsSUFBSTt3QkFBRSxPQUFPOzRCQUNqQyxNQUFNRSxJQUFJdEIsTUFBSUo7NEJBQ2R3QixJQUFJQyxJQUFJLE1BQU1DLElBQUcsS0FBRXRCLE1BQUlKLEdBQUUsSUFBSzBCLElBQUd0QixDQUFBQSxNQUFJSixHQUFFOzRCQUN2QyxPQUFPSTtnQ0FDTCxLQUFLaEo7b0NBQUdtSyxJQUFJLENBQUNKLElBQUVFLENBQUFBLElBQUdLLElBQUtQLENBQUFBLElBQUVFLElBQUUsSUFBRTtvQ0FBSTtnQ0FDakMsS0FBS0Y7b0NBQUdJLElBQUksQ0FBQ0YsSUFBRWpLLENBQUFBLElBQUdzSyxJQUFJO29DQUFHO2dDQUN6QixLQUFLTDtvQ0FBR0UsSUFBSSxDQUFDbkssSUFBRStKLENBQUFBLElBQUdPLElBQUk7b0NBQUc7NEJBQzNCOzRCQUNBSCxLQUFHO3dCQUNMO3dCQUNBQSxJQUFJLENBQUNBLElBQUksT0FBS3RMLEtBQUtRLEdBQUcsQ0FBQ21LLE9BQU9JLElBQUUsSUFBRyxJQUFLLEtBQUssY0FBYzt3QkFDM0Qsc0JBQXNCO3dCQUN0QixJQUFJVyxJQUFJRixJQUFJLE1BQU1BLElBQUcsS0FBRUQsQ0FBQUEsSUFBS0MsSUFBRUQsSUFBRUMsSUFBRUQ7d0JBQ2xDLElBQUlJLElBQUksSUFBRUgsSUFBRUU7d0JBQ1osSUFBSUUsS0FBS04sSUFBRSxJQUFFLEdBQUdPLEtBQUtQLEdBQUdRLEtBQUtSLElBQUUsSUFBRTt3QkFDakMsTUFBTVMsVUFBVSxDQUFDSixHQUFFRCxHQUFFTTs0QkFDbkIsSUFBSUEsSUFBRSxHQUFHQSxLQUFHOzRCQUFHLElBQUlBLElBQUUsR0FBR0EsS0FBRzs0QkFDM0IsSUFBSUEsSUFBRSxJQUFFLEdBQUcsT0FBT0wsSUFBRSxDQUFDRCxJQUFFQyxDQUFBQSxJQUFHLElBQUVLOzRCQUM1QixJQUFJQSxJQUFFLElBQUUsR0FBRyxPQUFPTjs0QkFDbEIsSUFBSU0sSUFBRSxJQUFFLEdBQUcsT0FBT0wsSUFBRSxDQUFDRCxJQUFFQyxDQUFBQSxJQUFJLEtBQUUsSUFBRUssQ0FBQUEsSUFBRzs0QkFDbEMsT0FBT0w7d0JBQ1Q7d0JBQ0E5RCxXQUFXb0UsSUFBSSxDQUFDbEIsR0FBR2dCLFFBQVFKLEdBQUVELEdBQUVFO3dCQUMvQi9ELFdBQVdxRSxJQUFJLENBQUNuQixHQUFHZ0IsUUFBUUosR0FBRUQsR0FBRUc7d0JBQy9CaEUsV0FBV3NFLElBQUksQ0FBQ3BCLEdBQUdnQixRQUFRSixHQUFFRCxHQUFFSTt3QkFDL0IsMEJBQTBCO3dCQUMxQmpFLFdBQVd1RSxJQUFJLENBQUNyQixHQUFHbEQsV0FBV3dFLElBQUksQ0FBQ3RCLEtBQU0sUUFBTyxPQUFLL0ssS0FBS1EsR0FBRyxDQUFDbUssT0FBSyxJQUFJSSxFQUFDO29CQUMxRTtvQkFDQWxELFdBQVdxQixXQUFXLEdBQUc7Z0JBQzNCO2dCQUNBLDJCQUEyQjtnQkFDM0JtQixJQUFJekIsSUFBSSxDQUFDak4sUUFBUSxDQUFDK0csR0FBRyxDQUFDMkgsSUFBSWxGLFFBQVE7Z0JBQ2xDa0YsSUFBSXhCLElBQUksQ0FBQ2xOLFFBQVEsQ0FBQzRLLElBQUksQ0FBQzhELElBQUl6QixJQUFJLENBQUNqTixRQUFRO2dCQUN4QyxJQUFJME8sSUFBSTdCLFNBQVMsRUFBRTZCLElBQUk3QixTQUFTLENBQUM3TSxRQUFRLENBQUM0SyxJQUFJLENBQUM4RCxJQUFJekIsSUFBSSxDQUFDak4sUUFBUTtnQkFDaEUsb0NBQW9DO2dCQUNwQyxrREFBa0Q7Z0JBQ2xEME8sSUFBSWhELEdBQUc7Z0JBQ1AsTUFBTUYsaUJBQWlCa0QsSUFBSWhELEdBQUcsR0FBR2dELElBQUlqRCxrQkFBa0I7Z0JBQ3ZEaUQsSUFBSTlDLFdBQVcsQ0FBQytFLE9BQU8sQ0FBQ2pDLElBQUl6QixJQUFJLENBQUNqTixRQUFRLENBQUM2SCxLQUFLO2dCQUMvQyxJQUFJNkcsSUFBSTlDLFdBQVcsQ0FBQ2hHLE1BQU0sR0FBRzRDLGFBQWEsR0FBR2tHLElBQUk5QyxXQUFXLENBQUNnRixHQUFHO2dCQUNoRSxJQUFJQyxXQUFXeE0sS0FBSytKLEdBQUcsQ0FBQyxHQUFHNUMsaUJBQWlCO2dCQUM1QyxJQUFJc0YsaUJBQWlCek0sS0FBS1csS0FBSyxDQUFDMEosSUFBSTlDLFdBQVcsQ0FBQ2hHLE1BQU0sR0FBR2lMO2dCQUN6RCxJQUFJQyxpQkFBaUIsR0FBR0EsaUJBQWlCO2dCQUN6QyxNQUFNQyxlQUFlckMsSUFBSTlDLFdBQVcsQ0FBQ3hGLEtBQUssQ0FBQyxHQUFHMEs7Z0JBQzlDcEMsSUFBSXhCLElBQUksQ0FBQ25KLFFBQVEsQ0FBQ2tJLGFBQWEsQ0FBQzhFO2dCQUNoQyxJQUFJckMsSUFBSTdCLFNBQVMsRUFBRTZCLElBQUk3QixTQUFTLENBQUM5SSxRQUFRLENBQUNrSSxhQUFhLENBQUM4RTtnQkFDeEQsTUFBTTdFLGFBQWF3QyxJQUFJeEIsSUFBSSxDQUFDbkosUUFBUSxDQUFDb0wsWUFBWSxDQUFDO2dCQUNsRCxJQUFJNkIsa0JBQWtCdEMsSUFBSTdCLFNBQVMsR0FBRzZCLElBQUk3QixTQUFTLENBQUM5SSxRQUFRLENBQUNvTCxZQUFZLENBQUMsV0FBVztnQkFDckYsSUFBSyxJQUFJSixJQUFJLEdBQUdBLElBQUlnQyxhQUFhbkwsTUFBTSxFQUFFbUosSUFBSztvQkFDNUMsSUFBSTVDLFFBQVEsQ0FBQyxJQUFJNEMsSUFBS2dDLENBQUFBLGFBQWFuTCxNQUFNLEdBQUcsRUFBQyxJQUFLO29CQUNsRHVHLFNBQVMsT0FBTyxPQUFPOUgsS0FBS1EsR0FBRyxDQUFDb00sS0FBSy9CLEdBQUcsS0FBRyxRQUFRSCxJQUFFO29CQUNyRCxJQUFJM0MsVUFBVTt3QkFBQzt3QkFBVTt3QkFBVTt3QkFBVTt3QkFBVTt3QkFBVTtxQkFBUztvQkFDMUUsSUFBSUMsWUFBWUQsT0FBTyxDQUFDMkMsSUFBSTNDLFFBQVF4RyxNQUFNLENBQUM7b0JBQzNDLElBQUk0RixpQkFBaUIsS0FBS1csU0FBUzlILEtBQUttSyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUNoRCxpQkFBaUIsTUFBTSxHQUFFLElBQUs7b0JBQ2xGVSxXQUFXZ0YsT0FBTyxDQUFDbkMsR0FBRyxDQUFDMUMsYUFBYSxLQUFLLEdBQUUsSUFBSyxLQUFLLENBQUNBLGFBQWEsSUFBSSxHQUFFLElBQUssS0FBSyxDQUFDQSxZQUFZLEdBQUUsSUFBSyxLQUFLRjtvQkFDNUcsSUFBSTZFLGlCQUFpQkEsZ0JBQWdCRSxPQUFPLENBQUNuQyxHQUFHLENBQUMxQyxhQUFhLEtBQUssR0FBRSxJQUFLLEtBQUssQ0FBQ0EsYUFBYSxJQUFJLEdBQUUsSUFBSyxLQUFLLENBQUNBLFlBQVksR0FBRSxJQUFLLEtBQUtGO2dCQUN4STtnQkFDQUQsV0FBV3FCLFdBQVcsR0FBRztnQkFDekIsZUFBZTtnQkFDZixJQUFJNEQ7Z0JBQ0osSUFBSTNGLGlCQUFpQixLQUFLO29CQUN4QjJGLFlBQVksSUFBSWhTLHdDQUFXLENBQUN1UCxJQUFJeEksS0FBSyxFQUFFbUwsSUFBSSxDQUFDLElBQUlsUyx3Q0FBVyxDQUFDLFdBQVdxTSxpQkFBZTtnQkFDeEYsT0FBTztvQkFDTDJGLFlBQVksSUFBSWhTLHdDQUFXLENBQUMsVUFBVWtTLElBQUksQ0FBQyxJQUFJbFMsd0NBQVcsQ0FBQyxXQUFXLENBQUNxTSxpQkFBZSxHQUFFLElBQUc7Z0JBQzdGO2dCQUNBLElBQUk4RixVQUFVLE9BQU8sT0FBT2pOLEtBQUtRLEdBQUcsQ0FBQ29NLEtBQUsvQixHQUFHLEtBQUcsT0FBTzdLLEtBQUtDLE1BQU0sS0FBRztnQkFDckU2TSxVQUFVakksY0FBYyxDQUFDb0k7Z0JBQ3pCNUMsSUFBSXpCLElBQUksQ0FBQ3ZLLFFBQVEsQ0FBQ3dELEtBQUssQ0FBQzBFLElBQUksQ0FBQ3VHO2dCQUM3QixJQUFJckosUUFBUSxJQUFJLE1BQU16RCxLQUFLUSxHQUFHLENBQUNSLEtBQUtHLEVBQUUsR0FBR2dIO2dCQUN6QyxJQUFJK0YsWUFBWTdDLElBQUl6QixJQUFJLENBQUNqTixRQUFRLENBQUM0RixNQUFNO2dCQUN4QyxJQUFJNEwsVUFBVUQsWUFBWTFOLGtCQUFrQixNQUFNLE1BQU07Z0JBQ3hENkssSUFBSXpCLElBQUksQ0FBQ25GLEtBQUssQ0FBQ2pILEdBQUcsQ0FBQ2lILFFBQVEwSixTQUFTMUosUUFBUTBKLFNBQVMxSixRQUFRMEo7Z0JBQzdELGdCQUFnQjtnQkFDaEIsSUFBSWhHLGtCQUFrQixLQUFLLENBQUNrRCxJQUFJdkIsYUFBYSxFQUFFO29CQUM3Qyw0Q0FBNEM7b0JBQzVDLE1BQU1zRSxjQUFjcE4sS0FBS0MsTUFBTSxLQUFLLE1BQU0sWUFBWTtvQkFDdEQsTUFBTW9OLGFBQWFELGNBQWMsTUFBTXBOLEtBQUtXLEtBQUssQ0FBQ1gsS0FBS0MsTUFBTSxLQUFHLE1BQU0sS0FBS0QsS0FBS1csS0FBSyxDQUFDWCxLQUFLQyxNQUFNLEtBQUc7b0JBQ3BHLE1BQU11QixVQUFVNEwsY0FDWjt3QkFBQzt3QkFBVTt3QkFBVTt3QkFBVTt3QkFBVTt3QkFBVTt3QkFBVTt3QkFBVTt3QkFBVTt3QkFBVTt3QkFBVTt3QkFBVTt3QkFBVTt3QkFBVTt3QkFBVTt3QkFBVTt3QkFBVTt3QkFBVTtxQkFBUyxHQUNwTDt3QkFBQzt3QkFBVTt3QkFBVTt3QkFBVTt3QkFBVTtxQkFBUztvQkFDdEQsSUFBSyxJQUFJN0IsSUFBSSxHQUFHQSxJQUFJOEIsWUFBWTlCLElBQUs7d0JBQ25DLE1BQU0xSixRQUFRTCxPQUFPLENBQUN4QixLQUFLVyxLQUFLLENBQUNYLEtBQUtDLE1BQU0sS0FBR3VCLFFBQVFELE1BQU0sRUFBRTt3QkFDL0QsTUFBTWMsT0FBTytLLGNBQWUsTUFBTXBOLEtBQUtDLE1BQU0sS0FBRyxNQUFRLE1BQU1ELEtBQUtDLE1BQU0sS0FBRzt3QkFDNUUsTUFBTXFOLGFBQWEsSUFBSXhTLGlEQUFvQixDQUFDdUgsTUFBTSxHQUFHO3dCQUNyRCxNQUFNa0wsYUFBYSxJQUFJelMsb0RBQXVCLENBQUM7NEJBQUUrRzs0QkFBT2tFLGFBQWE7NEJBQU03QyxTQUFTa0ssY0FBYyxPQUFPOzRCQUFLakssVUFBVXJJLG1EQUFzQjt3QkFBQzt3QkFDL0ksTUFBTTBTLFVBQVUsSUFBSTFTLHVDQUFVLENBQUN3UyxZQUFZQzt3QkFDM0NDLFFBQVE3UixRQUFRLENBQUM0SyxJQUFJLENBQUM4RCxJQUFJekIsSUFBSSxDQUFDak4sUUFBUTt3QkFDdkMsK0RBQStEO3dCQUMvRCxNQUFNOFIsTUFBTUwsY0FBZSxJQUFJcE4sS0FBS0MsTUFBTSxLQUFHLElBQU0sSUFBSUQsS0FBS0MsTUFBTSxLQUFHO3dCQUNyRSxNQUFNeU4sYUFBYSxJQUFJNVMsMENBQWEsQ0FBQ2tGLEtBQUtDLE1BQU0sS0FBRyxLQUFLRCxLQUFLQyxNQUFNLEtBQUcsS0FBS0QsS0FBS0MsTUFBTSxLQUFHLEtBQUt1RSxTQUFTLEdBQUdLLGNBQWMsQ0FBQzRJO3dCQUN6SEQsUUFBUUcsUUFBUSxHQUFHOzRCQUFFeEksVUFBVXVJOzRCQUFZckcsS0FBSzs0QkFBRytGOzRCQUFhUSxRQUFRUixjQUFjLEtBQUtwTixLQUFLQyxNQUFNLEtBQUcsS0FBSyxLQUFLRCxLQUFLQyxNQUFNLEtBQUc7d0JBQUcsR0FBRyxrQkFBa0I7d0JBQ3pKaEUsTUFBTXlHLEdBQUcsQ0FBQzhLO3dCQUNWLElBQUksQ0FBQ25SLE9BQU93UixTQUFTLEVBQUV4UixPQUFPd1IsU0FBUyxHQUFHLEVBQUU7d0JBQzVDeFIsT0FBT3dSLFNBQVMsQ0FBQzdNLElBQUksQ0FBQ3dNO29CQUN4QjtvQkFDQSxJQUFJSixhQUFhO3dCQUNmLGtCQUFrQjt3QkFDbEIsTUFBTVUsV0FBVyxJQUFJaFQsaURBQW9CLENBQUMsR0FBRyxJQUFJO3dCQUNqRCxNQUFNaVQsV0FBVyxJQUFJalQsb0RBQXVCLENBQUM7NEJBQUUrRyxPQUFPOzRCQUFVa0UsYUFBYTs0QkFBTTdDLFNBQVM7NEJBQUtDLFVBQVVySSxtREFBc0I7d0JBQUM7d0JBQ2xJLE1BQU1rVCxRQUFRLElBQUlsVCx1Q0FBVSxDQUFDZ1QsVUFBVUM7d0JBQ3ZDQyxNQUFNclMsUUFBUSxDQUFDNEssSUFBSSxDQUFDOEQsSUFBSXpCLElBQUksQ0FBQ2pOLFFBQVE7d0JBQ3JDTSxNQUFNeUcsR0FBRyxDQUFDc0w7d0JBQ1YsSUFBSSxDQUFDM1IsT0FBTzRSLFlBQVksRUFBRTVSLE9BQU80UixZQUFZLEdBQUcsRUFBRTt3QkFDbEQ1UixPQUFPNFIsWUFBWSxDQUFDak4sSUFBSSxDQUFDOzRCQUFFNEgsTUFBTW9GOzRCQUFPM0csS0FBSzt3QkFBRTtvQkFDakQ7b0JBQ0EsMENBQTBDO29CQUMxQyxNQUFNNkcsVUFBVTdELElBQUlsRixRQUFRLENBQUMzQixLQUFLLEdBQUcySyxjQUFjLENBQUMsSUFBSXJULDBDQUFhLENBQUMsR0FBRSxHQUFFLElBQUksQ0FBQ2tGLEtBQUtDLE1BQU0sS0FBRyxHQUFFLElBQUc7b0JBQ2xHLE1BQU1tTyxXQUFXL0QsSUFBSXpCLElBQUksQ0FBQ3BGLEtBQUs7b0JBQy9CNEssU0FBU3pTLFFBQVEsQ0FBQzRLLElBQUksQ0FBQzhELElBQUl6QixJQUFJLENBQUNqTixRQUFRO29CQUN4Q3lTLFNBQVNqSixRQUFRLEdBQUcrSTtvQkFDcEJFLFNBQVNqSCxjQUFjLEdBQUdBO29CQUMxQmlILFNBQVNoSCxrQkFBa0IsR0FBR2lELElBQUlqRCxrQkFBa0IsR0FBSSxPQUFNcEgsS0FBS0MsTUFBTSxLQUFHLEdBQUU7b0JBQzlFbU8sU0FBUy9HLEdBQUcsR0FBR2dELElBQUloRCxHQUFHO29CQUN0QitHLFNBQVMvUCxRQUFRLEdBQUdnTSxJQUFJekIsSUFBSSxDQUFDdkssUUFBUSxDQUFDbUYsS0FBSztvQkFDM0MsTUFBTTZLLGtCQUFrQmhFLElBQUk5QyxXQUFXLENBQUN4RixLQUFLO29CQUM3QyxNQUFNdU0sY0FBYyxJQUFJeFQsaURBQW9CLEdBQUc4TSxhQUFhLENBQUN5RztvQkFDN0RDLFlBQVlqTixZQUFZLENBQUMsU0FBU2dKLElBQUl4QixJQUFJLENBQUNuSixRQUFRLENBQUNvTCxZQUFZLENBQUMsU0FBU3RILEtBQUs7b0JBQy9FLE1BQU0rSyxjQUFjbEUsSUFBSXhCLElBQUksQ0FBQ3hLLFFBQVEsQ0FBQ21GLEtBQUs7b0JBQzNDLE1BQU1nTCxXQUFXLElBQUkxVCx1Q0FBVSxDQUFDd1QsYUFBYUM7b0JBQzdDQyxTQUFTN1MsUUFBUSxDQUFDNEssSUFBSSxDQUFDNkgsU0FBU3pTLFFBQVE7b0JBQ3hDTSxNQUFNeUcsR0FBRyxDQUFDMEw7b0JBQ1ZuUyxNQUFNeUcsR0FBRyxDQUFDOEw7b0JBQ1ZwSyxjQUFjcEQsSUFBSSxDQUFDO3dCQUFFNEgsTUFBTXdGO3dCQUFVdkYsTUFBTTJGO3dCQUFVckosVUFBVWlKLFNBQVNqSixRQUFRO3dCQUFFWixLQUFLOEYsSUFBSTlGLEdBQUc7d0JBQUU4QyxLQUFLK0csU0FBUy9HLEdBQUc7d0JBQUVELG9CQUFvQmdILFNBQVNoSCxrQkFBa0I7d0JBQUVHLGFBQWE4Rzt3QkFBaUJ4TSxPQUFPd0ksSUFBSXhJLEtBQUs7d0JBQUV3RCxZQUFZZ0YsSUFBSWhGLFVBQVU7d0JBQUV5RCxlQUFlO29CQUFLO29CQUNwUXVCLElBQUl2QixhQUFhLEdBQUc7Z0JBQ3RCO2dCQUNBLGNBQWM7Z0JBQ2QsSUFBSSxDQUFDdUIsSUFBSW9FLFVBQVUsSUFBSXRILGlCQUFpQixRQUFRbkgsS0FBS0MsTUFBTSxLQUFLLEtBQUs7b0JBQ25FLElBQUssSUFBSXNMLElBQUksR0FBR0EsSUFBSSxJQUFJdkwsS0FBS1csS0FBSyxDQUFDWCxLQUFLQyxNQUFNLEtBQUcsSUFBSXNMLElBQUs7d0JBQ3hELE1BQU14RSxXQUFXLElBQUlqTSxpREFBb0IsQ0FBQyxNQUFNa0YsS0FBS0MsTUFBTSxLQUFHLEtBQUssR0FBRzt3QkFDdEUsTUFBTTRHLFdBQVcsSUFBSS9MLG9EQUF1QixDQUFDOzRCQUFFK0csT0FBTzs0QkFBVWtFLGFBQWE7NEJBQU03QyxTQUFTOzRCQUFHQyxVQUFVckksbURBQXNCO3dCQUFDO3dCQUNoSSxNQUFNa00sUUFBUSxJQUFJbE0sdUNBQVUsQ0FBQ2lNLFVBQVVGO3dCQUN2Q0csTUFBTXJMLFFBQVEsQ0FBQzRLLElBQUksQ0FBQzhELElBQUl6QixJQUFJLENBQUNqTixRQUFRO3dCQUNyQ3FMLE1BQU0wSCxRQUFRLEdBQUcsSUFBSTVULDBDQUFhLENBQUNrRixLQUFLQyxNQUFNLEtBQUcsS0FBS0QsS0FBS0MsTUFBTSxLQUFHLEtBQUtELEtBQUtDLE1BQU0sS0FBRyxLQUFLdUUsU0FBUyxHQUFHSyxjQUFjLENBQUMsTUFBTTdFLEtBQUtDLE1BQU0sS0FBRzt3QkFDM0krRyxNQUFNMkgsU0FBUyxHQUFHLEtBQUszTyxLQUFLQyxNQUFNLEtBQUc7d0JBQ3JDK0csTUFBTTRILFFBQVEsR0FBRzt3QkFDakIzUyxNQUFNeUcsR0FBRyxDQUFDc0U7d0JBQ1YsSUFBSSxDQUFDM0ssT0FBT3dTLFdBQVcsRUFBRXhTLE9BQU93UyxXQUFXLEdBQUcsRUFBRTt3QkFDaER4UyxPQUFPd1MsV0FBVyxDQUFDN04sSUFBSSxDQUFDZ0c7b0JBQzFCO29CQUNBcUQsSUFBSW9FLFVBQVUsR0FBRztnQkFDbkI7Z0JBQ0EsUUFBUTtnQkFDUixJQUFJLENBQUNwRSxJQUFJeUUsVUFBVSxJQUFJM0gsaUJBQWlCLFFBQVFuSCxLQUFLQyxNQUFNLEtBQUssS0FBSztvQkFDbkUsTUFBTTZOLFdBQVcsSUFBSWhULGlEQUFvQixDQUFDLEdBQUcsSUFBSTtvQkFDakQsTUFBTWlULFdBQVcsSUFBSWpULG9EQUF1QixDQUFDO3dCQUFFK0csT0FBTzt3QkFBVWtFLGFBQWE7d0JBQU03QyxTQUFTO3dCQUFLQyxVQUFVckksbURBQXNCO29CQUFDO29CQUNsSSxNQUFNa1QsUUFBUSxJQUFJbFQsdUNBQVUsQ0FBQ2dULFVBQVVDO29CQUN2Q0MsTUFBTXJTLFFBQVEsQ0FBQzRLLElBQUksQ0FBQzhELElBQUl6QixJQUFJLENBQUNqTixRQUFRO29CQUNyQ00sTUFBTXlHLEdBQUcsQ0FBQ3NMO29CQUNWLElBQUksQ0FBQzNSLE9BQU80UixZQUFZLEVBQUU1UixPQUFPNFIsWUFBWSxHQUFHLEVBQUU7b0JBQ2xENVIsT0FBTzRSLFlBQVksQ0FBQ2pOLElBQUksQ0FBQzt3QkFBRTRILE1BQU1vRjt3QkFBTzNHLEtBQUs7b0JBQUU7b0JBQy9DZ0QsSUFBSXlFLFVBQVUsR0FBRztnQkFDbkI7Z0JBQ0EsK0JBQStCO2dCQUMvQixNQUFNbkssT0FBTzBGLElBQUl6QixJQUFJLENBQUNqTixRQUFRLENBQUNvVCxVQUFVLENBQUM1UyxPQUFPUixRQUFRO2dCQUN6RCxNQUFNcVQsWUFBWXhQLGtCQUFrQjtnQkFDcEMsSUFBSW1GLE9BQU9xSyxXQUFXO29CQUNwQixNQUFNQyxPQUFPLElBQUksQ0FBQ3RLLE9BQU9xSyxTQUFRLElBQU14UCxDQUFBQSxrQkFBa0J3UCxTQUFRO29CQUNqRTNFLElBQUl6QixJQUFJLENBQUN2SyxRQUFRLENBQUM2RSxPQUFPLEdBQUdsRCxLQUFLbUssR0FBRyxDQUFDLEdBQUc4RTtvQkFDeEM1RSxJQUFJekIsSUFBSSxDQUFDdkssUUFBUSxDQUFDMEgsV0FBVyxHQUFHO29CQUNoQ3NFLElBQUl4QixJQUFJLENBQUN4SyxRQUFRLENBQUM2RSxPQUFPLEdBQUdsRCxLQUFLbUssR0FBRyxDQUFDLEdBQUc4RSxPQUFPO29CQUMvQzVFLElBQUl4QixJQUFJLENBQUN4SyxRQUFRLENBQUMwSCxXQUFXLEdBQUc7Z0JBQ2xDO2dCQUNBLHlEQUF5RDtnQkFDekQsNEJBQTRCO2dCQUM1QixJQUFJLENBQUNvQixrQkFBa0IsT0FBT3hDLE9BQU9uRixtQkFBbUI2SyxJQUFJekIsSUFBSSxDQUFDdkssUUFBUSxDQUFDNkUsT0FBTyxJQUFJLElBQUcsS0FBTSxDQUFDbUgsSUFBSTZFLFVBQVUsRUFBRTtvQkFDN0dqVCxNQUFNa1QsTUFBTSxDQUFDOUUsSUFBSXpCLElBQUk7b0JBQ3JCLDRCQUE0QjtvQkFDNUJ5QixJQUFJNkUsVUFBVSxHQUFHO29CQUNqQjdFLElBQUkrRSxXQUFXLEdBQUc7b0JBQ2xCLElBQUksQ0FBQy9TLE9BQU9nVCxZQUFZLEVBQUVoVCxPQUFPZ1QsWUFBWSxHQUFHLEVBQUU7b0JBQ2xEaFQsT0FBT2dULFlBQVksQ0FBQ3JPLElBQUksQ0FBQzt3QkFBRTZILE1BQU13QixJQUFJeEIsSUFBSTt3QkFBRUwsV0FBVzZCLElBQUk3QixTQUFTO3dCQUFFbkIsS0FBSztvQkFBRTtvQkFDNUVqRCxjQUFja0wsTUFBTSxDQUFDNU4sR0FBRztnQkFDMUI7WUFDRjtZQUNBLGlCQUFpQjtZQUNqQixJQUFJckYsT0FBT3dTLFdBQVcsRUFBRTtnQkFDdEIsSUFBSyxJQUFJbk4sSUFBSXJGLE9BQU93UyxXQUFXLENBQUN0TixNQUFNLEdBQUcsR0FBR0csS0FBSyxHQUFHQSxJQUFLO29CQUN2RCxNQUFNc0YsUUFBUTNLLE9BQU93UyxXQUFXLENBQUNuTixFQUFFO29CQUNuQ3NGLE1BQU1yTCxRQUFRLENBQUMrRyxHQUFHLENBQUNzRSxNQUFNMEgsUUFBUTtvQkFDakMxSCxNQUFNNEgsUUFBUTtvQkFDZDVILE1BQU0zSSxRQUFRLENBQUM2RSxPQUFPLElBQUk7b0JBQzFCLElBQUk4RCxNQUFNNEgsUUFBUSxHQUFHNUgsTUFBTTJILFNBQVMsRUFBRTt3QkFDcEMxUyxNQUFNa1QsTUFBTSxDQUFDbkk7d0JBQ2IzSyxPQUFPd1MsV0FBVyxDQUFDUyxNQUFNLENBQUM1TixHQUFHO29CQUMvQjtnQkFDRjtZQUNGO1lBQ0EseUNBQXlDO1lBQ3pDLElBQUlyRixPQUFPd1IsU0FBUyxFQUFFO2dCQUNwQixJQUFLLElBQUluTSxJQUFJckYsT0FBT3dSLFNBQVMsQ0FBQ3RNLE1BQU0sR0FBRyxHQUFHRyxLQUFLLEdBQUdBLElBQUs7b0JBQ3JELE1BQU04TCxVQUFVblIsT0FBT3dSLFNBQVMsQ0FBQ25NLEVBQUU7b0JBQ25DOEwsUUFBUTdSLFFBQVEsQ0FBQytHLEdBQUcsQ0FBQzhLLFFBQVFHLFFBQVEsQ0FBQ3hJLFFBQVE7b0JBQzlDcUksUUFBUUcsUUFBUSxDQUFDdEcsR0FBRztvQkFDcEJtRyxRQUFRblAsUUFBUSxDQUFDNkUsT0FBTyxJQUFJO29CQUM1QixJQUFJc0ssUUFBUUcsUUFBUSxDQUFDdEcsR0FBRyxHQUFJbUcsQ0FBQUEsUUFBUUcsUUFBUSxDQUFDQyxNQUFNLElBQUksRUFBQyxHQUFJO3dCQUMxRDNSLE1BQU1rVCxNQUFNLENBQUMzQjt3QkFDYm5SLE9BQU93UixTQUFTLENBQUN5QixNQUFNLENBQUM1TixHQUFHO29CQUM3QjtnQkFDRjtZQUNGO1lBQ0EsZ0NBQWdDO1lBQ2hDLElBQUlyRixPQUFPZ1QsWUFBWSxFQUFFO2dCQUN2QixJQUFLLElBQUkzTixJQUFJckYsT0FBT2dULFlBQVksQ0FBQzlOLE1BQU0sR0FBRyxHQUFHRyxLQUFLLEdBQUdBLElBQUs7b0JBQ3hELE1BQU02TixRQUFRbFQsT0FBT2dULFlBQVksQ0FBQzNOLEVBQUU7b0JBQ3BDLElBQUk2TixNQUFNMUcsSUFBSSxFQUFFO3dCQUNkMEcsTUFBTTFHLElBQUksQ0FBQ3hLLFFBQVEsQ0FBQzZFLE9BQU8sSUFBSTt3QkFDL0IsSUFBSXFNLE1BQU0xRyxJQUFJLENBQUN4SyxRQUFRLENBQUM2RSxPQUFPLEdBQUcsTUFBTTs0QkFDdENqSCxNQUFNa1QsTUFBTSxDQUFDSSxNQUFNMUcsSUFBSTs0QkFDdkJ4TSxPQUFPZ1QsWUFBWSxDQUFDQyxNQUFNLENBQUM1TixHQUFHOzRCQUM5Qjt3QkFDRjtvQkFDRjtvQkFDQSxJQUFJNk4sTUFBTS9HLFNBQVMsRUFBRTt3QkFDbkIrRyxNQUFNL0csU0FBUyxDQUFDbkssUUFBUSxDQUFDNkUsT0FBTyxJQUFJO3dCQUNwQyxJQUFJcU0sTUFBTS9HLFNBQVMsQ0FBQ25LLFFBQVEsQ0FBQzZFLE9BQU8sR0FBRyxNQUFNOzRCQUMzQ3ZFLGtCQUFrQndRLE1BQU0sQ0FBQ0ksTUFBTS9HLFNBQVM7NEJBQ3hDK0csTUFBTS9HLFNBQVMsR0FBRzt3QkFDcEI7b0JBQ0Y7b0JBQ0ErRyxNQUFNbEksR0FBRztnQkFDWDtZQUNGO1lBRUEsa0JBQWtCO1lBQ2xCLElBQUloTCxPQUFPNFIsWUFBWSxFQUFFO2dCQUN2QixJQUFLLElBQUl2TSxJQUFJckYsT0FBTzRSLFlBQVksQ0FBQzFNLE1BQU0sR0FBRyxHQUFHRyxLQUFLLEdBQUdBLElBQUs7b0JBQ3hELE1BQU1zTSxRQUFRM1IsT0FBTzRSLFlBQVksQ0FBQ3ZNLEVBQUU7b0JBQ3BDc00sTUFBTXBGLElBQUksQ0FBQ25GLEtBQUssQ0FBQ29CLGNBQWMsQ0FBQztvQkFDaENtSixNQUFNcEYsSUFBSSxDQUFDdkssUUFBUSxDQUFDNkUsT0FBTyxJQUFJO29CQUMvQjhLLE1BQU0zRyxHQUFHO29CQUNULElBQUkyRyxNQUFNM0csR0FBRyxHQUFHLElBQUk7d0JBQ2xCcEwsTUFBTWtULE1BQU0sQ0FBQ25CLE1BQU1wRixJQUFJO3dCQUN2QnZNLE9BQU80UixZQUFZLENBQUNxQixNQUFNLENBQUM1TixHQUFHO29CQUNoQztnQkFDRjtZQUNGO1lBRUEsMEJBQTBCO1lBQzFCLE1BQU04TixTQUFTaFEsa0JBQWtCQTtZQUNqQyxJQUFLLElBQUlrQyxJQUFJLEdBQUdBLElBQUk3QixVQUFVMEIsTUFBTSxFQUFFRyxLQUFLLEVBQUc7Z0JBQzVDLE1BQU0rTixLQUFLNVAsU0FBUyxDQUFDNkIsRUFBRSxHQUFHakYsaUJBQWlCK0IsQ0FBQztnQkFDNUMsTUFBTWtSLEtBQUs3UCxTQUFTLENBQUM2QixJQUFJLEVBQUUsR0FBR2pGLGlCQUFpQmdDLENBQUM7Z0JBQ2hELE1BQU1rUixLQUFLOVAsU0FBUyxDQUFDNkIsSUFBSSxFQUFFLEdBQUdqRixpQkFBaUIyRSxDQUFDO2dCQUNoRCxJQUFJcU8sS0FBR0EsS0FBS0MsS0FBR0EsS0FBS0MsS0FBR0EsS0FBS0gsUUFBUTtvQkFDbEMsOEVBQThFO29CQUM5RSxNQUFNSSxZQUFZcFEsa0JBQWtCO29CQUNwQyxNQUFNcVEsWUFBWXJRO29CQUNsQixNQUFNMkIsSUFBSXlPLFlBQVk1UCxLQUFLQyxNQUFNLEtBQU00UCxDQUFBQSxZQUFZRCxTQUFRO29CQUMzRCxNQUFNM08sUUFBUWpCLEtBQUtDLE1BQU0sS0FBSyxJQUFJRCxLQUFLRyxFQUFFO29CQUN6QyxNQUFNZSxNQUFNbEIsS0FBS0ssSUFBSSxDQUFDLElBQUlMLEtBQUtDLE1BQU0sS0FBSztvQkFDMUNKLFNBQVMsQ0FBQzZCLEVBQUUsR0FBR2pGLGlCQUFpQitCLENBQUMsR0FBRzJDLElBQUluQixLQUFLUSxHQUFHLENBQUNVLE9BQU9sQixLQUFLUyxHQUFHLENBQUNRO29CQUNqRXBCLFNBQVMsQ0FBQzZCLElBQUUsRUFBRSxHQUFHakYsaUJBQWlCZ0MsQ0FBQyxHQUFHMEMsSUFBSW5CLEtBQUtRLEdBQUcsQ0FBQ1UsT0FBT2xCLEtBQUtRLEdBQUcsQ0FBQ1M7b0JBQ25FcEIsU0FBUyxDQUFDNkIsSUFBRSxFQUFFLEdBQUdqRixpQkFBaUIyRSxDQUFDLEdBQUdELElBQUluQixLQUFLUyxHQUFHLENBQUNTO2dCQUNyRDtZQUNGO1lBQ0Esd0VBQXdFO1lBRXhFLDREQUE0RDtZQUM1RCx1QkFBdUI7WUFDdkIsTUFBTTRPLFNBQVNwUSxTQUFTa0MsVUFBVSxDQUFDQyxLQUFLLENBQUNDLEtBQUs7WUFDOUMsSUFBSyxJQUFJSixJQUFJLEdBQUdBLElBQUk3QixVQUFVMEIsTUFBTSxFQUFFRyxLQUFLLEVBQUc7Z0JBQzVDLE1BQU15SCxNQUFNekgsSUFBSTtnQkFDaEIsTUFBTStOLEtBQUs1UCxTQUFTLENBQUM2QixFQUFFLEdBQUdqRixpQkFBaUIrQixDQUFDO2dCQUM1QyxNQUFNa1IsS0FBSzdQLFNBQVMsQ0FBQzZCLElBQUksRUFBRSxHQUFHakYsaUJBQWlCZ0MsQ0FBQztnQkFDaEQsTUFBTWtSLEtBQUs5UCxTQUFTLENBQUM2QixJQUFJLEVBQUUsR0FBR2pGLGlCQUFpQjJFLENBQUM7Z0JBQ2hELE1BQU11RCxPQUFPM0UsS0FBSzRKLElBQUksQ0FBQzZGLEtBQUtBLEtBQUtDLEtBQUtBLEtBQUtDLEtBQUtBO2dCQUNoRCxJQUFJM04sTUFBTSxDQUFDbUgsSUFBSSxHQUFHLEdBQUc7b0JBQ25CbkgsTUFBTSxDQUFDbUgsSUFBSTtvQkFDWCxJQUFJbkgsTUFBTSxDQUFDbUgsSUFBSSxLQUFLLEdBQUc7d0JBQ3JCLCtCQUErQjt3QkFDL0JqSCxXQUFXLENBQUNSLEVBQUUsR0FBR0MsY0FBYyxDQUFDRCxFQUFFO3dCQUNsQ1EsV0FBVyxDQUFDUixJQUFFLEVBQUUsR0FBR0MsY0FBYyxDQUFDRCxJQUFFLEVBQUU7d0JBQ3RDUSxXQUFXLENBQUNSLElBQUUsRUFBRSxHQUFHQyxjQUFjLENBQUNELElBQUUsRUFBRTt3QkFDdENvTyxNQUFNLENBQUNwTyxFQUFFLEdBQUdDLGNBQWMsQ0FBQ0QsRUFBRTt3QkFDN0JvTyxNQUFNLENBQUNwTyxJQUFFLEVBQUUsR0FBR0MsY0FBYyxDQUFDRCxJQUFFLEVBQUU7d0JBQ2pDb08sTUFBTSxDQUFDcE8sSUFBRSxFQUFFLEdBQUdDLGNBQWMsQ0FBQ0QsSUFBRSxFQUFFO29CQUNuQyxPQUFPO3dCQUNMb08sTUFBTSxDQUFDcE8sRUFBRSxHQUFHUSxXQUFXLENBQUNSLEVBQUU7d0JBQzFCb08sTUFBTSxDQUFDcE8sSUFBRSxFQUFFLEdBQUdRLFdBQVcsQ0FBQ1IsSUFBRSxFQUFFO3dCQUM5Qm9PLE1BQU0sQ0FBQ3BPLElBQUUsRUFBRSxHQUFHUSxXQUFXLENBQUNSLElBQUUsRUFBRTtvQkFDaEM7Z0JBQ0YsT0FBTyxJQUFJaUQsT0FBT25GLGtCQUFrQixPQUFPUSxLQUFLQyxNQUFNLEtBQUssTUFBTTtvQkFDL0QrQixNQUFNLENBQUNtSCxJQUFJLEdBQUdoSDtvQkFDZCxNQUFNdkIsSUFBSVksT0FBTyxDQUFDeEIsS0FBS1csS0FBSyxDQUFDWCxLQUFLQyxNQUFNLEtBQUt1QixRQUFRRCxNQUFNLEVBQUU7b0JBQzdEVyxXQUFXLENBQUNSLEVBQUUsR0FBR2QsQ0FBQyxDQUFDLEVBQUU7b0JBQ3JCc0IsV0FBVyxDQUFDUixJQUFFLEVBQUUsR0FBR2QsQ0FBQyxDQUFDLEVBQUU7b0JBQ3ZCc0IsV0FBVyxDQUFDUixJQUFFLEVBQUUsR0FBR2QsQ0FBQyxDQUFDLEVBQUU7b0JBQ3ZCa1AsTUFBTSxDQUFDcE8sRUFBRSxHQUFHUSxXQUFXLENBQUNSLEVBQUU7b0JBQzFCb08sTUFBTSxDQUFDcE8sSUFBRSxFQUFFLEdBQUdRLFdBQVcsQ0FBQ1IsSUFBRSxFQUFFO29CQUM5Qm9PLE1BQU0sQ0FBQ3BPLElBQUUsRUFBRSxHQUFHUSxXQUFXLENBQUNSLElBQUUsRUFBRTtnQkFDaEMsT0FBTztvQkFDTFEsV0FBVyxDQUFDUixFQUFFLEdBQUdDLGNBQWMsQ0FBQ0QsRUFBRTtvQkFDbENRLFdBQVcsQ0FBQ1IsSUFBRSxFQUFFLEdBQUdDLGNBQWMsQ0FBQ0QsSUFBRSxFQUFFO29CQUN0Q1EsV0FBVyxDQUFDUixJQUFFLEVBQUUsR0FBR0MsY0FBYyxDQUFDRCxJQUFFLEVBQUU7b0JBQ3RDb08sTUFBTSxDQUFDcE8sRUFBRSxHQUFHQyxjQUFjLENBQUNELEVBQUU7b0JBQzdCb08sTUFBTSxDQUFDcE8sSUFBRSxFQUFFLEdBQUdDLGNBQWMsQ0FBQ0QsSUFBRSxFQUFFO29CQUNqQ29PLE1BQU0sQ0FBQ3BPLElBQUUsRUFBRSxHQUFHQyxjQUFjLENBQUNELElBQUUsRUFBRTtnQkFDbkM7WUFDRjtZQUNBaEMsU0FBU2tDLFVBQVUsQ0FBQ0MsS0FBSyxDQUFDcUgsV0FBVyxHQUFHO1FBQzFDO1FBRUEsMkJBQTJCO1FBQzNCRjtRQUVBLHVCQUF1QjtRQUN2QixNQUFNK0csV0FBVztZQUNmNVQsT0FBT2lELE1BQU0sR0FBRy9DLE9BQU9DLFVBQVUsR0FBR0QsT0FBT0UsV0FBVztZQUN0REosT0FBT2tELHNCQUFzQjtZQUM3QjFDLFNBQVNLLE9BQU8sQ0FBQ1gsT0FBT0MsVUFBVSxFQUFFRCxPQUFPRSxXQUFXO1lBQ3REcUMscUJBQXFCNUIsT0FBTyxDQUFDWCxPQUFPQyxVQUFVLEVBQUVELE9BQU9FLFdBQVc7WUFDbEUwQyxXQUFXakMsT0FBTyxDQUFDWCxPQUFPQyxVQUFVLEVBQUVELE9BQU9FLFdBQVc7UUFDMUQ7UUFFQSxnQ0FBZ0M7UUFDaENGLE9BQU9pRCxnQkFBZ0IsQ0FBQyxVQUFVeVE7UUFFbEMsb0JBQW9CO1FBQ3BCLE9BQU87WUFDTDFULE9BQU8yVCxtQkFBbUIsQ0FBQyxVQUFVRDtZQUNyQzFULE9BQU8yVCxtQkFBbUIsQ0FBQyxVQUFVN1E7WUFDckM5QyxPQUFPMlQsbUJBQW1CLENBQUMsb0JBQW9CN1E7WUFDL0M5QyxPQUFPMlQsbUJBQW1CLENBQUMsVUFBVW5NO1lBQ3JDLGlEQUFpRDtZQUNqRCxJQUFJa0YsYUFBYTtnQkFDZmtILHFCQUFxQmxIO1lBQ3ZCO1lBQ0Esb0JBQW9CO1lBQ3BCLElBQUlqTCxVQUFVQSxTQUFTb1MsT0FBTztZQUM5QixJQUFJdFIsc0JBQXNCQSxxQkFBcUJzUixPQUFPO1lBQ3RELElBQUlqUixZQUFZQSxXQUFXaVIsT0FBTztZQUNsQyw4QkFBOEI7WUFDOUIsSUFBSXZULFVBQVU7Z0JBQ1pBLFNBQVN1VCxPQUFPO2dCQUNoQixJQUFJelUsU0FBU0EsTUFBTTBVLFFBQVEsQ0FBQ3hULFNBQVNrQixVQUFVLEdBQUc7b0JBQ2hEcEMsTUFBTTJVLFdBQVcsQ0FBQ3pULFNBQVNrQixVQUFVO2dCQUN2QztZQUNGO1FBQ0Y7SUFDRixHQUFHLEVBQUU7SUFFTCxxQkFBTyw4REFBQ3dTO1FBQUlDLEtBQUsvVTs7Ozs7O0FBQ25CO0dBM3hCTUQ7S0FBQUE7QUE2eEJOLCtEQUFlQSxTQUFTQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvU3RhcmZpZWxkLmpzeD9mMWEyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCB7IEVmZmVjdENvbXBvc2VyIH0gZnJvbSAndGhyZWUvZXhhbXBsZXMvanNtL3Bvc3Rwcm9jZXNzaW5nL0VmZmVjdENvbXBvc2VyJztcbmltcG9ydCB7IFVucmVhbEJsb29tUGFzcyB9IGZyb20gJ3RocmVlL2V4YW1wbGVzL2pzbS9wb3N0cHJvY2Vzc2luZy9VbnJlYWxCbG9vbVBhc3MnO1xuaW1wb3J0IHsgUmVuZGVyUGFzcyB9IGZyb20gJ3RocmVlL2V4YW1wbGVzL2pzbS9wb3N0cHJvY2Vzc2luZy9SZW5kZXJQYXNzJztcbmltcG9ydCB7IFNoYWRlclBhc3MgfSBmcm9tICd0aHJlZS9leGFtcGxlcy9qc20vcG9zdHByb2Nlc3NpbmcvU2hhZGVyUGFzcyc7XG5pbXBvcnQgeyBGWEFBU2hhZGVyIH0gZnJvbSAndGhyZWUvZXhhbXBsZXMvanNtL3NoYWRlcnMvRlhBQVNoYWRlcic7XG5pbXBvcnQgeyBGaWxtUGFzcyB9IGZyb20gJ3RocmVlL2V4YW1wbGVzL2pzbS9wb3N0cHJvY2Vzc2luZy9GaWxtUGFzcyc7XG5pbXBvcnQgeyBDaHJvbWF0aWNBYmVycmF0aW9uUGFzcyB9IGZyb20gJy4vQ2hyb21hdGljQWJlcnJhdGlvblBhc3MnO1xuXG5jb25zdCBTdGFyZmllbGQgPSAoKSA9PiB7XG4gIGNvbnN0IG1vdW50UmVmID0gdXNlUmVmKG51bGwpXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBEZWZlbnNpdmU6IGFsd2F5cyB1c2UgLmN1cnJlbnQgZm9yIHJlZnNcbiAgICBpZiAoIW1vdW50UmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICBjb25zdCBtb3VudCA9IG1vdW50UmVmLmN1cnJlbnRcbiAgICBtb3VudC5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCdcbiAgICBtb3VudC5zdHlsZS50b3AgPSAnMCdcbiAgICBtb3VudC5zdHlsZS5sZWZ0ID0gJzAnXG4gICAgbW91bnQuc3R5bGUud2lkdGggPSAnMTAwJSdcbiAgICBtb3VudC5zdHlsZS5oZWlnaHQgPSAnMTAwJSdcbiAgICBtb3VudC5zdHlsZS56SW5kZXggPSAnMCdcblxuICAgIC8vIFNjZW5lICYgUmVuZGVyZXJcbiAgICBjb25zdCBzY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpXG4gICAgY29uc3QgY2FtZXJhID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKDc1LCB3aW5kb3cuaW5uZXJXaWR0aCAvIHdpbmRvdy5pbm5lckhlaWdodCwgMC4xLCA1MDAwKVxuICAgIGNhbWVyYS5wb3NpdGlvbi5zZXQoMCwgMCwgMCk7XG4gICAgLy8gVmlydHVhbCBwb3NpdGlvbiB0byBzaW11bGF0ZSBpbmZpbml0ZSB0cmF2ZWxcbiAgICBsZXQgdmlydHVhbENhbWVyYVBvcyA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDApO1xuICAgIGNvbnN0IHJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoeyBhbnRpYWxpYXM6IGZhbHNlIH0pIC8vIFdlJ2xsIHVzZSBGWEFBIGluc3RlYWRcbiAgICByZW5kZXJlci5zZXRQaXhlbFJhdGlvKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKVxuICAgIHJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodClcbiAgICByZW5kZXJlci5zZXRDbGVhckNvbG9yKDB4MDAwMDAwLCAxKTtcbiAgICBpZiAoJ291dHB1dENvbG9yU3BhY2UnIGluIHJlbmRlcmVyKSB7XG4gICAgICByZW5kZXJlci5vdXRwdXRDb2xvclNwYWNlID0gVEhSRUUuU1JHQkNvbG9yU3BhY2U7XG4gICAgfVxuICAgIC8vIENyZWF0ZSBhIHJlbmRlciB0YXJnZXQgZm9yIHRoZSBjb21wb3NlciB3aXRoIGNvcnJlY3QgY29sb3Igc3BhY2VcbiAgICBjb25zdCByZW5kZXJUYXJnZXQgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCwge1xuICAgICAgY29sb3JTcGFjZTogVEhSRUUuU1JHQkNvbG9yU3BhY2UsXG4gICAgICB0eXBlOiBUSFJFRS5VbnNpZ25lZEJ5dGVUeXBlXG4gICAgfSk7XG4gICAgcmVuZGVyZXIudG9uZU1hcHBpbmcgPSBUSFJFRS5Ob1RvbmVNYXBwaW5nO1xuICAgIHJlbmRlcmVyLmF1dG9DbGVhciA9IHRydWU7XG4gICAgbW91bnQuYXBwZW5kQ2hpbGQocmVuZGVyZXIuZG9tRWxlbWVudClcblxuICAgIC8vIC0tLSBNQUlOIFNUQVJGSUVMRCBQT1NULVBST0NFU1NJTkcgLS0tXG4gICAgY29uc3QgY29tcG9zZXIgPSBuZXcgRWZmZWN0Q29tcG9zZXIocmVuZGVyZXIsIHJlbmRlclRhcmdldCk7XG4gICAgY29tcG9zZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICBjb25zdCByZW5kZXJQYXNzID0gbmV3IFJlbmRlclBhc3Moc2NlbmUsIGNhbWVyYSk7XG4gICAgcmVuZGVyUGFzcy5jbGVhciA9IHRydWU7XG4gICAgY29tcG9zZXIuYWRkUGFzcyhyZW5kZXJQYXNzKTtcbiAgICAvLyBVbnJlYWxCbG9vbVBhc3M6IFwiY3JhenlcIiBibG9vbVxuICAgIGNvbnN0IGJsb29tUGFzcyA9IG5ldyBVbnJlYWxCbG9vbVBhc3MoXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMih3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KSxcbiAgICAgIDMuNSwgLy8gaW50ZW5zaXR5XG4gICAgICAxLjYsIC8vIHJhZGl1c1xuICAgICAgMC4wMSAvLyB0aHJlc2hvbGRcbiAgICApO1xuICAgIGNvbXBvc2VyLmFkZFBhc3MoYmxvb21QYXNzKTtcbiAgICAvLyBGWEFBIFBhc3NcbiAgICBjb25zdCBmeGFhUGFzcyA9IG5ldyBTaGFkZXJQYXNzKEZYQUFTaGFkZXIpO1xuICAgIGZ4YWFQYXNzLm1hdGVyaWFsLnVuaWZvcm1zWydyZXNvbHV0aW9uJ10udmFsdWUueCA9IDEgLyB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICBmeGFhUGFzcy5tYXRlcmlhbC51bmlmb3Jtc1sncmVzb2x1dGlvbiddLnZhbHVlLnkgPSAxIC8gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIGNvbXBvc2VyLmFkZFBhc3MoZnhhYVBhc3MpO1xuICAgIC8vIEZpbG1QYXNzXG4gICAgY29uc3QgZmlsbVBhc3MgPSBuZXcgRmlsbVBhc3MoXG4gICAgICAwLjAsIC8vIG5vaXNlIGludGVuc2l0eSAod2FzIDAuNylcbiAgICAgIDAuMCwgLy8gc2NhbmxpbmUgaW50ZW5zaXR5ICh3YXMgMC4wOClcbiAgICAgIDY0OCwgLy8gc2NhbmxpbmUgY291bnRcbiAgICAgIGZhbHNlIC8vIGdyYXlzY2FsZVxuICAgICk7XG4gICAgY29tcG9zZXIuYWRkUGFzcyhmaWxtUGFzcyk7XG5cbiAgICBcbiAgICAvLyAtLS0gU0hPT1RJTkcgU1RBUiBQT1NULVBST0NFU1NJTkcgT05MWSAtLS1cbiAgICAvLyBTZXBhcmF0ZSBzY2VuZSBhbmQgY29tcG9zZXIgZm9yIHNob290aW5nIHN0YXJzXG4gICAgY29uc3Qgc2hvb3RpbmdTdGFyU2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcbiAgICBjb25zdCBzaG9vdGluZ1N0YXJDb21wb3NlciA9IG5ldyBFZmZlY3RDb21wb3NlcihyZW5kZXJlcik7XG4gICAgc2hvb3RpbmdTdGFyQ29tcG9zZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICBjb25zdCBzaG9vdGluZ1N0YXJSZW5kZXJQYXNzID0gbmV3IFJlbmRlclBhc3Moc2hvb3RpbmdTdGFyU2NlbmUsIGNhbWVyYSk7XG4gICAgc2hvb3RpbmdTdGFyQ29tcG9zZXIuYWRkUGFzcyhzaG9vdGluZ1N0YXJSZW5kZXJQYXNzKTtcbiAgICAvLyBJbnRlbnNlIGJsb29tIGZvciBzaG9vdGluZyBzdGFyc1xuICAgIGNvbnN0IHNob290aW5nU3RhckJsb29tUGFzcyA9IG5ldyBVbnJlYWxCbG9vbVBhc3MoXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMih3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KSxcbiAgICAgIDQuMCwgLy8gc3Ryb25nXG4gICAgICAyLjAsIC8vIHdpZGVcbiAgICAgIDAuMCAvLyBhbGwgYnJpZ2h0XG4gICAgKTtcbiAgICBzaG9vdGluZ1N0YXJDb21wb3Nlci5hZGRQYXNzKHNob290aW5nU3RhckJsb29tUGFzcyk7XG5cbiAgICAvLyAtLS0gQ0xPU0UgU1RBUlM6IFNlcGFyYXRlIFNjZW5lIGZvciBDaHJvbWF0aWMgQWJlcnJhdGlvbiAtLS1cbiAgICBjb25zdCBjbG9zZVN0YXJzU2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcbiAgICBjb25zdCBjYVBhc3MgPSBuZXcgQ2hyb21hdGljQWJlcnJhdGlvblBhc3MobmV3IFRIUkVFLlZlY3RvcjIoMC4wMDAyLCAwLjAwMDIpKTsgLy8gYmFyZWx5IHZpc2libGVcbiAgICBjb25zdCBjYUNvbXBvc2VyID0gbmV3IEVmZmVjdENvbXBvc2VyKHJlbmRlcmVyKTtcbiAgICBjYUNvbXBvc2VyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgY29uc3QgY2FSZW5kZXJQYXNzID0gbmV3IFJlbmRlclBhc3MoY2xvc2VTdGFyc1NjZW5lLCBjYW1lcmEpO1xuICAgIGNhQ29tcG9zZXIuYWRkUGFzcyhjYVJlbmRlclBhc3MpO1xuICAgIGNhQ29tcG9zZXIuYWRkUGFzcyhjYVBhc3MpO1xuXG4gICAgLy8gLS0tIEhBTkRMRSBSRVNJWkUgQU5EIEZVTExTQ1JFRU4gLS0tXG4gICAgZnVuY3Rpb24gcmVzaXplQWxsKCkge1xuICAgICAgY2FtZXJhLmFzcGVjdCA9IHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAgIHJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG5cbiAgICAgIC8vIE1haW4gY29tcG9zZXJcbiAgICAgIGNvbXBvc2VyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgICAvLyBGWEFBIHJlc29sdXRpb25cbiAgICAgIGZ4YWFQYXNzLm1hdGVyaWFsLnVuaWZvcm1zWydyZXNvbHV0aW9uJ10udmFsdWUueCA9IDEgLyB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgIGZ4YWFQYXNzLm1hdGVyaWFsLnVuaWZvcm1zWydyZXNvbHV0aW9uJ10udmFsdWUueSA9IDEgLyB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICAvLyBPdGhlciBjb21wb3NlcnNcbiAgICAgIHNob290aW5nU3RhckNvbXBvc2VyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgICBjYUNvbXBvc2VyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgfVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCByZXNpemVBbGwpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdmdWxsc2NyZWVuY2hhbmdlJywgcmVzaXplQWxsKTtcblxuICAgIC8vIFN0YXJmaWVsZFxuICAgIGNvbnN0IHN0YXJDb3VudCA9IDUwMDBcbiAgICBjb25zdCBzdGFyTWF4RGlzdGFuY2UgPSAyMDAwXG4gICAgY29uc3Qgc3RhclNwZWVkID0gMVxuICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KClcbiAgICBjb25zdCBjbG9zZUdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XG4gICAgY29uc3QgcG9zaXRpb25zID0gW107XG4gICAgY29uc3QgY2xvc2VQb3NpdGlvbnMgPSBbXTtcbiAgICBsZXQgc3RhcnNQbGFjZWQgPSAwO1xuICAgIHdoaWxlIChzdGFyc1BsYWNlZCA8IHN0YXJDb3VudCkge1xuICAgICAgLy8gV2l0aCAxJSBjaGFuY2UsIHNwYXduIGEgc3RhciBjbHVzdGVyICgxMC0zMCBzdGFycylcbiAgICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgMC4wMSAmJiBzdGFyc1BsYWNlZCA8IHN0YXJDb3VudCAtIDEwKSB7XG4gICAgICAgIGNvbnN0IGNsdXN0ZXJUaGV0YSA9IE1hdGgucmFuZG9tKCkgKiAyICogTWF0aC5QSTtcbiAgICAgICAgY29uc3QgY2x1c3RlclBoaSA9IE1hdGguYWNvcygyICogTWF0aC5yYW5kb20oKSAtIDEpO1xuICAgICAgICBjb25zdCBjbHVzdGVyUiA9IE1hdGgucmFuZG9tKCkgKiBzdGFyTWF4RGlzdGFuY2U7XG4gICAgICAgIGNvbnN0IGNsdXN0ZXJDZW50ZXIgPSBbXG4gICAgICAgICAgY2x1c3RlclIgKiBNYXRoLnNpbihjbHVzdGVyUGhpKSAqIE1hdGguY29zKGNsdXN0ZXJUaGV0YSksXG4gICAgICAgICAgY2x1c3RlclIgKiBNYXRoLnNpbihjbHVzdGVyUGhpKSAqIE1hdGguc2luKGNsdXN0ZXJUaGV0YSksXG4gICAgICAgICAgY2x1c3RlclIgKiBNYXRoLmNvcyhjbHVzdGVyUGhpKVxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBjbHVzdGVyU2l6ZSA9IDEwICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjApOyAvLyAxMC0zMCBzdGFyc1xuICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGNsdXN0ZXJTaXplICYmIHN0YXJzUGxhY2VkIDwgc3RhckNvdW50OyBjKyspIHtcbiAgICAgICAgICAvLyBFYWNoIHN0YXIgaW4gY2x1c3RlciBpcyB3aXRoaW4gMzAgdW5pdHMgb2YgY2VudGVyXG4gICAgICAgICAgY29uc3Qgb2Zmc2V0VGhldGEgPSBNYXRoLnJhbmRvbSgpICogMiAqIE1hdGguUEk7XG4gICAgICAgICAgY29uc3Qgb2Zmc2V0UGhpID0gTWF0aC5hY29zKDIgKiBNYXRoLnJhbmRvbSgpIC0gMSk7XG4gICAgICAgICAgY29uc3Qgb2Zmc2V0UiA9IE1hdGgucmFuZG9tKCkgKiAzMDsgLy8gY2x1c3RlciByYWRpdXNcbiAgICAgICAgICBwb3NpdGlvbnMucHVzaChcbiAgICAgICAgICAgIGNsdXN0ZXJDZW50ZXJbMF0gKyBvZmZzZXRSICogTWF0aC5zaW4ob2Zmc2V0UGhpKSAqIE1hdGguY29zKG9mZnNldFRoZXRhKSxcbiAgICAgICAgICAgIGNsdXN0ZXJDZW50ZXJbMV0gKyBvZmZzZXRSICogTWF0aC5zaW4ob2Zmc2V0UGhpKSAqIE1hdGguc2luKG9mZnNldFRoZXRhKSxcbiAgICAgICAgICAgIGNsdXN0ZXJDZW50ZXJbMl0gKyBvZmZzZXRSICogTWF0aC5jb3Mob2Zmc2V0UGhpKVxuICAgICAgICAgICk7XG4gICAgICAgICAgc3RhcnNQbGFjZWQrKztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm9ybWFsIHNpbmdsZSBzdGFyXG4gICAgICAgIGNvbnN0IHRoZXRhID0gTWF0aC5yYW5kb20oKSAqIDIgKiBNYXRoLlBJO1xuICAgICAgICBjb25zdCBwaGkgPSBNYXRoLmFjb3MoMiAqIE1hdGgucmFuZG9tKCkgLSAxKTtcbiAgICAgICAgY29uc3QgciA9IE1hdGgucmFuZG9tKCkgKiBzdGFyTWF4RGlzdGFuY2U7XG4gICAgICAgIGNvbnN0IHggPSByICogTWF0aC5zaW4ocGhpKSAqIE1hdGguY29zKHRoZXRhKTtcbiAgICAgICAgY29uc3QgeSA9IHIgKiBNYXRoLnNpbihwaGkpICogTWF0aC5zaW4odGhldGEpO1xuICAgICAgICBjb25zdCB6ID0gciAqIE1hdGguY29zKHBoaSk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKHgsIHksIHopO1xuICAgICAgICAvLyBJZiBjbG9zZSwgYWxzbyBhZGQgdG8gY2xvc2VQb3NpdGlvbnNcbiAgICAgICAgaWYgKHIgPCA0MDApIHtcbiAgICAgICAgICBjbG9zZVBvc2l0aW9ucy5wdXNoKHgsIHksIHopO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJzUGxhY2VkKys7XG4gICAgICB9XG4gICAgfVxuICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgVEhSRUUuRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbnMsIDMpKVxuICAgIGlmIChjbG9zZVBvc2l0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICBjbG9zZUdlb21ldHJ5LnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgVEhSRUUuRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShjbG9zZVBvc2l0aW9ucywgMykpO1xuICAgIH1cblxuICAgIC8vIENSQVpZIEJMT09NOiBBbGwgc3RhcnMgYXJlIGV4dHJlbWVseSBicmlnaHQgKGNvbG9yIGludGVuc2l0eSA+MSlcbiAgICBjb25zdCBwYWxldHRlID0gW1xuICAgICAgWzEuMCwgMC41LCAwLjVdLFxuICAgICAgWzEuMCwgMC43NSwgMC40XSxcbiAgICAgIFsxLjAsIDEuMCwgMC45XSxcbiAgICAgIFsxLjAsIDEuMCwgMS4wXSxcbiAgICAgIFswLjQsIDAuNSwgMS4wXSxcbiAgICBdO1xuICAgIGNvbnN0IGNvbG9ycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhckNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IGMgPSBwYWxldHRlW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHBhbGV0dGUubGVuZ3RoKV07XG4gICAgICBjb2xvcnMucHVzaCguLi5jKTtcbiAgICB9XG4gICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdjb2xvcicsIG5ldyBUSFJFRS5GbG9hdDMyQnVmZmVyQXR0cmlidXRlKGNvbG9ycywgMykpO1xuXG4gICAgY29uc3Qgb3JpZ2luYWxDb2xvcnMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLmNvbG9yLmFycmF5LnNsaWNlKClcbiAgICBjb25zdCB0aW1lcnMgPSBuZXcgRmxvYXQzMkFycmF5KHN0YXJDb3VudClcbiAgICBjb25zdCBzcGFya0NvbG9ycyA9IG5ldyBGbG9hdDMyQXJyYXkoc3RhckNvdW50ICogMylcbiAgICBjb25zdCBzcGFya2xlRHVyYXRpb24gPSAxODBcblxuICAgIC8vIC0tLSBTUVVBUkUgU1RBUlMgVVNJTkcgUE9JTlRTIC0tLVxuY29uc3QgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuUG9pbnRzTWF0ZXJpYWwoeyBzaXplOiAxMCwgc2l6ZUF0dGVudWF0aW9uOiBmYWxzZSwgdmVydGV4Q29sb3JzOiB0cnVlIH0pO1xuY29uc3Qgc3RhcnMgPSBuZXcgVEhSRUUuUG9pbnRzKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG5zY2VuZS5hZGQoc3RhcnMpO1xuLy8gQWRkIGdsb3cgc3ByaXRlcyB0byBlYWNoIHN0YXIgYW5kIGFuaW1hdGUgdGhlbSBiYXNlZCBvbiBkaXN0YW5jZVxuY29uc3QgZ2xvd01hcCA9IG5ldyBUSFJFRS5UZXh0dXJlTG9hZGVyKCkubG9hZCgnL2dsb3cucG5nJyk7XG5jb25zdCBnbG93U3ByaXRlcyA9IFtdO1xuY29uc3QgZ2xvd01hdGVyaWFsID0gbmV3IFRIUkVFLlNwcml0ZU1hdGVyaWFsKHsgbWFwOiBnbG93TWFwLCBjb2xvcjogMHhmZmZmZmYsIG9wYWNpdHk6IDAuMTgsIGJsZW5kaW5nOiBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nLCBkZXB0aFdyaXRlOiBmYWxzZSB9KTtcbmZvciAobGV0IGkgPSAwOyBpIDwgc3RhckNvdW50OyBpKyspIHtcbiAgY29uc3QgZ2xvdyA9IG5ldyBUSFJFRS5TcHJpdGUoZ2xvd01hdGVyaWFsLmNsb25lKCkpO1xuICBnbG93LnBvc2l0aW9uLnNldChwb3NpdGlvbnNbaSozXSwgcG9zaXRpb25zW2kqMysxXSwgcG9zaXRpb25zW2kqMysyXSk7XG4gIGdsb3cuc2NhbGUuc2V0KDEwLCAxMCwgMSk7XG4gIHNjZW5lLmFkZChnbG93KTtcbiAgZ2xvd1Nwcml0ZXMucHVzaChnbG93KTtcbn1cbi8vIEFkZCBjbG9zZSBzdGFycyB0byBzZXBhcmF0ZSBzY2VuZVxubGV0IGNsb3NlU3RhcnM7XG5pZiAoY2xvc2VQb3NpdGlvbnMubGVuZ3RoID4gMCkge1xuICBjbG9zZVN0YXJzID0gbmV3IFRIUkVFLlBvaW50cyhjbG9zZUdlb21ldHJ5LCBtYXRlcmlhbC5jbG9uZSgpKTtcbiAgY2xvc2VTdGFyc1NjZW5lLmFkZChjbG9zZVN0YXJzKTtcbn1cblxuICAgIGxldCB0YXJnZXRZID0gMFxuICAgIGNvbnN0IGRhbXBpbmcgPSAwLjA1XG4gICAgY29uc3Qgb25TY3JvbGwgPSAoKSA9PiB7XG4gICAgICBjb25zdCBwY3QgPSB3aW5kb3cuc2Nyb2xsWSAvIChkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCAtIHdpbmRvdy5pbm5lckhlaWdodClcbiAgICAgIHRhcmdldFkgPSBwY3QgKiBNYXRoLlBJICogMlxuICAgIH1cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25TY3JvbGwpXG5cblxuICAgIC8vIC0tLSBTaG9vdGluZyBTdGFycyAtLS1cbiAgICBjb25zdCB0YWlsTGVuZ3RoID0gMzI7IC8vIEluY3JlYXNlIGZvciBsb25nZXIgdGFpbHNcbiAgICBjb25zdCBzaG9vdGluZ1N0YXJzID0gW107XG4gICAgbGV0IHNob290aW5nU3RhckNvb2xkb3duID0gMDtcbiAgICAvLyBTcGF3biBhIHNob290aW5nIHN0YXIgd2l0aCBhIHN0dW5uaW5nIGdsb3dpbmcgdGFpbFxuICAgIGZ1bmN0aW9uIHNwYXduU2hvb3RpbmdTdGFyKCkge1xuICAgICAgLy8gUGljayBhIHJhbmRvbSBkaXJlY3Rpb24gb24gdGhlIHNwaGVyZSBmb3IgdGhlIHNwYXduIGxvY2F0aW9uXG4gICAgICBjb25zdCBkaXIgPSBuZXcgVEhSRUUuVmVjdG9yMyhNYXRoLnJhbmRvbSgpKjItMSwgTWF0aC5yYW5kb20oKSoyLTEsIE1hdGgucmFuZG9tKCkqMi0xKS5ub3JtYWxpemUoKTtcbiAgICAgIC8vIEVuc3VyZSBzaG9vdGluZyBzdGFycyBuZXZlciBzcGF3biBjbG9zZSB0byB0aGUgY2FtZXJhIChhdCBsZWFzdCA3MCUgb2YgbWF4IGRpc3RhbmNlKVxuICAgICAgY29uc3QgbWluRGlzdCA9IHN0YXJNYXhEaXN0YW5jZSAqIDAuNztcbiAgICAgIGNvbnN0IG1heERpc3QgPSBzdGFyTWF4RGlzdGFuY2UgKiAxLjA7XG4gICAgICBjb25zdCBkaXN0ID0gbWluRGlzdCArIE1hdGgucmFuZG9tKCkgKiAobWF4RGlzdCAtIG1pbkRpc3QpO1xuICAgICAgY29uc3Qgc3Bhd25Qb3MgPSBkaXIuY2xvbmUoKS5tdWx0aXBseVNjYWxhcihkaXN0KTtcbiAgICAgIC8vIFRhbmdlbnRpYWwgdmVsb2NpdHk6IHBlcnBlbmRpY3VsYXIgdG8gZGlyXG4gICAgICBsZXQgdGFuZ2VudCA9IG5ldyBUSFJFRS5WZWN0b3IzKE1hdGgucmFuZG9tKCkqMi0xLCBNYXRoLnJhbmRvbSgpKjItMSwgTWF0aC5yYW5kb20oKSoyLTEpO1xuICAgICAgdGFuZ2VudCA9IHRhbmdlbnQuc3ViKHRhbmdlbnQuY2xvbmUoKS5wcm9qZWN0T25WZWN0b3IoZGlyKSkubm9ybWFsaXplKCk7XG4gICAgICAvLyBNaXggaW4gYSBzbWFsbCByYWRpYWwgY29tcG9uZW50IChpbndhcmQgb3Igb3V0d2FyZClcbiAgICAgIGNvbnN0IHRhbmdlbnRpYWxTcGVlZCA9IHN0YXJTcGVlZCAqICgyLjUgKyBNYXRoLnJhbmRvbSgpICogMi41KTsgLy8gbXVjaCBmYXN0ZXJcbiAgICAgIGNvbnN0IHJhZGlhbFNwZWVkID0gc3RhclNwZWVkICogKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMC4zOyAvLyBtb3JlIGRyYW1hdGljXG4gICAgICBjb25zdCB2ZWxvY2l0eSA9IHRhbmdlbnQubXVsdGlwbHlTY2FsYXIodGFuZ2VudGlhbFNwZWVkKS5hZGQoZGlyLmNsb25lKCkubXVsdGlwbHlTY2FsYXIocmFkaWFsU3BlZWQpKTtcblxuICAgICAgLy8gU3R1bm5pbmcgY29sb3IgZ3JhZGllbnQgZm9yIHRoZSBoZWFkXG4gICAgICBjb25zdCB2aWJyYW50Q29sb3JzID0gWzB4ZmZlMDY2LCAweGZmNjZjYywgMHg2NmNjZmYsIDB4ZmZmZmZmLCAweDgwZmZlYSwgMHhmZmYyY2MsIDB4ZmZjMDgwLCAweDgwYzBmZiwgMHhmZjgwYjNdO1xuICAgICAgY29uc3QgY29sb3IgPSB2aWJyYW50Q29sb3JzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSp2aWJyYW50Q29sb3JzLmxlbmd0aCldO1xuICAgICAgLy8gU3RhciBicmlnaHRuZXNzIGFuZCBzaXplIChhbHdheXMgc21hbGwgYW5kIHN1YnRsZSlcbiAgICAgIGNvbnN0IGJyaWdodG5lc3MgPSAyLjUgKyBNYXRoLnJhbmRvbSgpKjEuNTtcbiAgICAgIGNvbnN0IGdlbyA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeSgwLjcgKyBNYXRoLnJhbmRvbSgpKjAuNSwgMTYsIDE2KTsgLy8gU21hbGwgc3BoZXJlXG4gICAgICBjb25zdCBtYXQgPSBuZXcgVEhSRUUuTWVzaFBoeXNpY2FsTWF0ZXJpYWwoe1xuICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgIGVtaXNzaXZlOiBjb2xvcixcbiAgICAgICAgZW1pc3NpdmVJbnRlbnNpdHk6IDE0LjAsIC8vIEludGVuc2UgYmxvb21cbiAgICAgICAgbWV0YWxuZXNzOiAwLjcsXG4gICAgICAgIHJvdWdobmVzczogMC4zLFxuICAgICAgICB0cmFuc21pc3Npb246IDAuNyxcbiAgICAgICAgb3BhY2l0eTogMC45OCxcbiAgICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXG4gICAgICAgIGNsZWFyY29hdDogMC44LFxuICAgICAgICBjbGVhcmNvYXRSb3VnaG5lc3M6IDAuMixcbiAgICAgIH0pO1xuICAgICAgY29uc3Qgc3RhciA9IG5ldyBUSFJFRS5NZXNoKGdlbywgbWF0KTtcbiAgICAgIC8vIEFkZCBhIGxhcmdlLCBpbnRlbnNlIGJsb29tIHNwcml0ZSBmb3IgZXh0cmEgYmxvb21cbiAgICAgIGNvbnN0IHNwcml0ZU1hcCA9IG5ldyBUSFJFRS5UZXh0dXJlTG9hZGVyKCkubG9hZCgnL2dsb3cucG5nJyk7XG4gICAgICBjb25zdCBzcHJpdGVNYXRlcmlhbCA9IG5ldyBUSFJFRS5TcHJpdGVNYXRlcmlhbCh7IG1hcDogc3ByaXRlTWFwLCBjb2xvcjogMHhmZmZmZmYsIG9wYWNpdHk6IDEuMCwgYmxlbmRpbmc6IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmcgfSk7XG4gICAgICBjb25zdCBzcHJpdGUgPSBuZXcgVEhSRUUuU3ByaXRlKHNwcml0ZU1hdGVyaWFsKTtcbiAgICAgIHNwcml0ZS5zY2FsZS5zZXQoNzAsIDcwLCAxKTsgLy8gTGFyZ2UgZm9yIGJsb29tXG4gICAgICBzcHJpdGUucG9zaXRpb24uY29weShzdGFyLnBvc2l0aW9uKTtcbiAgICAgIHN0YXIuYWRkKHNwcml0ZSk7XG4gICAgICAvLyBBZGQgYSBjb2xvcmVkIHNwcml0ZSBmb3IgY29sb3IgcG9wXG4gICAgICBjb25zdCBjb2xvclNwcml0ZU1hdGVyaWFsID0gbmV3IFRIUkVFLlNwcml0ZU1hdGVyaWFsKHsgbWFwOiBzcHJpdGVNYXAsIGNvbG9yOiBjb2xvciwgb3BhY2l0eTogMC42LCBibGVuZGluZzogVEhSRUUuQWRkaXRpdmVCbGVuZGluZyB9KTtcbiAgICAgIGNvbnN0IGNvbG9yU3ByaXRlID0gbmV3IFRIUkVFLlNwcml0ZShjb2xvclNwcml0ZU1hdGVyaWFsKTtcbiAgICAgIGNvbG9yU3ByaXRlLnNjYWxlLnNldCgzNCwgMzQsIDEpO1xuICAgICAgY29sb3JTcHJpdGUucG9zaXRpb24uY29weShzdGFyLnBvc2l0aW9uKTtcbiAgICAgIHN0YXIuYWRkKGNvbG9yU3ByaXRlKTtcbiAgICAgIC8vIEFkZCB0byBib3RoIG1haW4gc2NlbmUgYW5kIHNob290aW5nU3RhclNjZW5lXG4gICAgICBzY2VuZS5hZGQoc3Rhcik7XG4gICAgICBzaG9vdGluZ1N0YXJTY2VuZS5hZGQoc3Rhcik7XG4gICAgICAvLyBBZGQgZHluYW1pYyBzcGFyayBidXJzdCBhdCB0aGUgaGVhZFxuICAgICAgY29uc3Qgc3BhcmtDb3VudCA9IDE4ICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKjgpO1xuICAgICAgY29uc3Qgc3BhcmtHcm91cCA9IG5ldyBUSFJFRS5Hcm91cCgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGFya0NvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3Qgc3BhcmtNYXQgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoeyBjb2xvcjogdmlicmFudENvbG9yc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqdmlicmFudENvbG9ycy5sZW5ndGgpXSwgdHJhbnNwYXJlbnQ6IHRydWUsIG9wYWNpdHk6IDAuOCB9KTtcbiAgICAgICAgY29uc3Qgc3BhcmtHZW8gPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoMC4wNyArIE1hdGgucmFuZG9tKCkqMC4wNiwgOCwgOCk7XG4gICAgICAgIGNvbnN0IHNwYXJrID0gbmV3IFRIUkVFLk1lc2goc3BhcmtHZW8sIHNwYXJrTWF0KTtcbiAgICAgICAgY29uc3QgYW5nbGUgPSAoaSAvIHNwYXJrQ291bnQpICogTWF0aC5QSSAqIDI7XG4gICAgICAgIHNwYXJrLnBvc2l0aW9uLnNldChNYXRoLmNvcyhhbmdsZSkqMS4yLCBNYXRoLnNpbihhbmdsZSkqMS4yLCBNYXRoLnJhbmRvbSgpKjAuNC0wLjIpO1xuICAgICAgICBzcGFya0dyb3VwLmFkZChzcGFyayk7XG4gICAgICB9XG4gICAgICBzcGFya0dyb3VwLm5hbWUgPSAnc3BhcmtCdXJzdCc7XG4gICAgICBzdGFyLmFkZChzcGFya0dyb3VwKTtcbiAgICAgIHN0YXIucG9zaXRpb24uY29weShzcGF3blBvcyk7XG4gICAgICBzdGFyLnZlbG9jaXR5ID0gdmVsb2NpdHk7XG4gICAgICBzdGFyLm5vcm1hbGl6ZWRMaWZlID0gMC4wO1xuICAgICAgc3Rhci5ub3JtYWxpemVkTGlmZXRpbWUgPSA4MCArIE1hdGgucmFuZG9tKCkgKiA4MDsgLy8gTG9uZ2VyLCBtb3JlIGRyYW1hdGljXG4gICAgICBzdGFyLmFnZSA9IDA7XG4gICAgICAvLyAtLS0gU3R1bm5pbmcgTWV0ZW9yIFRhaWwgKHZlcnkgbG9uZywgbXVsdGktY29sb3IsIGdsb3dpbmcsIGZhZGluZywgYW5kIDNEIGN1cnZlKSAtLS1cbiAgICAgIGNvbnN0IHRyYWlsU2VnbWVudHMgPSB0YWlsTGVuZ3RoICogMzsgXG4gICAgICBjb25zdCB0cmFpbFBvaW50cyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFpbFNlZ21lbnRzOyBpKyspIHtcbiAgICAgICAgLy8gQWRkIGEgM0Qgc3BpcmFsL2N1cnZlIGZvciBtb3JlIGRlcHRoXG4gICAgICAgIGNvbnN0IHNwaXJhbCA9IE1hdGguc2luKGkgKiAwLjI1KSAqIDg7XG4gICAgICAgIGNvbnN0IGN1cnZlID0gTWF0aC5jb3MoaSAqIDAuMTUpICogNDtcbiAgICAgICAgY29uc3QgcHQgPSBzdGFyLnBvc2l0aW9uLmNsb25lKCkuYWRkKG5ldyBUSFJFRS5WZWN0b3IzKHNwaXJhbCwgY3VydmUsIC1pICogMykpO1xuICAgICAgICB0cmFpbFBvaW50cy5wdXNoKHB0KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhaWxHZW8gPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKS5zZXRGcm9tUG9pbnRzKHRyYWlsUG9pbnRzKTtcbiAgICAgIC8vIFBlci12ZXJ0ZXggY29sb3IgKG11bHRpLWNvbG9yIHJhaW5ib3cgZ3JhZGllbnQpXG4gICAgICBjb25zdCB0YWlsQ29sb3JzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYWlsU2VnbWVudHM7IGkrKykge1xuICAgICAgICAvLyBBbHBoYSBmYWRlcyBvdXQgYWxvbmcgdGhlIHRhaWxcbiAgICAgICAgY29uc3QgYWxwaGEgPSAoMSAtIGkgLyAodHJhaWxTZWdtZW50cyAtIDEpKSAqIDAuOTk7XG4gICAgICAgIC8vIFJhaW5ib3cgZ3JhZGllbnRcbiAgICAgICAgY29uc3QgcmFpbmJvdyA9IFsweGZmZTA2NiwgMHhmZjY2Y2MsIDB4NjZjY2ZmLCAweGZmZmZmZiwgMHg4MGZmZWEsIDB4ZmZmMmNjLCAweGZmYzA4MCwgMHg4MGMwZmYsIDB4ZmY4MGIzXTtcbiAgICAgICAgY29uc3QgZ3JhZENvbG9yID0gcmFpbmJvd1tNYXRoLmZsb29yKChpIC8gdHJhaWxTZWdtZW50cykgKiByYWluYm93Lmxlbmd0aCldO1xuICAgICAgICB0YWlsQ29sb3JzLnB1c2goKGdyYWRDb2xvciA+PiAxNiAmIDI1NSkgLyAyNTUsIChncmFkQ29sb3IgPj4gOCAmIDI1NSkgLyAyNTUsIChncmFkQ29sb3IgJiAyNTUpIC8gMjU1LCBhbHBoYSk7XG4gICAgICB9XG4gICAgICB0YWlsR2VvLnNldEF0dHJpYnV0ZSgnY29sb3InLCBuZXcgVEhSRUUuRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh0YWlsQ29sb3JzLCA0KSk7XG4gICAgICAvLyBBZGRpdGl2ZSBibGVuZGluZyBmb3IgZ2xvdyArIEJMT09NRUQgVEFJTFxuICAgICAgY29uc3QgdGFpbE1hdCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCh7IHZlcnRleENvbG9yczogdHJ1ZSwgdHJhbnNwYXJlbnQ6IHRydWUsIG9wYWNpdHk6IDEuMCwgYmxlbmRpbmc6IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmcgfSk7XG4gICAgICAvLyAtLS0gVEFJTFMgLS0tXG4gICAgICAvLyAxLiBDcmlzcCB0YWlsIGZvciBtYWluIHNjZW5lXG4gICAgICBjb25zdCB0YWlsTWF0TWFpbiA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCh7IHZlcnRleENvbG9yczogdHJ1ZSwgdHJhbnNwYXJlbnQ6IHRydWUsIG9wYWNpdHk6IDEuMCwgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nIH0pO1xuICAgICAgY29uc3QgdGFpbE1haW4gPSBuZXcgVEhSRUUuTGluZSh0YWlsR2VvLmNsb25lKCksIHRhaWxNYXRNYWluKTtcbiAgICAgIHRhaWxNYWluLnBvc2l0aW9uLmNvcHkoc3Rhci5wb3NpdGlvbik7XG4gICAgICBzY2VuZS5hZGQodGFpbE1haW4pO1xuICAgICAgLy8gMi4gSW50ZW5zZSBibG9vbSB0YWlsIGZvciBzaG9vdGluZ1N0YXJTY2VuZVxuICAgICAgY29uc3QgdGFpbE1hdEJsb29tID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKHsgdmVydGV4Q29sb3JzOiB0cnVlLCB0cmFuc3BhcmVudDogdHJ1ZSwgb3BhY2l0eTogMS4wLCBibGVuZGluZzogVEhSRUUuQWRkaXRpdmVCbGVuZGluZyB9KTtcbiAgICAgIGNvbnN0IHRhaWxCbG9vbSA9IG5ldyBUSFJFRS5MaW5lKHRhaWxHZW8sIHRhaWxNYXRCbG9vbSk7XG4gICAgICB0YWlsQmxvb20ucG9zaXRpb24uY29weShzdGFyLnBvc2l0aW9uKTtcbiAgICAgIC8vIEFkZCBhIGJsb29tIHNwcml0ZSB0byB0aGUgdGFpbCdzIGhlYWQgZm9yIGV4dHJhIGdsb3dcbiAgICAgIGNvbnN0IHRhaWxHbG93TWFwID0gbmV3IFRIUkVFLlRleHR1cmVMb2FkZXIoKS5sb2FkKCcvZ2xvdy5wbmcnKTtcbiAgICAgIGNvbnN0IHRhaWxHbG93TWF0ID0gbmV3IFRIUkVFLlNwcml0ZU1hdGVyaWFsKHsgbWFwOiB0YWlsR2xvd01hcCwgY29sb3I6IDB4ZmZmZmZmLCBvcGFjaXR5OiAwLjg4LCBibGVuZGluZzogVEhSRUUuQWRkaXRpdmVCbGVuZGluZyB9KTtcbiAgICAgIGNvbnN0IHRhaWxHbG93ID0gbmV3IFRIUkVFLlNwcml0ZSh0YWlsR2xvd01hdCk7XG4gICAgICB0YWlsR2xvdy5zY2FsZS5zZXQoNTAsIDUwLCAxKTsgLy8gTGFyZ2VyIGZvciBtb3JlIGJsb29tXG4gICAgICB0YWlsR2xvdy5wb3NpdGlvbi5jb3B5KHN0YXIucG9zaXRpb24pO1xuICAgICAgdGFpbEJsb29tLmFkZCh0YWlsR2xvdyk7XG4gICAgICBzaG9vdGluZ1N0YXJTY2VuZS5hZGQodGFpbEJsb29tKTtcbiAgICAgIC8vIEFkZCBzdGFyIHRvIGJvdGggc2NlbmVzXG4gICAgICBzY2VuZS5hZGQoc3Rhcik7XG4gICAgICBzaG9vdGluZ1N0YXJTY2VuZS5hZGQoc3Rhcik7XG4gICAgICBzaG9vdGluZ1N0YXJzLnB1c2goeyBtZXNoOiBzdGFyLCB0YWlsOiB0YWlsTWFpbiwgdGFpbEJsb29tLCB2ZWxvY2l0eTogc3Rhci52ZWxvY2l0eSwgZGlyLCBhZ2U6IDAsIG5vcm1hbGl6ZWRMaWZldGltZTogc3Rhci5ub3JtYWxpemVkTGlmZXRpbWUsIHRyYWlsUG9pbnRzLCBjb2xvciwgYnJpZ2h0bmVzcywgaGFzRnJhZ21lbnRlZDogZmFsc2UgfSk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGFuIGFuaW1hdGlvbiBJRCByZWZlcmVuY2UgZm9yIGNsZWFudXBcbiAgICBsZXQgYW5pbWF0aW9uSWQ7XG4gICAgXG4gICAgY29uc3QgYW5pbWF0ZSA9ICgpID0+IHtcbiAgICAgIC8vIFN0b3JlIHRoZSBhbmltYXRpb24gSUQgZm9yIGNsZWFudXBcbiAgICAgIGFuaW1hdGlvbklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgc3RhciBwb3NpdGlvbnMgcmVsYXRpdmUgdG8gdmlydHVhbCBjYW1lcmFcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXlbaV0gPSBwb3NpdGlvbnNbaV0gLSB2aXJ0dWFsQ2FtZXJhUG9zLng7XG4gICAgICAgIGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXlbaSsxXSA9IHBvc2l0aW9uc1tpKzFdIC0gdmlydHVhbENhbWVyYVBvcy55O1xuICAgICAgICBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5W2krMl0gPSBwb3NpdGlvbnNbaSsyXSAtIHZpcnR1YWxDYW1lcmFQb3MuejtcbiAgICAgIH1cbiAgICAgIGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgZ2xvdyBzcHJpdGUgcG9zaXRpb25zXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdsb3dTcHJpdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IGkgKiAzO1xuICAgICAgICBnbG93U3ByaXRlc1tpXS5wb3NpdGlvbi5zZXQoXG4gICAgICAgICAgcG9zaXRpb25zW2lkeF0gLSB2aXJ0dWFsQ2FtZXJhUG9zLngsXG4gICAgICAgICAgcG9zaXRpb25zW2lkeCsxXSAtIHZpcnR1YWxDYW1lcmFQb3MueSxcbiAgICAgICAgICBwb3NpdGlvbnNbaWR4KzJdIC0gdmlydHVhbENhbWVyYVBvcy56XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIC0tLSBQT1NULVBST0NFU1NJTkcgUElQRUxJTkUgLS0tXG4gICAgICAvLyAtLS0gUE9TVC1QUk9DRVNTSU5HIFBJUEVMSU5FIC0tLVxuICAgICAgY29tcG9zZXIucmVuZGVyKCk7IC8vIE9ubHkgUmVuZGVyUGFzcyBlbmFibGVkIGZvciBkZWJ1Z2dpbmdcbiAgICAgIC8vIChibG9vbSwgRlhBQSwgRmlsbVBhc3MgYXJlIE5PVCBhZGRlZClcbiAgICAgIC8vIHNob290aW5nU3RhckNvbXBvc2VyLCBjYUNvbXBvc2VyIHJlbWFpbiBkaXNhYmxlZCBmb3Igbm93XG5cbiAgICAgIGNhbWVyYS5yb3RhdGlvbi55ICs9ICh0YXJnZXRZIC0gY2FtZXJhLnJvdGF0aW9uLnkpICogZGFtcGluZztcbiAgICAgIC8vIE1vdmUgdGhlIHZpcnR1YWwgY2FtZXJhIHBvc2l0aW9uIGluIHRoZSBkaXJlY3Rpb24gdGhlIGNhbWVyYSBpcyBmYWNpbmdcbiAgICAgIGNvbnN0IGZvcndhcmQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKGZvcndhcmQpO1xuICAgICAgdmlydHVhbENhbWVyYVBvcy5hZGQoZm9yd2FyZC5tdWx0aXBseVNjYWxhcihzdGFyU3BlZWQpKTtcblxuICAgICAgLy8gSW50ZW5zZSBjb2xvciAob3ZlcnNhdHVyYXRlZCwgYnJpZ2h0ZW5lZCkgLS0gbXVzdCBiZSBpbnNpZGUgdGhlIGZvciBsb29wIG92ZXIgc3RhcnNcbiAgICAgIGNvbnN0IGNvbG9yQXR0ciA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3I7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc2l0aW9ucy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICBjb25zdCBvcmlnUiA9IGNvbG9yQXR0ci5hcnJheVtpXTtcbiAgICAgICAgY29uc3Qgb3JpZ0cgPSBjb2xvckF0dHIuYXJyYXlbaSsxXTtcbiAgICAgICAgY29uc3Qgb3JpZ0IgPSBjb2xvckF0dHIuYXJyYXlbaSsyXTtcbiAgICAgICAgY29uc3QgZGlzdCA9IE1hdGguc3FydChcbiAgICAgICAgICBNYXRoLnBvdyhwb3NpdGlvbnNbaV0gLSB2aXJ0dWFsQ2FtZXJhUG9zLngsIDIpICtcbiAgICAgICAgICBNYXRoLnBvdyhwb3NpdGlvbnNbaSsxXSAtIHZpcnR1YWxDYW1lcmFQb3MueSwgMikgK1xuICAgICAgICAgIE1hdGgucG93KHBvc2l0aW9uc1tpKzJdIC0gdmlydHVhbENhbWVyYVBvcy56LCAyKVxuICAgICAgICApO1xuICAgICAgICBjb25zdCBpbnRlbnNlUiA9IE1hdGgubWluKG9yaWdSICogMi41LCAxLjApLCBpbnRlbnNlRyA9IE1hdGgubWluKG9yaWdHICogMi41LCAxLjApLCBpbnRlbnNlQiA9IE1hdGgubWluKG9yaWdCICogMi41LCAxLjApO1xuICAgICAgICAvLyBGYWRlIGZhY3RvcjogMCA9IGNsb3NlLCAxID0gZmFyXG4gICAgICAgIGxldCBmYWRlVCA9IChkaXN0IC0gMjAwKSAvIChzdGFyTWF4RGlzdGFuY2UgKiAwLjkgLSAyMDApO1xuICAgICAgICBmYWRlVCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIGZhZGVUKSk7XG4gICAgICAgIC8vIEVhc2UgZm9yIHNtb290aG5lc3NcbiAgICAgICAgZmFkZVQgPSBNYXRoLnBvdyhmYWRlVCwgMS41KTtcbiAgICAgICAgLy8gTGVycCBiZXR3ZWVuIG9yaWdpbmFsIGFuZCBpbnRlbnNlIGNvbG9yXG4gICAgICAgIGNvbG9yQXR0ci5hcnJheVtpXSA9IG9yaWdSICogKDEtZmFkZVQpICsgaW50ZW5zZVIgKiBmYWRlVDtcbiAgICAgICAgY29sb3JBdHRyLmFycmF5W2krMV0gPSBvcmlnRyAqICgxLWZhZGVUKSArIGludGVuc2VHICogZmFkZVQ7XG4gICAgICAgIGNvbG9yQXR0ci5hcnJheVtpKzJdID0gb3JpZ0IgKiAoMS1mYWRlVCkgKyBpbnRlbnNlQiAqIGZhZGVUO1xuICAgICAgfVxuICAgICAgY29sb3JBdHRyLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIC8vIElmIHlvdSBoYXZlIGdsb3cgbG9naWMgcGVyLXN0YXIsIG1vdmUgdGhhdCBpbnNpZGUgdGhlIGxvb3AgYXMgd2VsbCwgb3IgaGFuZGxlIGFmdGVyXG5cbiAgICAgIGlmIChjbG9zZVN0YXJzICYmIGNsb3NlR2VvbWV0cnkgJiYgY2xvc2VQb3NpdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsb3NlUG9zaXRpb25zLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgY2xvc2VHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5W2ldID0gY2xvc2VQb3NpdGlvbnNbaV0gLSB2aXJ0dWFsQ2FtZXJhUG9zLng7XG4gICAgICAgICAgY2xvc2VHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5W2krMV0gPSBjbG9zZVBvc2l0aW9uc1tpKzFdIC0gdmlydHVhbENhbWVyYVBvcy55O1xuICAgICAgICAgIGNsb3NlR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheVtpKzJdID0gY2xvc2VQb3NpdGlvbnNbaSsyXSAtIHZpcnR1YWxDYW1lcmFQb3MuejtcbiAgICAgICAgfVxuICAgICAgICBjbG9zZUdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSBzaG9vdGluZyBzdGFyIGNvb2xkb3duXG4gICAgICBpZiAoc2hvb3RpbmdTdGFyQ29vbGRvd24gPD0gMCAmJiBNYXRoLnJhbmRvbSgpIDwgMC4wMikge1xuICAgICAgICBzcGF3blNob290aW5nU3RhcigpO1xuICAgICAgICBzaG9vdGluZ1N0YXJDb29sZG93biA9IDMwICsgTWF0aC5yYW5kb20oKSAqIDYwO1xuICAgICAgfSBlbHNlIGlmIChzaG9vdGluZ1N0YXJDb29sZG93biA+IDApIHtcbiAgICAgICAgc2hvb3RpbmdTdGFyQ29vbGRvd24tLTtcbiAgICAgIH1cblxuICAgICAgLy8gLS0tIFNob290aW5nIHN0YXIgc3Bhd25pbmcgLS0tXG4gICAgICBpZiAoc2hvb3RpbmdTdGFyQ29vbGRvd24gPD0gMCAmJiBNYXRoLnJhbmRvbSgpIDwgMC4xKSB7XG4gICAgICAgIHNwYXduU2hvb3RpbmdTdGFyKCk7XG4gICAgICAgIGlmIChjYW1lcmEpIHtcbiAgICAgICAgICBjb25zdCBzaGFrZVN0cmVuZ3RoID0gMC4wNiArIE1hdGgucmFuZG9tKCkqMC4wNDtcbiAgICAgICAgICBjYW1lcmEucG9zaXRpb24ueCArPSAoTWF0aC5yYW5kb20oKS0wLjUpKnNoYWtlU3RyZW5ndGg7XG4gICAgICAgICAgY2FtZXJhLnBvc2l0aW9uLnkgKz0gKE1hdGgucmFuZG9tKCktMC41KSpzaGFrZVN0cmVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHNob290aW5nU3RhckNvb2xkb3duID0gMTAgKyBNYXRoLnJhbmRvbSgpICogMTA7XG4gICAgICB9IGVsc2UgaWYgKHNob290aW5nU3RhckNvb2xkb3duID4gMCkge1xuICAgICAgICBzaG9vdGluZ1N0YXJDb29sZG93bi0tO1xuICAgICAgfVxuICAgICAgLy8gQW5pbWF0ZSBhbmQgY2xlYW4gdXAgc2hvb3Rpbmcgc3RhcnNcbiAgICAgIGZvciAobGV0IGkgPSBzaG9vdGluZ1N0YXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHNob290aW5nU3RhcnNbaV07XG4gICAgICAgIC8vIEFuaW1hdGUgc3BhcmsgYnVyc3QgKGZhZGUgYW5kIGV4cGFuZClcbiAgICAgICAgaWYgKG9iai5tZXNoLmNoaWxkcmVuKSB7XG4gICAgICAgICAgY29uc3Qgc3BhcmtzID0gb2JqLm1lc2guY2hpbGRyZW4uZmluZChjaGlsZCA9PiBjaGlsZC5uYW1lID09PSAnc3BhcmtCdXJzdCcpO1xuICAgICAgICAgIGlmIChzcGFya3MpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3BhcmtzLmNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHNwYXJrID0gc3BhcmtzLmNoaWxkcmVuW2pdO1xuICAgICAgICAgICAgICBzcGFyay5tYXRlcmlhbC5vcGFjaXR5ICo9IDAuOTY7IC8vIEZhZGVcbiAgICAgICAgICAgICAgc3Bhcmsuc2NhbGUubXVsdGlwbHlTY2FsYXIoMS4wMyk7IC8vIEV4cGFuZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBbmltYXRlIHRhaWwgc2hpbW1lciBhbmQgY29sb3IgY3ljbGluZ1xuICAgICAgICBpZiAob2JqLnRhaWwgJiYgb2JqLnRyYWlsUG9pbnRzKSB7XG4gICAgICAgICAgY29uc3QgdGltZSA9IHBlcmZvcm1hbmNlLm5vdygpICogMC4wMDE7XG4gICAgICAgICAgY29uc3QgdGFpbEdlbyA9IG9iai50YWlsLmdlb21ldHJ5O1xuICAgICAgICAgIGNvbnN0IHRhaWxDb2xvcnMgPSB0YWlsR2VvLmdldEF0dHJpYnV0ZSgnY29sb3InKTtcbiAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHRhaWxDb2xvcnMuY291bnQ7IGsrKykge1xuICAgICAgICAgICAgLy8gQ3ljbGUgaHVlXG4gICAgICAgICAgICBsZXQgciA9IHRhaWxDb2xvcnMuZ2V0WChrKSwgZyA9IHRhaWxDb2xvcnMuZ2V0WShrKSwgYiA9IHRhaWxDb2xvcnMuZ2V0WihrKTtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gSFNMXG4gICAgICAgICAgICBjb25zdCBtYXggPSBNYXRoLm1heChyLGcsYiksIG1pbiA9IE1hdGgubWluKHIsZyxiKTtcbiAgICAgICAgICAgIGxldCBoLHMsbDtcbiAgICAgICAgICAgIGwgPSAobWF4K21pbikvMjtcbiAgICAgICAgICAgIGlmIChtYXggPT09IG1pbikge2ggPSBzID0gMDt9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCBkID0gbWF4LW1pbjtcbiAgICAgICAgICAgICAgcyA9IGwgPiAwLjUgPyBkLygyLW1heC1taW4pIDogZC8obWF4K21pbik7XG4gICAgICAgICAgICAgIHN3aXRjaChtYXgpe1xuICAgICAgICAgICAgICAgIGNhc2UgcjogaCA9IChnLWIpL2QgKyAoZzxiPzY6MCk7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgZzogaCA9IChiLXIpL2QgKyAyOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIGI6IGggPSAoci1nKS9kICsgNDsgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaC89NjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGggPSAoaCArIDAuMjUqTWF0aC5zaW4odGltZSArIGsqMC4yKSkgJSAxLjA7IC8vIEFuaW1hdGUgaHVlXG4gICAgICAgICAgICAvLyBDb252ZXJ0IGJhY2sgdG8gUkdCXG4gICAgICAgICAgICBsZXQgcSA9IGwgPCAwLjUgPyBsKigxK3MpIDogbCtzLWwqcztcbiAgICAgICAgICAgIGxldCBwID0gMipsLXE7XG4gICAgICAgICAgICBsZXQgdHIgPSBoKzEvMywgdGcgPSBoLCB0YiA9IGgtMS8zO1xuICAgICAgICAgICAgY29uc3QgaHVlMnJnYiA9IChwLHEsdCkgPT4ge1xuICAgICAgICAgICAgICBpZiAodDwwKSB0Kz0xOyBpZiAodD4xKSB0LT0xO1xuICAgICAgICAgICAgICBpZiAodDwxLzYpIHJldHVybiBwKyhxLXApKjYqdDtcbiAgICAgICAgICAgICAgaWYgKHQ8MS8yKSByZXR1cm4gcTtcbiAgICAgICAgICAgICAgaWYgKHQ8Mi8zKSByZXR1cm4gcCsocS1wKSooMi8zLXQpKjY7XG4gICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRhaWxDb2xvcnMuc2V0WChrLCBodWUycmdiKHAscSx0cikpO1xuICAgICAgICAgICAgdGFpbENvbG9ycy5zZXRZKGssIGh1ZTJyZ2IocCxxLHRnKSk7XG4gICAgICAgICAgICB0YWlsQ29sb3JzLnNldFooaywgaHVlMnJnYihwLHEsdGIpKTtcbiAgICAgICAgICAgIC8vIFNoaW1tZXI6IG1vZHVsYXRlIGFscGhhXG4gICAgICAgICAgICB0YWlsQ29sb3JzLnNldFcoaywgdGFpbENvbG9ycy5nZXRXKGspICogKDAuOTcgKyAwLjAzKk1hdGguc2luKHRpbWUqOCArIGspKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRhaWxDb2xvcnMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0cmFpZ2h0LWxpbmUgdHJhamVjdG9yeVxuICAgICAgICBvYmoubWVzaC5wb3NpdGlvbi5hZGQob2JqLnZlbG9jaXR5KTtcbiAgICAgICAgb2JqLnRhaWwucG9zaXRpb24uY29weShvYmoubWVzaC5wb3NpdGlvbik7XG4gICAgICAgIGlmIChvYmoudGFpbEJsb29tKSBvYmoudGFpbEJsb29tLnBvc2l0aW9uLmNvcHkob2JqLm1lc2gucG9zaXRpb24pO1xuICAgICAgICAvLyBBbmltYXRlIHRhaWwgKG5vIGxlcnAsIGp1c3QgZHJhZylcbiAgICAgICAgLy8gQ09NUExFVEUgTUVTUyBWRVJZIEhBQ0tZIEZJWCBMQVRFUiBPUiBET05UPz8/Pz9cbiAgICAgICAgb2JqLmFnZSsrO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkTGlmZSA9IG9iai5hZ2UgLyBvYmoubm9ybWFsaXplZExpZmV0aW1lO1xuICAgICAgICBvYmoudHJhaWxQb2ludHMudW5zaGlmdChvYmoubWVzaC5wb3NpdGlvbi5jbG9uZSgpKTtcbiAgICAgICAgaWYgKG9iai50cmFpbFBvaW50cy5sZW5ndGggPiB0YWlsTGVuZ3RoICogMykgb2JqLnRyYWlsUG9pbnRzLnBvcCgpO1xuICAgICAgICBsZXQgdGFpbEdyb3cgPSBNYXRoLm1pbigxLCBub3JtYWxpemVkTGlmZSAvIDAuMyk7XG4gICAgICAgIGxldCBhY3RpdmVTZWdtZW50cyA9IE1hdGguZmxvb3Iob2JqLnRyYWlsUG9pbnRzLmxlbmd0aCAqIHRhaWxHcm93KTtcbiAgICAgICAgaWYgKGFjdGl2ZVNlZ21lbnRzIDwgMikgYWN0aXZlU2VnbWVudHMgPSAyO1xuICAgICAgICBjb25zdCB2aXNpYmxlVHJhaWwgPSBvYmoudHJhaWxQb2ludHMuc2xpY2UoMCwgYWN0aXZlU2VnbWVudHMpO1xuICAgICAgICBvYmoudGFpbC5nZW9tZXRyeS5zZXRGcm9tUG9pbnRzKHZpc2libGVUcmFpbCk7XG4gICAgICAgIGlmIChvYmoudGFpbEJsb29tKSBvYmoudGFpbEJsb29tLmdlb21ldHJ5LnNldEZyb21Qb2ludHModmlzaWJsZVRyYWlsKTtcbiAgICAgICAgY29uc3QgdGFpbENvbG9ycyA9IG9iai50YWlsLmdlb21ldHJ5LmdldEF0dHJpYnV0ZSgnY29sb3InKTtcbiAgICAgICAgbGV0IHRhaWxDb2xvcnNCbG9vbSA9IG9iai50YWlsQmxvb20gPyBvYmoudGFpbEJsb29tLmdlb21ldHJ5LmdldEF0dHJpYnV0ZSgnY29sb3InKSA6IG51bGw7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmlzaWJsZVRyYWlsLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgbGV0IGFscGhhID0gKDEgLSBqIC8gKHZpc2libGVUcmFpbC5sZW5ndGggLSAxKSkgKiAwLjk1O1xuICAgICAgICAgIGFscGhhICo9IDAuOTIgKyAwLjA4ICogTWF0aC5zaW4oRGF0ZS5ub3coKSowLjAxNSArIGoqMC41KTtcbiAgICAgICAgICBsZXQgcmFpbmJvdyA9IFsweGZmYzA4MCwgMHhmZmUwODAsIDB4ZmZmZjgwLCAweDgwZmZlNiwgMHg4MGMwZmYsIDB4YzA4MGZmXTtcbiAgICAgICAgICBsZXQgZ3JhZENvbG9yID0gcmFpbmJvd1tqICUgcmFpbmJvdy5sZW5ndGhdO1xuICAgICAgICAgIGlmIChub3JtYWxpemVkTGlmZSA+IDAuNykgYWxwaGEgKj0gTWF0aC5tYXgoMCwgMSAtIChub3JtYWxpemVkTGlmZSAtIDAuNyAtIDAuMikgLyAwLjMpO1xuICAgICAgICAgIHRhaWxDb2xvcnMuc2V0WFlaVyhqLCAoZ3JhZENvbG9yID4+IDE2ICYgMjU1KSAvIDI1NSwgKGdyYWRDb2xvciA+PiA4ICYgMjU1KSAvIDI1NSwgKGdyYWRDb2xvciAmIDI1NSkgLyAyNTUsIGFscGhhKTtcbiAgICAgICAgICBpZiAodGFpbENvbG9yc0Jsb29tKSB0YWlsQ29sb3JzQmxvb20uc2V0WFlaVyhqLCAoZ3JhZENvbG9yID4+IDE2ICYgMjU1KSAvIDI1NSwgKGdyYWRDb2xvciA+PiA4ICYgMjU1KSAvIDI1NSwgKGdyYWRDb2xvciAmIDI1NSkgLyAyNTUsIGFscGhhKTtcbiAgICAgICAgfVxuICAgICAgICB0YWlsQ29sb3JzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgLy8gQW5pbWF0ZSBoZWFkXG4gICAgICAgIGxldCBoZWFkQ29sb3I7XG4gICAgICAgIGlmIChub3JtYWxpemVkTGlmZSA8IDAuNSkge1xuICAgICAgICAgIGhlYWRDb2xvciA9IG5ldyBUSFJFRS5Db2xvcihvYmouY29sb3IpLmxlcnAobmV3IFRIUkVFLkNvbG9yKDB4ZmZjMDgwKSwgbm9ybWFsaXplZExpZmUqMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGVhZENvbG9yID0gbmV3IFRIUkVFLkNvbG9yKDB4ZmZjMDgwKS5sZXJwKG5ldyBUSFJFRS5Db2xvcigweGZmNDAwMCksIChub3JtYWxpemVkTGlmZS0wLjUpKjIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmbGlja2VyID0gMC45NSArIDAuMTMgKiBNYXRoLnNpbihEYXRlLm5vdygpKjAuMDcgKyBNYXRoLnJhbmRvbSgpKjEwKTtcbiAgICAgICAgaGVhZENvbG9yLm11bHRpcGx5U2NhbGFyKGZsaWNrZXIpO1xuICAgICAgICBvYmoubWVzaC5tYXRlcmlhbC5jb2xvci5jb3B5KGhlYWRDb2xvcik7XG4gICAgICAgIGxldCBzY2FsZSA9IDEgKyAyLjIgKiBNYXRoLnNpbihNYXRoLlBJICogbm9ybWFsaXplZExpZmUpO1xuICAgICAgICBsZXQgZGlzdFRvQ2FtID0gb2JqLm1lc2gucG9zaXRpb24ubGVuZ3RoKCk7XG4gICAgICAgIGxldCBkb2ZCbHVyID0gZGlzdFRvQ2FtIDwgc3Rhck1heERpc3RhbmNlICogMC43ID8gMC43IDogMS4wO1xuICAgICAgICBvYmoubWVzaC5zY2FsZS5zZXQoc2NhbGUgKiBkb2ZCbHVyLCBzY2FsZSAqIGRvZkJsdXIsIHNjYWxlICogZG9mQmx1cik7XG4gICAgICAgIC8vIFNwYXJrbGUgYnVyc3RcbiAgICAgICAgaWYgKG5vcm1hbGl6ZWRMaWZlID49IDEgJiYgIW9iai5oYXNGcmFnbWVudGVkKSB7XG4gICAgICAgICAgLy8gLS0tIFNQRUNUQUNVTEFSIEVYUExPU0lPTiAodmVyeSByYXJlKSAtLS1cbiAgICAgICAgICBjb25zdCBzcGVjdGFjdWxhciA9IE1hdGgucmFuZG9tKCkgPCAwLjAyOyAvLyAyJSBjaGFuY2VcbiAgICAgICAgICBjb25zdCBidXJzdENvdW50ID0gc3BlY3RhY3VsYXIgPyAxMjAgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqNjApIDogMTggKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqOCk7XG4gICAgICAgICAgY29uc3QgcGFsZXR0ZSA9IHNwZWN0YWN1bGFyXG4gICAgICAgICAgICA/IFsweGZmZTA2NiwgMHhmZjY2Y2MsIDB4NjZjY2ZmLCAweGZmZmZmZiwgMHg4MGZmZWEsIDB4ZmZmMmNjLCAweGZmYzA4MCwgMHg4MGMwZmYsIDB4ZmY4MGIzLCAweGZmMDAwMCwgMHgwMGZmMDAsIDB4MDAwMGZmLCAweGZmZmYwMCwgMHgwMGZmZmYsIDB4ZmYwMGZmLCAweGZmODgwMCwgMHgwMGZmODgsIDB4ODgwMGZmXVxuICAgICAgICAgICAgOiBbMHhmZmZmZmYsIDB4ZmZmNmMwLCAweGZmZTA2NiwgMHhmZmMwODAsIDB4ODBjMGZmXTtcbiAgICAgICAgICBmb3IgKGxldCBzID0gMDsgcyA8IGJ1cnN0Q291bnQ7IHMrKykge1xuICAgICAgICAgICAgY29uc3QgY29sb3IgPSBwYWxldHRlW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSpwYWxldHRlLmxlbmd0aCldO1xuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHNwZWN0YWN1bGFyID8gKDEuMiArIE1hdGgucmFuZG9tKCkqMi4yKSA6ICgwLjcgKyBNYXRoLnJhbmRvbSgpKjAuOCk7XG4gICAgICAgICAgICBjb25zdCBzcGFya2xlR2VvID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KHNpemUsIDgsIDgpO1xuICAgICAgICAgICAgY29uc3Qgc3BhcmtsZU1hdCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7IGNvbG9yLCB0cmFuc3BhcmVudDogdHJ1ZSwgb3BhY2l0eTogc3BlY3RhY3VsYXIgPyAwLjkyIDogMC43LCBibGVuZGluZzogVEhSRUUuQWRkaXRpdmVCbGVuZGluZyB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNwYXJrbGUgPSBuZXcgVEhSRUUuTWVzaChzcGFya2xlR2VvLCBzcGFya2xlTWF0KTtcbiAgICAgICAgICAgIHNwYXJrbGUucG9zaXRpb24uY29weShvYmoubWVzaC5wb3NpdGlvbik7XG4gICAgICAgICAgICAvLyBTcGVjdGFjdWxhcjogaHVnZSwgZmFzdCwgcmFuZG9tIGRpcmVjdGlvbnM7IG5vcm1hbDogbW9kZXJhdGVcbiAgICAgICAgICAgIGNvbnN0IHNwZCA9IHNwZWN0YWN1bGFyID8gKDQgKyBNYXRoLnJhbmRvbSgpKjgpIDogKDIgKyBNYXRoLnJhbmRvbSgpKjIpO1xuICAgICAgICAgICAgY29uc3Qgc3BhcmtsZVZlbCA9IG5ldyBUSFJFRS5WZWN0b3IzKE1hdGgucmFuZG9tKCktMC41LCBNYXRoLnJhbmRvbSgpLTAuNSwgTWF0aC5yYW5kb20oKS0wLjUpLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKHNwZCk7XG4gICAgICAgICAgICBzcGFya2xlLnVzZXJEYXRhID0geyB2ZWxvY2l0eTogc3BhcmtsZVZlbCwgYWdlOiAwLCBzcGVjdGFjdWxhciwgbWF4QWdlOiBzcGVjdGFjdWxhciA/IDgwICsgTWF0aC5yYW5kb20oKSo0MCA6IDQwICsgTWF0aC5yYW5kb20oKSoyMCB9OyAvLyA8LS0gTE9OR0VSIExJRkVcbiAgICAgICAgICAgIHNjZW5lLmFkZChzcGFya2xlKTtcbiAgICAgICAgICAgIGlmICghd2luZG93Ll9zcGFya2xlcykgd2luZG93Ll9zcGFya2xlcyA9IFtdO1xuICAgICAgICAgICAgd2luZG93Ll9zcGFya2xlcy5wdXNoKHNwYXJrbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3BlY3RhY3VsYXIpIHtcbiAgICAgICAgICAgIC8vIEFkZCBhIGJpZyBmbGFzaFxuICAgICAgICAgICAgY29uc3QgZmxhc2hHZW8gPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoNiwgMjQsIDI0KTtcbiAgICAgICAgICAgIGNvbnN0IGZsYXNoTWF0ID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHsgY29sb3I6IDB4ZmZmZmZmLCB0cmFuc3BhcmVudDogdHJ1ZSwgb3BhY2l0eTogMC44LCBibGVuZGluZzogVEhSRUUuQWRkaXRpdmVCbGVuZGluZyB9KTtcbiAgICAgICAgICAgIGNvbnN0IGZsYXNoID0gbmV3IFRIUkVFLk1lc2goZmxhc2hHZW8sIGZsYXNoTWF0KTtcbiAgICAgICAgICAgIGZsYXNoLnBvc2l0aW9uLmNvcHkob2JqLm1lc2gucG9zaXRpb24pO1xuICAgICAgICAgICAgc2NlbmUuYWRkKGZsYXNoKTtcbiAgICAgICAgICAgIGlmICghd2luZG93Ll9zdGFyRmxhc2hlcykgd2luZG93Ll9zdGFyRmxhc2hlcyA9IFtdO1xuICAgICAgICAgICAgd2luZG93Ll9zdGFyRmxhc2hlcy5wdXNoKHsgbWVzaDogZmxhc2gsIGFnZTogMCB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gRnJhZ21lbnRlZCB0cmFpbCBsb2dpYyAoa2VlcCBhcyBiZWZvcmUpXG4gICAgICAgICAgY29uc3QgZnJhZ1ZlbCA9IG9iai52ZWxvY2l0eS5jbG9uZSgpLmFwcGx5QXhpc0FuZ2xlKG5ldyBUSFJFRS5WZWN0b3IzKDAsMSwwKSwgKE1hdGgucmFuZG9tKCktMC41KSowLjMpO1xuICAgICAgICAgIGNvbnN0IGZyYWdTdGFyID0gb2JqLm1lc2guY2xvbmUoKTtcbiAgICAgICAgICBmcmFnU3Rhci5wb3NpdGlvbi5jb3B5KG9iai5tZXNoLnBvc2l0aW9uKTtcbiAgICAgICAgICBmcmFnU3Rhci52ZWxvY2l0eSA9IGZyYWdWZWw7XG4gICAgICAgICAgZnJhZ1N0YXIubm9ybWFsaXplZExpZmUgPSBub3JtYWxpemVkTGlmZTtcbiAgICAgICAgICBmcmFnU3Rhci5ub3JtYWxpemVkTGlmZXRpbWUgPSBvYmoubm9ybWFsaXplZExpZmV0aW1lICogKDAuNSArIE1hdGgucmFuZG9tKCkqMC41KTtcbiAgICAgICAgICBmcmFnU3Rhci5hZ2UgPSBvYmouYWdlO1xuICAgICAgICAgIGZyYWdTdGFyLm1hdGVyaWFsID0gb2JqLm1lc2gubWF0ZXJpYWwuY2xvbmUoKTtcbiAgICAgICAgICBjb25zdCBmcmFnVHJhaWxQb2ludHMgPSBvYmoudHJhaWxQb2ludHMuc2xpY2UoKTtcbiAgICAgICAgICBjb25zdCBmcmFnVGFpbEdlbyA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpLnNldEZyb21Qb2ludHMoZnJhZ1RyYWlsUG9pbnRzKTtcbiAgICAgICAgICBmcmFnVGFpbEdlby5zZXRBdHRyaWJ1dGUoJ2NvbG9yJywgb2JqLnRhaWwuZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCdjb2xvcicpLmNsb25lKCkpO1xuICAgICAgICAgIGNvbnN0IGZyYWdUYWlsTWF0ID0gb2JqLnRhaWwubWF0ZXJpYWwuY2xvbmUoKTtcbiAgICAgICAgICBjb25zdCBmcmFnVGFpbCA9IG5ldyBUSFJFRS5MaW5lKGZyYWdUYWlsR2VvLCBmcmFnVGFpbE1hdCk7XG4gICAgICAgICAgZnJhZ1RhaWwucG9zaXRpb24uY29weShmcmFnU3Rhci5wb3NpdGlvbik7XG4gICAgICAgICAgc2NlbmUuYWRkKGZyYWdTdGFyKTtcbiAgICAgICAgICBzY2VuZS5hZGQoZnJhZ1RhaWwpO1xuICAgICAgICAgIHNob290aW5nU3RhcnMucHVzaCh7IG1lc2g6IGZyYWdTdGFyLCB0YWlsOiBmcmFnVGFpbCwgdmVsb2NpdHk6IGZyYWdTdGFyLnZlbG9jaXR5LCBkaXI6IG9iai5kaXIsIGFnZTogZnJhZ1N0YXIuYWdlLCBub3JtYWxpemVkTGlmZXRpbWU6IGZyYWdTdGFyLm5vcm1hbGl6ZWRMaWZldGltZSwgdHJhaWxQb2ludHM6IGZyYWdUcmFpbFBvaW50cywgY29sb3I6IG9iai5jb2xvciwgYnJpZ2h0bmVzczogb2JqLmJyaWdodG5lc3MsIGhhc0ZyYWdtZW50ZWQ6IHRydWUgfSk7XG4gICAgICAgICAgb2JqLmhhc0ZyYWdtZW50ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNwYXJrIGJ1cnN0XG4gICAgICAgIGlmICghb2JqLmhhc1NwYXJrZWQgJiYgbm9ybWFsaXplZExpZmUgPiAwLjk1ICYmIE1hdGgucmFuZG9tKCkgPCAwLjEpIHtcbiAgICAgICAgICBmb3IgKGxldCBzID0gMDsgcyA8IDggKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqOCk7IHMrKykge1xuICAgICAgICAgICAgY29uc3Qgc3BhcmtHZW8gPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoMC41ICsgTWF0aC5yYW5kb20oKSowLjUsIDgsIDgpO1xuICAgICAgICAgICAgY29uc3Qgc3BhcmtNYXQgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoeyBjb2xvcjogMHhmZmY2YzAsIHRyYW5zcGFyZW50OiB0cnVlLCBvcGFjaXR5OiAxLCBibGVuZGluZzogVEhSRUUuQWRkaXRpdmVCbGVuZGluZyB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNwYXJrID0gbmV3IFRIUkVFLk1lc2goc3BhcmtHZW8sIHNwYXJrTWF0KTtcbiAgICAgICAgICAgIHNwYXJrLnBvc2l0aW9uLmNvcHkob2JqLm1lc2gucG9zaXRpb24pO1xuICAgICAgICAgICAgc3Bhcmsuc3BhcmtWZWwgPSBuZXcgVEhSRUUuVmVjdG9yMyhNYXRoLnJhbmRvbSgpLTAuNSwgTWF0aC5yYW5kb20oKS0wLjUsIE1hdGgucmFuZG9tKCktMC41KS5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhcigwLjUgKyBNYXRoLnJhbmRvbSgpKjEuMik7XG4gICAgICAgICAgICBzcGFyay5zcGFya0xpZmUgPSAxMiArIE1hdGgucmFuZG9tKCkqMTA7XG4gICAgICAgICAgICBzcGFyay5zcGFya0FnZSA9IDA7XG4gICAgICAgICAgICBzY2VuZS5hZGQoc3BhcmspO1xuICAgICAgICAgICAgaWYgKCF3aW5kb3cuX3N0YXJTcGFya3MpIHdpbmRvdy5fc3RhclNwYXJrcyA9IFtdO1xuICAgICAgICAgICAgd2luZG93Ll9zdGFyU3BhcmtzLnB1c2goc3BhcmspO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvYmouaGFzU3BhcmtlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmxhc2hcbiAgICAgICAgaWYgKCFvYmouaGFzRmxhc2hlZCAmJiBub3JtYWxpemVkTGlmZSA+IDAuOTggJiYgTWF0aC5yYW5kb20oKSA8IDAuMikge1xuICAgICAgICAgIGNvbnN0IGZsYXNoR2VvID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KDEsIDE2LCAxNik7XG4gICAgICAgICAgY29uc3QgZmxhc2hNYXQgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoeyBjb2xvcjogMHhmZmZmZWUsIHRyYW5zcGFyZW50OiB0cnVlLCBvcGFjaXR5OiAwLjgsIGJsZW5kaW5nOiBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nIH0pO1xuICAgICAgICAgIGNvbnN0IGZsYXNoID0gbmV3IFRIUkVFLk1lc2goZmxhc2hHZW8sIGZsYXNoTWF0KTtcbiAgICAgICAgICBmbGFzaC5wb3NpdGlvbi5jb3B5KG9iai5tZXNoLnBvc2l0aW9uKTtcbiAgICAgICAgICBzY2VuZS5hZGQoZmxhc2gpO1xuICAgICAgICAgIGlmICghd2luZG93Ll9zdGFyRmxhc2hlcykgd2luZG93Ll9zdGFyRmxhc2hlcyA9IFtdO1xuICAgICAgICAgIHdpbmRvdy5fc3RhckZsYXNoZXMucHVzaCh7IG1lc2g6IGZsYXNoLCBhZ2U6IDAgfSk7XG4gICAgICAgICAgb2JqLmhhc0ZsYXNoZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZhZGUgb3V0IGFzIGl0IGdldHMgZmFyIGF3YXlcbiAgICAgICAgY29uc3QgZGlzdCA9IG9iai5tZXNoLnBvc2l0aW9uLmRpc3RhbmNlVG8oY2FtZXJhLnBvc2l0aW9uKTtcbiAgICAgICAgY29uc3QgZmFkZVN0YXJ0ID0gc3Rhck1heERpc3RhbmNlICogMC41O1xuICAgICAgICBpZiAoZGlzdCA+IGZhZGVTdGFydCkge1xuICAgICAgICAgIGNvbnN0IGZhZGUgPSAxIC0gKGRpc3QgLSBmYWRlU3RhcnQpIC8gKHN0YXJNYXhEaXN0YW5jZSAtIGZhZGVTdGFydCk7XG4gICAgICAgICAgb2JqLm1lc2gubWF0ZXJpYWwub3BhY2l0eSA9IE1hdGgubWF4KDAsIGZhZGUpO1xuICAgICAgICAgIG9iai5tZXNoLm1hdGVyaWFsLnRyYW5zcGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgICBvYmoudGFpbC5tYXRlcmlhbC5vcGFjaXR5ID0gTWF0aC5tYXgoMCwgZmFkZSAqIDAuOCk7XG4gICAgICAgICAgb2JqLnRhaWwubWF0ZXJpYWwudHJhbnNwYXJlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSB3aGVuIG91dCBvZiBib3VuZHMgb3IgZnVsbHkgZmFkZWQgb3IgbGlmZSBlbmRlZFxuICAgICAgICAvLyBGYWRlIHRhaWwgYWZ0ZXIgZXhwbG9zaW9uXG4gICAgICAgIGlmICgobm9ybWFsaXplZExpZmUgPj0gMS4wIHx8IGRpc3QgPiBzdGFyTWF4RGlzdGFuY2UgfHwgb2JqLm1lc2gubWF0ZXJpYWwub3BhY2l0eSA8PSAwLjAxKSAmJiAhb2JqLnRhaWxGYWRpbmcpIHtcbiAgICAgICAgICBzY2VuZS5yZW1vdmUob2JqLm1lc2gpO1xuICAgICAgICAgIC8vIFN0YXJ0IHRhaWwgZmFkZS1vdXQgZ2hvc3RcbiAgICAgICAgICBvYmoudGFpbEZhZGluZyA9IHRydWU7XG4gICAgICAgICAgb2JqLnRhaWxGYWRlQWdlID0gMDtcbiAgICAgICAgICBpZiAoIXdpbmRvdy5fZmFkaW5nVGFpbHMpIHdpbmRvdy5fZmFkaW5nVGFpbHMgPSBbXTtcbiAgICAgICAgICB3aW5kb3cuX2ZhZGluZ1RhaWxzLnB1c2goeyB0YWlsOiBvYmoudGFpbCwgdGFpbEJsb29tOiBvYmoudGFpbEJsb29tLCBhZ2U6IDAgfSk7XG4gICAgICAgICAgc2hvb3RpbmdTdGFycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEFuaW1hdGUgc3BhcmtzXG4gICAgICBpZiAod2luZG93Ll9zdGFyU3BhcmtzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB3aW5kb3cuX3N0YXJTcGFya3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBjb25zdCBzcGFyayA9IHdpbmRvdy5fc3RhclNwYXJrc1tpXTtcbiAgICAgICAgICBzcGFyay5wb3NpdGlvbi5hZGQoc3Bhcmsuc3BhcmtWZWwpO1xuICAgICAgICAgIHNwYXJrLnNwYXJrQWdlKys7XG4gICAgICAgICAgc3BhcmsubWF0ZXJpYWwub3BhY2l0eSAqPSAwLjkyO1xuICAgICAgICAgIGlmIChzcGFyay5zcGFya0FnZSA+IHNwYXJrLnNwYXJrTGlmZSkge1xuICAgICAgICAgICAgc2NlbmUucmVtb3ZlKHNwYXJrKTtcbiAgICAgICAgICAgIHdpbmRvdy5fc3RhclNwYXJrcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBBbmltYXRlIGV4cGxvc2lvbiBwYXJ0aWNsZXMgKHNwYXJrbGVzKVxuICAgICAgaWYgKHdpbmRvdy5fc3BhcmtsZXMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHdpbmRvdy5fc3BhcmtsZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBjb25zdCBzcGFya2xlID0gd2luZG93Ll9zcGFya2xlc1tpXTtcbiAgICAgICAgICBzcGFya2xlLnBvc2l0aW9uLmFkZChzcGFya2xlLnVzZXJEYXRhLnZlbG9jaXR5KTtcbiAgICAgICAgICBzcGFya2xlLnVzZXJEYXRhLmFnZSsrO1xuICAgICAgICAgIHNwYXJrbGUubWF0ZXJpYWwub3BhY2l0eSAqPSAwLjk3O1xuICAgICAgICAgIGlmIChzcGFya2xlLnVzZXJEYXRhLmFnZSA+IChzcGFya2xlLnVzZXJEYXRhLm1heEFnZSB8fCA0MCkpIHtcbiAgICAgICAgICAgIHNjZW5lLnJlbW92ZShzcGFya2xlKTtcbiAgICAgICAgICAgIHdpbmRvdy5fc3BhcmtsZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQW5pbWF0ZSBmYWRpbmcgdGFpbHMgKGdob3N0cylcbiAgICAgIGlmICh3aW5kb3cuX2ZhZGluZ1RhaWxzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB3aW5kb3cuX2ZhZGluZ1RhaWxzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgY29uc3QgZ2hvc3QgPSB3aW5kb3cuX2ZhZGluZ1RhaWxzW2ldO1xuICAgICAgICAgIGlmIChnaG9zdC50YWlsKSB7XG4gICAgICAgICAgICBnaG9zdC50YWlsLm1hdGVyaWFsLm9wYWNpdHkgKj0gMC45MjtcbiAgICAgICAgICAgIGlmIChnaG9zdC50YWlsLm1hdGVyaWFsLm9wYWNpdHkgPCAwLjAxKSB7XG4gICAgICAgICAgICAgIHNjZW5lLnJlbW92ZShnaG9zdC50YWlsKTtcbiAgICAgICAgICAgICAgd2luZG93Ll9mYWRpbmdUYWlscy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZ2hvc3QudGFpbEJsb29tKSB7XG4gICAgICAgICAgICBnaG9zdC50YWlsQmxvb20ubWF0ZXJpYWwub3BhY2l0eSAqPSAwLjkyO1xuICAgICAgICAgICAgaWYgKGdob3N0LnRhaWxCbG9vbS5tYXRlcmlhbC5vcGFjaXR5IDwgMC4wMSkge1xuICAgICAgICAgICAgICBzaG9vdGluZ1N0YXJTY2VuZS5yZW1vdmUoZ2hvc3QudGFpbEJsb29tKTtcbiAgICAgICAgICAgICAgZ2hvc3QudGFpbEJsb29tID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZ2hvc3QuYWdlKys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQW5pbWF0ZSBmbGFzaGVzXG4gICAgICBpZiAod2luZG93Ll9zdGFyRmxhc2hlcykge1xuICAgICAgICBmb3IgKGxldCBpID0gd2luZG93Ll9zdGFyRmxhc2hlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGNvbnN0IGZsYXNoID0gd2luZG93Ll9zdGFyRmxhc2hlc1tpXTtcbiAgICAgICAgICBmbGFzaC5tZXNoLnNjYWxlLm11bHRpcGx5U2NhbGFyKDEuMTUpO1xuICAgICAgICAgIGZsYXNoLm1lc2gubWF0ZXJpYWwub3BhY2l0eSAqPSAwLjg1O1xuICAgICAgICAgIGZsYXNoLmFnZSsrO1xuICAgICAgICAgIGlmIChmbGFzaC5hZ2UgPiAxMCkge1xuICAgICAgICAgICAgc2NlbmUucmVtb3ZlKGZsYXNoLm1lc2gpO1xuICAgICAgICAgICAgd2luZG93Ll9zdGFyRmxhc2hlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIC0tLSBTdGFyZmllbGQgbG9naWMgLS0tXG4gICAgICBjb25zdCBzcURpc3QgPSBzdGFyTWF4RGlzdGFuY2UgKiBzdGFyTWF4RGlzdGFuY2U7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc2l0aW9ucy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICBjb25zdCBkeCA9IHBvc2l0aW9uc1tpXSAtIHZpcnR1YWxDYW1lcmFQb3MueDtcbiAgICAgICAgY29uc3QgZHkgPSBwb3NpdGlvbnNbaSArIDFdIC0gdmlydHVhbENhbWVyYVBvcy55O1xuICAgICAgICBjb25zdCBkeiA9IHBvc2l0aW9uc1tpICsgMl0gLSB2aXJ0dWFsQ2FtZXJhUG9zLno7XG4gICAgICAgIGlmIChkeCpkeCArIGR5KmR5ICsgZHoqZHogPiBzcURpc3QpIHtcbiAgICAgICAgICAvLyBQbGFjZSBpbiBhIHRoaWNrIHNwaGVyaWNhbCBzaGVsbCBhcm91bmQgdGhlIHZpcnR1YWwgY2FtZXJhLCBuZXZlciB0b28gY2xvc2VcbiAgICAgICAgICBjb25zdCBtaW5SYWRpdXMgPSBzdGFyTWF4RGlzdGFuY2UgKiAwLjg7XG4gICAgICAgICAgY29uc3QgbWF4UmFkaXVzID0gc3Rhck1heERpc3RhbmNlO1xuICAgICAgICAgIGNvbnN0IHIgPSBtaW5SYWRpdXMgKyBNYXRoLnJhbmRvbSgpICogKG1heFJhZGl1cyAtIG1pblJhZGl1cyk7XG4gICAgICAgICAgY29uc3QgdGhldGEgPSBNYXRoLnJhbmRvbSgpICogMiAqIE1hdGguUEk7XG4gICAgICAgICAgY29uc3QgcGhpID0gTWF0aC5hY29zKDIgKiBNYXRoLnJhbmRvbSgpIC0gMSk7XG4gICAgICAgICAgcG9zaXRpb25zW2ldID0gdmlydHVhbENhbWVyYVBvcy54ICsgciAqIE1hdGguc2luKHBoaSkgKiBNYXRoLmNvcyh0aGV0YSk7XG4gICAgICAgICAgcG9zaXRpb25zW2krMV0gPSB2aXJ0dWFsQ2FtZXJhUG9zLnkgKyByICogTWF0aC5zaW4ocGhpKSAqIE1hdGguc2luKHRoZXRhKTtcbiAgICAgICAgICBwb3NpdGlvbnNbaSsyXSA9IHZpcnR1YWxDYW1lcmFQb3MueiArIHIgKiBNYXRoLmNvcyhwaGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTsgLy8gQWxyZWFkeSBzZXQgYWJvdmVcbiAgXG4gICAgICAvLyBSb2J1c3Qgc3RhcmZpZWxkIGNvbG9yIHVwZGF0ZSB0byBwcmV2ZW50IHN0dWNrIHdoaXRlIGRvdHNcbiAgICAgIC8vIFRoaXMgd29ya3MgTk8gVE9VQ0hZXG4gICAgICBjb25zdCBjb2xBcnIgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLmNvbG9yLmFycmF5O1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3NpdGlvbnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gaSAvIDM7XG4gICAgICAgIGNvbnN0IGR4ID0gcG9zaXRpb25zW2ldIC0gdmlydHVhbENhbWVyYVBvcy54O1xuICAgICAgICBjb25zdCBkeSA9IHBvc2l0aW9uc1tpICsgMV0gLSB2aXJ0dWFsQ2FtZXJhUG9zLnk7XG4gICAgICAgIGNvbnN0IGR6ID0gcG9zaXRpb25zW2kgKyAyXSAtIHZpcnR1YWxDYW1lcmFQb3MuejtcbiAgICAgICAgY29uc3QgZGlzdCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSArIGR6ICogZHopO1xuICAgICAgICBpZiAodGltZXJzW2lkeF0gPiAwKSB7XG4gICAgICAgICAgdGltZXJzW2lkeF0tLTtcbiAgICAgICAgICBpZiAodGltZXJzW2lkeF0gPT09IDApIHtcbiAgICAgICAgICAgIC8vIFRpbWVyIGV4cGlyZWQsIHJlc3RvcmUgY29sb3JcbiAgICAgICAgICAgIHNwYXJrQ29sb3JzW2ldID0gb3JpZ2luYWxDb2xvcnNbaV07XG4gICAgICAgICAgICBzcGFya0NvbG9yc1tpKzFdID0gb3JpZ2luYWxDb2xvcnNbaSsxXTtcbiAgICAgICAgICAgIHNwYXJrQ29sb3JzW2krMl0gPSBvcmlnaW5hbENvbG9yc1tpKzJdO1xuICAgICAgICAgICAgY29sQXJyW2ldID0gb3JpZ2luYWxDb2xvcnNbaV07XG4gICAgICAgICAgICBjb2xBcnJbaSsxXSA9IG9yaWdpbmFsQ29sb3JzW2krMV07XG4gICAgICAgICAgICBjb2xBcnJbaSsyXSA9IG9yaWdpbmFsQ29sb3JzW2krMl07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbEFycltpXSA9IHNwYXJrQ29sb3JzW2ldO1xuICAgICAgICAgICAgY29sQXJyW2krMV0gPSBzcGFya0NvbG9yc1tpKzFdO1xuICAgICAgICAgICAgY29sQXJyW2krMl0gPSBzcGFya0NvbG9yc1tpKzJdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChkaXN0ID4gc3Rhck1heERpc3RhbmNlICogMC4zICYmIE1hdGgucmFuZG9tKCkgPCAwLjA1KSB7XG4gICAgICAgICAgdGltZXJzW2lkeF0gPSBzcGFya2xlRHVyYXRpb247XG4gICAgICAgICAgY29uc3QgYyA9IHBhbGV0dGVbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcGFsZXR0ZS5sZW5ndGgpXTtcbiAgICAgICAgICBzcGFya0NvbG9yc1tpXSA9IGNbMF07XG4gICAgICAgICAgc3BhcmtDb2xvcnNbaSsxXSA9IGNbMV07XG4gICAgICAgICAgc3BhcmtDb2xvcnNbaSsyXSA9IGNbMl07XG4gICAgICAgICAgY29sQXJyW2ldID0gc3BhcmtDb2xvcnNbaV07XG4gICAgICAgICAgY29sQXJyW2krMV0gPSBzcGFya0NvbG9yc1tpKzFdO1xuICAgICAgICAgIGNvbEFycltpKzJdID0gc3BhcmtDb2xvcnNbaSsyXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzcGFya0NvbG9yc1tpXSA9IG9yaWdpbmFsQ29sb3JzW2ldO1xuICAgICAgICAgIHNwYXJrQ29sb3JzW2krMV0gPSBvcmlnaW5hbENvbG9yc1tpKzFdO1xuICAgICAgICAgIHNwYXJrQ29sb3JzW2krMl0gPSBvcmlnaW5hbENvbG9yc1tpKzJdO1xuICAgICAgICAgIGNvbEFycltpXSA9IG9yaWdpbmFsQ29sb3JzW2ldO1xuICAgICAgICAgIGNvbEFycltpKzFdID0gb3JpZ2luYWxDb2xvcnNbaSsxXTtcbiAgICAgICAgICBjb2xBcnJbaSsyXSA9IG9yaWdpbmFsQ29sb3JzW2krMl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3IubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH07XG4gICAgXG4gICAgLy8gU3RhcnQgdGhlIGFuaW1hdGlvbiBsb29wXG4gICAgYW5pbWF0ZSgpO1xuICAgIFxuICAgIC8vIEhhbmRsZSB3aW5kb3cgcmVzaXplXG4gICAgY29uc3Qgb25SZXNpemUgPSAoKSA9PiB7XG4gICAgICBjYW1lcmEuYXNwZWN0ID0gd2luZG93LmlubmVyV2lkdGggLyB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICBjYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgICAgcmVuZGVyZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICAgIHNob290aW5nU3RhckNvbXBvc2VyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgICBjYUNvbXBvc2VyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgfTtcbiAgICBcbiAgICAvLyBBZGQgZXZlbnQgbGlzdGVuZXIgZm9yIHJlc2l6ZVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvblJlc2l6ZSk7XG4gICAgXG4gICAgLy8gQ2xlYW4gdXAgZnVuY3Rpb25cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uUmVzaXplKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCByZXNpemVBbGwpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Z1bGxzY3JlZW5jaGFuZ2UnLCByZXNpemVBbGwpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIG9uU2Nyb2xsKTtcbiAgICAgIC8vIENhbmNlbCB0aGUgYW5pbWF0aW9uIGZyYW1lIHVzaW5nIHRoZSBzdG9yZWQgSURcbiAgICAgIGlmIChhbmltYXRpb25JZCkge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShhbmltYXRpb25JZCk7XG4gICAgICB9XG4gICAgICAvLyBEaXNwb3NlIGNvbXBvc2Vyc1xuICAgICAgaWYgKGNvbXBvc2VyKSBjb21wb3Nlci5kaXNwb3NlKCk7XG4gICAgICBpZiAoc2hvb3RpbmdTdGFyQ29tcG9zZXIpIHNob290aW5nU3RhckNvbXBvc2VyLmRpc3Bvc2UoKTtcbiAgICAgIGlmIChjYUNvbXBvc2VyKSBjYUNvbXBvc2VyLmRpc3Bvc2UoKTtcbiAgICAgIC8vIENsZWFuIHVwIFRocmVlLmpzIHJlc291cmNlc1xuICAgICAgaWYgKHJlbmRlcmVyKSB7XG4gICAgICAgIHJlbmRlcmVyLmRpc3Bvc2UoKTtcbiAgICAgICAgaWYgKG1vdW50ICYmIG1vdW50LmNvbnRhaW5zKHJlbmRlcmVyLmRvbUVsZW1lbnQpKSB7XG4gICAgICAgICAgbW91bnQucmVtb3ZlQ2hpbGQocmVuZGVyZXIuZG9tRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9LCBbXSlcblxuICByZXR1cm4gPGRpdiByZWY9e21vdW50UmVmfSAvPjtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFN0YXJmaWVsZDtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUVmZmVjdCIsInVzZVJlZiIsIlRIUkVFIiwiRWZmZWN0Q29tcG9zZXIiLCJVbnJlYWxCbG9vbVBhc3MiLCJSZW5kZXJQYXNzIiwiU2hhZGVyUGFzcyIsIkZYQUFTaGFkZXIiLCJGaWxtUGFzcyIsIkNocm9tYXRpY0FiZXJyYXRpb25QYXNzIiwiU3RhcmZpZWxkIiwibW91bnRSZWYiLCJjdXJyZW50IiwibW91bnQiLCJzdHlsZSIsInBvc2l0aW9uIiwidG9wIiwibGVmdCIsIndpZHRoIiwiaGVpZ2h0IiwiekluZGV4Iiwic2NlbmUiLCJTY2VuZSIsImNhbWVyYSIsIlBlcnNwZWN0aXZlQ2FtZXJhIiwid2luZG93IiwiaW5uZXJXaWR0aCIsImlubmVySGVpZ2h0Iiwic2V0IiwidmlydHVhbENhbWVyYVBvcyIsIlZlY3RvcjMiLCJyZW5kZXJlciIsIldlYkdMUmVuZGVyZXIiLCJhbnRpYWxpYXMiLCJzZXRQaXhlbFJhdGlvIiwiZGV2aWNlUGl4ZWxSYXRpbyIsInNldFNpemUiLCJzZXRDbGVhckNvbG9yIiwib3V0cHV0Q29sb3JTcGFjZSIsIlNSR0JDb2xvclNwYWNlIiwicmVuZGVyVGFyZ2V0IiwiV2ViR0xSZW5kZXJUYXJnZXQiLCJjb2xvclNwYWNlIiwidHlwZSIsIlVuc2lnbmVkQnl0ZVR5cGUiLCJ0b25lTWFwcGluZyIsIk5vVG9uZU1hcHBpbmciLCJhdXRvQ2xlYXIiLCJhcHBlbmRDaGlsZCIsImRvbUVsZW1lbnQiLCJjb21wb3NlciIsInJlbmRlclBhc3MiLCJjbGVhciIsImFkZFBhc3MiLCJibG9vbVBhc3MiLCJWZWN0b3IyIiwiZnhhYVBhc3MiLCJtYXRlcmlhbCIsInVuaWZvcm1zIiwidmFsdWUiLCJ4IiwieSIsImZpbG1QYXNzIiwic2hvb3RpbmdTdGFyU2NlbmUiLCJzaG9vdGluZ1N0YXJDb21wb3NlciIsInNob290aW5nU3RhclJlbmRlclBhc3MiLCJzaG9vdGluZ1N0YXJCbG9vbVBhc3MiLCJjbG9zZVN0YXJzU2NlbmUiLCJjYVBhc3MiLCJjYUNvbXBvc2VyIiwiY2FSZW5kZXJQYXNzIiwicmVzaXplQWxsIiwiYXNwZWN0IiwidXBkYXRlUHJvamVjdGlvbk1hdHJpeCIsImFkZEV2ZW50TGlzdGVuZXIiLCJzdGFyQ291bnQiLCJzdGFyTWF4RGlzdGFuY2UiLCJzdGFyU3BlZWQiLCJnZW9tZXRyeSIsIkJ1ZmZlckdlb21ldHJ5IiwiY2xvc2VHZW9tZXRyeSIsInBvc2l0aW9ucyIsImNsb3NlUG9zaXRpb25zIiwic3RhcnNQbGFjZWQiLCJNYXRoIiwicmFuZG9tIiwiY2x1c3RlclRoZXRhIiwiUEkiLCJjbHVzdGVyUGhpIiwiYWNvcyIsImNsdXN0ZXJSIiwiY2x1c3RlckNlbnRlciIsInNpbiIsImNvcyIsImNsdXN0ZXJTaXplIiwiZmxvb3IiLCJjIiwib2Zmc2V0VGhldGEiLCJvZmZzZXRQaGkiLCJvZmZzZXRSIiwicHVzaCIsInRoZXRhIiwicGhpIiwiciIsInoiLCJzZXRBdHRyaWJ1dGUiLCJGbG9hdDMyQnVmZmVyQXR0cmlidXRlIiwibGVuZ3RoIiwicGFsZXR0ZSIsImNvbG9ycyIsImkiLCJvcmlnaW5hbENvbG9ycyIsImF0dHJpYnV0ZXMiLCJjb2xvciIsImFycmF5Iiwic2xpY2UiLCJ0aW1lcnMiLCJGbG9hdDMyQXJyYXkiLCJzcGFya0NvbG9ycyIsInNwYXJrbGVEdXJhdGlvbiIsIlBvaW50c01hdGVyaWFsIiwic2l6ZSIsInNpemVBdHRlbnVhdGlvbiIsInZlcnRleENvbG9ycyIsInN0YXJzIiwiUG9pbnRzIiwiYWRkIiwiZ2xvd01hcCIsIlRleHR1cmVMb2FkZXIiLCJsb2FkIiwiZ2xvd1Nwcml0ZXMiLCJnbG93TWF0ZXJpYWwiLCJTcHJpdGVNYXRlcmlhbCIsIm1hcCIsIm9wYWNpdHkiLCJibGVuZGluZyIsIkFkZGl0aXZlQmxlbmRpbmciLCJkZXB0aFdyaXRlIiwiZ2xvdyIsIlNwcml0ZSIsImNsb25lIiwic2NhbGUiLCJjbG9zZVN0YXJzIiwidGFyZ2V0WSIsImRhbXBpbmciLCJvblNjcm9sbCIsInBjdCIsInNjcm9sbFkiLCJkb2N1bWVudCIsImJvZHkiLCJzY3JvbGxIZWlnaHQiLCJ0YWlsTGVuZ3RoIiwic2hvb3RpbmdTdGFycyIsInNob290aW5nU3RhckNvb2xkb3duIiwic3Bhd25TaG9vdGluZ1N0YXIiLCJkaXIiLCJub3JtYWxpemUiLCJtaW5EaXN0IiwibWF4RGlzdCIsImRpc3QiLCJzcGF3blBvcyIsIm11bHRpcGx5U2NhbGFyIiwidGFuZ2VudCIsInN1YiIsInByb2plY3RPblZlY3RvciIsInRhbmdlbnRpYWxTcGVlZCIsInJhZGlhbFNwZWVkIiwidmVsb2NpdHkiLCJ2aWJyYW50Q29sb3JzIiwiYnJpZ2h0bmVzcyIsImdlbyIsIlNwaGVyZUdlb21ldHJ5IiwibWF0IiwiTWVzaFBoeXNpY2FsTWF0ZXJpYWwiLCJlbWlzc2l2ZSIsImVtaXNzaXZlSW50ZW5zaXR5IiwibWV0YWxuZXNzIiwicm91Z2huZXNzIiwidHJhbnNtaXNzaW9uIiwidHJhbnNwYXJlbnQiLCJjbGVhcmNvYXQiLCJjbGVhcmNvYXRSb3VnaG5lc3MiLCJzdGFyIiwiTWVzaCIsInNwcml0ZU1hcCIsInNwcml0ZU1hdGVyaWFsIiwic3ByaXRlIiwiY29weSIsImNvbG9yU3ByaXRlTWF0ZXJpYWwiLCJjb2xvclNwcml0ZSIsInNwYXJrQ291bnQiLCJzcGFya0dyb3VwIiwiR3JvdXAiLCJzcGFya01hdCIsIk1lc2hCYXNpY01hdGVyaWFsIiwic3BhcmtHZW8iLCJzcGFyayIsImFuZ2xlIiwibmFtZSIsIm5vcm1hbGl6ZWRMaWZlIiwibm9ybWFsaXplZExpZmV0aW1lIiwiYWdlIiwidHJhaWxTZWdtZW50cyIsInRyYWlsUG9pbnRzIiwic3BpcmFsIiwiY3VydmUiLCJwdCIsInRhaWxHZW8iLCJzZXRGcm9tUG9pbnRzIiwidGFpbENvbG9ycyIsImFscGhhIiwicmFpbmJvdyIsImdyYWRDb2xvciIsInRhaWxNYXQiLCJMaW5lQmFzaWNNYXRlcmlhbCIsInRhaWxNYXRNYWluIiwiTm9ybWFsQmxlbmRpbmciLCJ0YWlsTWFpbiIsIkxpbmUiLCJ0YWlsTWF0Qmxvb20iLCJ0YWlsQmxvb20iLCJ0YWlsR2xvd01hcCIsInRhaWxHbG93TWF0IiwidGFpbEdsb3ciLCJtZXNoIiwidGFpbCIsImhhc0ZyYWdtZW50ZWQiLCJhbmltYXRpb25JZCIsImFuaW1hdGUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJuZWVkc1VwZGF0ZSIsImlkeCIsInJlbmRlciIsInJvdGF0aW9uIiwiZm9yd2FyZCIsImdldFdvcmxkRGlyZWN0aW9uIiwiY29sb3JBdHRyIiwib3JpZ1IiLCJvcmlnRyIsIm9yaWdCIiwic3FydCIsInBvdyIsImludGVuc2VSIiwibWluIiwiaW50ZW5zZUciLCJpbnRlbnNlQiIsImZhZGVUIiwibWF4Iiwic2hha2VTdHJlbmd0aCIsIm9iaiIsImNoaWxkcmVuIiwic3BhcmtzIiwiZmluZCIsImNoaWxkIiwiaiIsInRpbWUiLCJwZXJmb3JtYW5jZSIsIm5vdyIsImdldEF0dHJpYnV0ZSIsImsiLCJjb3VudCIsImdldFgiLCJnIiwiZ2V0WSIsImIiLCJnZXRaIiwiaCIsInMiLCJsIiwiZCIsInEiLCJwIiwidHIiLCJ0ZyIsInRiIiwiaHVlMnJnYiIsInQiLCJzZXRYIiwic2V0WSIsInNldFoiLCJzZXRXIiwiZ2V0VyIsInVuc2hpZnQiLCJwb3AiLCJ0YWlsR3JvdyIsImFjdGl2ZVNlZ21lbnRzIiwidmlzaWJsZVRyYWlsIiwidGFpbENvbG9yc0Jsb29tIiwiRGF0ZSIsInNldFhZWlciLCJoZWFkQ29sb3IiLCJDb2xvciIsImxlcnAiLCJmbGlja2VyIiwiZGlzdFRvQ2FtIiwiZG9mQmx1ciIsInNwZWN0YWN1bGFyIiwiYnVyc3RDb3VudCIsInNwYXJrbGVHZW8iLCJzcGFya2xlTWF0Iiwic3BhcmtsZSIsInNwZCIsInNwYXJrbGVWZWwiLCJ1c2VyRGF0YSIsIm1heEFnZSIsIl9zcGFya2xlcyIsImZsYXNoR2VvIiwiZmxhc2hNYXQiLCJmbGFzaCIsIl9zdGFyRmxhc2hlcyIsImZyYWdWZWwiLCJhcHBseUF4aXNBbmdsZSIsImZyYWdTdGFyIiwiZnJhZ1RyYWlsUG9pbnRzIiwiZnJhZ1RhaWxHZW8iLCJmcmFnVGFpbE1hdCIsImZyYWdUYWlsIiwiaGFzU3BhcmtlZCIsInNwYXJrVmVsIiwic3BhcmtMaWZlIiwic3BhcmtBZ2UiLCJfc3RhclNwYXJrcyIsImhhc0ZsYXNoZWQiLCJkaXN0YW5jZVRvIiwiZmFkZVN0YXJ0IiwiZmFkZSIsInRhaWxGYWRpbmciLCJyZW1vdmUiLCJ0YWlsRmFkZUFnZSIsIl9mYWRpbmdUYWlscyIsInNwbGljZSIsImdob3N0Iiwic3FEaXN0IiwiZHgiLCJkeSIsImR6IiwibWluUmFkaXVzIiwibWF4UmFkaXVzIiwiY29sQXJyIiwib25SZXNpemUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJkaXNwb3NlIiwiY29udGFpbnMiLCJyZW1vdmVDaGlsZCIsImRpdiIsInJlZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/Starfield.jsx\n"));

/***/ }),

/***/ "./node_modules/three/examples/jsm/postprocessing/FilmPass.js":
/*!********************************************************************!*\
  !*** ./node_modules/three/examples/jsm/postprocessing/FilmPass.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FilmPass: function() { return /* binding */ FilmPass; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var _Pass_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Pass.js */ \"./node_modules/three/examples/jsm/postprocessing/Pass.js\");\n/* harmony import */ var _shaders_FilmShader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shaders/FilmShader.js */ \"./node_modules/three/examples/jsm/shaders/FilmShader.js\");\n\n\n\n\nclass FilmPass extends _Pass_js__WEBPACK_IMPORTED_MODULE_0__.Pass {\n\n\tconstructor( intensity = 0.5, grayscale = false ) {\n\n\t\tsuper();\n\n\t\tconst shader = _shaders_FilmShader_js__WEBPACK_IMPORTED_MODULE_1__.FilmShader;\n\n\t\tthis.uniforms = three__WEBPACK_IMPORTED_MODULE_2__.UniformsUtils.clone( shader.uniforms );\n\n\t\tthis.material = new three__WEBPACK_IMPORTED_MODULE_2__.ShaderMaterial( {\n\n\t\t\tname: shader.name,\n\t\t\tuniforms: this.uniforms,\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tfragmentShader: shader.fragmentShader\n\n\t\t} );\n\n\t\tthis.uniforms.intensity.value = intensity; // (0 = no effect, 1 = full effect)\n\t\tthis.uniforms.grayscale.value = grayscale;\n\n\t\tthis.fsQuad = new _Pass_js__WEBPACK_IMPORTED_MODULE_0__.FullScreenQuad( this.material );\n\n\t}\n\n\trender( renderer, writeBuffer, readBuffer, deltaTime /*, maskActive */ ) {\n\n\t\tthis.uniforms[ 'tDiffuse' ].value = readBuffer.texture;\n\t\tthis.uniforms[ 'time' ].value += deltaTime;\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\trenderer.setRenderTarget( null );\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t} else {\n\n\t\t\trenderer.setRenderTarget( writeBuffer );\n\t\t\tif ( this.clear ) renderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t}\n\n\t}\n\n\tdispose() {\n\n\t\tthis.material.dispose();\n\n\t\tthis.fsQuad.dispose();\n\n\t}\n\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGhyZWUvZXhhbXBsZXMvanNtL3Bvc3Rwcm9jZXNzaW5nL0ZpbG1QYXNzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFHZTtBQUNrQztBQUNLOztBQUV0RCx1QkFBdUIsMENBQUk7O0FBRTNCOztBQUVBOztBQUVBLGlCQUFpQiw4REFBVTs7QUFFM0Isa0JBQWtCLGdEQUFhOztBQUUvQixzQkFBc0IsaURBQWM7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUosNkNBQTZDO0FBQzdDOztBQUVBLG9CQUFvQixvREFBYzs7QUFFbEM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVvQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdGhyZWUvZXhhbXBsZXMvanNtL3Bvc3Rwcm9jZXNzaW5nL0ZpbG1QYXNzLmpzPzNlZjMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcblx0U2hhZGVyTWF0ZXJpYWwsXG5cdFVuaWZvcm1zVXRpbHNcbn0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgUGFzcywgRnVsbFNjcmVlblF1YWQgfSBmcm9tICcuL1Bhc3MuanMnO1xuaW1wb3J0IHsgRmlsbVNoYWRlciB9IGZyb20gJy4uL3NoYWRlcnMvRmlsbVNoYWRlci5qcyc7XG5cbmNsYXNzIEZpbG1QYXNzIGV4dGVuZHMgUGFzcyB7XG5cblx0Y29uc3RydWN0b3IoIGludGVuc2l0eSA9IDAuNSwgZ3JheXNjYWxlID0gZmFsc2UgKSB7XG5cblx0XHRzdXBlcigpO1xuXG5cdFx0Y29uc3Qgc2hhZGVyID0gRmlsbVNoYWRlcjtcblxuXHRcdHRoaXMudW5pZm9ybXMgPSBVbmlmb3Jtc1V0aWxzLmNsb25lKCBzaGFkZXIudW5pZm9ybXMgKTtcblxuXHRcdHRoaXMubWF0ZXJpYWwgPSBuZXcgU2hhZGVyTWF0ZXJpYWwoIHtcblxuXHRcdFx0bmFtZTogc2hhZGVyLm5hbWUsXG5cdFx0XHR1bmlmb3JtczogdGhpcy51bmlmb3Jtcyxcblx0XHRcdHZlcnRleFNoYWRlcjogc2hhZGVyLnZlcnRleFNoYWRlcixcblx0XHRcdGZyYWdtZW50U2hhZGVyOiBzaGFkZXIuZnJhZ21lbnRTaGFkZXJcblxuXHRcdH0gKTtcblxuXHRcdHRoaXMudW5pZm9ybXMuaW50ZW5zaXR5LnZhbHVlID0gaW50ZW5zaXR5OyAvLyAoMCA9IG5vIGVmZmVjdCwgMSA9IGZ1bGwgZWZmZWN0KVxuXHRcdHRoaXMudW5pZm9ybXMuZ3JheXNjYWxlLnZhbHVlID0gZ3JheXNjYWxlO1xuXG5cdFx0dGhpcy5mc1F1YWQgPSBuZXcgRnVsbFNjcmVlblF1YWQoIHRoaXMubWF0ZXJpYWwgKTtcblxuXHR9XG5cblx0cmVuZGVyKCByZW5kZXJlciwgd3JpdGVCdWZmZXIsIHJlYWRCdWZmZXIsIGRlbHRhVGltZSAvKiwgbWFza0FjdGl2ZSAqLyApIHtcblxuXHRcdHRoaXMudW5pZm9ybXNbICd0RGlmZnVzZScgXS52YWx1ZSA9IHJlYWRCdWZmZXIudGV4dHVyZTtcblx0XHR0aGlzLnVuaWZvcm1zWyAndGltZScgXS52YWx1ZSArPSBkZWx0YVRpbWU7XG5cblx0XHRpZiAoIHRoaXMucmVuZGVyVG9TY3JlZW4gKSB7XG5cblx0XHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCggbnVsbCApO1xuXHRcdFx0dGhpcy5mc1F1YWQucmVuZGVyKCByZW5kZXJlciApO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCB3cml0ZUJ1ZmZlciApO1xuXHRcdFx0aWYgKCB0aGlzLmNsZWFyICkgcmVuZGVyZXIuY2xlYXIoKTtcblx0XHRcdHRoaXMuZnNRdWFkLnJlbmRlciggcmVuZGVyZXIgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0ZGlzcG9zZSgpIHtcblxuXHRcdHRoaXMubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXG5cdFx0dGhpcy5mc1F1YWQuZGlzcG9zZSgpO1xuXG5cdH1cblxufVxuXG5leHBvcnQgeyBGaWxtUGFzcyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/three/examples/jsm/postprocessing/FilmPass.js\n"));

/***/ }),

/***/ "./node_modules/three/examples/jsm/shaders/FXAAShader.js":
/*!***************************************************************!*\
  !*** ./node_modules/three/examples/jsm/shaders/FXAAShader.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FXAAShader: function() { return /* binding */ FXAAShader; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\n\n/**\n * NVIDIA FXAA by Timothy Lottes\n * https://developer.download.nvidia.com/assets/gamedev/files/sdk/11/FXAA_WhitePaper.pdf\n * - WebGL port by @supereggbert\n * http://www.glge.org/demos/fxaa/\n * Further improved by Daniel Sturk\n */\n\nconst FXAAShader = {\n\n\tuniforms: {\n\n\t\t'tDiffuse': { value: null },\n\t\t'resolution': { value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2( 1 / 1024, 1 / 512 ) }\n\n\t},\n\n\tvertexShader: /* glsl */`\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n\n\tfragmentShader: `\n\tprecision highp float;\n\n\tuniform sampler2D tDiffuse;\n\n\tuniform vec2 resolution;\n\n\tvarying vec2 vUv;\n\n\t// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)\n\n\t//----------------------------------------------------------------------------------\n\t// File:        es3-kepler\\FXAA\\assets\\shaders/FXAA_DefaultES.frag\n\t// SDK Version: v3.00\n\t// Email:       gameworks@nvidia.com\n\t// Site:        http://developer.nvidia.com/\n\t//\n\t// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.\n\t//\n\t// Redistribution and use in source and binary forms, with or without\n\t// modification, are permitted provided that the following conditions\n\t// are met:\n\t//  * Redistributions of source code must retain the above copyright\n\t//    notice, this list of conditions and the following disclaimer.\n\t//  * Redistributions in binary form must reproduce the above copyright\n\t//    notice, this list of conditions and the following disclaimer in the\n\t//    documentation and/or other materials provided with the distribution.\n\t//  * Neither the name of NVIDIA CORPORATION nor the names of its\n\t//    contributors may be used to endorse or promote products derived\n\t//    from this software without specific prior written permission.\n\t//\n\t// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ''AS IS'' AND ANY\n\t// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n\t// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n\t// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n\t// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n\t// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n\t// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n\t// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n\t// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t//\n\t//----------------------------------------------------------------------------------\n\n\t#ifndef FXAA_DISCARD\n\t\t\t//\n\t\t\t// Only valid for PC OpenGL currently.\n\t\t\t// Probably will not work when FXAA_GREEN_AS_LUMA = 1.\n\t\t\t//\n\t\t\t// 1 = Use discard on pixels which don't need AA.\n\t\t\t//     For APIs which enable concurrent TEX+ROP from same surface.\n\t\t\t// 0 = Return unchanged color on pixels which don't need AA.\n\t\t\t//\n\t\t\t#define FXAA_DISCARD 0\n\t#endif\n\n\t/*--------------------------------------------------------------------------*/\n\t#define FxaaTexTop(t, p) texture2D(t, p, -100.0)\n\t#define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), -100.0)\n\t/*--------------------------------------------------------------------------*/\n\n\t#define NUM_SAMPLES 5\n\n\t// assumes colors have premultipliedAlpha, so that the calculated color contrast is scaled by alpha\n\tfloat contrast( vec4 a, vec4 b ) {\n\t\t\tvec4 diff = abs( a - b );\n\t\t\treturn max( max( max( diff.r, diff.g ), diff.b ), diff.a );\n\t}\n\n\t/*============================================================================\n\n\t\t\t\t\t\t\t\t\tFXAA3 QUALITY - PC\n\n\t============================================================================*/\n\n\t/*--------------------------------------------------------------------------*/\n\tvec4 FxaaPixelShader(\n\t\t\tvec2 posM,\n\t\t\tsampler2D tex,\n\t\t\tvec2 fxaaQualityRcpFrame,\n\t\t\tfloat fxaaQualityEdgeThreshold,\n\t\t\tfloat fxaaQualityinvEdgeThreshold\n\t) {\n\t\t\tvec4 rgbaM = FxaaTexTop(tex, posM);\n\t\t\tvec4 rgbaS = FxaaTexOff(tex, posM, vec2( 0.0, 1.0), fxaaQualityRcpFrame.xy);\n\t\t\tvec4 rgbaE = FxaaTexOff(tex, posM, vec2( 1.0, 0.0), fxaaQualityRcpFrame.xy);\n\t\t\tvec4 rgbaN = FxaaTexOff(tex, posM, vec2( 0.0,-1.0), fxaaQualityRcpFrame.xy);\n\t\t\tvec4 rgbaW = FxaaTexOff(tex, posM, vec2(-1.0, 0.0), fxaaQualityRcpFrame.xy);\n\t\t\t// . S .\n\t\t\t// W M E\n\t\t\t// . N .\n\n\t\t\tbool earlyExit = max( max( max(\n\t\t\t\t\tcontrast( rgbaM, rgbaN ),\n\t\t\t\t\tcontrast( rgbaM, rgbaS ) ),\n\t\t\t\t\tcontrast( rgbaM, rgbaE ) ),\n\t\t\t\t\tcontrast( rgbaM, rgbaW ) )\n\t\t\t\t\t< fxaaQualityEdgeThreshold;\n\t\t\t// . 0 .\n\t\t\t// 0 0 0\n\t\t\t// . 0 .\n\n\t\t\t#if (FXAA_DISCARD == 1)\n\t\t\t\t\tif(earlyExit) FxaaDiscard;\n\t\t\t#else\n\t\t\t\t\tif(earlyExit) return rgbaM;\n\t\t\t#endif\n\n\t\t\tfloat contrastN = contrast( rgbaM, rgbaN );\n\t\t\tfloat contrastS = contrast( rgbaM, rgbaS );\n\t\t\tfloat contrastE = contrast( rgbaM, rgbaE );\n\t\t\tfloat contrastW = contrast( rgbaM, rgbaW );\n\n\t\t\tfloat relativeVContrast = ( contrastN + contrastS ) - ( contrastE + contrastW );\n\t\t\trelativeVContrast *= fxaaQualityinvEdgeThreshold;\n\n\t\t\tbool horzSpan = relativeVContrast > 0.;\n\t\t\t// . 1 .\n\t\t\t// 0 0 0\n\t\t\t// . 1 .\n\n\t\t\t// 45 deg edge detection and corners of objects, aka V/H contrast is too similar\n\t\t\tif( abs( relativeVContrast ) < .3 ) {\n\t\t\t\t\t// locate the edge\n\t\t\t\t\tvec2 dirToEdge;\n\t\t\t\t\tdirToEdge.x = contrastE > contrastW ? 1. : -1.;\n\t\t\t\t\tdirToEdge.y = contrastS > contrastN ? 1. : -1.;\n\t\t\t\t\t// . 2 .      . 1 .\n\t\t\t\t\t// 1 0 2  ~=  0 0 1\n\t\t\t\t\t// . 1 .      . 0 .\n\n\t\t\t\t\t// tap 2 pixels and see which ones are \"outside\" the edge, to\n\t\t\t\t\t// determine if the edge is vertical or horizontal\n\n\t\t\t\t\tvec4 rgbaAlongH = FxaaTexOff(tex, posM, vec2( dirToEdge.x, -dirToEdge.y ), fxaaQualityRcpFrame.xy);\n\t\t\t\t\tfloat matchAlongH = contrast( rgbaM, rgbaAlongH );\n\t\t\t\t\t// . 1 .\n\t\t\t\t\t// 0 0 1\n\t\t\t\t\t// . 0 H\n\n\t\t\t\t\tvec4 rgbaAlongV = FxaaTexOff(tex, posM, vec2( -dirToEdge.x, dirToEdge.y ), fxaaQualityRcpFrame.xy);\n\t\t\t\t\tfloat matchAlongV = contrast( rgbaM, rgbaAlongV );\n\t\t\t\t\t// V 1 .\n\t\t\t\t\t// 0 0 1\n\t\t\t\t\t// . 0 .\n\n\t\t\t\t\trelativeVContrast = matchAlongV - matchAlongH;\n\t\t\t\t\trelativeVContrast *= fxaaQualityinvEdgeThreshold;\n\n\t\t\t\t\tif( abs( relativeVContrast ) < .3 ) { // 45 deg edge\n\t\t\t\t\t\t\t// 1 1 .\n\t\t\t\t\t\t\t// 0 0 1\n\t\t\t\t\t\t\t// . 0 1\n\n\t\t\t\t\t\t\t// do a simple blur\n\t\t\t\t\t\t\treturn mix(\n\t\t\t\t\t\t\t\t\trgbaM,\n\t\t\t\t\t\t\t\t\t(rgbaN + rgbaS + rgbaE + rgbaW) * .25,\n\t\t\t\t\t\t\t\t\t.4\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\thorzSpan = relativeVContrast > 0.;\n\t\t\t}\n\n\t\t\tif(!horzSpan) rgbaN = rgbaW;\n\t\t\tif(!horzSpan) rgbaS = rgbaE;\n\t\t\t// . 0 .      1\n\t\t\t// 1 0 1  ->  0\n\t\t\t// . 0 .      1\n\n\t\t\tbool pairN = contrast( rgbaM, rgbaN ) > contrast( rgbaM, rgbaS );\n\t\t\tif(!pairN) rgbaN = rgbaS;\n\n\t\t\tvec2 offNP;\n\t\t\toffNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n\t\t\toffNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n\n\t\t\tbool doneN = false;\n\t\t\tbool doneP = false;\n\n\t\t\tfloat nDist = 0.;\n\t\t\tfloat pDist = 0.;\n\n\t\t\tvec2 posN = posM;\n\t\t\tvec2 posP = posM;\n\n\t\t\tint iterationsUsed = 0;\n\t\t\tint iterationsUsedN = 0;\n\t\t\tint iterationsUsedP = 0;\n\t\t\tfor( int i = 0; i < NUM_SAMPLES; i++ ) {\n\t\t\t\t\titerationsUsed = i;\n\n\t\t\t\t\tfloat increment = float(i + 1);\n\n\t\t\t\t\tif(!doneN) {\n\t\t\t\t\t\t\tnDist += increment;\n\t\t\t\t\t\t\tposN = posM + offNP * nDist;\n\t\t\t\t\t\t\tvec4 rgbaEndN = FxaaTexTop(tex, posN.xy);\n\t\t\t\t\t\t\tdoneN = contrast( rgbaEndN, rgbaM ) > contrast( rgbaEndN, rgbaN );\n\t\t\t\t\t\t\titerationsUsedN = i;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(!doneP) {\n\t\t\t\t\t\t\tpDist += increment;\n\t\t\t\t\t\t\tposP = posM - offNP * pDist;\n\t\t\t\t\t\t\tvec4 rgbaEndP = FxaaTexTop(tex, posP.xy);\n\t\t\t\t\t\t\tdoneP = contrast( rgbaEndP, rgbaM ) > contrast( rgbaEndP, rgbaN );\n\t\t\t\t\t\t\titerationsUsedP = i;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(doneN || doneP) break;\n\t\t\t}\n\n\n\t\t\tif ( !doneP && !doneN ) return rgbaM; // failed to find end of edge\n\n\t\t\tfloat dist = min(\n\t\t\t\t\tdoneN ? float( iterationsUsedN ) / float( NUM_SAMPLES - 1 ) : 1.,\n\t\t\t\t\tdoneP ? float( iterationsUsedP ) / float( NUM_SAMPLES - 1 ) : 1.\n\t\t\t);\n\n\t\t\t// hacky way of reduces blurriness of mostly diagonal edges\n\t\t\t// but reduces AA quality\n\t\t\tdist = pow(dist, .5);\n\n\t\t\tdist = 1. - dist;\n\n\t\t\treturn mix(\n\t\t\t\t\trgbaM,\n\t\t\t\t\trgbaN,\n\t\t\t\t\tdist * .5\n\t\t\t);\n\t}\n\n\tvoid main() {\n\t\t\tconst float edgeDetectionQuality = .2;\n\t\t\tconst float invEdgeDetectionQuality = 1. / edgeDetectionQuality;\n\n\t\t\tgl_FragColor = FxaaPixelShader(\n\t\t\t\t\tvUv,\n\t\t\t\t\ttDiffuse,\n\t\t\t\t\tresolution,\n\t\t\t\t\tedgeDetectionQuality, // [0,1] contrast needed, otherwise early discard\n\t\t\t\t\tinvEdgeDetectionQuality\n\t\t\t);\n\n\t}\n\t`\n\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGhyZWUvZXhhbXBsZXMvanNtL3NoYWRlcnMvRlhBQVNoYWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUVlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGdCQUFnQixhQUFhO0FBQzdCLGtCQUFrQixXQUFXLDBDQUFPOztBQUVwQyxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRXNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90aHJlZS9leGFtcGxlcy9qc20vc2hhZGVycy9GWEFBU2hhZGVyLmpzPzM0YzQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcblx0VmVjdG9yMlxufSBmcm9tICd0aHJlZSc7XG5cbi8qKlxuICogTlZJRElBIEZYQUEgYnkgVGltb3RoeSBMb3R0ZXNcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLmRvd25sb2FkLm52aWRpYS5jb20vYXNzZXRzL2dhbWVkZXYvZmlsZXMvc2RrLzExL0ZYQUFfV2hpdGVQYXBlci5wZGZcbiAqIC0gV2ViR0wgcG9ydCBieSBAc3VwZXJlZ2diZXJ0XG4gKiBodHRwOi8vd3d3LmdsZ2Uub3JnL2RlbW9zL2Z4YWEvXG4gKiBGdXJ0aGVyIGltcHJvdmVkIGJ5IERhbmllbCBTdHVya1xuICovXG5cbmNvbnN0IEZYQUFTaGFkZXIgPSB7XG5cblx0dW5pZm9ybXM6IHtcblxuXHRcdCd0RGlmZnVzZSc6IHsgdmFsdWU6IG51bGwgfSxcblx0XHQncmVzb2x1dGlvbic6IHsgdmFsdWU6IG5ldyBWZWN0b3IyKCAxIC8gMTAyNCwgMSAvIDUxMiApIH1cblxuXHR9LFxuXG5cdHZlcnRleFNoYWRlcjogLyogZ2xzbCAqL2BcblxuXHRcdHZhcnlpbmcgdmVjMiB2VXY7XG5cblx0XHR2b2lkIG1haW4oKSB7XG5cblx0XHRcdHZVdiA9IHV2O1xuXHRcdFx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xuXG5cdFx0fWAsXG5cblx0ZnJhZ21lbnRTaGFkZXI6IGBcblx0cHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuXG5cdHVuaWZvcm0gc2FtcGxlcjJEIHREaWZmdXNlO1xuXG5cdHVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO1xuXG5cdHZhcnlpbmcgdmVjMiB2VXY7XG5cblx0Ly8gRlhBQSAzLjExIGltcGxlbWVudGF0aW9uIGJ5IE5WSURJQSwgcG9ydGVkIHRvIFdlYkdMIGJ5IEFnb3N0IEJpcm8gKGJpcm9AYXJjaGlsb2dpYy5jb20pXG5cblx0Ly8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdC8vIEZpbGU6ICAgICAgICBlczMta2VwbGVyXFxGWEFBXFxhc3NldHNcXHNoYWRlcnMvRlhBQV9EZWZhdWx0RVMuZnJhZ1xuXHQvLyBTREsgVmVyc2lvbjogdjMuMDBcblx0Ly8gRW1haWw6ICAgICAgIGdhbWV3b3Jrc0BudmlkaWEuY29tXG5cdC8vIFNpdGU6ICAgICAgICBodHRwOi8vZGV2ZWxvcGVyLm52aWRpYS5jb20vXG5cdC8vXG5cdC8vIENvcHlyaWdodCAoYykgMjAxNC0yMDE1LCBOVklESUEgQ09SUE9SQVRJT04uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cdC8vXG5cdC8vIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuXHQvLyBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcblx0Ly8gYXJlIG1ldDpcblx0Ly8gICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcblx0Ly8gICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuXHQvLyAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuXHQvLyAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG5cdC8vICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cdC8vICAqIE5laXRoZXIgdGhlIG5hbWUgb2YgTlZJRElBIENPUlBPUkFUSU9OIG5vciB0aGUgbmFtZXMgb2YgaXRzXG5cdC8vICAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZFxuXHQvLyAgICBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG5cdC8vXG5cdC8vIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTICcnQVMgSVMnJyBBTkQgQU5ZXG5cdC8vIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG5cdC8vIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUlxuXHQvLyBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBPV05FUiBPUlxuXHQvLyBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCxcblx0Ly8gRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuXHQvLyBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1Jcblx0Ly8gUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWVxuXHQvLyBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcblx0Ly8gKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG5cdC8vIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG5cdC8vXG5cdC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdCNpZm5kZWYgRlhBQV9ESVNDQVJEXG5cdFx0XHQvL1xuXHRcdFx0Ly8gT25seSB2YWxpZCBmb3IgUEMgT3BlbkdMIGN1cnJlbnRseS5cblx0XHRcdC8vIFByb2JhYmx5IHdpbGwgbm90IHdvcmsgd2hlbiBGWEFBX0dSRUVOX0FTX0xVTUEgPSAxLlxuXHRcdFx0Ly9cblx0XHRcdC8vIDEgPSBVc2UgZGlzY2FyZCBvbiBwaXhlbHMgd2hpY2ggZG9uJ3QgbmVlZCBBQS5cblx0XHRcdC8vICAgICBGb3IgQVBJcyB3aGljaCBlbmFibGUgY29uY3VycmVudCBURVgrUk9QIGZyb20gc2FtZSBzdXJmYWNlLlxuXHRcdFx0Ly8gMCA9IFJldHVybiB1bmNoYW5nZWQgY29sb3Igb24gcGl4ZWxzIHdoaWNoIGRvbid0IG5lZWQgQUEuXG5cdFx0XHQvL1xuXHRcdFx0I2RlZmluZSBGWEFBX0RJU0NBUkQgMFxuXHQjZW5kaWZcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblx0I2RlZmluZSBGeGFhVGV4VG9wKHQsIHApIHRleHR1cmUyRCh0LCBwLCAtMTAwLjApXG5cdCNkZWZpbmUgRnhhYVRleE9mZih0LCBwLCBvLCByKSB0ZXh0dXJlMkQodCwgcCArIChvICogciksIC0xMDAuMClcblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0I2RlZmluZSBOVU1fU0FNUExFUyA1XG5cblx0Ly8gYXNzdW1lcyBjb2xvcnMgaGF2ZSBwcmVtdWx0aXBsaWVkQWxwaGEsIHNvIHRoYXQgdGhlIGNhbGN1bGF0ZWQgY29sb3IgY29udHJhc3QgaXMgc2NhbGVkIGJ5IGFscGhhXG5cdGZsb2F0IGNvbnRyYXN0KCB2ZWM0IGEsIHZlYzQgYiApIHtcblx0XHRcdHZlYzQgZGlmZiA9IGFicyggYSAtIGIgKTtcblx0XHRcdHJldHVybiBtYXgoIG1heCggbWF4KCBkaWZmLnIsIGRpZmYuZyApLCBkaWZmLmIgKSwgZGlmZi5hICk7XG5cdH1cblxuXHQvKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXHRcdFx0XHRcdFx0XHRcdFx0RlhBQTMgUVVBTElUWSAtIFBDXG5cblx0PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cdHZlYzQgRnhhYVBpeGVsU2hhZGVyKFxuXHRcdFx0dmVjMiBwb3NNLFxuXHRcdFx0c2FtcGxlcjJEIHRleCxcblx0XHRcdHZlYzIgZnhhYVF1YWxpdHlSY3BGcmFtZSxcblx0XHRcdGZsb2F0IGZ4YWFRdWFsaXR5RWRnZVRocmVzaG9sZCxcblx0XHRcdGZsb2F0IGZ4YWFRdWFsaXR5aW52RWRnZVRocmVzaG9sZFxuXHQpIHtcblx0XHRcdHZlYzQgcmdiYU0gPSBGeGFhVGV4VG9wKHRleCwgcG9zTSk7XG5cdFx0XHR2ZWM0IHJnYmFTID0gRnhhYVRleE9mZih0ZXgsIHBvc00sIHZlYzIoIDAuMCwgMS4wKSwgZnhhYVF1YWxpdHlSY3BGcmFtZS54eSk7XG5cdFx0XHR2ZWM0IHJnYmFFID0gRnhhYVRleE9mZih0ZXgsIHBvc00sIHZlYzIoIDEuMCwgMC4wKSwgZnhhYVF1YWxpdHlSY3BGcmFtZS54eSk7XG5cdFx0XHR2ZWM0IHJnYmFOID0gRnhhYVRleE9mZih0ZXgsIHBvc00sIHZlYzIoIDAuMCwtMS4wKSwgZnhhYVF1YWxpdHlSY3BGcmFtZS54eSk7XG5cdFx0XHR2ZWM0IHJnYmFXID0gRnhhYVRleE9mZih0ZXgsIHBvc00sIHZlYzIoLTEuMCwgMC4wKSwgZnhhYVF1YWxpdHlSY3BGcmFtZS54eSk7XG5cdFx0XHQvLyAuIFMgLlxuXHRcdFx0Ly8gVyBNIEVcblx0XHRcdC8vIC4gTiAuXG5cblx0XHRcdGJvb2wgZWFybHlFeGl0ID0gbWF4KCBtYXgoIG1heChcblx0XHRcdFx0XHRjb250cmFzdCggcmdiYU0sIHJnYmFOICksXG5cdFx0XHRcdFx0Y29udHJhc3QoIHJnYmFNLCByZ2JhUyApICksXG5cdFx0XHRcdFx0Y29udHJhc3QoIHJnYmFNLCByZ2JhRSApICksXG5cdFx0XHRcdFx0Y29udHJhc3QoIHJnYmFNLCByZ2JhVyApIClcblx0XHRcdFx0XHQ8IGZ4YWFRdWFsaXR5RWRnZVRocmVzaG9sZDtcblx0XHRcdC8vIC4gMCAuXG5cdFx0XHQvLyAwIDAgMFxuXHRcdFx0Ly8gLiAwIC5cblxuXHRcdFx0I2lmIChGWEFBX0RJU0NBUkQgPT0gMSlcblx0XHRcdFx0XHRpZihlYXJseUV4aXQpIEZ4YWFEaXNjYXJkO1xuXHRcdFx0I2Vsc2Vcblx0XHRcdFx0XHRpZihlYXJseUV4aXQpIHJldHVybiByZ2JhTTtcblx0XHRcdCNlbmRpZlxuXG5cdFx0XHRmbG9hdCBjb250cmFzdE4gPSBjb250cmFzdCggcmdiYU0sIHJnYmFOICk7XG5cdFx0XHRmbG9hdCBjb250cmFzdFMgPSBjb250cmFzdCggcmdiYU0sIHJnYmFTICk7XG5cdFx0XHRmbG9hdCBjb250cmFzdEUgPSBjb250cmFzdCggcmdiYU0sIHJnYmFFICk7XG5cdFx0XHRmbG9hdCBjb250cmFzdFcgPSBjb250cmFzdCggcmdiYU0sIHJnYmFXICk7XG5cblx0XHRcdGZsb2F0IHJlbGF0aXZlVkNvbnRyYXN0ID0gKCBjb250cmFzdE4gKyBjb250cmFzdFMgKSAtICggY29udHJhc3RFICsgY29udHJhc3RXICk7XG5cdFx0XHRyZWxhdGl2ZVZDb250cmFzdCAqPSBmeGFhUXVhbGl0eWludkVkZ2VUaHJlc2hvbGQ7XG5cblx0XHRcdGJvb2wgaG9yelNwYW4gPSByZWxhdGl2ZVZDb250cmFzdCA+IDAuO1xuXHRcdFx0Ly8gLiAxIC5cblx0XHRcdC8vIDAgMCAwXG5cdFx0XHQvLyAuIDEgLlxuXG5cdFx0XHQvLyA0NSBkZWcgZWRnZSBkZXRlY3Rpb24gYW5kIGNvcm5lcnMgb2Ygb2JqZWN0cywgYWthIFYvSCBjb250cmFzdCBpcyB0b28gc2ltaWxhclxuXHRcdFx0aWYoIGFicyggcmVsYXRpdmVWQ29udHJhc3QgKSA8IC4zICkge1xuXHRcdFx0XHRcdC8vIGxvY2F0ZSB0aGUgZWRnZVxuXHRcdFx0XHRcdHZlYzIgZGlyVG9FZGdlO1xuXHRcdFx0XHRcdGRpclRvRWRnZS54ID0gY29udHJhc3RFID4gY29udHJhc3RXID8gMS4gOiAtMS47XG5cdFx0XHRcdFx0ZGlyVG9FZGdlLnkgPSBjb250cmFzdFMgPiBjb250cmFzdE4gPyAxLiA6IC0xLjtcblx0XHRcdFx0XHQvLyAuIDIgLiAgICAgIC4gMSAuXG5cdFx0XHRcdFx0Ly8gMSAwIDIgIH49ICAwIDAgMVxuXHRcdFx0XHRcdC8vIC4gMSAuICAgICAgLiAwIC5cblxuXHRcdFx0XHRcdC8vIHRhcCAyIHBpeGVscyBhbmQgc2VlIHdoaWNoIG9uZXMgYXJlIFwib3V0c2lkZVwiIHRoZSBlZGdlLCB0b1xuXHRcdFx0XHRcdC8vIGRldGVybWluZSBpZiB0aGUgZWRnZSBpcyB2ZXJ0aWNhbCBvciBob3Jpem9udGFsXG5cblx0XHRcdFx0XHR2ZWM0IHJnYmFBbG9uZ0ggPSBGeGFhVGV4T2ZmKHRleCwgcG9zTSwgdmVjMiggZGlyVG9FZGdlLngsIC1kaXJUb0VkZ2UueSApLCBmeGFhUXVhbGl0eVJjcEZyYW1lLnh5KTtcblx0XHRcdFx0XHRmbG9hdCBtYXRjaEFsb25nSCA9IGNvbnRyYXN0KCByZ2JhTSwgcmdiYUFsb25nSCApO1xuXHRcdFx0XHRcdC8vIC4gMSAuXG5cdFx0XHRcdFx0Ly8gMCAwIDFcblx0XHRcdFx0XHQvLyAuIDAgSFxuXG5cdFx0XHRcdFx0dmVjNCByZ2JhQWxvbmdWID0gRnhhYVRleE9mZih0ZXgsIHBvc00sIHZlYzIoIC1kaXJUb0VkZ2UueCwgZGlyVG9FZGdlLnkgKSwgZnhhYVF1YWxpdHlSY3BGcmFtZS54eSk7XG5cdFx0XHRcdFx0ZmxvYXQgbWF0Y2hBbG9uZ1YgPSBjb250cmFzdCggcmdiYU0sIHJnYmFBbG9uZ1YgKTtcblx0XHRcdFx0XHQvLyBWIDEgLlxuXHRcdFx0XHRcdC8vIDAgMCAxXG5cdFx0XHRcdFx0Ly8gLiAwIC5cblxuXHRcdFx0XHRcdHJlbGF0aXZlVkNvbnRyYXN0ID0gbWF0Y2hBbG9uZ1YgLSBtYXRjaEFsb25nSDtcblx0XHRcdFx0XHRyZWxhdGl2ZVZDb250cmFzdCAqPSBmeGFhUXVhbGl0eWludkVkZ2VUaHJlc2hvbGQ7XG5cblx0XHRcdFx0XHRpZiggYWJzKCByZWxhdGl2ZVZDb250cmFzdCApIDwgLjMgKSB7IC8vIDQ1IGRlZyBlZGdlXG5cdFx0XHRcdFx0XHRcdC8vIDEgMSAuXG5cdFx0XHRcdFx0XHRcdC8vIDAgMCAxXG5cdFx0XHRcdFx0XHRcdC8vIC4gMCAxXG5cblx0XHRcdFx0XHRcdFx0Ly8gZG8gYSBzaW1wbGUgYmx1clxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbWl4KFxuXHRcdFx0XHRcdFx0XHRcdFx0cmdiYU0sXG5cdFx0XHRcdFx0XHRcdFx0XHQocmdiYU4gKyByZ2JhUyArIHJnYmFFICsgcmdiYVcpICogLjI1LFxuXHRcdFx0XHRcdFx0XHRcdFx0LjRcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRob3J6U3BhbiA9IHJlbGF0aXZlVkNvbnRyYXN0ID4gMC47XG5cdFx0XHR9XG5cblx0XHRcdGlmKCFob3J6U3BhbikgcmdiYU4gPSByZ2JhVztcblx0XHRcdGlmKCFob3J6U3BhbikgcmdiYVMgPSByZ2JhRTtcblx0XHRcdC8vIC4gMCAuICAgICAgMVxuXHRcdFx0Ly8gMSAwIDEgIC0+ICAwXG5cdFx0XHQvLyAuIDAgLiAgICAgIDFcblxuXHRcdFx0Ym9vbCBwYWlyTiA9IGNvbnRyYXN0KCByZ2JhTSwgcmdiYU4gKSA+IGNvbnRyYXN0KCByZ2JhTSwgcmdiYVMgKTtcblx0XHRcdGlmKCFwYWlyTikgcmdiYU4gPSByZ2JhUztcblxuXHRcdFx0dmVjMiBvZmZOUDtcblx0XHRcdG9mZk5QLnggPSAoIWhvcnpTcGFuKSA/IDAuMCA6IGZ4YWFRdWFsaXR5UmNwRnJhbWUueDtcblx0XHRcdG9mZk5QLnkgPSAoIGhvcnpTcGFuKSA/IDAuMCA6IGZ4YWFRdWFsaXR5UmNwRnJhbWUueTtcblxuXHRcdFx0Ym9vbCBkb25lTiA9IGZhbHNlO1xuXHRcdFx0Ym9vbCBkb25lUCA9IGZhbHNlO1xuXG5cdFx0XHRmbG9hdCBuRGlzdCA9IDAuO1xuXHRcdFx0ZmxvYXQgcERpc3QgPSAwLjtcblxuXHRcdFx0dmVjMiBwb3NOID0gcG9zTTtcblx0XHRcdHZlYzIgcG9zUCA9IHBvc007XG5cblx0XHRcdGludCBpdGVyYXRpb25zVXNlZCA9IDA7XG5cdFx0XHRpbnQgaXRlcmF0aW9uc1VzZWROID0gMDtcblx0XHRcdGludCBpdGVyYXRpb25zVXNlZFAgPSAwO1xuXHRcdFx0Zm9yKCBpbnQgaSA9IDA7IGkgPCBOVU1fU0FNUExFUzsgaSsrICkge1xuXHRcdFx0XHRcdGl0ZXJhdGlvbnNVc2VkID0gaTtcblxuXHRcdFx0XHRcdGZsb2F0IGluY3JlbWVudCA9IGZsb2F0KGkgKyAxKTtcblxuXHRcdFx0XHRcdGlmKCFkb25lTikge1xuXHRcdFx0XHRcdFx0XHRuRGlzdCArPSBpbmNyZW1lbnQ7XG5cdFx0XHRcdFx0XHRcdHBvc04gPSBwb3NNICsgb2ZmTlAgKiBuRGlzdDtcblx0XHRcdFx0XHRcdFx0dmVjNCByZ2JhRW5kTiA9IEZ4YWFUZXhUb3AodGV4LCBwb3NOLnh5KTtcblx0XHRcdFx0XHRcdFx0ZG9uZU4gPSBjb250cmFzdCggcmdiYUVuZE4sIHJnYmFNICkgPiBjb250cmFzdCggcmdiYUVuZE4sIHJnYmFOICk7XG5cdFx0XHRcdFx0XHRcdGl0ZXJhdGlvbnNVc2VkTiA9IGk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYoIWRvbmVQKSB7XG5cdFx0XHRcdFx0XHRcdHBEaXN0ICs9IGluY3JlbWVudDtcblx0XHRcdFx0XHRcdFx0cG9zUCA9IHBvc00gLSBvZmZOUCAqIHBEaXN0O1xuXHRcdFx0XHRcdFx0XHR2ZWM0IHJnYmFFbmRQID0gRnhhYVRleFRvcCh0ZXgsIHBvc1AueHkpO1xuXHRcdFx0XHRcdFx0XHRkb25lUCA9IGNvbnRyYXN0KCByZ2JhRW5kUCwgcmdiYU0gKSA+IGNvbnRyYXN0KCByZ2JhRW5kUCwgcmdiYU4gKTtcblx0XHRcdFx0XHRcdFx0aXRlcmF0aW9uc1VzZWRQID0gaTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZihkb25lTiB8fCBkb25lUCkgYnJlYWs7XG5cdFx0XHR9XG5cblxuXHRcdFx0aWYgKCAhZG9uZVAgJiYgIWRvbmVOICkgcmV0dXJuIHJnYmFNOyAvLyBmYWlsZWQgdG8gZmluZCBlbmQgb2YgZWRnZVxuXG5cdFx0XHRmbG9hdCBkaXN0ID0gbWluKFxuXHRcdFx0XHRcdGRvbmVOID8gZmxvYXQoIGl0ZXJhdGlvbnNVc2VkTiApIC8gZmxvYXQoIE5VTV9TQU1QTEVTIC0gMSApIDogMS4sXG5cdFx0XHRcdFx0ZG9uZVAgPyBmbG9hdCggaXRlcmF0aW9uc1VzZWRQICkgLyBmbG9hdCggTlVNX1NBTVBMRVMgLSAxICkgOiAxLlxuXHRcdFx0KTtcblxuXHRcdFx0Ly8gaGFja3kgd2F5IG9mIHJlZHVjZXMgYmx1cnJpbmVzcyBvZiBtb3N0bHkgZGlhZ29uYWwgZWRnZXNcblx0XHRcdC8vIGJ1dCByZWR1Y2VzIEFBIHF1YWxpdHlcblx0XHRcdGRpc3QgPSBwb3coZGlzdCwgLjUpO1xuXG5cdFx0XHRkaXN0ID0gMS4gLSBkaXN0O1xuXG5cdFx0XHRyZXR1cm4gbWl4KFxuXHRcdFx0XHRcdHJnYmFNLFxuXHRcdFx0XHRcdHJnYmFOLFxuXHRcdFx0XHRcdGRpc3QgKiAuNVxuXHRcdFx0KTtcblx0fVxuXG5cdHZvaWQgbWFpbigpIHtcblx0XHRcdGNvbnN0IGZsb2F0IGVkZ2VEZXRlY3Rpb25RdWFsaXR5ID0gLjI7XG5cdFx0XHRjb25zdCBmbG9hdCBpbnZFZGdlRGV0ZWN0aW9uUXVhbGl0eSA9IDEuIC8gZWRnZURldGVjdGlvblF1YWxpdHk7XG5cblx0XHRcdGdsX0ZyYWdDb2xvciA9IEZ4YWFQaXhlbFNoYWRlcihcblx0XHRcdFx0XHR2VXYsXG5cdFx0XHRcdFx0dERpZmZ1c2UsXG5cdFx0XHRcdFx0cmVzb2x1dGlvbixcblx0XHRcdFx0XHRlZGdlRGV0ZWN0aW9uUXVhbGl0eSwgLy8gWzAsMV0gY29udHJhc3QgbmVlZGVkLCBvdGhlcndpc2UgZWFybHkgZGlzY2FyZFxuXHRcdFx0XHRcdGludkVkZ2VEZXRlY3Rpb25RdWFsaXR5XG5cdFx0XHQpO1xuXG5cdH1cblx0YFxuXG59O1xuXG5leHBvcnQgeyBGWEFBU2hhZGVyIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/three/examples/jsm/shaders/FXAAShader.js\n"));

/***/ }),

/***/ "./node_modules/three/examples/jsm/shaders/FilmShader.js":
/*!***************************************************************!*\
  !*** ./node_modules/three/examples/jsm/shaders/FilmShader.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FilmShader: function() { return /* binding */ FilmShader; }\n/* harmony export */ });\nconst FilmShader = {\n\n\tname: 'FilmShader',\n\n\tuniforms: {\n\n\t\t'tDiffuse': { value: null },\n\t\t'time': { value: 0.0 },\n\t\t'intensity': { value: 0.5 },\n\t\t'grayscale': { value: false }\n\n\t},\n\n\tvertexShader: /* glsl */`\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\n\t\t#include <common>\n\n\t\tuniform float intensity;\n\t\tuniform bool grayscale;\n\t\tuniform float time;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 base = texture2D( tDiffuse, vUv );\n\n\t\t\tfloat noise = rand( vUv + time );\n\n\t\t\tvec3 color = base.rgb + base.rgb * clamp( 0.1 + noise, 0.0, 1.0 );\n\n\t\t\tcolor = mix( base.rgb, color, intensity );\n\n\t\t\tif ( grayscale ) {\n\n\t\t\t\tcolor = vec3( luminance( color ) ); // assuming linear-srgb\n\n\t\t\t}\n\n\t\t\tgl_FragColor = vec4( color, base.a );\n\n\t\t}`,\n\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGhyZWUvZXhhbXBsZXMvanNtL3NoYWRlcnMvRmlsbVNoYWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7O0FBRUE7O0FBRUE7O0FBRUEsZ0JBQWdCLGFBQWE7QUFDN0IsWUFBWSxZQUFZO0FBQ3hCLGlCQUFpQixZQUFZO0FBQzdCLGlCQUFpQjs7QUFFakIsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHdDQUF3Qzs7QUFFeEM7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSDs7QUFFc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RocmVlL2V4YW1wbGVzL2pzbS9zaGFkZXJzL0ZpbG1TaGFkZXIuanM/OTVhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBGaWxtU2hhZGVyID0ge1xuXG5cdG5hbWU6ICdGaWxtU2hhZGVyJyxcblxuXHR1bmlmb3Jtczoge1xuXG5cdFx0J3REaWZmdXNlJzogeyB2YWx1ZTogbnVsbCB9LFxuXHRcdCd0aW1lJzogeyB2YWx1ZTogMC4wIH0sXG5cdFx0J2ludGVuc2l0eSc6IHsgdmFsdWU6IDAuNSB9LFxuXHRcdCdncmF5c2NhbGUnOiB7IHZhbHVlOiBmYWxzZSB9XG5cblx0fSxcblxuXHR2ZXJ0ZXhTaGFkZXI6IC8qIGdsc2wgKi9gXG5cblx0XHR2YXJ5aW5nIHZlYzIgdlV2O1xuXG5cdFx0dm9pZCBtYWluKCkge1xuXG5cdFx0XHR2VXYgPSB1djtcblx0XHRcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcblxuXHRcdH1gLFxuXG5cdGZyYWdtZW50U2hhZGVyOiAvKiBnbHNsICovYFxuXG5cdFx0I2luY2x1ZGUgPGNvbW1vbj5cblxuXHRcdHVuaWZvcm0gZmxvYXQgaW50ZW5zaXR5O1xuXHRcdHVuaWZvcm0gYm9vbCBncmF5c2NhbGU7XG5cdFx0dW5pZm9ybSBmbG9hdCB0aW1lO1xuXG5cdFx0dW5pZm9ybSBzYW1wbGVyMkQgdERpZmZ1c2U7XG5cblx0XHR2YXJ5aW5nIHZlYzIgdlV2O1xuXG5cdFx0dm9pZCBtYWluKCkge1xuXG5cdFx0XHR2ZWM0IGJhc2UgPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2VXYgKTtcblxuXHRcdFx0ZmxvYXQgbm9pc2UgPSByYW5kKCB2VXYgKyB0aW1lICk7XG5cblx0XHRcdHZlYzMgY29sb3IgPSBiYXNlLnJnYiArIGJhc2UucmdiICogY2xhbXAoIDAuMSArIG5vaXNlLCAwLjAsIDEuMCApO1xuXG5cdFx0XHRjb2xvciA9IG1peCggYmFzZS5yZ2IsIGNvbG9yLCBpbnRlbnNpdHkgKTtcblxuXHRcdFx0aWYgKCBncmF5c2NhbGUgKSB7XG5cblx0XHRcdFx0Y29sb3IgPSB2ZWMzKCBsdW1pbmFuY2UoIGNvbG9yICkgKTsgLy8gYXNzdW1pbmcgbGluZWFyLXNyZ2JcblxuXHRcdFx0fVxuXG5cdFx0XHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBjb2xvciwgYmFzZS5hICk7XG5cblx0XHR9YCxcblxufTtcblxuZXhwb3J0IHsgRmlsbVNoYWRlciB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/three/examples/jsm/shaders/FilmShader.js\n"));

/***/ })

});