"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./components/Starfield.jsx":
/*!**********************************!*\
  !*** ./components/Starfield.jsx ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var three_examples_jsm_postprocessing_EffectComposer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three/examples/jsm/postprocessing/EffectComposer */ \"./node_modules/three/examples/jsm/postprocessing/EffectComposer.js\");\n/* harmony import */ var three_examples_jsm_postprocessing_UnrealBloomPass__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three/examples/jsm/postprocessing/UnrealBloomPass */ \"./node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js\");\n/* harmony import */ var three_examples_jsm_postprocessing_RenderPass__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three/examples/jsm/postprocessing/RenderPass */ \"./node_modules/three/examples/jsm/postprocessing/RenderPass.js\");\n/* harmony import */ var three_examples_jsm_postprocessing_FilmPass__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! three/examples/jsm/postprocessing/FilmPass */ \"./node_modules/three/examples/jsm/postprocessing/FilmPass.js\");\n/* harmony import */ var _ChromaticAberrationPass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ChromaticAberrationPass */ \"./components/ChromaticAberrationPass.js\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\n\nconst Starfield = ()=>{\n    _s();\n    const mountRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [cinematic, setCinematic] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [barsVisible, setBarsVisible] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Listen for focus mode toggle (example: press 'F' to toggle)\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const onKeyDown = (e)=>{\n            if (e.key === \"f\" || e.key === \"F\") {\n                setCinematic((c)=>!c);\n            }\n        };\n        window.addEventListener(\"keydown\", onKeyDown);\n        return ()=>window.removeEventListener(\"keydown\", onKeyDown);\n    }, []);\n    // Delay cinematic bars by 1s after cinematic state changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        let timeout;\n        if (cinematic) {\n            timeout = setTimeout(()=>setBarsVisible(true), 300);\n        } else {\n            setBarsVisible(false);\n        }\n        return ()=>clearTimeout(timeout);\n    }, [\n        cinematic\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // Defensive: always use .current for refs\n        if (!mountRef.current) return;\n        const mount = mountRef.current;\n        mount.style.position = \"fixed\";\n        mount.style.top = \"0\";\n        mount.style.left = \"0\";\n        mount.style.width = \"100%\";\n        mount.style.height = \"100%\";\n        mount.style.zIndex = \"0\";\n        // Scene & Renderer\n        const scene = new three__WEBPACK_IMPORTED_MODULE_3__.Scene();\n        const camera = new three__WEBPACK_IMPORTED_MODULE_3__.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);\n        camera.position.set(0, 0, 0);\n        // Virtual position to simulate infinite travel\n        let virtualCameraPos = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(0, 0, 0);\n        const renderer = new three__WEBPACK_IMPORTED_MODULE_3__.WebGLRenderer({\n            antialias: false\n        }) // We'll use FXAA instead\n        ;\n        renderer.setPixelRatio(window.devicePixelRatio);\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        renderer.setClearColor(0x000000, 1);\n        if (\"outputColorSpace\" in renderer) {\n            renderer.outputColorSpace = three__WEBPACK_IMPORTED_MODULE_3__.SRGBColorSpace;\n        }\n        // Create a render target for the composer with correct color space\n        const renderTarget = new three__WEBPACK_IMPORTED_MODULE_3__.WebGLRenderTarget(window.innerWidth, window.innerHeight, {\n            colorSpace: three__WEBPACK_IMPORTED_MODULE_3__.SRGBColorSpace,\n            type: three__WEBPACK_IMPORTED_MODULE_3__.UnsignedByteType\n        });\n        renderer.toneMapping = three__WEBPACK_IMPORTED_MODULE_3__.NoToneMapping;\n        renderer.autoClear = true;\n        mount.appendChild(renderer.domElement);\n        // --- MAIN STARFIELD POST-PROCESSING ---\n        const composer = new three_examples_jsm_postprocessing_EffectComposer__WEBPACK_IMPORTED_MODULE_4__.EffectComposer(renderer, renderTarget);\n        composer.setSize(window.innerWidth, window.innerHeight);\n        const renderPass = new three_examples_jsm_postprocessing_RenderPass__WEBPACK_IMPORTED_MODULE_5__.RenderPass(scene, camera);\n        renderPass.clear = true;\n        composer.addPass(renderPass);\n        // UnrealBloomPass: \"crazy\" bloom\n        const bloomPass = new three_examples_jsm_postprocessing_UnrealBloomPass__WEBPACK_IMPORTED_MODULE_6__.UnrealBloomPass(new three__WEBPACK_IMPORTED_MODULE_3__.Vector2(window.innerWidth, window.innerHeight), 1.5, 1.6, 0.01 // threshold\n        );\n        composer.addPass(bloomPass);\n        // FilmPass\n        const filmPass = new three_examples_jsm_postprocessing_FilmPass__WEBPACK_IMPORTED_MODULE_7__.FilmPass(0.0, 0.0, 648, false // grayscale\n        );\n        composer.addPass(filmPass);\n        // --- SHOOTING STAR POST-PROCESSING ONLY ---\n        // Separate scene and composer for shooting stars\n        const shootingStarScene = new three__WEBPACK_IMPORTED_MODULE_3__.Scene();\n        const shootingStarComposer = new three_examples_jsm_postprocessing_EffectComposer__WEBPACK_IMPORTED_MODULE_4__.EffectComposer(renderer);\n        shootingStarComposer.setSize(window.innerWidth, window.innerHeight);\n        const shootingStarRenderPass = new three_examples_jsm_postprocessing_RenderPass__WEBPACK_IMPORTED_MODULE_5__.RenderPass(shootingStarScene, camera);\n        shootingStarComposer.addPass(shootingStarRenderPass);\n        // Intense bloom for shooting stars\n        const shootingStarBloomPass = new three_examples_jsm_postprocessing_UnrealBloomPass__WEBPACK_IMPORTED_MODULE_6__.UnrealBloomPass(new three__WEBPACK_IMPORTED_MODULE_3__.Vector2(window.innerWidth, window.innerHeight), 4.0, 2.0, 0.0 // all bright\n        );\n        shootingStarComposer.addPass(shootingStarBloomPass);\n        // --- CLOSE STARS: Separate Scene for Chromatic Aberration ---\n        const closeStarsScene = new three__WEBPACK_IMPORTED_MODULE_3__.Scene();\n        const caPass = new _ChromaticAberrationPass__WEBPACK_IMPORTED_MODULE_2__.ChromaticAberrationPass(new three__WEBPACK_IMPORTED_MODULE_3__.Vector2(0.0002, 0.0002)); // barely visible\n        const caComposer = new three_examples_jsm_postprocessing_EffectComposer__WEBPACK_IMPORTED_MODULE_4__.EffectComposer(renderer);\n        caComposer.setSize(window.innerWidth, window.innerHeight);\n        const caRenderPass = new three_examples_jsm_postprocessing_RenderPass__WEBPACK_IMPORTED_MODULE_5__.RenderPass(closeStarsScene, camera);\n        caComposer.addPass(caRenderPass);\n        caComposer.addPass(caPass);\n        // --- HANDLE RESIZE AND FULLSCREEN ---\n        function resizeAll() {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n            // Main composer\n            composer.setSize(window.innerWidth, window.innerHeight);\n            // Other composers\n            shootingStarComposer.setSize(window.innerWidth, window.innerHeight);\n            caComposer.setSize(window.innerWidth, window.innerHeight);\n        }\n        window.addEventListener(\"resize\", resizeAll);\n        window.addEventListener(\"fullscreenchange\", resizeAll);\n        // Starfield\n        const starCount = 5000;\n        const starMaxDistance = 2000;\n        const starMinDistance = 1200 // minimum distance from camera\n        ;\n        const starSpeed = 1;\n        const geometry = new three__WEBPACK_IMPORTED_MODULE_3__.BufferGeometry();\n        const closeGeometry = new three__WEBPACK_IMPORTED_MODULE_3__.BufferGeometry();\n        const positions = [];\n        const closePositions = [];\n        const starAges = [];\n        const fadeDuration = 5.0; // seconds to fade in\n        // --- SPAWN CLOSE STARS AROUND CAMERA ---\n        const closeStarCount = 300;\n        for(let i = 0; i < closeStarCount; i++){\n            const theta = Math.random() * 2 * Math.PI;\n            const phi = Math.acos(2 * Math.random() - 1);\n            const r = 100 + Math.random() * 300; // 100 to 400 units from camera\n            const x = r * Math.sin(phi) * Math.cos(theta);\n            const y = r * Math.sin(phi) * Math.sin(theta);\n            const z = r * Math.cos(phi);\n            closePositions.push(x, y, z);\n        }\n        let starsPlaced = 0;\n        while(starsPlaced < starCount){\n            // With 1% chance, spawn a star cluster (10-30 stars)\n            if (Math.random() < 0.01 && starsPlaced < starCount - 10) {\n                const clusterTheta = Math.random() * 2 * Math.PI;\n                const clusterPhi = Math.acos(2 * Math.random() - 1);\n                const clusterR = starMinDistance + Math.random() * (starMaxDistance - starMinDistance);\n                const clusterCenter = [\n                    clusterR * Math.sin(clusterPhi) * Math.cos(clusterTheta),\n                    clusterR * Math.sin(clusterPhi) * Math.sin(clusterTheta),\n                    clusterR * Math.cos(clusterPhi)\n                ];\n                const clusterSize = 10 + Math.floor(Math.random() * 20); // 10-30 stars\n                for(let c = 0; c < clusterSize && starsPlaced < starCount; c++){\n                    // Each star in cluster is within 30 units of center\n                    const offsetTheta = Math.random() * 2 * Math.PI;\n                    const offsetPhi = Math.acos(2 * Math.random() - 1);\n                    const offsetR = Math.random() * 30; // cluster radius\n                    positions.push(clusterCenter[0] + offsetR * Math.sin(offsetPhi) * Math.cos(offsetTheta), clusterCenter[1] + offsetR * Math.sin(offsetPhi) * Math.sin(offsetTheta), clusterCenter[2] + offsetR * Math.cos(offsetPhi));\n                    starsPlaced++;\n                    starAges.push(0); // cluster stars spawn at age 0\n                }\n            } else {\n                // Normal single star\n                const theta = Math.random() * 2 * Math.PI;\n                const phi = Math.acos(2 * Math.random() - 1);\n                const r = starMinDistance + Math.random() * (starMaxDistance - starMinDistance);\n                const x = r * Math.sin(phi) * Math.cos(theta);\n                const y = r * Math.sin(phi) * Math.sin(theta);\n                const z = r * Math.cos(phi);\n                positions.push(x, y, z);\n                starAges.push(0); // new star starts faded out\n                // If close, also add to closePositions\n                if (r < 400) {\n                    closePositions.push(x, y, z);\n                }\n                starsPlaced++;\n            }\n        }\n        geometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_3__.Float32BufferAttribute(positions, 3));\n        // Add alpha attribute for per-star fade-in\n        const alphas = new Float32Array(starAges.length).fill(0);\n        geometry.setAttribute(\"alpha\", new three__WEBPACK_IMPORTED_MODULE_3__.BufferAttribute(alphas, 1));\n        if (closePositions.length > 0) {\n            closeGeometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_3__.Float32BufferAttribute(closePositions, 3));\n        }\n        // CRAZY BLOOM: All stars are extremely bright (color intensity >1)\n        const palette = [\n            [\n                1.0,\n                0.5,\n                0.5\n            ],\n            [\n                1.0,\n                0.75,\n                0.4\n            ],\n            [\n                1.0,\n                1.0,\n                0.9\n            ],\n            [\n                1.0,\n                1.0,\n                1.0\n            ],\n            [\n                0.4,\n                0.5,\n                1.0\n            ]\n        ];\n        const colors = [];\n        for(let i = 0; i < starCount; i++){\n            const c = palette[Math.floor(Math.random() * palette.length)];\n            colors.push(...c);\n        }\n        geometry.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_3__.Float32BufferAttribute(colors, 3));\n        const originalColors = geometry.attributes.color.array.slice();\n        const timers = new Float32Array(starCount);\n        const sparkColors = new Float32Array(starCount * 3);\n        const sparkleDuration = 180;\n        // --- SQUARE STARS USING POINTS ---\n        const material = new three__WEBPACK_IMPORTED_MODULE_3__.PointsMaterial({\n            size: 10,\n            sizeAttenuation: true,\n            vertexColors: true,\n            transparent: true\n        });\n        // Custom shader to use per-vertex alpha\n        material.onBeforeCompile = (shader)=>{\n            shader.vertexShader = shader.vertexShader.replace(\"void main() {\", \"attribute float alpha; varying float vAlpha; void main() { vAlpha = alpha;\");\n            shader.fragmentShader = shader.fragmentShader.replace(\"void main() {\", \"varying float vAlpha; void main() {\").replace(\"gl_FragColor = vec4( outgoingLight, diffuseColor.a );\", \"gl_FragColor = vec4( outgoingLight, diffuseColor.a * vAlpha );\");\n        };\n        const stars = new three__WEBPACK_IMPORTED_MODULE_3__.Points(geometry, material);\n        scene.add(stars);\n        // Add glow sprites to each star and animate them based on distance\n        const glowMap = new three__WEBPACK_IMPORTED_MODULE_3__.TextureLoader().load(\"/glow.png\");\n        const glowSprites = [];\n        const glowMaterial = new three__WEBPACK_IMPORTED_MODULE_3__.SpriteMaterial({\n            map: glowMap,\n            color: 0xffffff,\n            opacity: 0.55,\n            blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending,\n            depthWrite: false,\n            transparent: true\n        });\n        for(let i = 0; i < starCount; i++){\n            const glow = new three__WEBPACK_IMPORTED_MODULE_3__.Sprite(glowMaterial.clone());\n            glow.position.set(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2]);\n            glow.scale.set(32, 32, 1); // much larger aura\n            scene.add(glow);\n            glowSprites.push(glow);\n        }\n        // Add close stars to separate scene\n        let closeStars;\n        if (closePositions.length > 0) {\n            closeStars = new three__WEBPACK_IMPORTED_MODULE_3__.Points(closeGeometry, material.clone());\n            closeStarsScene.add(closeStars);\n        }\n        let targetY = 0;\n        const damping = 0.05;\n        const onScroll = ()=>{\n            const pct = window.scrollY / (document.body.scrollHeight - window.innerHeight);\n            targetY = pct * Math.PI * 2;\n        };\n        window.addEventListener(\"scroll\", onScroll);\n        // --- Shooting Stars ---\n        const tailLength = 32; // Increase for longer tails\n        const shootingStars = [];\n        let shootingStarCooldown = 0;\n        // Spawn a shooting star with a stunning glowing tail\n        function spawnShootingStar() {\n            // Pick a random direction on the sphere for the spawn location\n            const dir = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();\n            // Ensure shooting stars never spawn close to the camera (at least 70% of max distance)\n            const minDist = starMaxDistance * 0.7;\n            const maxDist = starMaxDistance * 1.0;\n            const dist = minDist + Math.random() * (maxDist - minDist);\n            const spawnPos = dir.clone().multiplyScalar(dist);\n            // Tangential velocity: perpendicular to dir\n            let tangent = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1);\n            tangent = tangent.sub(tangent.clone().projectOnVector(dir)).normalize();\n            // Mix in a small radial component (inward or outward)\n            const tangentialSpeed = starSpeed * (2.5 + Math.random() * 2.5); // much faster\n            const radialSpeed = starSpeed * (Math.random() - 0.5) * 0.3; // more dramatic\n            const velocity = tangent.multiplyScalar(tangentialSpeed).add(dir.clone().multiplyScalar(radialSpeed));\n            // Stunning color gradient for the head\n            const vibrantColors = [\n                0xffe066,\n                0xff66cc,\n                0x66ccff,\n                0xffffff,\n                0x80ffea,\n                0xfff2cc,\n                0xffc080,\n                0x80c0ff,\n                0xff80b3\n            ];\n            const color = vibrantColors[Math.floor(Math.random() * vibrantColors.length)];\n            // Star brightness and size (always small and subtle)\n            const brightness = 2.5 + Math.random() * 1.5;\n            const geo = new three__WEBPACK_IMPORTED_MODULE_3__.SphereGeometry(0.7 + Math.random() * 0.5, 16, 16); // Small sphere\n            const mat = new three__WEBPACK_IMPORTED_MODULE_3__.MeshPhysicalMaterial({\n                color: color,\n                emissive: color,\n                emissiveIntensity: 14.0,\n                metalness: 0.7,\n                roughness: 0.3,\n                transmission: 0.7,\n                opacity: 0.98,\n                transparent: true,\n                clearcoat: 0.8,\n                clearcoatRoughness: 0.2\n            });\n            const star = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(geo, mat);\n            // Add a large, intense bloom sprite for extra bloom\n            const spriteMap = new three__WEBPACK_IMPORTED_MODULE_3__.TextureLoader().load(\"/glow.png\");\n            const spriteMaterial = new three__WEBPACK_IMPORTED_MODULE_3__.SpriteMaterial({\n                map: spriteMap,\n                color: 0xffffff,\n                opacity: 1.0,\n                blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n            });\n            const sprite = new three__WEBPACK_IMPORTED_MODULE_3__.Sprite(spriteMaterial);\n            sprite.scale.set(70, 70, 1); // Large for bloom\n            sprite.position.copy(star.position);\n            star.add(sprite);\n            // Add a colored sprite for color pop\n            const colorSpriteMaterial = new three__WEBPACK_IMPORTED_MODULE_3__.SpriteMaterial({\n                map: spriteMap,\n                color: color,\n                opacity: 0.6,\n                blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n            });\n            const colorSprite = new three__WEBPACK_IMPORTED_MODULE_3__.Sprite(colorSpriteMaterial);\n            colorSprite.scale.set(34, 34, 1);\n            colorSprite.position.copy(star.position);\n            star.add(colorSprite);\n            // Add to both main scene and shootingStarScene\n            scene.add(star);\n            shootingStarScene.add(star);\n            // Add dynamic spark burst at the head\n            const sparkCount = 18 + Math.floor(Math.random() * 8);\n            const sparkGroup = new three__WEBPACK_IMPORTED_MODULE_3__.Group();\n            for(let i = 0; i < sparkCount; i++){\n                const sparkMat = new three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial({\n                    color: vibrantColors[Math.floor(Math.random() * vibrantColors.length)],\n                    transparent: true,\n                    opacity: 0.8\n                });\n                const sparkGeo = new three__WEBPACK_IMPORTED_MODULE_3__.SphereGeometry(0.07 + Math.random() * 0.06, 8, 8);\n                const spark = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(sparkGeo, sparkMat);\n                const angle = i / sparkCount * Math.PI * 2;\n                spark.position.set(Math.cos(angle) * 1.2, Math.sin(angle) * 1.2, Math.random() * 0.4 - 0.2);\n                sparkGroup.add(spark);\n            }\n            sparkGroup.name = \"sparkBurst\";\n            star.add(sparkGroup);\n            star.position.copy(spawnPos);\n            star.velocity = velocity;\n            star.normalizedLife = 0.0;\n            star.normalizedLifetime = 80 + Math.random() * 80; // Longer, more dramatic\n            star.age = 0;\n            // --- Stunning Meteor Tail (very long, multi-color, glowing, fading, and 3D curve) ---\n            const trailSegments = tailLength * 3;\n            const trailPoints = [];\n            for(let i = 0; i < trailSegments; i++){\n                // Add a 3D spiral/curve for more depth\n                const spiral = Math.sin(i * 0.25) * 8;\n                const curve = Math.cos(i * 0.15) * 4;\n                const pt = star.position.clone().add(new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(spiral, curve, -i * 3));\n                trailPoints.push(pt);\n            }\n            const tailGeo = new three__WEBPACK_IMPORTED_MODULE_3__.BufferGeometry().setFromPoints(trailPoints);\n            // Per-vertex color (multi-color rainbow gradient)\n            const tailColors = [];\n            for(let i = 0; i < trailSegments; i++){\n                // Alpha fades out along the tail\n                const alpha = (1 - i / (trailSegments - 1)) * 0.99;\n                // Rainbow gradient\n                const rainbow = [\n                    0xffe066,\n                    0xff66cc,\n                    0x66ccff,\n                    0xffffff,\n                    0x80ffea,\n                    0xfff2cc,\n                    0xffc080,\n                    0x80c0ff,\n                    0xff80b3\n                ];\n                const gradColor = rainbow[Math.floor(i / trailSegments * rainbow.length)];\n                tailColors.push((gradColor >> 16 & 255) / 255, (gradColor >> 8 & 255) / 255, (gradColor & 255) / 255, alpha);\n            }\n            tailGeo.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_3__.Float32BufferAttribute(tailColors, 4));\n            // Additive blending for glow + BLOOMED TAIL\n            const tailMat = new three__WEBPACK_IMPORTED_MODULE_3__.LineBasicMaterial({\n                vertexColors: true,\n                transparent: true,\n                opacity: 1.0,\n                blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n            });\n            // --- TAILS ---\n            // 1. Crisp tail for main scene\n            const tailMatMain = new three__WEBPACK_IMPORTED_MODULE_3__.LineBasicMaterial({\n                vertexColors: true,\n                transparent: true,\n                opacity: 1.0,\n                blending: three__WEBPACK_IMPORTED_MODULE_3__.NormalBlending\n            });\n            const tailMain = new three__WEBPACK_IMPORTED_MODULE_3__.Line(tailGeo.clone(), tailMatMain);\n            tailMain.position.copy(star.position);\n            scene.add(tailMain);\n            // 2. Intense bloom tail for shootingStarScene\n            const tailMatBloom = new three__WEBPACK_IMPORTED_MODULE_3__.LineBasicMaterial({\n                vertexColors: true,\n                transparent: true,\n                opacity: 1.0,\n                blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n            });\n            const tailBloom = new three__WEBPACK_IMPORTED_MODULE_3__.Line(tailGeo, tailMatBloom);\n            tailBloom.position.copy(star.position);\n            // Add a bloom sprite to the tail's head for extra glow\n            const tailGlowMap = new three__WEBPACK_IMPORTED_MODULE_3__.TextureLoader().load(\"/glow.png\");\n            const tailGlowMat = new three__WEBPACK_IMPORTED_MODULE_3__.SpriteMaterial({\n                map: tailGlowMap,\n                color: 0xffffff,\n                opacity: 0.88,\n                blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n            });\n            const tailGlow = new three__WEBPACK_IMPORTED_MODULE_3__.Sprite(tailGlowMat);\n            tailGlow.scale.set(50, 50, 1); // Larger for more bloom\n            tailGlow.position.copy(star.position);\n            tailBloom.add(tailGlow);\n            shootingStarScene.add(tailBloom);\n            // Add star to both scenes\n            scene.add(star);\n            shootingStarScene.add(star);\n            shootingStars.push({\n                mesh: star,\n                tail: tailMain,\n                tailBloom,\n                velocity: star.velocity,\n                dir,\n                age: 0,\n                normalizedLifetime: star.normalizedLifetime,\n                trailPoints,\n                color,\n                brightness,\n                hasFragmented: false\n            });\n        }\n        // Create an animation ID reference for cleanup\n        let animationId;\n        const animate = ()=>{\n            // Store the animation ID for cleanup\n            animationId = requestAnimationFrame(animate);\n            // Update star positions relative to virtual camera\n            for(let i = 0; i < positions.length; i += 3){\n                geometry.attributes.position.array[i] = positions[i] - virtualCameraPos.x;\n                geometry.attributes.position.array[i + 1] = positions[i + 1] - virtualCameraPos.y;\n                geometry.attributes.position.array[i + 2] = positions[i + 2] - virtualCameraPos.z;\n            }\n            geometry.attributes.position.needsUpdate = true;\n            // Fade-in logic for stars\n            let needsAlphaUpdate = false;\n            for(let i = 0; i < starAges.length; i++){\n                if (starAges[i] < fadeDuration) {\n                    starAges[i] += 1 / 60; // assuming ~60fps, or use deltaTime if available\n                    geometry.attributes.alpha.array[i] = Math.min(1, starAges[i] / fadeDuration);\n                    needsAlphaUpdate = true;\n                }\n            }\n            if (needsAlphaUpdate) geometry.attributes.alpha.needsUpdate = true;\n            // Update glow sprite positions\n            for(let i = 0; i < glowSprites.length; i++){\n                const idx = i * 3;\n                glowSprites[i].position.set(positions[idx] - virtualCameraPos.x, positions[idx + 1] - virtualCameraPos.y, positions[idx + 2] - virtualCameraPos.z);\n            }\n            // --- POST-PROCESSING PIPELINE ---\n            // --- POST-PROCESSING PIPELINE ---\n            composer.render(); // Only RenderPass enabled for debugging\n            // (bloom, FXAA, FilmPass are NOT added)\n            // shootingStarComposer, caComposer remain disabled for now\n            camera.rotation.y += (targetY - camera.rotation.y) * damping;\n            // Move the virtual camera position in the direction the camera is facing\n            const forward = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();\n            camera.getWorldDirection(forward);\n            virtualCameraPos.add(forward.multiplyScalar(starSpeed));\n            // Intense color (oversaturated, brightened) -- must be inside the for loop over stars\n            const colorAttr = geometry.attributes.color;\n            for(let i = 0; i < positions.length; i += 3){\n                const origR = colorAttr.array[i];\n                const origG = colorAttr.array[i + 1];\n                const origB = colorAttr.array[i + 2];\n                const dist = Math.sqrt(Math.pow(positions[i] - virtualCameraPos.x, 2) + Math.pow(positions[i + 1] - virtualCameraPos.y, 2) + Math.pow(positions[i + 2] - virtualCameraPos.z, 2));\n                const intenseR = Math.min(origR * 2.5, 1.0), intenseG = Math.min(origG * 2.5, 1.0), intenseB = Math.min(origB * 2.5, 1.0);\n                // Fade factor: 0 = close, 1 = far\n                let fadeT = (dist - 200) / (starMaxDistance * 0.9 - 200);\n                fadeT = Math.max(0, Math.min(1, fadeT));\n                // Ease for smoothness\n                fadeT = Math.pow(fadeT, 1.5);\n                // Lerp between original and intense color\n                colorAttr.array[i] = origR * (1 - fadeT) + intenseR * fadeT;\n                colorAttr.array[i + 1] = origG * (1 - fadeT) + intenseG * fadeT;\n                colorAttr.array[i + 2] = origB * (1 - fadeT) + intenseB * fadeT;\n            }\n            colorAttr.needsUpdate = true;\n            // If you have glow logic per-star, move that inside the loop as well, or handle after\n            if (closeStars && closeGeometry && closePositions.length > 0) {\n                for(let i = 0; i < closePositions.length; i += 3){\n                    closeGeometry.attributes.position.array[i] = closePositions[i] - virtualCameraPos.x;\n                    closeGeometry.attributes.position.array[i + 1] = closePositions[i + 1] - virtualCameraPos.y;\n                    closeGeometry.attributes.position.array[i + 2] = closePositions[i + 2] - virtualCameraPos.z;\n                }\n                closeGeometry.attributes.position.needsUpdate = true;\n            }\n            geometry.attributes.position.needsUpdate = true;\n            // Update shooting star cooldown\n            if (shootingStarCooldown <= 0 && Math.random() < 0.02) {\n                spawnShootingStar();\n                shootingStarCooldown = 30 + Math.random() * 60;\n            } else if (shootingStarCooldown > 0) {\n                shootingStarCooldown--;\n            }\n            // --- Shooting star spawning ---\n            if (shootingStarCooldown <= 0 && Math.random() < 0.1) {\n                spawnShootingStar();\n                if (camera) {\n                    const shakeStrength = 0.06 + Math.random() * 0.04;\n                    camera.position.x += (Math.random() - 0.5) * shakeStrength;\n                    camera.position.y += (Math.random() - 0.5) * shakeStrength;\n                }\n                shootingStarCooldown = 10 + Math.random() * 10;\n            } else if (shootingStarCooldown > 0) {\n                shootingStarCooldown--;\n            }\n            // Animate and clean up shooting stars\n            for(let i = shootingStars.length - 1; i >= 0; i--){\n                const obj = shootingStars[i];\n                // Animate spark burst (fade and expand)\n                if (obj.mesh.children) {\n                    const sparks = obj.mesh.children.find((child)=>child.name === \"sparkBurst\");\n                    if (sparks) {\n                        for(let j = 0; j < sparks.children.length; j++){\n                            const spark = sparks.children[j];\n                            spark.material.opacity *= 0.96; // Fade\n                            spark.scale.multiplyScalar(1.03); // Expand\n                        }\n                    }\n                }\n                // Animate tail shimmer and color cycling\n                if (obj.tail && obj.trailPoints) {\n                    const time = performance.now() * 0.001;\n                    const tailGeo = obj.tail.geometry;\n                    const tailColors = tailGeo.getAttribute(\"color\");\n                    for(let k = 0; k < tailColors.count; k++){\n                        // Cycle hue\n                        let r = tailColors.getX(k), g = tailColors.getY(k), b = tailColors.getZ(k);\n                        // Convert to HSL\n                        const max = Math.max(r, g, b), min = Math.min(r, g, b);\n                        let h, s, l;\n                        l = (max + min) / 2;\n                        if (max === min) {\n                            h = s = 0;\n                        } else {\n                            const d = max - min;\n                            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n                            switch(max){\n                                case r:\n                                    h = (g - b) / d + (g < b ? 6 : 0);\n                                    break;\n                                case g:\n                                    h = (b - r) / d + 2;\n                                    break;\n                                case b:\n                                    h = (r - g) / d + 4;\n                                    break;\n                            }\n                            h /= 6;\n                        }\n                        h = (h + 0.25 * Math.sin(time + k * 0.2)) % 1.0; // Animate hue\n                        // Convert back to RGB\n                        let q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n                        let p = 2 * l - q;\n                        let tr = h + 1 / 3, tg = h, tb = h - 1 / 3;\n                        const hue2rgb = (p, q, t)=>{\n                            if (t < 0) t += 1;\n                            if (t > 1) t -= 1;\n                            if (t < 1 / 6) return p + (q - p) * 6 * t;\n                            if (t < 1 / 2) return q;\n                            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n                            return p;\n                        };\n                        tailColors.setX(k, hue2rgb(p, q, tr));\n                        tailColors.setY(k, hue2rgb(p, q, tg));\n                        tailColors.setZ(k, hue2rgb(p, q, tb));\n                        // Shimmer: modulate alpha\n                        tailColors.setW(k, tailColors.getW(k) * (0.97 + 0.03 * Math.sin(time * 8 + k)));\n                    }\n                    tailColors.needsUpdate = true;\n                }\n                // Straight-line trajectory\n                obj.mesh.position.add(obj.velocity);\n                obj.tail.position.copy(obj.mesh.position);\n                if (obj.tailBloom) obj.tailBloom.position.copy(obj.mesh.position);\n                // Animate tail (no lerp, just drag)\n                // COMPLETE MESS VERY HACKY FIX LATER OR DONT?????\n                obj.age++;\n                const normalizedLife = obj.age / obj.normalizedLifetime;\n                obj.trailPoints.unshift(obj.mesh.position.clone());\n                if (obj.trailPoints.length > tailLength * 3) obj.trailPoints.pop();\n                let tailGrow = Math.min(1, normalizedLife / 0.3);\n                let activeSegments = Math.floor(obj.trailPoints.length * tailGrow);\n                if (activeSegments < 2) activeSegments = 2;\n                const visibleTrail = obj.trailPoints.slice(0, activeSegments);\n                obj.tail.geometry.setFromPoints(visibleTrail);\n                if (obj.tailBloom) obj.tailBloom.geometry.setFromPoints(visibleTrail);\n                const tailColors = obj.tail.geometry.getAttribute(\"color\");\n                let tailColorsBloom = obj.tailBloom ? obj.tailBloom.geometry.getAttribute(\"color\") : null;\n                for(let j = 0; j < visibleTrail.length; j++){\n                    let alpha = (1 - j / (visibleTrail.length - 1)) * 0.95;\n                    alpha *= 0.92 + 0.08 * Math.sin(Date.now() * 0.015 + j * 0.5);\n                    let rainbow = [\n                        0xffc080,\n                        0xffe080,\n                        0xffff80,\n                        0x80ffe6,\n                        0x80c0ff,\n                        0xc080ff\n                    ];\n                    let gradColor = rainbow[j % rainbow.length];\n                    if (normalizedLife > 0.7) alpha *= Math.max(0, 1 - (normalizedLife - 0.7 - 0.2) / 0.3);\n                    tailColors.setXYZW(j, (gradColor >> 16 & 255) / 255, (gradColor >> 8 & 255) / 255, (gradColor & 255) / 255, alpha);\n                    if (tailColorsBloom) tailColorsBloom.setXYZW(j, (gradColor >> 16 & 255) / 255, (gradColor >> 8 & 255) / 255, (gradColor & 255) / 255, alpha);\n                }\n                tailColors.needsUpdate = true;\n                // Animate head\n                let headColor;\n                if (normalizedLife < 0.5) {\n                    headColor = new three__WEBPACK_IMPORTED_MODULE_3__.Color(obj.color).lerp(new three__WEBPACK_IMPORTED_MODULE_3__.Color(0xffc080), normalizedLife * 2);\n                } else {\n                    headColor = new three__WEBPACK_IMPORTED_MODULE_3__.Color(0xffc080).lerp(new three__WEBPACK_IMPORTED_MODULE_3__.Color(0xff4000), (normalizedLife - 0.5) * 2);\n                }\n                let flicker = 0.95 + 0.13 * Math.sin(Date.now() * 0.07 + Math.random() * 10);\n                headColor.multiplyScalar(flicker);\n                obj.mesh.material.color.copy(headColor);\n                let scale = 1 + 2.2 * Math.sin(Math.PI * normalizedLife);\n                let distToCam = obj.mesh.position.length();\n                let dofBlur = distToCam < starMaxDistance * 0.7 ? 0.7 : 1.0;\n                obj.mesh.scale.set(scale * dofBlur, scale * dofBlur, scale * dofBlur);\n                // Sparkle burst\n                if (normalizedLife >= 1 && !obj.hasFragmented) {\n                    // --- SPECTACULAR EXPLOSION (very rare) ---\n                    const spectacular = Math.random() < 0.02; // 2% chance\n                    const burstCount = spectacular ? 120 + Math.floor(Math.random() * 60) : 18 + Math.floor(Math.random() * 8);\n                    const palette = spectacular ? [\n                        0xffe066,\n                        0xff66cc,\n                        0x66ccff,\n                        0xffffff,\n                        0x80ffea,\n                        0xfff2cc,\n                        0xffc080,\n                        0x80c0ff,\n                        0xff80b3,\n                        0xff0000,\n                        0x00ff00,\n                        0x0000ff,\n                        0xffff00,\n                        0x00ffff,\n                        0xff00ff,\n                        0xff8800,\n                        0x00ff88,\n                        0x8800ff\n                    ] : [\n                        0xffffff,\n                        0xfff6c0,\n                        0xffe066,\n                        0xffc080,\n                        0x80c0ff\n                    ];\n                    for(let s = 0; s < burstCount; s++){\n                        const color = palette[Math.floor(Math.random() * palette.length)];\n                        const size = spectacular ? 1.2 + Math.random() * 2.2 : 0.7 + Math.random() * 0.8;\n                        const sparkleGeo = new three__WEBPACK_IMPORTED_MODULE_3__.SphereGeometry(size, 8, 8);\n                        const sparkleMat = new three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial({\n                            color,\n                            transparent: true,\n                            opacity: spectacular ? 0.92 : 0.7,\n                            blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n                        });\n                        const sparkle = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(sparkleGeo, sparkleMat);\n                        sparkle.position.copy(obj.mesh.position);\n                        // Spectacular: huge, fast, random directions; normal: moderate\n                        const spd = spectacular ? 4 + Math.random() * 8 : 2 + Math.random() * 2;\n                        const sparkleVel = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize().multiplyScalar(spd);\n                        sparkle.userData = {\n                            velocity: sparkleVel,\n                            age: 0,\n                            spectacular,\n                            maxAge: spectacular ? 80 + Math.random() * 40 : 40 + Math.random() * 20\n                        }; // <-- LONGER LIFE\n                        scene.add(sparkle);\n                        if (!window._sparkles) window._sparkles = [];\n                        window._sparkles.push(sparkle);\n                    }\n                    if (spectacular) {\n                        // Add a big flash\n                        const flashGeo = new three__WEBPACK_IMPORTED_MODULE_3__.SphereGeometry(6, 24, 24);\n                        const flashMat = new three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial({\n                            color: 0xffffff,\n                            transparent: true,\n                            opacity: 0.8,\n                            blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n                        });\n                        const flash = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(flashGeo, flashMat);\n                        flash.position.copy(obj.mesh.position);\n                        scene.add(flash);\n                        if (!window._starFlashes) window._starFlashes = [];\n                        window._starFlashes.push({\n                            mesh: flash,\n                            age: 0\n                        });\n                    }\n                    // Fragmented trail logic (keep as before)\n                    const fragVel = obj.velocity.clone().applyAxisAngle(new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(0, 1, 0), (Math.random() - 0.5) * 0.3);\n                    const fragStar = obj.mesh.clone();\n                    fragStar.position.copy(obj.mesh.position);\n                    fragStar.velocity = fragVel;\n                    fragStar.normalizedLife = normalizedLife;\n                    fragStar.normalizedLifetime = obj.normalizedLifetime * (0.5 + Math.random() * 0.5);\n                    fragStar.age = obj.age;\n                    fragStar.material = obj.mesh.material.clone();\n                    const fragTrailPoints = obj.trailPoints.slice();\n                    const fragTailGeo = new three__WEBPACK_IMPORTED_MODULE_3__.BufferGeometry().setFromPoints(fragTrailPoints);\n                    fragTailGeo.setAttribute(\"color\", obj.tail.geometry.getAttribute(\"color\").clone());\n                    const fragTailMat = obj.tail.material.clone();\n                    const fragTail = new three__WEBPACK_IMPORTED_MODULE_3__.Line(fragTailGeo, fragTailMat);\n                    fragTail.position.copy(fragStar.position);\n                    scene.add(fragStar);\n                    scene.add(fragTail);\n                    shootingStars.push({\n                        mesh: fragStar,\n                        tail: fragTail,\n                        velocity: fragStar.velocity,\n                        dir: obj.dir,\n                        age: fragStar.age,\n                        normalizedLifetime: fragStar.normalizedLifetime,\n                        trailPoints: fragTrailPoints,\n                        color: obj.color,\n                        brightness: obj.brightness,\n                        hasFragmented: true\n                    });\n                    obj.hasFragmented = true;\n                }\n                // Spark burst\n                if (!obj.hasSparked && normalizedLife > 0.95 && Math.random() < 0.1) {\n                    for(let s = 0; s < 8 + Math.floor(Math.random() * 8); s++){\n                        const sparkGeo = new three__WEBPACK_IMPORTED_MODULE_3__.SphereGeometry(0.5 + Math.random() * 0.5, 8, 8);\n                        const sparkMat = new three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial({\n                            color: 0xfff6c0,\n                            transparent: true,\n                            opacity: 1,\n                            blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n                        });\n                        const spark = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(sparkGeo, sparkMat);\n                        spark.position.copy(obj.mesh.position);\n                        spark.sparkVel = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize().multiplyScalar(0.5 + Math.random() * 1.2);\n                        spark.sparkLife = 12 + Math.random() * 10;\n                        spark.sparkAge = 0;\n                        scene.add(spark);\n                        if (!window._starSparks) window._starSparks = [];\n                        window._starSparks.push(spark);\n                    }\n                    obj.hasSparked = true;\n                }\n                // Flash\n                if (!obj.hasFlashed && normalizedLife > 0.98 && Math.random() < 0.2) {\n                    const flashGeo = new three__WEBPACK_IMPORTED_MODULE_3__.SphereGeometry(1, 16, 16);\n                    const flashMat = new three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial({\n                        color: 0xffffee,\n                        transparent: true,\n                        opacity: 0.8,\n                        blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n                    });\n                    const flash = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(flashGeo, flashMat);\n                    flash.position.copy(obj.mesh.position);\n                    scene.add(flash);\n                    if (!window._starFlashes) window._starFlashes = [];\n                    window._starFlashes.push({\n                        mesh: flash,\n                        age: 0\n                    });\n                    obj.hasFlashed = true;\n                }\n                // Fade out as it gets far away\n                const dist = obj.mesh.position.distanceTo(camera.position);\n                const fadeStart = starMaxDistance * 0.5;\n                if (dist > fadeStart) {\n                    const fade = 1 - (dist - fadeStart) / (starMaxDistance - fadeStart);\n                    obj.mesh.material.opacity = Math.max(0, fade);\n                    obj.mesh.material.transparent = true;\n                    obj.tail.material.opacity = Math.max(0, fade * 0.8);\n                    obj.tail.material.transparent = true;\n                }\n                // Remove when out of bounds or fully faded or life ended\n                // Fade tail after explosion\n                if ((normalizedLife >= 1.0 || dist > starMaxDistance || obj.mesh.material.opacity <= 0.01) && !obj.tailFading) {\n                    scene.remove(obj.mesh);\n                    // Start tail fade-out ghost\n                    obj.tailFading = true;\n                    obj.tailFadeAge = 0;\n                    if (!window._fadingTails) window._fadingTails = [];\n                    window._fadingTails.push({\n                        tail: obj.tail,\n                        tailBloom: obj.tailBloom,\n                        age: 0\n                    });\n                    shootingStars.splice(i, 1);\n                }\n            }\n            // Animate sparks\n            if (window._starSparks) {\n                for(let i = window._starSparks.length - 1; i >= 0; i--){\n                    const spark = window._starSparks[i];\n                    spark.position.add(spark.sparkVel);\n                    spark.sparkAge++;\n                    spark.material.opacity *= 0.92;\n                    if (spark.sparkAge > spark.sparkLife) {\n                        scene.remove(spark);\n                        window._starSparks.splice(i, 1);\n                    }\n                }\n            }\n            // Animate explosion particles (sparkles)\n            if (window._sparkles) {\n                for(let i = window._sparkles.length - 1; i >= 0; i--){\n                    const sparkle = window._sparkles[i];\n                    sparkle.position.add(sparkle.userData.velocity);\n                    sparkle.userData.age++;\n                    sparkle.material.opacity *= 0.97;\n                    if (sparkle.userData.age > (sparkle.userData.maxAge || 40)) {\n                        scene.remove(sparkle);\n                        window._sparkles.splice(i, 1);\n                    }\n                }\n            }\n            // Animate fading tails (ghosts)\n            if (window._fadingTails) {\n                for(let i = window._fadingTails.length - 1; i >= 0; i--){\n                    const ghost = window._fadingTails[i];\n                    if (ghost.tail) {\n                        ghost.tail.material.opacity *= 0.92;\n                        if (ghost.tail.material.opacity < 0.01) {\n                            scene.remove(ghost.tail);\n                            window._fadingTails.splice(i, 1);\n                            continue;\n                        }\n                    }\n                    if (ghost.tailBloom) {\n                        ghost.tailBloom.material.opacity *= 0.92;\n                        if (ghost.tailBloom.material.opacity < 0.01) {\n                            shootingStarScene.remove(ghost.tailBloom);\n                            ghost.tailBloom = null;\n                        }\n                    }\n                    ghost.age++;\n                }\n            }\n            // Animate flashes\n            if (window._starFlashes) {\n                for(let i = window._starFlashes.length - 1; i >= 0; i--){\n                    const flash = window._starFlashes[i];\n                    flash.mesh.scale.multiplyScalar(1.15);\n                    flash.mesh.material.opacity *= 0.85;\n                    flash.age++;\n                    if (flash.age > 10) {\n                        scene.remove(flash.mesh);\n                        window._starFlashes.splice(i, 1);\n                    }\n                }\n            }\n            // --- Starfield logic ---\n            const sqDist = starMaxDistance * starMaxDistance;\n            for(let i = 0; i < positions.length; i += 3){\n                const dx = positions[i] - virtualCameraPos.x;\n                const dy = positions[i + 1] - virtualCameraPos.y;\n                const dz = positions[i + 2] - virtualCameraPos.z;\n                if (dx * dx + dy * dy + dz * dz > sqDist) {\n                    // Place in a thick spherical shell around the virtual camera, never too close\n                    const minRadius = starMaxDistance * 0.8;\n                    const maxRadius = starMaxDistance;\n                    const r = minRadius + Math.random() * (maxRadius - minRadius);\n                    const theta = Math.random() * 2 * Math.PI;\n                    const phi = Math.acos(2 * Math.random() - 1);\n                    positions[i] = virtualCameraPos.x + r * Math.sin(phi) * Math.cos(theta);\n                    positions[i + 1] = virtualCameraPos.y + r * Math.sin(phi) * Math.sin(theta);\n                    positions[i + 2] = virtualCameraPos.z + r * Math.cos(phi);\n                }\n            }\n            // geometry.attributes.position.needsUpdate = true; // Already set above\n            // Robust starfield color update to prevent stuck white dots\n            // This works NO TOUCHY\n            const colArr = geometry.attributes.color.array;\n            for(let i = 0; i < positions.length; i += 3){\n                const idx = i / 3;\n                const dx = positions[i] - virtualCameraPos.x;\n                const dy = positions[i + 1] - virtualCameraPos.y;\n                const dz = positions[i + 2] - virtualCameraPos.z;\n                const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);\n                if (timers[idx] > 0) {\n                    timers[idx]--;\n                    if (timers[idx] === 0) {\n                        // Timer expired, restore color\n                        sparkColors[i] = originalColors[i];\n                        sparkColors[i + 1] = originalColors[i + 1];\n                        sparkColors[i + 2] = originalColors[i + 2];\n                        colArr[i] = originalColors[i];\n                        colArr[i + 1] = originalColors[i + 1];\n                        colArr[i + 2] = originalColors[i + 2];\n                    } else {\n                        colArr[i] = sparkColors[i];\n                        colArr[i + 1] = sparkColors[i + 1];\n                        colArr[i + 2] = sparkColors[i + 2];\n                    }\n                } else if (dist > starMaxDistance * 0.3 && Math.random() < 0.05) {\n                    timers[idx] = sparkleDuration;\n                    const c = palette[Math.floor(Math.random() * palette.length)];\n                    sparkColors[i] = c[0];\n                    sparkColors[i + 1] = c[1];\n                    sparkColors[i + 2] = c[2];\n                    colArr[i] = sparkColors[i];\n                    colArr[i + 1] = sparkColors[i + 1];\n                    colArr[i + 2] = sparkColors[i + 2];\n                } else {\n                    sparkColors[i] = originalColors[i];\n                    sparkColors[i + 1] = originalColors[i + 1];\n                    sparkColors[i + 2] = originalColors[i + 2];\n                    colArr[i] = originalColors[i];\n                    colArr[i + 1] = originalColors[i + 1];\n                    colArr[i + 2] = originalColors[i + 2];\n                }\n            }\n            geometry.attributes.color.needsUpdate = true;\n        };\n        // Start the animation loop\n        animate();\n        // Handle window resize\n        const onResize = ()=>{\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n            shootingStarComposer.setSize(window.innerWidth, window.innerHeight);\n            caComposer.setSize(window.innerWidth, window.innerHeight);\n        };\n        // Add event listener for resize\n        window.addEventListener(\"resize\", onResize);\n        // Clean up function\n        return ()=>{\n            window.removeEventListener(\"resize\", onResize);\n            window.removeEventListener(\"resize\", resizeAll);\n            window.removeEventListener(\"fullscreenchange\", resizeAll);\n            window.removeEventListener(\"scroll\", onScroll);\n            // Cancel the animation frame using the stored ID\n            if (animationId) {\n                cancelAnimationFrame(animationId);\n            }\n        // Dispose composers, renderer, etc. (rest of your cleanup)\n        };\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                ref: mountRef,\n                style: {\n                    width: \"100vw\",\n                    height: \"100vh\",\n                    position: \"fixed\",\n                    top: 0,\n                    left: 0,\n                    zIndex: 0\n                }\n            }, void 0, false, {\n                fileName: \"/home/kayosdev/Websites/Portfolio/components/Starfield.jsx\",\n                lineNumber: 859,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    position: \"fixed\",\n                    left: 0,\n                    top: 0,\n                    width: \"100vw\",\n                    height: \"10vh\",\n                    background: \"black\",\n                    zIndex: 10,\n                    opacity: barsVisible ? 0.95 : 0,\n                    transform: barsVisible ? \"translateY(0)\" : \"translateY(-100%)\",\n                    transition: \"transform 0.3s cubic-bezier(0.77,0,0.175,1), opacity 0.3s\",\n                    pointerEvents: \"none\"\n                }\n            }, void 0, false, {\n                fileName: \"/home/kayosdev/Websites/Portfolio/components/Starfield.jsx\",\n                lineNumber: 860,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    position: \"fixed\",\n                    left: 0,\n                    bottom: 0,\n                    width: \"100vw\",\n                    height: \"10vh\",\n                    background: \"black\",\n                    zIndex: 10,\n                    opacity: barsVisible ? 0.95 : 0,\n                    transform: barsVisible ? \"translateY(0)\" : \"translateY(100%)\",\n                    transition: \"transform 0.3s cubic-bezier(0.77,0,0.175,1), opacity 0.3s\",\n                    pointerEvents: \"none\"\n                }\n            }, void 0, false, {\n                fileName: \"/home/kayosdev/Websites/Portfolio/components/Starfield.jsx\",\n                lineNumber: 867,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true);\n};\n_s(Starfield, \"WVetDqXOZBVy8petTmsK+ULb8v0=\");\n_c = Starfield;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Starfield);\nvar _c;\n$RefreshReg$(_c, \"Starfield\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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cG9uZW50cy9TdGFyZmllbGQuanN4P2YxYTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCB7IEVmZmVjdENvbXBvc2VyIH0gZnJvbSAndGhyZWUvZXhhbXBsZXMvanNtL3Bvc3Rwcm9jZXNzaW5nL0VmZmVjdENvbXBvc2VyJztcbmltcG9ydCB7IFVucmVhbEJsb29tUGFzcyB9IGZyb20gJ3RocmVlL2V4YW1wbGVzL2pzbS9wb3N0cHJvY2Vzc2luZy9VbnJlYWxCbG9vbVBhc3MnO1xuaW1wb3J0IHsgUmVuZGVyUGFzcyB9IGZyb20gJ3RocmVlL2V4YW1wbGVzL2pzbS9wb3N0cHJvY2Vzc2luZy9SZW5kZXJQYXNzJztcbmltcG9ydCB7IFNoYWRlclBhc3MgfSBmcm9tICd0aHJlZS9leGFtcGxlcy9qc20vcG9zdHByb2Nlc3NpbmcvU2hhZGVyUGFzcyc7XG5pbXBvcnQgeyBGWEFBU2hhZGVyIH0gZnJvbSAndGhyZWUvZXhhbXBsZXMvanNtL3NoYWRlcnMvRlhBQVNoYWRlcic7XG5pbXBvcnQgeyBGaWxtUGFzcyB9IGZyb20gJ3RocmVlL2V4YW1wbGVzL2pzbS9wb3N0cHJvY2Vzc2luZy9GaWxtUGFzcyc7XG5pbXBvcnQgeyBDaHJvbWF0aWNBYmVycmF0aW9uUGFzcyB9IGZyb20gJy4vQ2hyb21hdGljQWJlcnJhdGlvblBhc3MnO1xuXG5jb25zdCBTdGFyZmllbGQgPSAoKSA9PiB7XG4gIGNvbnN0IG1vdW50UmVmID0gdXNlUmVmKG51bGwpXG4gIGNvbnN0IFtjaW5lbWF0aWMsIHNldENpbmVtYXRpY10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtiYXJzVmlzaWJsZSwgc2V0QmFyc1Zpc2libGVdID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gIC8vIExpc3RlbiBmb3IgZm9jdXMgbW9kZSB0b2dnbGUgKGV4YW1wbGU6IHByZXNzICdGJyB0byB0b2dnbGUpXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qgb25LZXlEb3duID0gKGUpID0+IHtcbiAgICAgIGlmIChlLmtleSA9PT0gJ2YnIHx8IGUua2V5ID09PSAnRicpIHtcbiAgICAgICAgc2V0Q2luZW1hdGljKGMgPT4gIWMpO1xuICAgICAgfVxuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBvbktleURvd24pO1xuICAgIHJldHVybiAoKSA9PiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIG9uS2V5RG93bik7XG4gIH0sIFtdKTtcblxuICAvLyBEZWxheSBjaW5lbWF0aWMgYmFycyBieSAxcyBhZnRlciBjaW5lbWF0aWMgc3RhdGUgY2hhbmdlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCB0aW1lb3V0O1xuICAgIGlmIChjaW5lbWF0aWMpIHtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHNldEJhcnNWaXNpYmxlKHRydWUpLCAzMDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRCYXJzVmlzaWJsZShmYWxzZSk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gIH0sIFtjaW5lbWF0aWNdKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIERlZmVuc2l2ZTogYWx3YXlzIHVzZSAuY3VycmVudCBmb3IgcmVmc1xuICAgIGlmICghbW91bnRSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgIGNvbnN0IG1vdW50ID0gbW91bnRSZWYuY3VycmVudFxuICAgIG1vdW50LnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJ1xuICAgIG1vdW50LnN0eWxlLnRvcCA9ICcwJ1xuICAgIG1vdW50LnN0eWxlLmxlZnQgPSAnMCdcbiAgICBtb3VudC5zdHlsZS53aWR0aCA9ICcxMDAlJ1xuICAgIG1vdW50LnN0eWxlLmhlaWdodCA9ICcxMDAlJ1xuICAgIG1vdW50LnN0eWxlLnpJbmRleCA9ICcwJ1xuXG4gICAgLy8gU2NlbmUgJiBSZW5kZXJlclxuICAgIGNvbnN0IHNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKClcbiAgICBjb25zdCBjYW1lcmEgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoNzUsIHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmlubmVySGVpZ2h0LCAwLjEsIDUwMDApXG4gICAgY2FtZXJhLnBvc2l0aW9uLnNldCgwLCAwLCAwKTtcbiAgICAvLyBWaXJ0dWFsIHBvc2l0aW9uIHRvIHNpbXVsYXRlIGluZmluaXRlIHRyYXZlbFxuICAgIGxldCB2aXJ0dWFsQ2FtZXJhUG9zID0gbmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMCk7XG4gICAgY29uc3QgcmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcih7IGFudGlhbGlhczogZmFsc2UgfSkgLy8gV2UnbGwgdXNlIEZYQUEgaW5zdGVhZFxuICAgIHJlbmRlcmVyLnNldFBpeGVsUmF0aW8od2luZG93LmRldmljZVBpeGVsUmF0aW8pXG4gICAgcmVuZGVyZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KVxuICAgIHJlbmRlcmVyLnNldENsZWFyQ29sb3IoMHgwMDAwMDAsIDEpO1xuICAgIGlmICgnb3V0cHV0Q29sb3JTcGFjZScgaW4gcmVuZGVyZXIpIHtcbiAgICAgIHJlbmRlcmVyLm91dHB1dENvbG9yU3BhY2UgPSBUSFJFRS5TUkdCQ29sb3JTcGFjZTtcbiAgICB9XG4gICAgLy8gQ3JlYXRlIGEgcmVuZGVyIHRhcmdldCBmb3IgdGhlIGNvbXBvc2VyIHdpdGggY29ycmVjdCBjb2xvciBzcGFjZVxuICAgIGNvbnN0IHJlbmRlclRhcmdldCA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlclRhcmdldCh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0LCB7XG4gICAgICBjb2xvclNwYWNlOiBUSFJFRS5TUkdCQ29sb3JTcGFjZSxcbiAgICAgIHR5cGU6IFRIUkVFLlVuc2lnbmVkQnl0ZVR5cGVcbiAgICB9KTtcbiAgICByZW5kZXJlci50b25lTWFwcGluZyA9IFRIUkVFLk5vVG9uZU1hcHBpbmc7XG4gICAgcmVuZGVyZXIuYXV0b0NsZWFyID0gdHJ1ZTtcbiAgICBtb3VudC5hcHBlbmRDaGlsZChyZW5kZXJlci5kb21FbGVtZW50KVxuXG4gICAgLy8gLS0tIE1BSU4gU1RBUkZJRUxEIFBPU1QtUFJPQ0VTU0lORyAtLS1cbiAgICBjb25zdCBjb21wb3NlciA9IG5ldyBFZmZlY3RDb21wb3NlcihyZW5kZXJlciwgcmVuZGVyVGFyZ2V0KTtcbiAgICBjb21wb3Nlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIGNvbnN0IHJlbmRlclBhc3MgPSBuZXcgUmVuZGVyUGFzcyhzY2VuZSwgY2FtZXJhKTtcbiAgICByZW5kZXJQYXNzLmNsZWFyID0gdHJ1ZTtcbiAgICBjb21wb3Nlci5hZGRQYXNzKHJlbmRlclBhc3MpO1xuICAgIC8vIFVucmVhbEJsb29tUGFzczogXCJjcmF6eVwiIGJsb29tXG4gICAgY29uc3QgYmxvb21QYXNzID0gbmV3IFVucmVhbEJsb29tUGFzcyhcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpLFxuICAgICAgMS41LCAvLyBpbnRlbnNpdHkgKGxlc3MgdGhhbiBiZWZvcmUpXG4gICAgICAxLjYsIC8vIHJhZGl1c1xuICAgICAgMC4wMSAvLyB0aHJlc2hvbGRcbiAgICApO1xuICAgIGNvbXBvc2VyLmFkZFBhc3MoYmxvb21QYXNzKTtcblxuICAgIC8vIEZpbG1QYXNzXG4gICAgY29uc3QgZmlsbVBhc3MgPSBuZXcgRmlsbVBhc3MoXG4gICAgICAwLjAsIC8vIG5vaXNlIGludGVuc2l0eSAod2FzIDAuNylcbiAgICAgIDAuMCwgLy8gc2NhbmxpbmUgaW50ZW5zaXR5ICh3YXMgMC4wOClcbiAgICAgIDY0OCwgLy8gc2NhbmxpbmUgY291bnRcbiAgICAgIGZhbHNlIC8vIGdyYXlzY2FsZVxuICAgICk7XG4gICAgY29tcG9zZXIuYWRkUGFzcyhmaWxtUGFzcyk7XG5cbiAgICBcbiAgICAvLyAtLS0gU0hPT1RJTkcgU1RBUiBQT1NULVBST0NFU1NJTkcgT05MWSAtLS1cbiAgICAvLyBTZXBhcmF0ZSBzY2VuZSBhbmQgY29tcG9zZXIgZm9yIHNob290aW5nIHN0YXJzXG4gICAgY29uc3Qgc2hvb3RpbmdTdGFyU2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcbiAgICBjb25zdCBzaG9vdGluZ1N0YXJDb21wb3NlciA9IG5ldyBFZmZlY3RDb21wb3NlcihyZW5kZXJlcik7XG4gICAgc2hvb3RpbmdTdGFyQ29tcG9zZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICBjb25zdCBzaG9vdGluZ1N0YXJSZW5kZXJQYXNzID0gbmV3IFJlbmRlclBhc3Moc2hvb3RpbmdTdGFyU2NlbmUsIGNhbWVyYSk7XG4gICAgc2hvb3RpbmdTdGFyQ29tcG9zZXIuYWRkUGFzcyhzaG9vdGluZ1N0YXJSZW5kZXJQYXNzKTtcbiAgICAvLyBJbnRlbnNlIGJsb29tIGZvciBzaG9vdGluZyBzdGFyc1xuICAgIGNvbnN0IHNob290aW5nU3RhckJsb29tUGFzcyA9IG5ldyBVbnJlYWxCbG9vbVBhc3MoXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMih3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KSxcbiAgICAgIDQuMCwgLy8gc3Ryb25nXG4gICAgICAyLjAsIC8vIHdpZGVcbiAgICAgIDAuMCAvLyBhbGwgYnJpZ2h0XG4gICAgKTtcbiAgICBzaG9vdGluZ1N0YXJDb21wb3Nlci5hZGRQYXNzKHNob290aW5nU3RhckJsb29tUGFzcyk7XG5cbiAgICAvLyAtLS0gQ0xPU0UgU1RBUlM6IFNlcGFyYXRlIFNjZW5lIGZvciBDaHJvbWF0aWMgQWJlcnJhdGlvbiAtLS1cbiAgICBjb25zdCBjbG9zZVN0YXJzU2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcbiAgICBjb25zdCBjYVBhc3MgPSBuZXcgQ2hyb21hdGljQWJlcnJhdGlvblBhc3MobmV3IFRIUkVFLlZlY3RvcjIoMC4wMDAyLCAwLjAwMDIpKTsgLy8gYmFyZWx5IHZpc2libGVcbiAgICBjb25zdCBjYUNvbXBvc2VyID0gbmV3IEVmZmVjdENvbXBvc2VyKHJlbmRlcmVyKTtcbiAgICBjYUNvbXBvc2VyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgY29uc3QgY2FSZW5kZXJQYXNzID0gbmV3IFJlbmRlclBhc3MoY2xvc2VTdGFyc1NjZW5lLCBjYW1lcmEpO1xuICAgIGNhQ29tcG9zZXIuYWRkUGFzcyhjYVJlbmRlclBhc3MpO1xuICAgIGNhQ29tcG9zZXIuYWRkUGFzcyhjYVBhc3MpO1xuXG4gICAgLy8gLS0tIEhBTkRMRSBSRVNJWkUgQU5EIEZVTExTQ1JFRU4gLS0tXG4gICAgZnVuY3Rpb24gcmVzaXplQWxsKCkge1xuICAgICAgY2FtZXJhLmFzcGVjdCA9IHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAgIHJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG5cbiAgICAgIC8vIE1haW4gY29tcG9zZXJcbiAgICAgIGNvbXBvc2VyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgICAvLyBPdGhlciBjb21wb3NlcnNcbiAgICAgIHNob290aW5nU3RhckNvbXBvc2VyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgICBjYUNvbXBvc2VyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgfVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCByZXNpemVBbGwpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdmdWxsc2NyZWVuY2hhbmdlJywgcmVzaXplQWxsKTtcblxuICAgIC8vIFN0YXJmaWVsZFxuICAgIGNvbnN0IHN0YXJDb3VudCA9IDUwMDBcbiAgICBjb25zdCBzdGFyTWF4RGlzdGFuY2UgPSAyMDAwXG4gICAgY29uc3Qgc3Rhck1pbkRpc3RhbmNlID0gMTIwMCAvLyBtaW5pbXVtIGRpc3RhbmNlIGZyb20gY2FtZXJhXG4gICAgY29uc3Qgc3RhclNwZWVkID0gMVxuICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KClcbiAgICBjb25zdCBjbG9zZUdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XG4gICAgY29uc3QgcG9zaXRpb25zID0gW107XG4gICAgY29uc3QgY2xvc2VQb3NpdGlvbnMgPSBbXTtcbiAgICBjb25zdCBzdGFyQWdlcyA9IFtdO1xuICAgIGNvbnN0IGZhZGVEdXJhdGlvbiA9IDUuMDsgLy8gc2Vjb25kcyB0byBmYWRlIGluXG5cbiAgICAvLyAtLS0gU1BBV04gQ0xPU0UgU1RBUlMgQVJPVU5EIENBTUVSQSAtLS1cbiAgICBjb25zdCBjbG9zZVN0YXJDb3VudCA9IDMwMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsb3NlU3RhckNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHRoZXRhID0gTWF0aC5yYW5kb20oKSAqIDIgKiBNYXRoLlBJO1xuICAgICAgY29uc3QgcGhpID0gTWF0aC5hY29zKDIgKiBNYXRoLnJhbmRvbSgpIC0gMSk7XG4gICAgICBjb25zdCByID0gMTAwICsgTWF0aC5yYW5kb20oKSAqIDMwMDsgLy8gMTAwIHRvIDQwMCB1bml0cyBmcm9tIGNhbWVyYVxuICAgICAgY29uc3QgeCA9IHIgKiBNYXRoLnNpbihwaGkpICogTWF0aC5jb3ModGhldGEpO1xuICAgICAgY29uc3QgeSA9IHIgKiBNYXRoLnNpbihwaGkpICogTWF0aC5zaW4odGhldGEpO1xuICAgICAgY29uc3QgeiA9IHIgKiBNYXRoLmNvcyhwaGkpO1xuICAgICAgY2xvc2VQb3NpdGlvbnMucHVzaCh4LCB5LCB6KTtcbiAgICB9XG5cbiAgICBsZXQgc3RhcnNQbGFjZWQgPSAwO1xuICAgIHdoaWxlIChzdGFyc1BsYWNlZCA8IHN0YXJDb3VudCkge1xuICAgICAgLy8gV2l0aCAxJSBjaGFuY2UsIHNwYXduIGEgc3RhciBjbHVzdGVyICgxMC0zMCBzdGFycylcbiAgICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgMC4wMSAmJiBzdGFyc1BsYWNlZCA8IHN0YXJDb3VudCAtIDEwKSB7XG4gICAgICAgIGNvbnN0IGNsdXN0ZXJUaGV0YSA9IE1hdGgucmFuZG9tKCkgKiAyICogTWF0aC5QSTtcbiAgICAgICAgY29uc3QgY2x1c3RlclBoaSA9IE1hdGguYWNvcygyICogTWF0aC5yYW5kb20oKSAtIDEpO1xuICAgICAgICBjb25zdCBjbHVzdGVyUiA9IHN0YXJNaW5EaXN0YW5jZSArIE1hdGgucmFuZG9tKCkgKiAoc3Rhck1heERpc3RhbmNlIC0gc3Rhck1pbkRpc3RhbmNlKTtcbiAgICAgICAgY29uc3QgY2x1c3RlckNlbnRlciA9IFtcbiAgICAgICAgICBjbHVzdGVyUiAqIE1hdGguc2luKGNsdXN0ZXJQaGkpICogTWF0aC5jb3MoY2x1c3RlclRoZXRhKSxcbiAgICAgICAgICBjbHVzdGVyUiAqIE1hdGguc2luKGNsdXN0ZXJQaGkpICogTWF0aC5zaW4oY2x1c3RlclRoZXRhKSxcbiAgICAgICAgICBjbHVzdGVyUiAqIE1hdGguY29zKGNsdXN0ZXJQaGkpXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGNsdXN0ZXJTaXplID0gMTAgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyMCk7IC8vIDEwLTMwIHN0YXJzXG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgY2x1c3RlclNpemUgJiYgc3RhcnNQbGFjZWQgPCBzdGFyQ291bnQ7IGMrKykge1xuICAgICAgICAgIC8vIEVhY2ggc3RhciBpbiBjbHVzdGVyIGlzIHdpdGhpbiAzMCB1bml0cyBvZiBjZW50ZXJcbiAgICAgICAgICBjb25zdCBvZmZzZXRUaGV0YSA9IE1hdGgucmFuZG9tKCkgKiAyICogTWF0aC5QSTtcbiAgICAgICAgICBjb25zdCBvZmZzZXRQaGkgPSBNYXRoLmFjb3MoMiAqIE1hdGgucmFuZG9tKCkgLSAxKTtcbiAgICAgICAgICBjb25zdCBvZmZzZXRSID0gTWF0aC5yYW5kb20oKSAqIDMwOyAvLyBjbHVzdGVyIHJhZGl1c1xuICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKFxuICAgICAgICAgICAgY2x1c3RlckNlbnRlclswXSArIG9mZnNldFIgKiBNYXRoLnNpbihvZmZzZXRQaGkpICogTWF0aC5jb3Mob2Zmc2V0VGhldGEpLFxuICAgICAgICAgICAgY2x1c3RlckNlbnRlclsxXSArIG9mZnNldFIgKiBNYXRoLnNpbihvZmZzZXRQaGkpICogTWF0aC5zaW4ob2Zmc2V0VGhldGEpLFxuICAgICAgICAgICAgY2x1c3RlckNlbnRlclsyXSArIG9mZnNldFIgKiBNYXRoLmNvcyhvZmZzZXRQaGkpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzdGFyc1BsYWNlZCsrO1xuICAgICAgICAgIHN0YXJBZ2VzLnB1c2goMCk7IC8vIGNsdXN0ZXIgc3RhcnMgc3Bhd24gYXQgYWdlIDBcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm9ybWFsIHNpbmdsZSBzdGFyXG4gICAgICAgIGNvbnN0IHRoZXRhID0gTWF0aC5yYW5kb20oKSAqIDIgKiBNYXRoLlBJO1xuICAgICAgICBjb25zdCBwaGkgPSBNYXRoLmFjb3MoMiAqIE1hdGgucmFuZG9tKCkgLSAxKTtcbiAgICAgICAgY29uc3QgciA9IHN0YXJNaW5EaXN0YW5jZSArIE1hdGgucmFuZG9tKCkgKiAoc3Rhck1heERpc3RhbmNlIC0gc3Rhck1pbkRpc3RhbmNlKTtcbiAgICAgICAgY29uc3QgeCA9IHIgKiBNYXRoLnNpbihwaGkpICogTWF0aC5jb3ModGhldGEpO1xuICAgICAgICBjb25zdCB5ID0gciAqIE1hdGguc2luKHBoaSkgKiBNYXRoLnNpbih0aGV0YSk7XG4gICAgICAgIGNvbnN0IHogPSByICogTWF0aC5jb3MocGhpKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goeCwgeSwgeik7XG4gICAgICAgIHN0YXJBZ2VzLnB1c2goMCk7IC8vIG5ldyBzdGFyIHN0YXJ0cyBmYWRlZCBvdXRcbiAgICAgICAgLy8gSWYgY2xvc2UsIGFsc28gYWRkIHRvIGNsb3NlUG9zaXRpb25zXG4gICAgICAgIGlmIChyIDwgNDAwKSB7XG4gICAgICAgICAgY2xvc2VQb3NpdGlvbnMucHVzaCh4LCB5LCB6KTtcbiAgICAgICAgfVxuICAgICAgICBzdGFyc1BsYWNlZCsrO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25zLCAzKSlcbiAgICAvLyBBZGQgYWxwaGEgYXR0cmlidXRlIGZvciBwZXItc3RhciBmYWRlLWluXG4gICAgY29uc3QgYWxwaGFzID0gbmV3IEZsb2F0MzJBcnJheShzdGFyQWdlcy5sZW5ndGgpLmZpbGwoMCk7XG4gICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdhbHBoYScsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoYWxwaGFzLCAxKSk7XG4gICAgaWYgKGNsb3NlUG9zaXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIGNsb3NlR2VvbWV0cnkuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBUSFJFRS5GbG9hdDMyQnVmZmVyQXR0cmlidXRlKGNsb3NlUG9zaXRpb25zLCAzKSk7XG4gICAgfVxuXG4gICAgLy8gQ1JBWlkgQkxPT006IEFsbCBzdGFycyBhcmUgZXh0cmVtZWx5IGJyaWdodCAoY29sb3IgaW50ZW5zaXR5ID4xKVxuICAgIGNvbnN0IHBhbGV0dGUgPSBbXG4gICAgICBbMS4wLCAwLjUsIDAuNV0sXG4gICAgICBbMS4wLCAwLjc1LCAwLjRdLFxuICAgICAgWzEuMCwgMS4wLCAwLjldLFxuICAgICAgWzEuMCwgMS4wLCAxLjBdLFxuICAgICAgWzAuNCwgMC41LCAxLjBdLFxuICAgIF07XG4gICAgY29uc3QgY29sb3JzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFyQ291bnQ7IGkrKykge1xuICAgICAgY29uc3QgYyA9IHBhbGV0dGVbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcGFsZXR0ZS5sZW5ndGgpXTtcbiAgICAgIGNvbG9ycy5wdXNoKC4uLmMpO1xuICAgIH1cbiAgICBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2NvbG9yJywgbmV3IFRIUkVFLkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoY29sb3JzLCAzKSk7XG5cbiAgICBjb25zdCBvcmlnaW5hbENvbG9ycyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3IuYXJyYXkuc2xpY2UoKVxuICAgIGNvbnN0IHRpbWVycyA9IG5ldyBGbG9hdDMyQXJyYXkoc3RhckNvdW50KVxuICAgIGNvbnN0IHNwYXJrQ29sb3JzID0gbmV3IEZsb2F0MzJBcnJheShzdGFyQ291bnQgKiAzKVxuICAgIGNvbnN0IHNwYXJrbGVEdXJhdGlvbiA9IDE4MFxuXG4gICAgLy8gLS0tIFNRVUFSRSBTVEFSUyBVU0lORyBQT0lOVFMgLS0tXG4gICAgY29uc3QgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuUG9pbnRzTWF0ZXJpYWwoeyBzaXplOiAxMCwgc2l6ZUF0dGVudWF0aW9uOiB0cnVlLCB2ZXJ0ZXhDb2xvcnM6IHRydWUsIHRyYW5zcGFyZW50OiB0cnVlIH0pO1xuICAgIC8vIEN1c3RvbSBzaGFkZXIgdG8gdXNlIHBlci12ZXJ0ZXggYWxwaGFcbiAgICBtYXRlcmlhbC5vbkJlZm9yZUNvbXBpbGUgPSAoc2hhZGVyKSA9PiB7XG4gICAgICBzaGFkZXIudmVydGV4U2hhZGVyID0gc2hhZGVyLnZlcnRleFNoYWRlci5yZXBsYWNlKFxuICAgICAgICAndm9pZCBtYWluKCkgeycsXG4gICAgICAgICdhdHRyaWJ1dGUgZmxvYXQgYWxwaGE7IHZhcnlpbmcgZmxvYXQgdkFscGhhOyB2b2lkIG1haW4oKSB7IHZBbHBoYSA9IGFscGhhOydcbiAgICAgICk7XG4gICAgICBzaGFkZXIuZnJhZ21lbnRTaGFkZXIgPSBzaGFkZXIuZnJhZ21lbnRTaGFkZXIucmVwbGFjZShcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHsnLFxuICAgICAgICAndmFyeWluZyBmbG9hdCB2QWxwaGE7IHZvaWQgbWFpbigpIHsnXG4gICAgICApLnJlcGxhY2UoXG4gICAgICAgICdnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApOycsXG4gICAgICAgICdnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSAqIHZBbHBoYSApOydcbiAgICAgICk7XG4gICAgfTtcbiAgICBjb25zdCBzdGFycyA9IG5ldyBUSFJFRS5Qb2ludHMoZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICBzY2VuZS5hZGQoc3RhcnMpO1xuLy8gQWRkIGdsb3cgc3ByaXRlcyB0byBlYWNoIHN0YXIgYW5kIGFuaW1hdGUgdGhlbSBiYXNlZCBvbiBkaXN0YW5jZVxuY29uc3QgZ2xvd01hcCA9IG5ldyBUSFJFRS5UZXh0dXJlTG9hZGVyKCkubG9hZCgnL2dsb3cucG5nJyk7XG5jb25zdCBnbG93U3ByaXRlcyA9IFtdO1xuY29uc3QgZ2xvd01hdGVyaWFsID0gbmV3IFRIUkVFLlNwcml0ZU1hdGVyaWFsKHsgbWFwOiBnbG93TWFwLCBjb2xvcjogMHhmZmZmZmYsIG9wYWNpdHk6IDAuNTUsIGJsZW5kaW5nOiBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nLCBkZXB0aFdyaXRlOiBmYWxzZSwgdHJhbnNwYXJlbnQ6IHRydWUgfSk7XG5mb3IgKGxldCBpID0gMDsgaSA8IHN0YXJDb3VudDsgaSsrKSB7XG4gIGNvbnN0IGdsb3cgPSBuZXcgVEhSRUUuU3ByaXRlKGdsb3dNYXRlcmlhbC5jbG9uZSgpKTtcbiAgZ2xvdy5wb3NpdGlvbi5zZXQocG9zaXRpb25zW2kqM10sIHBvc2l0aW9uc1tpKjMrMV0sIHBvc2l0aW9uc1tpKjMrMl0pO1xuICBnbG93LnNjYWxlLnNldCgzMiwgMzIsIDEpOyAvLyBtdWNoIGxhcmdlciBhdXJhXG4gIHNjZW5lLmFkZChnbG93KTtcbiAgZ2xvd1Nwcml0ZXMucHVzaChnbG93KTtcbn1cbi8vIEFkZCBjbG9zZSBzdGFycyB0byBzZXBhcmF0ZSBzY2VuZVxubGV0IGNsb3NlU3RhcnM7XG5pZiAoY2xvc2VQb3NpdGlvbnMubGVuZ3RoID4gMCkge1xuICBjbG9zZVN0YXJzID0gbmV3IFRIUkVFLlBvaW50cyhjbG9zZUdlb21ldHJ5LCBtYXRlcmlhbC5jbG9uZSgpKTtcbiAgY2xvc2VTdGFyc1NjZW5lLmFkZChjbG9zZVN0YXJzKTtcbn1cblxuICAgIGxldCB0YXJnZXRZID0gMFxuICAgIGNvbnN0IGRhbXBpbmcgPSAwLjA1XG4gICAgY29uc3Qgb25TY3JvbGwgPSAoKSA9PiB7XG4gICAgICBjb25zdCBwY3QgPSB3aW5kb3cuc2Nyb2xsWSAvIChkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCAtIHdpbmRvdy5pbm5lckhlaWdodClcbiAgICAgIHRhcmdldFkgPSBwY3QgKiBNYXRoLlBJICogMlxuICAgIH1cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25TY3JvbGwpXG5cblxuICAgIC8vIC0tLSBTaG9vdGluZyBTdGFycyAtLS1cbiAgICBjb25zdCB0YWlsTGVuZ3RoID0gMzI7IC8vIEluY3JlYXNlIGZvciBsb25nZXIgdGFpbHNcbiAgICBjb25zdCBzaG9vdGluZ1N0YXJzID0gW107XG4gICAgbGV0IHNob290aW5nU3RhckNvb2xkb3duID0gMDtcbiAgICAvLyBTcGF3biBhIHNob290aW5nIHN0YXIgd2l0aCBhIHN0dW5uaW5nIGdsb3dpbmcgdGFpbFxuICAgIGZ1bmN0aW9uIHNwYXduU2hvb3RpbmdTdGFyKCkge1xuICAgICAgLy8gUGljayBhIHJhbmRvbSBkaXJlY3Rpb24gb24gdGhlIHNwaGVyZSBmb3IgdGhlIHNwYXduIGxvY2F0aW9uXG4gICAgICBjb25zdCBkaXIgPSBuZXcgVEhSRUUuVmVjdG9yMyhNYXRoLnJhbmRvbSgpKjItMSwgTWF0aC5yYW5kb20oKSoyLTEsIE1hdGgucmFuZG9tKCkqMi0xKS5ub3JtYWxpemUoKTtcbiAgICAgIC8vIEVuc3VyZSBzaG9vdGluZyBzdGFycyBuZXZlciBzcGF3biBjbG9zZSB0byB0aGUgY2FtZXJhIChhdCBsZWFzdCA3MCUgb2YgbWF4IGRpc3RhbmNlKVxuICAgICAgY29uc3QgbWluRGlzdCA9IHN0YXJNYXhEaXN0YW5jZSAqIDAuNztcbiAgICAgIGNvbnN0IG1heERpc3QgPSBzdGFyTWF4RGlzdGFuY2UgKiAxLjA7XG4gICAgICBjb25zdCBkaXN0ID0gbWluRGlzdCArIE1hdGgucmFuZG9tKCkgKiAobWF4RGlzdCAtIG1pbkRpc3QpO1xuICAgICAgY29uc3Qgc3Bhd25Qb3MgPSBkaXIuY2xvbmUoKS5tdWx0aXBseVNjYWxhcihkaXN0KTtcbiAgICAgIC8vIFRhbmdlbnRpYWwgdmVsb2NpdHk6IHBlcnBlbmRpY3VsYXIgdG8gZGlyXG4gICAgICBsZXQgdGFuZ2VudCA9IG5ldyBUSFJFRS5WZWN0b3IzKE1hdGgucmFuZG9tKCkqMi0xLCBNYXRoLnJhbmRvbSgpKjItMSwgTWF0aC5yYW5kb20oKSoyLTEpO1xuICAgICAgdGFuZ2VudCA9IHRhbmdlbnQuc3ViKHRhbmdlbnQuY2xvbmUoKS5wcm9qZWN0T25WZWN0b3IoZGlyKSkubm9ybWFsaXplKCk7XG4gICAgICAvLyBNaXggaW4gYSBzbWFsbCByYWRpYWwgY29tcG9uZW50IChpbndhcmQgb3Igb3V0d2FyZClcbiAgICAgIGNvbnN0IHRhbmdlbnRpYWxTcGVlZCA9IHN0YXJTcGVlZCAqICgyLjUgKyBNYXRoLnJhbmRvbSgpICogMi41KTsgLy8gbXVjaCBmYXN0ZXJcbiAgICAgIGNvbnN0IHJhZGlhbFNwZWVkID0gc3RhclNwZWVkICogKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMC4zOyAvLyBtb3JlIGRyYW1hdGljXG4gICAgICBjb25zdCB2ZWxvY2l0eSA9IHRhbmdlbnQubXVsdGlwbHlTY2FsYXIodGFuZ2VudGlhbFNwZWVkKS5hZGQoZGlyLmNsb25lKCkubXVsdGlwbHlTY2FsYXIocmFkaWFsU3BlZWQpKTtcblxuICAgICAgLy8gU3R1bm5pbmcgY29sb3IgZ3JhZGllbnQgZm9yIHRoZSBoZWFkXG4gICAgICBjb25zdCB2aWJyYW50Q29sb3JzID0gWzB4ZmZlMDY2LCAweGZmNjZjYywgMHg2NmNjZmYsIDB4ZmZmZmZmLCAweDgwZmZlYSwgMHhmZmYyY2MsIDB4ZmZjMDgwLCAweDgwYzBmZiwgMHhmZjgwYjNdO1xuICAgICAgY29uc3QgY29sb3IgPSB2aWJyYW50Q29sb3JzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSp2aWJyYW50Q29sb3JzLmxlbmd0aCldO1xuICAgICAgLy8gU3RhciBicmlnaHRuZXNzIGFuZCBzaXplIChhbHdheXMgc21hbGwgYW5kIHN1YnRsZSlcbiAgICAgIGNvbnN0IGJyaWdodG5lc3MgPSAyLjUgKyBNYXRoLnJhbmRvbSgpKjEuNTtcbiAgICAgIGNvbnN0IGdlbyA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeSgwLjcgKyBNYXRoLnJhbmRvbSgpKjAuNSwgMTYsIDE2KTsgLy8gU21hbGwgc3BoZXJlXG4gICAgICBjb25zdCBtYXQgPSBuZXcgVEhSRUUuTWVzaFBoeXNpY2FsTWF0ZXJpYWwoe1xuICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgIGVtaXNzaXZlOiBjb2xvcixcbiAgICAgICAgZW1pc3NpdmVJbnRlbnNpdHk6IDE0LjAsIC8vIEludGVuc2UgYmxvb21cbiAgICAgICAgbWV0YWxuZXNzOiAwLjcsXG4gICAgICAgIHJvdWdobmVzczogMC4zLFxuICAgICAgICB0cmFuc21pc3Npb246IDAuNyxcbiAgICAgICAgb3BhY2l0eTogMC45OCxcbiAgICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXG4gICAgICAgIGNsZWFyY29hdDogMC44LFxuICAgICAgICBjbGVhcmNvYXRSb3VnaG5lc3M6IDAuMixcbiAgICAgIH0pO1xuICAgICAgY29uc3Qgc3RhciA9IG5ldyBUSFJFRS5NZXNoKGdlbywgbWF0KTtcbiAgICAgIC8vIEFkZCBhIGxhcmdlLCBpbnRlbnNlIGJsb29tIHNwcml0ZSBmb3IgZXh0cmEgYmxvb21cbiAgICAgIGNvbnN0IHNwcml0ZU1hcCA9IG5ldyBUSFJFRS5UZXh0dXJlTG9hZGVyKCkubG9hZCgnL2dsb3cucG5nJyk7XG4gICAgICBjb25zdCBzcHJpdGVNYXRlcmlhbCA9IG5ldyBUSFJFRS5TcHJpdGVNYXRlcmlhbCh7IG1hcDogc3ByaXRlTWFwLCBjb2xvcjogMHhmZmZmZmYsIG9wYWNpdHk6IDEuMCwgYmxlbmRpbmc6IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmcgfSk7XG4gICAgICBjb25zdCBzcHJpdGUgPSBuZXcgVEhSRUUuU3ByaXRlKHNwcml0ZU1hdGVyaWFsKTtcbiAgICAgIHNwcml0ZS5zY2FsZS5zZXQoNzAsIDcwLCAxKTsgLy8gTGFyZ2UgZm9yIGJsb29tXG4gICAgICBzcHJpdGUucG9zaXRpb24uY29weShzdGFyLnBvc2l0aW9uKTtcbiAgICAgIHN0YXIuYWRkKHNwcml0ZSk7XG4gICAgICAvLyBBZGQgYSBjb2xvcmVkIHNwcml0ZSBmb3IgY29sb3IgcG9wXG4gICAgICBjb25zdCBjb2xvclNwcml0ZU1hdGVyaWFsID0gbmV3IFRIUkVFLlNwcml0ZU1hdGVyaWFsKHsgbWFwOiBzcHJpdGVNYXAsIGNvbG9yOiBjb2xvciwgb3BhY2l0eTogMC42LCBibGVuZGluZzogVEhSRUUuQWRkaXRpdmVCbGVuZGluZyB9KTtcbiAgICAgIGNvbnN0IGNvbG9yU3ByaXRlID0gbmV3IFRIUkVFLlNwcml0ZShjb2xvclNwcml0ZU1hdGVyaWFsKTtcbiAgICAgIGNvbG9yU3ByaXRlLnNjYWxlLnNldCgzNCwgMzQsIDEpO1xuICAgICAgY29sb3JTcHJpdGUucG9zaXRpb24uY29weShzdGFyLnBvc2l0aW9uKTtcbiAgICAgIHN0YXIuYWRkKGNvbG9yU3ByaXRlKTtcbiAgICAgIC8vIEFkZCB0byBib3RoIG1haW4gc2NlbmUgYW5kIHNob290aW5nU3RhclNjZW5lXG4gICAgICBzY2VuZS5hZGQoc3Rhcik7XG4gICAgICBzaG9vdGluZ1N0YXJTY2VuZS5hZGQoc3Rhcik7XG4gICAgICAvLyBBZGQgZHluYW1pYyBzcGFyayBidXJzdCBhdCB0aGUgaGVhZFxuICAgICAgY29uc3Qgc3BhcmtDb3VudCA9IDE4ICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKjgpO1xuICAgICAgY29uc3Qgc3BhcmtHcm91cCA9IG5ldyBUSFJFRS5Hcm91cCgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGFya0NvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3Qgc3BhcmtNYXQgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoeyBjb2xvcjogdmlicmFudENvbG9yc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqdmlicmFudENvbG9ycy5sZW5ndGgpXSwgdHJhbnNwYXJlbnQ6IHRydWUsIG9wYWNpdHk6IDAuOCB9KTtcbiAgICAgICAgY29uc3Qgc3BhcmtHZW8gPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoMC4wNyArIE1hdGgucmFuZG9tKCkqMC4wNiwgOCwgOCk7XG4gICAgICAgIGNvbnN0IHNwYXJrID0gbmV3IFRIUkVFLk1lc2goc3BhcmtHZW8sIHNwYXJrTWF0KTtcbiAgICAgICAgY29uc3QgYW5nbGUgPSAoaSAvIHNwYXJrQ291bnQpICogTWF0aC5QSSAqIDI7XG4gICAgICAgIHNwYXJrLnBvc2l0aW9uLnNldChNYXRoLmNvcyhhbmdsZSkqMS4yLCBNYXRoLnNpbihhbmdsZSkqMS4yLCBNYXRoLnJhbmRvbSgpKjAuNC0wLjIpO1xuICAgICAgICBzcGFya0dyb3VwLmFkZChzcGFyayk7XG4gICAgICB9XG4gICAgICBzcGFya0dyb3VwLm5hbWUgPSAnc3BhcmtCdXJzdCc7XG4gICAgICBzdGFyLmFkZChzcGFya0dyb3VwKTtcbiAgICAgIHN0YXIucG9zaXRpb24uY29weShzcGF3blBvcyk7XG4gICAgICBzdGFyLnZlbG9jaXR5ID0gdmVsb2NpdHk7XG4gICAgICBzdGFyLm5vcm1hbGl6ZWRMaWZlID0gMC4wO1xuICAgICAgc3Rhci5ub3JtYWxpemVkTGlmZXRpbWUgPSA4MCArIE1hdGgucmFuZG9tKCkgKiA4MDsgLy8gTG9uZ2VyLCBtb3JlIGRyYW1hdGljXG4gICAgICBzdGFyLmFnZSA9IDA7XG4gICAgICAvLyAtLS0gU3R1bm5pbmcgTWV0ZW9yIFRhaWwgKHZlcnkgbG9uZywgbXVsdGktY29sb3IsIGdsb3dpbmcsIGZhZGluZywgYW5kIDNEIGN1cnZlKSAtLS1cbiAgICAgIGNvbnN0IHRyYWlsU2VnbWVudHMgPSB0YWlsTGVuZ3RoICogMzsgXG4gICAgICBjb25zdCB0cmFpbFBvaW50cyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFpbFNlZ21lbnRzOyBpKyspIHtcbiAgICAgICAgLy8gQWRkIGEgM0Qgc3BpcmFsL2N1cnZlIGZvciBtb3JlIGRlcHRoXG4gICAgICAgIGNvbnN0IHNwaXJhbCA9IE1hdGguc2luKGkgKiAwLjI1KSAqIDg7XG4gICAgICAgIGNvbnN0IGN1cnZlID0gTWF0aC5jb3MoaSAqIDAuMTUpICogNDtcbiAgICAgICAgY29uc3QgcHQgPSBzdGFyLnBvc2l0aW9uLmNsb25lKCkuYWRkKG5ldyBUSFJFRS5WZWN0b3IzKHNwaXJhbCwgY3VydmUsIC1pICogMykpO1xuICAgICAgICB0cmFpbFBvaW50cy5wdXNoKHB0KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhaWxHZW8gPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKS5zZXRGcm9tUG9pbnRzKHRyYWlsUG9pbnRzKTtcbiAgICAgIC8vIFBlci12ZXJ0ZXggY29sb3IgKG11bHRpLWNvbG9yIHJhaW5ib3cgZ3JhZGllbnQpXG4gICAgICBjb25zdCB0YWlsQ29sb3JzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYWlsU2VnbWVudHM7IGkrKykge1xuICAgICAgICAvLyBBbHBoYSBmYWRlcyBvdXQgYWxvbmcgdGhlIHRhaWxcbiAgICAgICAgY29uc3QgYWxwaGEgPSAoMSAtIGkgLyAodHJhaWxTZWdtZW50cyAtIDEpKSAqIDAuOTk7XG4gICAgICAgIC8vIFJhaW5ib3cgZ3JhZGllbnRcbiAgICAgICAgY29uc3QgcmFpbmJvdyA9IFsweGZmZTA2NiwgMHhmZjY2Y2MsIDB4NjZjY2ZmLCAweGZmZmZmZiwgMHg4MGZmZWEsIDB4ZmZmMmNjLCAweGZmYzA4MCwgMHg4MGMwZmYsIDB4ZmY4MGIzXTtcbiAgICAgICAgY29uc3QgZ3JhZENvbG9yID0gcmFpbmJvd1tNYXRoLmZsb29yKChpIC8gdHJhaWxTZWdtZW50cykgKiByYWluYm93Lmxlbmd0aCldO1xuICAgICAgICB0YWlsQ29sb3JzLnB1c2goKGdyYWRDb2xvciA+PiAxNiAmIDI1NSkgLyAyNTUsIChncmFkQ29sb3IgPj4gOCAmIDI1NSkgLyAyNTUsIChncmFkQ29sb3IgJiAyNTUpIC8gMjU1LCBhbHBoYSk7XG4gICAgICB9XG4gICAgICB0YWlsR2VvLnNldEF0dHJpYnV0ZSgnY29sb3InLCBuZXcgVEhSRUUuRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh0YWlsQ29sb3JzLCA0KSk7XG4gICAgICAvLyBBZGRpdGl2ZSBibGVuZGluZyBmb3IgZ2xvdyArIEJMT09NRUQgVEFJTFxuICAgICAgY29uc3QgdGFpbE1hdCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCh7IHZlcnRleENvbG9yczogdHJ1ZSwgdHJhbnNwYXJlbnQ6IHRydWUsIG9wYWNpdHk6IDEuMCwgYmxlbmRpbmc6IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmcgfSk7XG4gICAgICAvLyAtLS0gVEFJTFMgLS0tXG4gICAgICAvLyAxLiBDcmlzcCB0YWlsIGZvciBtYWluIHNjZW5lXG4gICAgICBjb25zdCB0YWlsTWF0TWFpbiA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCh7IHZlcnRleENvbG9yczogdHJ1ZSwgdHJhbnNwYXJlbnQ6IHRydWUsIG9wYWNpdHk6IDEuMCwgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nIH0pO1xuICAgICAgY29uc3QgdGFpbE1haW4gPSBuZXcgVEhSRUUuTGluZSh0YWlsR2VvLmNsb25lKCksIHRhaWxNYXRNYWluKTtcbiAgICAgIHRhaWxNYWluLnBvc2l0aW9uLmNvcHkoc3Rhci5wb3NpdGlvbik7XG4gICAgICBzY2VuZS5hZGQodGFpbE1haW4pO1xuICAgICAgLy8gMi4gSW50ZW5zZSBibG9vbSB0YWlsIGZvciBzaG9vdGluZ1N0YXJTY2VuZVxuICAgICAgY29uc3QgdGFpbE1hdEJsb29tID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKHsgdmVydGV4Q29sb3JzOiB0cnVlLCB0cmFuc3BhcmVudDogdHJ1ZSwgb3BhY2l0eTogMS4wLCBibGVuZGluZzogVEhSRUUuQWRkaXRpdmVCbGVuZGluZyB9KTtcbiAgICAgIGNvbnN0IHRhaWxCbG9vbSA9IG5ldyBUSFJFRS5MaW5lKHRhaWxHZW8sIHRhaWxNYXRCbG9vbSk7XG4gICAgICB0YWlsQmxvb20ucG9zaXRpb24uY29weShzdGFyLnBvc2l0aW9uKTtcbiAgICAgIC8vIEFkZCBhIGJsb29tIHNwcml0ZSB0byB0aGUgdGFpbCdzIGhlYWQgZm9yIGV4dHJhIGdsb3dcbiAgICAgIGNvbnN0IHRhaWxHbG93TWFwID0gbmV3IFRIUkVFLlRleHR1cmVMb2FkZXIoKS5sb2FkKCcvZ2xvdy5wbmcnKTtcbiAgICAgIGNvbnN0IHRhaWxHbG93TWF0ID0gbmV3IFRIUkVFLlNwcml0ZU1hdGVyaWFsKHsgbWFwOiB0YWlsR2xvd01hcCwgY29sb3I6IDB4ZmZmZmZmLCBvcGFjaXR5OiAwLjg4LCBibGVuZGluZzogVEhSRUUuQWRkaXRpdmVCbGVuZGluZyB9KTtcbiAgICAgIGNvbnN0IHRhaWxHbG93ID0gbmV3IFRIUkVFLlNwcml0ZSh0YWlsR2xvd01hdCk7XG4gICAgICB0YWlsR2xvdy5zY2FsZS5zZXQoNTAsIDUwLCAxKTsgLy8gTGFyZ2VyIGZvciBtb3JlIGJsb29tXG4gICAgICB0YWlsR2xvdy5wb3NpdGlvbi5jb3B5KHN0YXIucG9zaXRpb24pO1xuICAgICAgdGFpbEJsb29tLmFkZCh0YWlsR2xvdyk7XG4gICAgICBzaG9vdGluZ1N0YXJTY2VuZS5hZGQodGFpbEJsb29tKTtcbiAgICAgIC8vIEFkZCBzdGFyIHRvIGJvdGggc2NlbmVzXG4gICAgICBzY2VuZS5hZGQoc3Rhcik7XG4gICAgICBzaG9vdGluZ1N0YXJTY2VuZS5hZGQoc3Rhcik7XG4gICAgICBzaG9vdGluZ1N0YXJzLnB1c2goeyBtZXNoOiBzdGFyLCB0YWlsOiB0YWlsTWFpbiwgdGFpbEJsb29tLCB2ZWxvY2l0eTogc3Rhci52ZWxvY2l0eSwgZGlyLCBhZ2U6IDAsIG5vcm1hbGl6ZWRMaWZldGltZTogc3Rhci5ub3JtYWxpemVkTGlmZXRpbWUsIHRyYWlsUG9pbnRzLCBjb2xvciwgYnJpZ2h0bmVzcywgaGFzRnJhZ21lbnRlZDogZmFsc2UgfSk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGFuIGFuaW1hdGlvbiBJRCByZWZlcmVuY2UgZm9yIGNsZWFudXBcbiAgICBsZXQgYW5pbWF0aW9uSWQ7XG4gICAgXG4gICAgY29uc3QgYW5pbWF0ZSA9ICgpID0+IHtcbiAgICAgIC8vIFN0b3JlIHRoZSBhbmltYXRpb24gSUQgZm9yIGNsZWFudXBcbiAgICAgIGFuaW1hdGlvbklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgc3RhciBwb3NpdGlvbnMgcmVsYXRpdmUgdG8gdmlydHVhbCBjYW1lcmFcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXlbaV0gPSBwb3NpdGlvbnNbaV0gLSB2aXJ0dWFsQ2FtZXJhUG9zLng7XG4gICAgICAgIGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXlbaSsxXSA9IHBvc2l0aW9uc1tpKzFdIC0gdmlydHVhbENhbWVyYVBvcy55O1xuICAgICAgICBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5W2krMl0gPSBwb3NpdGlvbnNbaSsyXSAtIHZpcnR1YWxDYW1lcmFQb3MuejtcbiAgICAgIH1cbiAgICAgIGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICAvLyBGYWRlLWluIGxvZ2ljIGZvciBzdGFyc1xuICAgICAgbGV0IG5lZWRzQWxwaGFVcGRhdGUgPSBmYWxzZTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhckFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHN0YXJBZ2VzW2ldIDwgZmFkZUR1cmF0aW9uKSB7XG4gICAgICAgICAgc3RhckFnZXNbaV0gKz0gMS82MDsgLy8gYXNzdW1pbmcgfjYwZnBzLCBvciB1c2UgZGVsdGFUaW1lIGlmIGF2YWlsYWJsZVxuICAgICAgICAgIGdlb21ldHJ5LmF0dHJpYnV0ZXMuYWxwaGEuYXJyYXlbaV0gPSBNYXRoLm1pbigxLCBzdGFyQWdlc1tpXSAvIGZhZGVEdXJhdGlvbik7XG4gICAgICAgICAgbmVlZHNBbHBoYVVwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChuZWVkc0FscGhhVXBkYXRlKSBnZW9tZXRyeS5hdHRyaWJ1dGVzLmFscGhhLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIGdsb3cgc3ByaXRlIHBvc2l0aW9uc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnbG93U3ByaXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBpZHggPSBpICogMztcbiAgICAgICAgZ2xvd1Nwcml0ZXNbaV0ucG9zaXRpb24uc2V0KFxuICAgICAgICAgIHBvc2l0aW9uc1tpZHhdIC0gdmlydHVhbENhbWVyYVBvcy54LFxuICAgICAgICAgIHBvc2l0aW9uc1tpZHgrMV0gLSB2aXJ0dWFsQ2FtZXJhUG9zLnksXG4gICAgICAgICAgcG9zaXRpb25zW2lkeCsyXSAtIHZpcnR1YWxDYW1lcmFQb3MuelxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyAtLS0gUE9TVC1QUk9DRVNTSU5HIFBJUEVMSU5FIC0tLVxuICAgICAgLy8gLS0tIFBPU1QtUFJPQ0VTU0lORyBQSVBFTElORSAtLS1cbiAgICAgIGNvbXBvc2VyLnJlbmRlcigpOyAvLyBPbmx5IFJlbmRlclBhc3MgZW5hYmxlZCBmb3IgZGVidWdnaW5nXG4gICAgICAvLyAoYmxvb20sIEZYQUEsIEZpbG1QYXNzIGFyZSBOT1QgYWRkZWQpXG4gICAgICAvLyBzaG9vdGluZ1N0YXJDb21wb3NlciwgY2FDb21wb3NlciByZW1haW4gZGlzYWJsZWQgZm9yIG5vd1xuXG4gICAgICBjYW1lcmEucm90YXRpb24ueSArPSAodGFyZ2V0WSAtIGNhbWVyYS5yb3RhdGlvbi55KSAqIGRhbXBpbmc7XG4gICAgICAvLyBNb3ZlIHRoZSB2aXJ0dWFsIGNhbWVyYSBwb3NpdGlvbiBpbiB0aGUgZGlyZWN0aW9uIHRoZSBjYW1lcmEgaXMgZmFjaW5nXG4gICAgICBjb25zdCBmb3J3YXJkID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgIGNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihmb3J3YXJkKTtcbiAgICAgIHZpcnR1YWxDYW1lcmFQb3MuYWRkKGZvcndhcmQubXVsdGlwbHlTY2FsYXIoc3RhclNwZWVkKSk7XG5cbiAgICAgIC8vIEludGVuc2UgY29sb3IgKG92ZXJzYXR1cmF0ZWQsIGJyaWdodGVuZWQpIC0tIG11c3QgYmUgaW5zaWRlIHRoZSBmb3IgbG9vcCBvdmVyIHN0YXJzXG4gICAgICBjb25zdCBjb2xvckF0dHIgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLmNvbG9yO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3NpdGlvbnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgY29uc3Qgb3JpZ1IgPSBjb2xvckF0dHIuYXJyYXlbaV07XG4gICAgICAgIGNvbnN0IG9yaWdHID0gY29sb3JBdHRyLmFycmF5W2krMV07XG4gICAgICAgIGNvbnN0IG9yaWdCID0gY29sb3JBdHRyLmFycmF5W2krMl07XG4gICAgICAgIGNvbnN0IGRpc3QgPSBNYXRoLnNxcnQoXG4gICAgICAgICAgTWF0aC5wb3cocG9zaXRpb25zW2ldIC0gdmlydHVhbENhbWVyYVBvcy54LCAyKSArXG4gICAgICAgICAgTWF0aC5wb3cocG9zaXRpb25zW2krMV0gLSB2aXJ0dWFsQ2FtZXJhUG9zLnksIDIpICtcbiAgICAgICAgICBNYXRoLnBvdyhwb3NpdGlvbnNbaSsyXSAtIHZpcnR1YWxDYW1lcmFQb3MueiwgMilcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgaW50ZW5zZVIgPSBNYXRoLm1pbihvcmlnUiAqIDIuNSwgMS4wKSwgaW50ZW5zZUcgPSBNYXRoLm1pbihvcmlnRyAqIDIuNSwgMS4wKSwgaW50ZW5zZUIgPSBNYXRoLm1pbihvcmlnQiAqIDIuNSwgMS4wKTtcbiAgICAgICAgLy8gRmFkZSBmYWN0b3I6IDAgPSBjbG9zZSwgMSA9IGZhclxuICAgICAgICBsZXQgZmFkZVQgPSAoZGlzdCAtIDIwMCkgLyAoc3Rhck1heERpc3RhbmNlICogMC45IC0gMjAwKTtcbiAgICAgICAgZmFkZVQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBmYWRlVCkpO1xuICAgICAgICAvLyBFYXNlIGZvciBzbW9vdGhuZXNzXG4gICAgICAgIGZhZGVUID0gTWF0aC5wb3coZmFkZVQsIDEuNSk7XG4gICAgICAgIC8vIExlcnAgYmV0d2VlbiBvcmlnaW5hbCBhbmQgaW50ZW5zZSBjb2xvclxuICAgICAgICBjb2xvckF0dHIuYXJyYXlbaV0gPSBvcmlnUiAqICgxLWZhZGVUKSArIGludGVuc2VSICogZmFkZVQ7XG4gICAgICAgIGNvbG9yQXR0ci5hcnJheVtpKzFdID0gb3JpZ0cgKiAoMS1mYWRlVCkgKyBpbnRlbnNlRyAqIGZhZGVUO1xuICAgICAgICBjb2xvckF0dHIuYXJyYXlbaSsyXSA9IG9yaWdCICogKDEtZmFkZVQpICsgaW50ZW5zZUIgKiBmYWRlVDtcbiAgICAgIH1cbiAgICAgIGNvbG9yQXR0ci5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAvLyBJZiB5b3UgaGF2ZSBnbG93IGxvZ2ljIHBlci1zdGFyLCBtb3ZlIHRoYXQgaW5zaWRlIHRoZSBsb29wIGFzIHdlbGwsIG9yIGhhbmRsZSBhZnRlclxuXG4gICAgICBpZiAoY2xvc2VTdGFycyAmJiBjbG9zZUdlb21ldHJ5ICYmIGNsb3NlUG9zaXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbG9zZVBvc2l0aW9ucy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgIGNsb3NlR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheVtpXSA9IGNsb3NlUG9zaXRpb25zW2ldIC0gdmlydHVhbENhbWVyYVBvcy54O1xuICAgICAgICAgIGNsb3NlR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheVtpKzFdID0gY2xvc2VQb3NpdGlvbnNbaSsxXSAtIHZpcnR1YWxDYW1lcmFQb3MueTtcbiAgICAgICAgICBjbG9zZUdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXlbaSsyXSA9IGNsb3NlUG9zaXRpb25zW2krMl0gLSB2aXJ0dWFsQ2FtZXJhUG9zLno7XG4gICAgICAgIH1cbiAgICAgICAgY2xvc2VHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgc2hvb3Rpbmcgc3RhciBjb29sZG93blxuICAgICAgaWYgKHNob290aW5nU3RhckNvb2xkb3duIDw9IDAgJiYgTWF0aC5yYW5kb20oKSA8IDAuMDIpIHtcbiAgICAgICAgc3Bhd25TaG9vdGluZ1N0YXIoKTtcbiAgICAgICAgc2hvb3RpbmdTdGFyQ29vbGRvd24gPSAzMCArIE1hdGgucmFuZG9tKCkgKiA2MDtcbiAgICAgIH0gZWxzZSBpZiAoc2hvb3RpbmdTdGFyQ29vbGRvd24gPiAwKSB7XG4gICAgICAgIHNob290aW5nU3RhckNvb2xkb3duLS07XG4gICAgICB9XG5cbiAgICAgIC8vIC0tLSBTaG9vdGluZyBzdGFyIHNwYXduaW5nIC0tLVxuICAgICAgaWYgKHNob290aW5nU3RhckNvb2xkb3duIDw9IDAgJiYgTWF0aC5yYW5kb20oKSA8IDAuMSkge1xuICAgICAgICBzcGF3blNob290aW5nU3RhcigpO1xuICAgICAgICBpZiAoY2FtZXJhKSB7XG4gICAgICAgICAgY29uc3Qgc2hha2VTdHJlbmd0aCA9IDAuMDYgKyBNYXRoLnJhbmRvbSgpKjAuMDQ7XG4gICAgICAgICAgY2FtZXJhLnBvc2l0aW9uLnggKz0gKE1hdGgucmFuZG9tKCktMC41KSpzaGFrZVN0cmVuZ3RoO1xuICAgICAgICAgIGNhbWVyYS5wb3NpdGlvbi55ICs9IChNYXRoLnJhbmRvbSgpLTAuNSkqc2hha2VTdHJlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBzaG9vdGluZ1N0YXJDb29sZG93biA9IDEwICsgTWF0aC5yYW5kb20oKSAqIDEwO1xuICAgICAgfSBlbHNlIGlmIChzaG9vdGluZ1N0YXJDb29sZG93biA+IDApIHtcbiAgICAgICAgc2hvb3RpbmdTdGFyQ29vbGRvd24tLTtcbiAgICAgIH1cbiAgICAgIC8vIEFuaW1hdGUgYW5kIGNsZWFuIHVwIHNob290aW5nIHN0YXJzXG4gICAgICBmb3IgKGxldCBpID0gc2hvb3RpbmdTdGFycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBvYmogPSBzaG9vdGluZ1N0YXJzW2ldO1xuICAgICAgICAvLyBBbmltYXRlIHNwYXJrIGJ1cnN0IChmYWRlIGFuZCBleHBhbmQpXG4gICAgICAgIGlmIChvYmoubWVzaC5jaGlsZHJlbikge1xuICAgICAgICAgIGNvbnN0IHNwYXJrcyA9IG9iai5tZXNoLmNoaWxkcmVuLmZpbmQoY2hpbGQgPT4gY2hpbGQubmFtZSA9PT0gJ3NwYXJrQnVyc3QnKTtcbiAgICAgICAgICBpZiAoc3BhcmtzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNwYXJrcy5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICBjb25zdCBzcGFyayA9IHNwYXJrcy5jaGlsZHJlbltqXTtcbiAgICAgICAgICAgICAgc3BhcmsubWF0ZXJpYWwub3BhY2l0eSAqPSAwLjk2OyAvLyBGYWRlXG4gICAgICAgICAgICAgIHNwYXJrLnNjYWxlLm11bHRpcGx5U2NhbGFyKDEuMDMpOyAvLyBFeHBhbmRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQW5pbWF0ZSB0YWlsIHNoaW1tZXIgYW5kIGNvbG9yIGN5Y2xpbmdcbiAgICAgICAgaWYgKG9iai50YWlsICYmIG9iai50cmFpbFBvaW50cykge1xuICAgICAgICAgIGNvbnN0IHRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAqIDAuMDAxO1xuICAgICAgICAgIGNvbnN0IHRhaWxHZW8gPSBvYmoudGFpbC5nZW9tZXRyeTtcbiAgICAgICAgICBjb25zdCB0YWlsQ29sb3JzID0gdGFpbEdlby5nZXRBdHRyaWJ1dGUoJ2NvbG9yJyk7XG4gICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCB0YWlsQ29sb3JzLmNvdW50OyBrKyspIHtcbiAgICAgICAgICAgIC8vIEN5Y2xlIGh1ZVxuICAgICAgICAgICAgbGV0IHIgPSB0YWlsQ29sb3JzLmdldFgoayksIGcgPSB0YWlsQ29sb3JzLmdldFkoayksIGIgPSB0YWlsQ29sb3JzLmdldFooayk7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRvIEhTTFxuICAgICAgICAgICAgY29uc3QgbWF4ID0gTWF0aC5tYXgocixnLGIpLCBtaW4gPSBNYXRoLm1pbihyLGcsYik7XG4gICAgICAgICAgICBsZXQgaCxzLGw7XG4gICAgICAgICAgICBsID0gKG1heCttaW4pLzI7XG4gICAgICAgICAgICBpZiAobWF4ID09PSBtaW4pIHtoID0gcyA9IDA7fSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3QgZCA9IG1heC1taW47XG4gICAgICAgICAgICAgIHMgPSBsID4gMC41ID8gZC8oMi1tYXgtbWluKSA6IGQvKG1heCttaW4pO1xuICAgICAgICAgICAgICBzd2l0Y2gobWF4KXtcbiAgICAgICAgICAgICAgICBjYXNlIHI6IGggPSAoZy1iKS9kICsgKGc8Yj82OjApOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIGc6IGggPSAoYi1yKS9kICsgMjsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBiOiBoID0gKHItZykvZCArIDQ7IGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGgvPTY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoID0gKGggKyAwLjI1Kk1hdGguc2luKHRpbWUgKyBrKjAuMikpICUgMS4wOyAvLyBBbmltYXRlIGh1ZVxuICAgICAgICAgICAgLy8gQ29udmVydCBiYWNrIHRvIFJHQlxuICAgICAgICAgICAgbGV0IHEgPSBsIDwgMC41ID8gbCooMStzKSA6IGwrcy1sKnM7XG4gICAgICAgICAgICBsZXQgcCA9IDIqbC1xO1xuICAgICAgICAgICAgbGV0IHRyID0gaCsxLzMsIHRnID0gaCwgdGIgPSBoLTEvMztcbiAgICAgICAgICAgIGNvbnN0IGh1ZTJyZ2IgPSAocCxxLHQpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHQ8MCkgdCs9MTsgaWYgKHQ+MSkgdC09MTtcbiAgICAgICAgICAgICAgaWYgKHQ8MS82KSByZXR1cm4gcCsocS1wKSo2KnQ7XG4gICAgICAgICAgICAgIGlmICh0PDEvMikgcmV0dXJuIHE7XG4gICAgICAgICAgICAgIGlmICh0PDIvMykgcmV0dXJuIHArKHEtcCkqKDIvMy10KSo2O1xuICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0YWlsQ29sb3JzLnNldFgoaywgaHVlMnJnYihwLHEsdHIpKTtcbiAgICAgICAgICAgIHRhaWxDb2xvcnMuc2V0WShrLCBodWUycmdiKHAscSx0ZykpO1xuICAgICAgICAgICAgdGFpbENvbG9ycy5zZXRaKGssIGh1ZTJyZ2IocCxxLHRiKSk7XG4gICAgICAgICAgICAvLyBTaGltbWVyOiBtb2R1bGF0ZSBhbHBoYVxuICAgICAgICAgICAgdGFpbENvbG9ycy5zZXRXKGssIHRhaWxDb2xvcnMuZ2V0VyhrKSAqICgwLjk3ICsgMC4wMypNYXRoLnNpbih0aW1lKjggKyBrKSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0YWlsQ29sb3JzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdHJhaWdodC1saW5lIHRyYWplY3RvcnlcbiAgICAgICAgb2JqLm1lc2gucG9zaXRpb24uYWRkKG9iai52ZWxvY2l0eSk7XG4gICAgICAgIG9iai50YWlsLnBvc2l0aW9uLmNvcHkob2JqLm1lc2gucG9zaXRpb24pO1xuICAgICAgICBpZiAob2JqLnRhaWxCbG9vbSkgb2JqLnRhaWxCbG9vbS5wb3NpdGlvbi5jb3B5KG9iai5tZXNoLnBvc2l0aW9uKTtcbiAgICAgICAgLy8gQW5pbWF0ZSB0YWlsIChubyBsZXJwLCBqdXN0IGRyYWcpXG4gICAgICAgIC8vIENPTVBMRVRFIE1FU1MgVkVSWSBIQUNLWSBGSVggTEFURVIgT1IgRE9OVD8/Pz8/XG4gICAgICAgIG9iai5hZ2UrKztcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZExpZmUgPSBvYmouYWdlIC8gb2JqLm5vcm1hbGl6ZWRMaWZldGltZTtcbiAgICAgICAgb2JqLnRyYWlsUG9pbnRzLnVuc2hpZnQob2JqLm1lc2gucG9zaXRpb24uY2xvbmUoKSk7XG4gICAgICAgIGlmIChvYmoudHJhaWxQb2ludHMubGVuZ3RoID4gdGFpbExlbmd0aCAqIDMpIG9iai50cmFpbFBvaW50cy5wb3AoKTtcbiAgICAgICAgbGV0IHRhaWxHcm93ID0gTWF0aC5taW4oMSwgbm9ybWFsaXplZExpZmUgLyAwLjMpO1xuICAgICAgICBsZXQgYWN0aXZlU2VnbWVudHMgPSBNYXRoLmZsb29yKG9iai50cmFpbFBvaW50cy5sZW5ndGggKiB0YWlsR3Jvdyk7XG4gICAgICAgIGlmIChhY3RpdmVTZWdtZW50cyA8IDIpIGFjdGl2ZVNlZ21lbnRzID0gMjtcbiAgICAgICAgY29uc3QgdmlzaWJsZVRyYWlsID0gb2JqLnRyYWlsUG9pbnRzLnNsaWNlKDAsIGFjdGl2ZVNlZ21lbnRzKTtcbiAgICAgICAgb2JqLnRhaWwuZ2VvbWV0cnkuc2V0RnJvbVBvaW50cyh2aXNpYmxlVHJhaWwpO1xuICAgICAgICBpZiAob2JqLnRhaWxCbG9vbSkgb2JqLnRhaWxCbG9vbS5nZW9tZXRyeS5zZXRGcm9tUG9pbnRzKHZpc2libGVUcmFpbCk7XG4gICAgICAgIGNvbnN0IHRhaWxDb2xvcnMgPSBvYmoudGFpbC5nZW9tZXRyeS5nZXRBdHRyaWJ1dGUoJ2NvbG9yJyk7XG4gICAgICAgIGxldCB0YWlsQ29sb3JzQmxvb20gPSBvYmoudGFpbEJsb29tID8gb2JqLnRhaWxCbG9vbS5nZW9tZXRyeS5nZXRBdHRyaWJ1dGUoJ2NvbG9yJykgOiBudWxsO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZpc2libGVUcmFpbC5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGxldCBhbHBoYSA9ICgxIC0gaiAvICh2aXNpYmxlVHJhaWwubGVuZ3RoIC0gMSkpICogMC45NTtcbiAgICAgICAgICBhbHBoYSAqPSAwLjkyICsgMC4wOCAqIE1hdGguc2luKERhdGUubm93KCkqMC4wMTUgKyBqKjAuNSk7XG4gICAgICAgICAgbGV0IHJhaW5ib3cgPSBbMHhmZmMwODAsIDB4ZmZlMDgwLCAweGZmZmY4MCwgMHg4MGZmZTYsIDB4ODBjMGZmLCAweGMwODBmZl07XG4gICAgICAgICAgbGV0IGdyYWRDb2xvciA9IHJhaW5ib3dbaiAlIHJhaW5ib3cubGVuZ3RoXTtcbiAgICAgICAgICBpZiAobm9ybWFsaXplZExpZmUgPiAwLjcpIGFscGhhICo9IE1hdGgubWF4KDAsIDEgLSAobm9ybWFsaXplZExpZmUgLSAwLjcgLSAwLjIpIC8gMC4zKTtcbiAgICAgICAgICB0YWlsQ29sb3JzLnNldFhZWlcoaiwgKGdyYWRDb2xvciA+PiAxNiAmIDI1NSkgLyAyNTUsIChncmFkQ29sb3IgPj4gOCAmIDI1NSkgLyAyNTUsIChncmFkQ29sb3IgJiAyNTUpIC8gMjU1LCBhbHBoYSk7XG4gICAgICAgICAgaWYgKHRhaWxDb2xvcnNCbG9vbSkgdGFpbENvbG9yc0Jsb29tLnNldFhZWlcoaiwgKGdyYWRDb2xvciA+PiAxNiAmIDI1NSkgLyAyNTUsIChncmFkQ29sb3IgPj4gOCAmIDI1NSkgLyAyNTUsIChncmFkQ29sb3IgJiAyNTUpIC8gMjU1LCBhbHBoYSk7XG4gICAgICAgIH1cbiAgICAgICAgdGFpbENvbG9ycy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIC8vIEFuaW1hdGUgaGVhZFxuICAgICAgICBsZXQgaGVhZENvbG9yO1xuICAgICAgICBpZiAobm9ybWFsaXplZExpZmUgPCAwLjUpIHtcbiAgICAgICAgICBoZWFkQ29sb3IgPSBuZXcgVEhSRUUuQ29sb3Iob2JqLmNvbG9yKS5sZXJwKG5ldyBUSFJFRS5Db2xvcigweGZmYzA4MCksIG5vcm1hbGl6ZWRMaWZlKjIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhlYWRDb2xvciA9IG5ldyBUSFJFRS5Db2xvcigweGZmYzA4MCkubGVycChuZXcgVEhSRUUuQ29sb3IoMHhmZjQwMDApLCAobm9ybWFsaXplZExpZmUtMC41KSoyKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZmxpY2tlciA9IDAuOTUgKyAwLjEzICogTWF0aC5zaW4oRGF0ZS5ub3coKSowLjA3ICsgTWF0aC5yYW5kb20oKSoxMCk7XG4gICAgICAgIGhlYWRDb2xvci5tdWx0aXBseVNjYWxhcihmbGlja2VyKTtcbiAgICAgICAgb2JqLm1lc2gubWF0ZXJpYWwuY29sb3IuY29weShoZWFkQ29sb3IpO1xuICAgICAgICBsZXQgc2NhbGUgPSAxICsgMi4yICogTWF0aC5zaW4oTWF0aC5QSSAqIG5vcm1hbGl6ZWRMaWZlKTtcbiAgICAgICAgbGV0IGRpc3RUb0NhbSA9IG9iai5tZXNoLnBvc2l0aW9uLmxlbmd0aCgpO1xuICAgICAgICBsZXQgZG9mQmx1ciA9IGRpc3RUb0NhbSA8IHN0YXJNYXhEaXN0YW5jZSAqIDAuNyA/IDAuNyA6IDEuMDtcbiAgICAgICAgb2JqLm1lc2guc2NhbGUuc2V0KHNjYWxlICogZG9mQmx1ciwgc2NhbGUgKiBkb2ZCbHVyLCBzY2FsZSAqIGRvZkJsdXIpO1xuICAgICAgICAvLyBTcGFya2xlIGJ1cnN0XG4gICAgICAgIGlmIChub3JtYWxpemVkTGlmZSA+PSAxICYmICFvYmouaGFzRnJhZ21lbnRlZCkge1xuICAgICAgICAgIC8vIC0tLSBTUEVDVEFDVUxBUiBFWFBMT1NJT04gKHZlcnkgcmFyZSkgLS0tXG4gICAgICAgICAgY29uc3Qgc3BlY3RhY3VsYXIgPSBNYXRoLnJhbmRvbSgpIDwgMC4wMjsgLy8gMiUgY2hhbmNlXG4gICAgICAgICAgY29uc3QgYnVyc3RDb3VudCA9IHNwZWN0YWN1bGFyID8gMTIwICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKjYwKSA6IDE4ICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKjgpO1xuICAgICAgICAgIGNvbnN0IHBhbGV0dGUgPSBzcGVjdGFjdWxhclxuICAgICAgICAgICAgPyBbMHhmZmUwNjYsIDB4ZmY2NmNjLCAweDY2Y2NmZiwgMHhmZmZmZmYsIDB4ODBmZmVhLCAweGZmZjJjYywgMHhmZmMwODAsIDB4ODBjMGZmLCAweGZmODBiMywgMHhmZjAwMDAsIDB4MDBmZjAwLCAweDAwMDBmZiwgMHhmZmZmMDAsIDB4MDBmZmZmLCAweGZmMDBmZiwgMHhmZjg4MDAsIDB4MDBmZjg4LCAweDg4MDBmZl1cbiAgICAgICAgICAgIDogWzB4ZmZmZmZmLCAweGZmZjZjMCwgMHhmZmUwNjYsIDB4ZmZjMDgwLCAweDgwYzBmZl07XG4gICAgICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCBidXJzdENvdW50OyBzKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gcGFsZXR0ZVtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqcGFsZXR0ZS5sZW5ndGgpXTtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBzcGVjdGFjdWxhciA/ICgxLjIgKyBNYXRoLnJhbmRvbSgpKjIuMikgOiAoMC43ICsgTWF0aC5yYW5kb20oKSowLjgpO1xuICAgICAgICAgICAgY29uc3Qgc3BhcmtsZUdlbyA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeShzaXplLCA4LCA4KTtcbiAgICAgICAgICAgIGNvbnN0IHNwYXJrbGVNYXQgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoeyBjb2xvciwgdHJhbnNwYXJlbnQ6IHRydWUsIG9wYWNpdHk6IHNwZWN0YWN1bGFyID8gMC45MiA6IDAuNywgYmxlbmRpbmc6IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmcgfSk7XG4gICAgICAgICAgICBjb25zdCBzcGFya2xlID0gbmV3IFRIUkVFLk1lc2goc3BhcmtsZUdlbywgc3BhcmtsZU1hdCk7XG4gICAgICAgICAgICBzcGFya2xlLnBvc2l0aW9uLmNvcHkob2JqLm1lc2gucG9zaXRpb24pO1xuICAgICAgICAgICAgLy8gU3BlY3RhY3VsYXI6IGh1Z2UsIGZhc3QsIHJhbmRvbSBkaXJlY3Rpb25zOyBub3JtYWw6IG1vZGVyYXRlXG4gICAgICAgICAgICBjb25zdCBzcGQgPSBzcGVjdGFjdWxhciA/ICg0ICsgTWF0aC5yYW5kb20oKSo4KSA6ICgyICsgTWF0aC5yYW5kb20oKSoyKTtcbiAgICAgICAgICAgIGNvbnN0IHNwYXJrbGVWZWwgPSBuZXcgVEhSRUUuVmVjdG9yMyhNYXRoLnJhbmRvbSgpLTAuNSwgTWF0aC5yYW5kb20oKS0wLjUsIE1hdGgucmFuZG9tKCktMC41KS5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhcihzcGQpO1xuICAgICAgICAgICAgc3BhcmtsZS51c2VyRGF0YSA9IHsgdmVsb2NpdHk6IHNwYXJrbGVWZWwsIGFnZTogMCwgc3BlY3RhY3VsYXIsIG1heEFnZTogc3BlY3RhY3VsYXIgPyA4MCArIE1hdGgucmFuZG9tKCkqNDAgOiA0MCArIE1hdGgucmFuZG9tKCkqMjAgfTsgLy8gPC0tIExPTkdFUiBMSUZFXG4gICAgICAgICAgICBzY2VuZS5hZGQoc3BhcmtsZSk7XG4gICAgICAgICAgICBpZiAoIXdpbmRvdy5fc3BhcmtsZXMpIHdpbmRvdy5fc3BhcmtsZXMgPSBbXTtcbiAgICAgICAgICAgIHdpbmRvdy5fc3BhcmtsZXMucHVzaChzcGFya2xlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNwZWN0YWN1bGFyKSB7XG4gICAgICAgICAgICAvLyBBZGQgYSBiaWcgZmxhc2hcbiAgICAgICAgICAgIGNvbnN0IGZsYXNoR2VvID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KDYsIDI0LCAyNCk7XG4gICAgICAgICAgICBjb25zdCBmbGFzaE1hdCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7IGNvbG9yOiAweGZmZmZmZiwgdHJhbnNwYXJlbnQ6IHRydWUsIG9wYWNpdHk6IDAuOCwgYmxlbmRpbmc6IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmcgfSk7XG4gICAgICAgICAgICBjb25zdCBmbGFzaCA9IG5ldyBUSFJFRS5NZXNoKGZsYXNoR2VvLCBmbGFzaE1hdCk7XG4gICAgICAgICAgICBmbGFzaC5wb3NpdGlvbi5jb3B5KG9iai5tZXNoLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIHNjZW5lLmFkZChmbGFzaCk7XG4gICAgICAgICAgICBpZiAoIXdpbmRvdy5fc3RhckZsYXNoZXMpIHdpbmRvdy5fc3RhckZsYXNoZXMgPSBbXTtcbiAgICAgICAgICAgIHdpbmRvdy5fc3RhckZsYXNoZXMucHVzaCh7IG1lc2g6IGZsYXNoLCBhZ2U6IDAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEZyYWdtZW50ZWQgdHJhaWwgbG9naWMgKGtlZXAgYXMgYmVmb3JlKVxuICAgICAgICAgIGNvbnN0IGZyYWdWZWwgPSBvYmoudmVsb2NpdHkuY2xvbmUoKS5hcHBseUF4aXNBbmdsZShuZXcgVEhSRUUuVmVjdG9yMygwLDEsMCksIChNYXRoLnJhbmRvbSgpLTAuNSkqMC4zKTtcbiAgICAgICAgICBjb25zdCBmcmFnU3RhciA9IG9iai5tZXNoLmNsb25lKCk7XG4gICAgICAgICAgZnJhZ1N0YXIucG9zaXRpb24uY29weShvYmoubWVzaC5wb3NpdGlvbik7XG4gICAgICAgICAgZnJhZ1N0YXIudmVsb2NpdHkgPSBmcmFnVmVsO1xuICAgICAgICAgIGZyYWdTdGFyLm5vcm1hbGl6ZWRMaWZlID0gbm9ybWFsaXplZExpZmU7XG4gICAgICAgICAgZnJhZ1N0YXIubm9ybWFsaXplZExpZmV0aW1lID0gb2JqLm5vcm1hbGl6ZWRMaWZldGltZSAqICgwLjUgKyBNYXRoLnJhbmRvbSgpKjAuNSk7XG4gICAgICAgICAgZnJhZ1N0YXIuYWdlID0gb2JqLmFnZTtcbiAgICAgICAgICBmcmFnU3Rhci5tYXRlcmlhbCA9IG9iai5tZXNoLm1hdGVyaWFsLmNsb25lKCk7XG4gICAgICAgICAgY29uc3QgZnJhZ1RyYWlsUG9pbnRzID0gb2JqLnRyYWlsUG9pbnRzLnNsaWNlKCk7XG4gICAgICAgICAgY29uc3QgZnJhZ1RhaWxHZW8gPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKS5zZXRGcm9tUG9pbnRzKGZyYWdUcmFpbFBvaW50cyk7XG4gICAgICAgICAgZnJhZ1RhaWxHZW8uc2V0QXR0cmlidXRlKCdjb2xvcicsIG9iai50YWlsLmdlb21ldHJ5LmdldEF0dHJpYnV0ZSgnY29sb3InKS5jbG9uZSgpKTtcbiAgICAgICAgICBjb25zdCBmcmFnVGFpbE1hdCA9IG9iai50YWlsLm1hdGVyaWFsLmNsb25lKCk7XG4gICAgICAgICAgY29uc3QgZnJhZ1RhaWwgPSBuZXcgVEhSRUUuTGluZShmcmFnVGFpbEdlbywgZnJhZ1RhaWxNYXQpO1xuICAgICAgICAgIGZyYWdUYWlsLnBvc2l0aW9uLmNvcHkoZnJhZ1N0YXIucG9zaXRpb24pO1xuICAgICAgICAgIHNjZW5lLmFkZChmcmFnU3Rhcik7XG4gICAgICAgICAgc2NlbmUuYWRkKGZyYWdUYWlsKTtcbiAgICAgICAgICBzaG9vdGluZ1N0YXJzLnB1c2goeyBtZXNoOiBmcmFnU3RhciwgdGFpbDogZnJhZ1RhaWwsIHZlbG9jaXR5OiBmcmFnU3Rhci52ZWxvY2l0eSwgZGlyOiBvYmouZGlyLCBhZ2U6IGZyYWdTdGFyLmFnZSwgbm9ybWFsaXplZExpZmV0aW1lOiBmcmFnU3Rhci5ub3JtYWxpemVkTGlmZXRpbWUsIHRyYWlsUG9pbnRzOiBmcmFnVHJhaWxQb2ludHMsIGNvbG9yOiBvYmouY29sb3IsIGJyaWdodG5lc3M6IG9iai5icmlnaHRuZXNzLCBoYXNGcmFnbWVudGVkOiB0cnVlIH0pO1xuICAgICAgICAgIG9iai5oYXNGcmFnbWVudGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTcGFyayBidXJzdFxuICAgICAgICBpZiAoIW9iai5oYXNTcGFya2VkICYmIG5vcm1hbGl6ZWRMaWZlID4gMC45NSAmJiBNYXRoLnJhbmRvbSgpIDwgMC4xKSB7XG4gICAgICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCA4ICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKjgpOyBzKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNwYXJrR2VvID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KDAuNSArIE1hdGgucmFuZG9tKCkqMC41LCA4LCA4KTtcbiAgICAgICAgICAgIGNvbnN0IHNwYXJrTWF0ID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHsgY29sb3I6IDB4ZmZmNmMwLCB0cmFuc3BhcmVudDogdHJ1ZSwgb3BhY2l0eTogMSwgYmxlbmRpbmc6IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmcgfSk7XG4gICAgICAgICAgICBjb25zdCBzcGFyayA9IG5ldyBUSFJFRS5NZXNoKHNwYXJrR2VvLCBzcGFya01hdCk7XG4gICAgICAgICAgICBzcGFyay5wb3NpdGlvbi5jb3B5KG9iai5tZXNoLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIHNwYXJrLnNwYXJrVmVsID0gbmV3IFRIUkVFLlZlY3RvcjMoTWF0aC5yYW5kb20oKS0wLjUsIE1hdGgucmFuZG9tKCktMC41LCBNYXRoLnJhbmRvbSgpLTAuNSkubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoMC41ICsgTWF0aC5yYW5kb20oKSoxLjIpO1xuICAgICAgICAgICAgc3Bhcmsuc3BhcmtMaWZlID0gMTIgKyBNYXRoLnJhbmRvbSgpKjEwO1xuICAgICAgICAgICAgc3Bhcmsuc3BhcmtBZ2UgPSAwO1xuICAgICAgICAgICAgc2NlbmUuYWRkKHNwYXJrKTtcbiAgICAgICAgICAgIGlmICghd2luZG93Ll9zdGFyU3BhcmtzKSB3aW5kb3cuX3N0YXJTcGFya3MgPSBbXTtcbiAgICAgICAgICAgIHdpbmRvdy5fc3RhclNwYXJrcy5wdXNoKHNwYXJrKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2JqLmhhc1NwYXJrZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZsYXNoXG4gICAgICAgIGlmICghb2JqLmhhc0ZsYXNoZWQgJiYgbm9ybWFsaXplZExpZmUgPiAwLjk4ICYmIE1hdGgucmFuZG9tKCkgPCAwLjIpIHtcbiAgICAgICAgICBjb25zdCBmbGFzaEdlbyA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeSgxLCAxNiwgMTYpO1xuICAgICAgICAgIGNvbnN0IGZsYXNoTWF0ID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHsgY29sb3I6IDB4ZmZmZmVlLCB0cmFuc3BhcmVudDogdHJ1ZSwgb3BhY2l0eTogMC44LCBibGVuZGluZzogVEhSRUUuQWRkaXRpdmVCbGVuZGluZyB9KTtcbiAgICAgICAgICBjb25zdCBmbGFzaCA9IG5ldyBUSFJFRS5NZXNoKGZsYXNoR2VvLCBmbGFzaE1hdCk7XG4gICAgICAgICAgZmxhc2gucG9zaXRpb24uY29weShvYmoubWVzaC5wb3NpdGlvbik7XG4gICAgICAgICAgc2NlbmUuYWRkKGZsYXNoKTtcbiAgICAgICAgICBpZiAoIXdpbmRvdy5fc3RhckZsYXNoZXMpIHdpbmRvdy5fc3RhckZsYXNoZXMgPSBbXTtcbiAgICAgICAgICB3aW5kb3cuX3N0YXJGbGFzaGVzLnB1c2goeyBtZXNoOiBmbGFzaCwgYWdlOiAwIH0pO1xuICAgICAgICAgIG9iai5oYXNGbGFzaGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGYWRlIG91dCBhcyBpdCBnZXRzIGZhciBhd2F5XG4gICAgICAgIGNvbnN0IGRpc3QgPSBvYmoubWVzaC5wb3NpdGlvbi5kaXN0YW5jZVRvKGNhbWVyYS5wb3NpdGlvbik7XG4gICAgICAgIGNvbnN0IGZhZGVTdGFydCA9IHN0YXJNYXhEaXN0YW5jZSAqIDAuNTtcbiAgICAgICAgaWYgKGRpc3QgPiBmYWRlU3RhcnQpIHtcbiAgICAgICAgICBjb25zdCBmYWRlID0gMSAtIChkaXN0IC0gZmFkZVN0YXJ0KSAvIChzdGFyTWF4RGlzdGFuY2UgLSBmYWRlU3RhcnQpO1xuICAgICAgICAgIG9iai5tZXNoLm1hdGVyaWFsLm9wYWNpdHkgPSBNYXRoLm1heCgwLCBmYWRlKTtcbiAgICAgICAgICBvYmoubWVzaC5tYXRlcmlhbC50cmFuc3BhcmVudCA9IHRydWU7XG4gICAgICAgICAgb2JqLnRhaWwubWF0ZXJpYWwub3BhY2l0eSA9IE1hdGgubWF4KDAsIGZhZGUgKiAwLjgpO1xuICAgICAgICAgIG9iai50YWlsLm1hdGVyaWFsLnRyYW5zcGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgd2hlbiBvdXQgb2YgYm91bmRzIG9yIGZ1bGx5IGZhZGVkIG9yIGxpZmUgZW5kZWRcbiAgICAgICAgLy8gRmFkZSB0YWlsIGFmdGVyIGV4cGxvc2lvblxuICAgICAgICBpZiAoKG5vcm1hbGl6ZWRMaWZlID49IDEuMCB8fCBkaXN0ID4gc3Rhck1heERpc3RhbmNlIHx8IG9iai5tZXNoLm1hdGVyaWFsLm9wYWNpdHkgPD0gMC4wMSkgJiYgIW9iai50YWlsRmFkaW5nKSB7XG4gICAgICAgICAgc2NlbmUucmVtb3ZlKG9iai5tZXNoKTtcbiAgICAgICAgICAvLyBTdGFydCB0YWlsIGZhZGUtb3V0IGdob3N0XG4gICAgICAgICAgb2JqLnRhaWxGYWRpbmcgPSB0cnVlO1xuICAgICAgICAgIG9iai50YWlsRmFkZUFnZSA9IDA7XG4gICAgICAgICAgaWYgKCF3aW5kb3cuX2ZhZGluZ1RhaWxzKSB3aW5kb3cuX2ZhZGluZ1RhaWxzID0gW107XG4gICAgICAgICAgd2luZG93Ll9mYWRpbmdUYWlscy5wdXNoKHsgdGFpbDogb2JqLnRhaWwsIHRhaWxCbG9vbTogb2JqLnRhaWxCbG9vbSwgYWdlOiAwIH0pO1xuICAgICAgICAgIHNob290aW5nU3RhcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBBbmltYXRlIHNwYXJrc1xuICAgICAgaWYgKHdpbmRvdy5fc3RhclNwYXJrcykge1xuICAgICAgICBmb3IgKGxldCBpID0gd2luZG93Ll9zdGFyU3BhcmtzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgY29uc3Qgc3BhcmsgPSB3aW5kb3cuX3N0YXJTcGFya3NbaV07XG4gICAgICAgICAgc3BhcmsucG9zaXRpb24uYWRkKHNwYXJrLnNwYXJrVmVsKTtcbiAgICAgICAgICBzcGFyay5zcGFya0FnZSsrO1xuICAgICAgICAgIHNwYXJrLm1hdGVyaWFsLm9wYWNpdHkgKj0gMC45MjtcbiAgICAgICAgICBpZiAoc3Bhcmsuc3BhcmtBZ2UgPiBzcGFyay5zcGFya0xpZmUpIHtcbiAgICAgICAgICAgIHNjZW5lLnJlbW92ZShzcGFyayk7XG4gICAgICAgICAgICB3aW5kb3cuX3N0YXJTcGFya3Muc3BsaWNlKGksIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQW5pbWF0ZSBleHBsb3Npb24gcGFydGljbGVzIChzcGFya2xlcylcbiAgICAgIGlmICh3aW5kb3cuX3NwYXJrbGVzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB3aW5kb3cuX3NwYXJrbGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgY29uc3Qgc3BhcmtsZSA9IHdpbmRvdy5fc3BhcmtsZXNbaV07XG4gICAgICAgICAgc3BhcmtsZS5wb3NpdGlvbi5hZGQoc3BhcmtsZS51c2VyRGF0YS52ZWxvY2l0eSk7XG4gICAgICAgICAgc3BhcmtsZS51c2VyRGF0YS5hZ2UrKztcbiAgICAgICAgICBzcGFya2xlLm1hdGVyaWFsLm9wYWNpdHkgKj0gMC45NztcbiAgICAgICAgICBpZiAoc3BhcmtsZS51c2VyRGF0YS5hZ2UgPiAoc3BhcmtsZS51c2VyRGF0YS5tYXhBZ2UgfHwgNDApKSB7XG4gICAgICAgICAgICBzY2VuZS5yZW1vdmUoc3BhcmtsZSk7XG4gICAgICAgICAgICB3aW5kb3cuX3NwYXJrbGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEFuaW1hdGUgZmFkaW5nIHRhaWxzIChnaG9zdHMpXG4gICAgICBpZiAod2luZG93Ll9mYWRpbmdUYWlscykge1xuICAgICAgICBmb3IgKGxldCBpID0gd2luZG93Ll9mYWRpbmdUYWlscy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGNvbnN0IGdob3N0ID0gd2luZG93Ll9mYWRpbmdUYWlsc1tpXTtcbiAgICAgICAgICBpZiAoZ2hvc3QudGFpbCkge1xuICAgICAgICAgICAgZ2hvc3QudGFpbC5tYXRlcmlhbC5vcGFjaXR5ICo9IDAuOTI7XG4gICAgICAgICAgICBpZiAoZ2hvc3QudGFpbC5tYXRlcmlhbC5vcGFjaXR5IDwgMC4wMSkge1xuICAgICAgICAgICAgICBzY2VuZS5yZW1vdmUoZ2hvc3QudGFpbCk7XG4gICAgICAgICAgICAgIHdpbmRvdy5fZmFkaW5nVGFpbHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGdob3N0LnRhaWxCbG9vbSkge1xuICAgICAgICAgICAgZ2hvc3QudGFpbEJsb29tLm1hdGVyaWFsLm9wYWNpdHkgKj0gMC45MjtcbiAgICAgICAgICAgIGlmIChnaG9zdC50YWlsQmxvb20ubWF0ZXJpYWwub3BhY2l0eSA8IDAuMDEpIHtcbiAgICAgICAgICAgICAgc2hvb3RpbmdTdGFyU2NlbmUucmVtb3ZlKGdob3N0LnRhaWxCbG9vbSk7XG4gICAgICAgICAgICAgIGdob3N0LnRhaWxCbG9vbSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGdob3N0LmFnZSsrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEFuaW1hdGUgZmxhc2hlc1xuICAgICAgaWYgKHdpbmRvdy5fc3RhckZsYXNoZXMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHdpbmRvdy5fc3RhckZsYXNoZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBjb25zdCBmbGFzaCA9IHdpbmRvdy5fc3RhckZsYXNoZXNbaV07XG4gICAgICAgICAgZmxhc2gubWVzaC5zY2FsZS5tdWx0aXBseVNjYWxhcigxLjE1KTtcbiAgICAgICAgICBmbGFzaC5tZXNoLm1hdGVyaWFsLm9wYWNpdHkgKj0gMC44NTtcbiAgICAgICAgICBmbGFzaC5hZ2UrKztcbiAgICAgICAgICBpZiAoZmxhc2guYWdlID4gMTApIHtcbiAgICAgICAgICAgIHNjZW5lLnJlbW92ZShmbGFzaC5tZXNoKTtcbiAgICAgICAgICAgIHdpbmRvdy5fc3RhckZsYXNoZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyAtLS0gU3RhcmZpZWxkIGxvZ2ljIC0tLVxuICAgICAgY29uc3Qgc3FEaXN0ID0gc3Rhck1heERpc3RhbmNlICogc3Rhck1heERpc3RhbmNlO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3NpdGlvbnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgY29uc3QgZHggPSBwb3NpdGlvbnNbaV0gLSB2aXJ0dWFsQ2FtZXJhUG9zLng7XG4gICAgICAgIGNvbnN0IGR5ID0gcG9zaXRpb25zW2kgKyAxXSAtIHZpcnR1YWxDYW1lcmFQb3MueTtcbiAgICAgICAgY29uc3QgZHogPSBwb3NpdGlvbnNbaSArIDJdIC0gdmlydHVhbENhbWVyYVBvcy56O1xuICAgICAgICBpZiAoZHgqZHggKyBkeSpkeSArIGR6KmR6ID4gc3FEaXN0KSB7XG4gICAgICAgICAgLy8gUGxhY2UgaW4gYSB0aGljayBzcGhlcmljYWwgc2hlbGwgYXJvdW5kIHRoZSB2aXJ0dWFsIGNhbWVyYSwgbmV2ZXIgdG9vIGNsb3NlXG4gICAgICAgICAgY29uc3QgbWluUmFkaXVzID0gc3Rhck1heERpc3RhbmNlICogMC44O1xuICAgICAgICAgIGNvbnN0IG1heFJhZGl1cyA9IHN0YXJNYXhEaXN0YW5jZTtcbiAgICAgICAgICBjb25zdCByID0gbWluUmFkaXVzICsgTWF0aC5yYW5kb20oKSAqIChtYXhSYWRpdXMgLSBtaW5SYWRpdXMpO1xuICAgICAgICAgIGNvbnN0IHRoZXRhID0gTWF0aC5yYW5kb20oKSAqIDIgKiBNYXRoLlBJO1xuICAgICAgICAgIGNvbnN0IHBoaSA9IE1hdGguYWNvcygyICogTWF0aC5yYW5kb20oKSAtIDEpO1xuICAgICAgICAgIHBvc2l0aW9uc1tpXSA9IHZpcnR1YWxDYW1lcmFQb3MueCArIHIgKiBNYXRoLnNpbihwaGkpICogTWF0aC5jb3ModGhldGEpO1xuICAgICAgICAgIHBvc2l0aW9uc1tpKzFdID0gdmlydHVhbENhbWVyYVBvcy55ICsgciAqIE1hdGguc2luKHBoaSkgKiBNYXRoLnNpbih0aGV0YSk7XG4gICAgICAgICAgcG9zaXRpb25zW2krMl0gPSB2aXJ0dWFsQ2FtZXJhUG9zLnogKyByICogTWF0aC5jb3MocGhpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7IC8vIEFscmVhZHkgc2V0IGFib3ZlXG4gIFxuICAgICAgLy8gUm9idXN0IHN0YXJmaWVsZCBjb2xvciB1cGRhdGUgdG8gcHJldmVudCBzdHVjayB3aGl0ZSBkb3RzXG4gICAgICAvLyBUaGlzIHdvcmtzIE5PIFRPVUNIWVxuICAgICAgY29uc3QgY29sQXJyID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvci5hcnJheTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IGkgLyAzO1xuICAgICAgICBjb25zdCBkeCA9IHBvc2l0aW9uc1tpXSAtIHZpcnR1YWxDYW1lcmFQb3MueDtcbiAgICAgICAgY29uc3QgZHkgPSBwb3NpdGlvbnNbaSArIDFdIC0gdmlydHVhbENhbWVyYVBvcy55O1xuICAgICAgICBjb25zdCBkeiA9IHBvc2l0aW9uc1tpICsgMl0gLSB2aXJ0dWFsQ2FtZXJhUG9zLno7XG4gICAgICAgIGNvbnN0IGRpc3QgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkgKyBkeiAqIGR6KTtcbiAgICAgICAgaWYgKHRpbWVyc1tpZHhdID4gMCkge1xuICAgICAgICAgIHRpbWVyc1tpZHhdLS07XG4gICAgICAgICAgaWYgKHRpbWVyc1tpZHhdID09PSAwKSB7XG4gICAgICAgICAgICAvLyBUaW1lciBleHBpcmVkLCByZXN0b3JlIGNvbG9yXG4gICAgICAgICAgICBzcGFya0NvbG9yc1tpXSA9IG9yaWdpbmFsQ29sb3JzW2ldO1xuICAgICAgICAgICAgc3BhcmtDb2xvcnNbaSsxXSA9IG9yaWdpbmFsQ29sb3JzW2krMV07XG4gICAgICAgICAgICBzcGFya0NvbG9yc1tpKzJdID0gb3JpZ2luYWxDb2xvcnNbaSsyXTtcbiAgICAgICAgICAgIGNvbEFycltpXSA9IG9yaWdpbmFsQ29sb3JzW2ldO1xuICAgICAgICAgICAgY29sQXJyW2krMV0gPSBvcmlnaW5hbENvbG9yc1tpKzFdO1xuICAgICAgICAgICAgY29sQXJyW2krMl0gPSBvcmlnaW5hbENvbG9yc1tpKzJdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2xBcnJbaV0gPSBzcGFya0NvbG9yc1tpXTtcbiAgICAgICAgICAgIGNvbEFycltpKzFdID0gc3BhcmtDb2xvcnNbaSsxXTtcbiAgICAgICAgICAgIGNvbEFycltpKzJdID0gc3BhcmtDb2xvcnNbaSsyXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZGlzdCA+IHN0YXJNYXhEaXN0YW5jZSAqIDAuMyAmJiBNYXRoLnJhbmRvbSgpIDwgMC4wNSkge1xuICAgICAgICAgIHRpbWVyc1tpZHhdID0gc3BhcmtsZUR1cmF0aW9uO1xuICAgICAgICAgIGNvbnN0IGMgPSBwYWxldHRlW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHBhbGV0dGUubGVuZ3RoKV07XG4gICAgICAgICAgc3BhcmtDb2xvcnNbaV0gPSBjWzBdO1xuICAgICAgICAgIHNwYXJrQ29sb3JzW2krMV0gPSBjWzFdO1xuICAgICAgICAgIHNwYXJrQ29sb3JzW2krMl0gPSBjWzJdO1xuICAgICAgICAgIGNvbEFycltpXSA9IHNwYXJrQ29sb3JzW2ldO1xuICAgICAgICAgIGNvbEFycltpKzFdID0gc3BhcmtDb2xvcnNbaSsxXTtcbiAgICAgICAgICBjb2xBcnJbaSsyXSA9IHNwYXJrQ29sb3JzW2krMl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3BhcmtDb2xvcnNbaV0gPSBvcmlnaW5hbENvbG9yc1tpXTtcbiAgICAgICAgICBzcGFya0NvbG9yc1tpKzFdID0gb3JpZ2luYWxDb2xvcnNbaSsxXTtcbiAgICAgICAgICBzcGFya0NvbG9yc1tpKzJdID0gb3JpZ2luYWxDb2xvcnNbaSsyXTtcbiAgICAgICAgICBjb2xBcnJbaV0gPSBvcmlnaW5hbENvbG9yc1tpXTtcbiAgICAgICAgICBjb2xBcnJbaSsxXSA9IG9yaWdpbmFsQ29sb3JzW2krMV07XG4gICAgICAgICAgY29sQXJyW2krMl0gPSBvcmlnaW5hbENvbG9yc1tpKzJdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBnZW9tZXRyeS5hdHRyaWJ1dGVzLmNvbG9yLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9O1xuICAgIFxuICAgIC8vIFN0YXJ0IHRoZSBhbmltYXRpb24gbG9vcFxuICAgIGFuaW1hdGUoKTtcbiAgICBcbiAgICAvLyBIYW5kbGUgd2luZG93IHJlc2l6ZVxuICAgIGNvbnN0IG9uUmVzaXplID0gKCkgPT4ge1xuICAgICAgY2FtZXJhLmFzcGVjdCA9IHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAgIHJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgICBzaG9vdGluZ1N0YXJDb21wb3Nlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgICAgY2FDb21wb3Nlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIH07XG4gICAgLy8gQWRkIGV2ZW50IGxpc3RlbmVyIGZvciByZXNpemVcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25SZXNpemUpO1xuICAgIFxuICAgIC8vIENsZWFuIHVwIGZ1bmN0aW9uXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvblJlc2l6ZSk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplQWxsKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdmdWxsc2NyZWVuY2hhbmdlJywgcmVzaXplQWxsKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBvblNjcm9sbCk7XG4gICAgICAvLyBDYW5jZWwgdGhlIGFuaW1hdGlvbiBmcmFtZSB1c2luZyB0aGUgc3RvcmVkIElEXG4gICAgICBpZiAoYW5pbWF0aW9uSWQpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uSWQpO1xuICAgICAgfVxuICAgICAgLy8gRGlzcG9zZSBjb21wb3NlcnMsIHJlbmRlcmVyLCBldGMuIChyZXN0IG9mIHlvdXIgY2xlYW51cClcbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPGRpdiByZWY9e21vdW50UmVmfSBzdHlsZT17eyB3aWR0aDogJzEwMHZ3JywgaGVpZ2h0OiAnMTAwdmgnLCBwb3NpdGlvbjogJ2ZpeGVkJywgdG9wOiAwLCBsZWZ0OiAwLCB6SW5kZXg6IDAgfX0gLz5cbiAgICAgIDxkaXYgc3R5bGU9e3tcbiAgICAgICAgcG9zaXRpb246ICdmaXhlZCcsIGxlZnQ6IDAsIHRvcDogMCwgd2lkdGg6ICcxMDB2dycsIGhlaWdodDogJzEwdmgnLCBiYWNrZ3JvdW5kOiAnYmxhY2snLCB6SW5kZXg6IDEwLFxuICAgICAgICBvcGFjaXR5OiBiYXJzVmlzaWJsZSA/IDAuOTUgOiAwLFxuICAgICAgICB0cmFuc2Zvcm06IGJhcnNWaXNpYmxlID8gJ3RyYW5zbGF0ZVkoMCknIDogJ3RyYW5zbGF0ZVkoLTEwMCUpJyxcbiAgICAgICAgdHJhbnNpdGlvbjogJ3RyYW5zZm9ybSAwLjNzIGN1YmljLWJlemllcigwLjc3LDAsMC4xNzUsMSksIG9wYWNpdHkgMC4zcycsXG4gICAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJ1xuICAgICAgfX0gLz5cbiAgICAgIDxkaXYgc3R5bGU9e3tcbiAgICAgICAgcG9zaXRpb246ICdmaXhlZCcsIGxlZnQ6IDAsIGJvdHRvbTogMCwgd2lkdGg6ICcxMDB2dycsIGhlaWdodDogJzEwdmgnLCBiYWNrZ3JvdW5kOiAnYmxhY2snLCB6SW5kZXg6IDEwLFxuICAgICAgICBvcGFjaXR5OiBiYXJzVmlzaWJsZSA/IDAuOTUgOiAwLFxuICAgICAgICB0cmFuc2Zvcm06IGJhcnNWaXNpYmxlID8gJ3RyYW5zbGF0ZVkoMCknIDogJ3RyYW5zbGF0ZVkoMTAwJSknLFxuICAgICAgICB0cmFuc2l0aW9uOiAndHJhbnNmb3JtIDAuM3MgY3ViaWMtYmV6aWVyKDAuNzcsMCwwLjE3NSwxKSwgb3BhY2l0eSAwLjNzJyxcbiAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnXG4gICAgICB9fSAvPlxuICAgIDwvPlxuICApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBTdGFyZmllbGQ7XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsIlRIUkVFIiwiRWZmZWN0Q29tcG9zZXIiLCJVbnJlYWxCbG9vbVBhc3MiLCJSZW5kZXJQYXNzIiwiU2hhZGVyUGFzcyIsIkZYQUFTaGFkZXIiLCJGaWxtUGFzcyIsIkNocm9tYXRpY0FiZXJyYXRpb25QYXNzIiwiU3RhcmZpZWxkIiwibW91bnRSZWYiLCJjaW5lbWF0aWMiLCJzZXRDaW5lbWF0aWMiLCJiYXJzVmlzaWJsZSIsInNldEJhcnNWaXNpYmxlIiwib25LZXlEb3duIiwiZSIsImtleSIsImMiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiY3VycmVudCIsIm1vdW50Iiwic3R5bGUiLCJwb3NpdGlvbiIsInRvcCIsImxlZnQiLCJ3aWR0aCIsImhlaWdodCIsInpJbmRleCIsInNjZW5lIiwiU2NlbmUiLCJjYW1lcmEiLCJQZXJzcGVjdGl2ZUNhbWVyYSIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsInNldCIsInZpcnR1YWxDYW1lcmFQb3MiLCJWZWN0b3IzIiwicmVuZGVyZXIiLCJXZWJHTFJlbmRlcmVyIiwiYW50aWFsaWFzIiwic2V0UGl4ZWxSYXRpbyIsImRldmljZVBpeGVsUmF0aW8iLCJzZXRTaXplIiwic2V0Q2xlYXJDb2xvciIsIm91dHB1dENvbG9yU3BhY2UiLCJTUkdCQ29sb3JTcGFjZSIsInJlbmRlclRhcmdldCIsIldlYkdMUmVuZGVyVGFyZ2V0IiwiY29sb3JTcGFjZSIsInR5cGUiLCJVbnNpZ25lZEJ5dGVUeXBlIiwidG9uZU1hcHBpbmciLCJOb1RvbmVNYXBwaW5nIiwiYXV0b0NsZWFyIiwiYXBwZW5kQ2hpbGQiLCJkb21FbGVtZW50IiwiY29tcG9zZXIiLCJyZW5kZXJQYXNzIiwiY2xlYXIiLCJhZGRQYXNzIiwiYmxvb21QYXNzIiwiVmVjdG9yMiIsImZpbG1QYXNzIiwic2hvb3RpbmdTdGFyU2NlbmUiLCJzaG9vdGluZ1N0YXJDb21wb3NlciIsInNob290aW5nU3RhclJlbmRlclBhc3MiLCJzaG9vdGluZ1N0YXJCbG9vbVBhc3MiLCJjbG9zZVN0YXJzU2NlbmUiLCJjYVBhc3MiLCJjYUNvbXBvc2VyIiwiY2FSZW5kZXJQYXNzIiwicmVzaXplQWxsIiwiYXNwZWN0IiwidXBkYXRlUHJvamVjdGlvbk1hdHJpeCIsInN0YXJDb3VudCIsInN0YXJNYXhEaXN0YW5jZSIsInN0YXJNaW5EaXN0YW5jZSIsInN0YXJTcGVlZCIsImdlb21ldHJ5IiwiQnVmZmVyR2VvbWV0cnkiLCJjbG9zZUdlb21ldHJ5IiwicG9zaXRpb25zIiwiY2xvc2VQb3NpdGlvbnMiLCJzdGFyQWdlcyIsImZhZGVEdXJhdGlvbiIsImNsb3NlU3RhckNvdW50IiwiaSIsInRoZXRhIiwiTWF0aCIsInJhbmRvbSIsIlBJIiwicGhpIiwiYWNvcyIsInIiLCJ4Iiwic2luIiwiY29zIiwieSIsInoiLCJwdXNoIiwic3RhcnNQbGFjZWQiLCJjbHVzdGVyVGhldGEiLCJjbHVzdGVyUGhpIiwiY2x1c3RlclIiLCJjbHVzdGVyQ2VudGVyIiwiY2x1c3RlclNpemUiLCJmbG9vciIsIm9mZnNldFRoZXRhIiwib2Zmc2V0UGhpIiwib2Zmc2V0UiIsInNldEF0dHJpYnV0ZSIsIkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUiLCJhbHBoYXMiLCJGbG9hdDMyQXJyYXkiLCJsZW5ndGgiLCJmaWxsIiwiQnVmZmVyQXR0cmlidXRlIiwicGFsZXR0ZSIsImNvbG9ycyIsIm9yaWdpbmFsQ29sb3JzIiwiYXR0cmlidXRlcyIsImNvbG9yIiwiYXJyYXkiLCJzbGljZSIsInRpbWVycyIsInNwYXJrQ29sb3JzIiwic3BhcmtsZUR1cmF0aW9uIiwibWF0ZXJpYWwiLCJQb2ludHNNYXRlcmlhbCIsInNpemUiLCJzaXplQXR0ZW51YXRpb24iLCJ2ZXJ0ZXhDb2xvcnMiLCJ0cmFuc3BhcmVudCIsIm9uQmVmb3JlQ29tcGlsZSIsInNoYWRlciIsInZlcnRleFNoYWRlciIsInJlcGxhY2UiLCJmcmFnbWVudFNoYWRlciIsInN0YXJzIiwiUG9pbnRzIiwiYWRkIiwiZ2xvd01hcCIsIlRleHR1cmVMb2FkZXIiLCJsb2FkIiwiZ2xvd1Nwcml0ZXMiLCJnbG93TWF0ZXJpYWwiLCJTcHJpdGVNYXRlcmlhbCIsIm1hcCIsIm9wYWNpdHkiLCJibGVuZGluZyIsIkFkZGl0aXZlQmxlbmRpbmciLCJkZXB0aFdyaXRlIiwiZ2xvdyIsIlNwcml0ZSIsImNsb25lIiwic2NhbGUiLCJjbG9zZVN0YXJzIiwidGFyZ2V0WSIsImRhbXBpbmciLCJvblNjcm9sbCIsInBjdCIsInNjcm9sbFkiLCJkb2N1bWVudCIsImJvZHkiLCJzY3JvbGxIZWlnaHQiLCJ0YWlsTGVuZ3RoIiwic2hvb3RpbmdTdGFycyIsInNob290aW5nU3RhckNvb2xkb3duIiwic3Bhd25TaG9vdGluZ1N0YXIiLCJkaXIiLCJub3JtYWxpemUiLCJtaW5EaXN0IiwibWF4RGlzdCIsImRpc3QiLCJzcGF3blBvcyIsIm11bHRpcGx5U2NhbGFyIiwidGFuZ2VudCIsInN1YiIsInByb2plY3RPblZlY3RvciIsInRhbmdlbnRpYWxTcGVlZCIsInJhZGlhbFNwZWVkIiwidmVsb2NpdHkiLCJ2aWJyYW50Q29sb3JzIiwiYnJpZ2h0bmVzcyIsImdlbyIsIlNwaGVyZUdlb21ldHJ5IiwibWF0IiwiTWVzaFBoeXNpY2FsTWF0ZXJpYWwiLCJlbWlzc2l2ZSIsImVtaXNzaXZlSW50ZW5zaXR5IiwibWV0YWxuZXNzIiwicm91Z2huZXNzIiwidHJhbnNtaXNzaW9uIiwiY2xlYXJjb2F0IiwiY2xlYXJjb2F0Um91Z2huZXNzIiwic3RhciIsIk1lc2giLCJzcHJpdGVNYXAiLCJzcHJpdGVNYXRlcmlhbCIsInNwcml0ZSIsImNvcHkiLCJjb2xvclNwcml0ZU1hdGVyaWFsIiwiY29sb3JTcHJpdGUiLCJzcGFya0NvdW50Iiwic3BhcmtHcm91cCIsIkdyb3VwIiwic3BhcmtNYXQiLCJNZXNoQmFzaWNNYXRlcmlhbCIsInNwYXJrR2VvIiwic3BhcmsiLCJhbmdsZSIsIm5hbWUiLCJub3JtYWxpemVkTGlmZSIsIm5vcm1hbGl6ZWRMaWZldGltZSIsImFnZSIsInRyYWlsU2VnbWVudHMiLCJ0cmFpbFBvaW50cyIsInNwaXJhbCIsImN1cnZlIiwicHQiLCJ0YWlsR2VvIiwic2V0RnJvbVBvaW50cyIsInRhaWxDb2xvcnMiLCJhbHBoYSIsInJhaW5ib3ciLCJncmFkQ29sb3IiLCJ0YWlsTWF0IiwiTGluZUJhc2ljTWF0ZXJpYWwiLCJ0YWlsTWF0TWFpbiIsIk5vcm1hbEJsZW5kaW5nIiwidGFpbE1haW4iLCJMaW5lIiwidGFpbE1hdEJsb29tIiwidGFpbEJsb29tIiwidGFpbEdsb3dNYXAiLCJ0YWlsR2xvd01hdCIsInRhaWxHbG93IiwibWVzaCIsInRhaWwiLCJoYXNGcmFnbWVudGVkIiwiYW5pbWF0aW9uSWQiLCJhbmltYXRlIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibmVlZHNVcGRhdGUiLCJuZWVkc0FscGhhVXBkYXRlIiwibWluIiwiaWR4IiwicmVuZGVyIiwicm90YXRpb24iLCJmb3J3YXJkIiwiZ2V0V29ybGREaXJlY3Rpb24iLCJjb2xvckF0dHIiLCJvcmlnUiIsIm9yaWdHIiwib3JpZ0IiLCJzcXJ0IiwicG93IiwiaW50ZW5zZVIiLCJpbnRlbnNlRyIsImludGVuc2VCIiwiZmFkZVQiLCJtYXgiLCJzaGFrZVN0cmVuZ3RoIiwib2JqIiwiY2hpbGRyZW4iLCJzcGFya3MiLCJmaW5kIiwiY2hpbGQiLCJqIiwidGltZSIsInBlcmZvcm1hbmNlIiwibm93IiwiZ2V0QXR0cmlidXRlIiwiayIsImNvdW50IiwiZ2V0WCIsImciLCJnZXRZIiwiYiIsImdldFoiLCJoIiwicyIsImwiLCJkIiwicSIsInAiLCJ0ciIsInRnIiwidGIiLCJodWUycmdiIiwidCIsInNldFgiLCJzZXRZIiwic2V0WiIsInNldFciLCJnZXRXIiwidW5zaGlmdCIsInBvcCIsInRhaWxHcm93IiwiYWN0aXZlU2VnbWVudHMiLCJ2aXNpYmxlVHJhaWwiLCJ0YWlsQ29sb3JzQmxvb20iLCJEYXRlIiwic2V0WFlaVyIsImhlYWRDb2xvciIsIkNvbG9yIiwibGVycCIsImZsaWNrZXIiLCJkaXN0VG9DYW0iLCJkb2ZCbHVyIiwic3BlY3RhY3VsYXIiLCJidXJzdENvdW50Iiwic3BhcmtsZUdlbyIsInNwYXJrbGVNYXQiLCJzcGFya2xlIiwic3BkIiwic3BhcmtsZVZlbCIsInVzZXJEYXRhIiwibWF4QWdlIiwiX3NwYXJrbGVzIiwiZmxhc2hHZW8iLCJmbGFzaE1hdCIsImZsYXNoIiwiX3N0YXJGbGFzaGVzIiwiZnJhZ1ZlbCIsImFwcGx5QXhpc0FuZ2xlIiwiZnJhZ1N0YXIiLCJmcmFnVHJhaWxQb2ludHMiLCJmcmFnVGFpbEdlbyIsImZyYWdUYWlsTWF0IiwiZnJhZ1RhaWwiLCJoYXNTcGFya2VkIiwic3BhcmtWZWwiLCJzcGFya0xpZmUiLCJzcGFya0FnZSIsIl9zdGFyU3BhcmtzIiwiaGFzRmxhc2hlZCIsImRpc3RhbmNlVG8iLCJmYWRlU3RhcnQiLCJmYWRlIiwidGFpbEZhZGluZyIsInJlbW92ZSIsInRhaWxGYWRlQWdlIiwiX2ZhZGluZ1RhaWxzIiwic3BsaWNlIiwiZ2hvc3QiLCJzcURpc3QiLCJkeCIsImR5IiwiZHoiLCJtaW5SYWRpdXMiLCJtYXhSYWRpdXMiLCJjb2xBcnIiLCJvblJlc2l6ZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiZGl2IiwicmVmIiwiYmFja2dyb3VuZCIsInRyYW5zZm9ybSIsInRyYW5zaXRpb24iLCJwb2ludGVyRXZlbnRzIiwiYm90dG9tIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/Starfield.jsx\n"));

/***/ })

});