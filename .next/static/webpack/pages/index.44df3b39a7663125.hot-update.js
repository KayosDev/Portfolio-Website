"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./components/Starfield.jsx":
/*!**********************************!*\
  !*** ./components/Starfield.jsx ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var three_examples_jsm_postprocessing_EffectComposer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three/examples/jsm/postprocessing/EffectComposer */ \"./node_modules/three/examples/jsm/postprocessing/EffectComposer.js\");\n/* harmony import */ var three_examples_jsm_postprocessing_UnrealBloomPass__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three/examples/jsm/postprocessing/UnrealBloomPass */ \"./node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js\");\n/* harmony import */ var three_examples_jsm_postprocessing_RenderPass__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three/examples/jsm/postprocessing/RenderPass */ \"./node_modules/three/examples/jsm/postprocessing/RenderPass.js\");\n/* harmony import */ var _ChromaticAberrationPass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ChromaticAberrationPass */ \"./components/ChromaticAberrationPass.js\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\nconst Starfield = ()=>{\n    _s();\n    const mountRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // Defensive: always use .current for refs\n        if (!mountRef.current) return;\n        const mount = mountRef.current;\n        mount.style.position = \"fixed\";\n        mount.style.top = \"0\";\n        mount.style.left = \"0\";\n        mount.style.width = \"100%\";\n        mount.style.height = \"100%\";\n        mount.style.zIndex = \"0\";\n        // Scene & Renderer\n        const scene = new three__WEBPACK_IMPORTED_MODULE_3__.Scene();\n        const camera = new three__WEBPACK_IMPORTED_MODULE_3__.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);\n        camera.position.set(0, 0, 0);\n        // Virtual position to simulate infinite travel\n        let virtualCameraPos = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(0, 0, 0);\n        const renderer = new three__WEBPACK_IMPORTED_MODULE_3__.WebGLRenderer({\n            antialias: true\n        });\n        renderer.setPixelRatio(window.devicePixelRatio);\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        renderer.setClearColor(0x000000, 1);\n        mount.appendChild(renderer.domElement);\n        // --- POSTPROCESSING ---\n        // Composer\n        const composer = new three_examples_jsm_postprocessing_EffectComposer__WEBPACK_IMPORTED_MODULE_4__.EffectComposer(renderer);\n        composer.setSize(window.innerWidth, window.innerHeight);\n        // Render pass\n        const renderPass = new three_examples_jsm_postprocessing_RenderPass__WEBPACK_IMPORTED_MODULE_5__.RenderPass(scene, camera);\n        composer.addPass(renderPass);\n        // Unreal Bloom Pass\n        // --- BLOOM (MAX) ---\n        const bloomPass = new three_examples_jsm_postprocessing_UnrealBloomPass__WEBPACK_IMPORTED_MODULE_6__.UnrealBloomPass(new three__WEBPACK_IMPORTED_MODULE_3__.Vector2(window.innerWidth, window.innerHeight), 2.5, 1.2, 0.12 // threshold (lower = more)\n        );\n        composer.addPass(bloomPass);\n        // --- CLOSE STARS: Separate Scene for Chromatic Aberration ---\n        const closeStarsScene = new three__WEBPACK_IMPORTED_MODULE_3__.Scene();\n        const caPass = new _ChromaticAberrationPass__WEBPACK_IMPORTED_MODULE_2__.ChromaticAberrationPass(new three__WEBPACK_IMPORTED_MODULE_3__.Vector2(0.0002, 0.0002)); // barely visible\n        const caComposer = new three_examples_jsm_postprocessing_EffectComposer__WEBPACK_IMPORTED_MODULE_4__.EffectComposer(renderer);\n        caComposer.setSize(window.innerWidth, window.innerHeight);\n        const caRenderPass = new three_examples_jsm_postprocessing_RenderPass__WEBPACK_IMPORTED_MODULE_5__.RenderPass(closeStarsScene, camera);\n        caComposer.addPass(caRenderPass);\n        caComposer.addPass(caPass);\n        // --- HANDLE RESIZE AND FULLSCREEN ---\n        function resizeAll() {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n            composer.setSize(window.innerWidth, window.innerHeight);\n            caComposer.setSize(window.innerWidth, window.innerHeight);\n        }\n        window.addEventListener(\"resize\", resizeAll);\n        window.addEventListener(\"fullscreenchange\", resizeAll);\n        // Starfield\n        const starCount = 2000;\n        const starMaxDistance = 2000;\n        const starSpeed = 1;\n        const geometry = new three__WEBPACK_IMPORTED_MODULE_3__.BufferGeometry();\n        const closeGeometry = new three__WEBPACK_IMPORTED_MODULE_3__.BufferGeometry();\n        const positions = [];\n        const closePositions = [];\n        let starsPlaced = 0;\n        while(starsPlaced < starCount){\n            // With 1% chance, spawn a star cluster (10-30 stars)\n            if (Math.random() < 0.01 && starsPlaced < starCount - 10) {\n                const clusterTheta = Math.random() * 2 * Math.PI;\n                const clusterPhi = Math.acos(2 * Math.random() - 1);\n                const clusterR = Math.random() * starMaxDistance;\n                const clusterCenter = [\n                    clusterR * Math.sin(clusterPhi) * Math.cos(clusterTheta),\n                    clusterR * Math.sin(clusterPhi) * Math.sin(clusterTheta),\n                    clusterR * Math.cos(clusterPhi)\n                ];\n                const clusterSize = 10 + Math.floor(Math.random() * 20); // 10-30 stars\n                for(let c = 0; c < clusterSize && starsPlaced < starCount; c++){\n                    // Each star in cluster is within 30 units of center\n                    const offsetTheta = Math.random() * 2 * Math.PI;\n                    const offsetPhi = Math.acos(2 * Math.random() - 1);\n                    const offsetR = Math.random() * 30; // cluster radius\n                    positions.push(clusterCenter[0] + offsetR * Math.sin(offsetPhi) * Math.cos(offsetTheta), clusterCenter[1] + offsetR * Math.sin(offsetPhi) * Math.sin(offsetTheta), clusterCenter[2] + offsetR * Math.cos(offsetPhi));\n                    starsPlaced++;\n                }\n            } else {\n                // Normal single star\n                const theta = Math.random() * 2 * Math.PI;\n                const phi = Math.acos(2 * Math.random() - 1);\n                const r = Math.random() * starMaxDistance;\n                const x = r * Math.sin(phi) * Math.cos(theta);\n                const y = r * Math.sin(phi) * Math.sin(theta);\n                const z = r * Math.cos(phi);\n                positions.push(x, y, z);\n                // If close, also add to closePositions\n                if (r < 400) {\n                    closePositions.push(x, y, z);\n                }\n                starsPlaced++;\n            }\n        }\n        geometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_3__.Float32BufferAttribute(positions, 3));\n        if (closePositions.length > 0) {\n            closeGeometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_3__.Float32BufferAttribute(closePositions, 3));\n        }\n        // CRAZY BLOOM: All stars are extremely bright (color intensity >1)\n        const palette = [\n            [\n                3.0,\n                1.5,\n                1.5\n            ],\n            [\n                3.0,\n                2.25,\n                1.2\n            ],\n            [\n                3.0,\n                3.0,\n                2.7\n            ],\n            [\n                3.0,\n                3.0,\n                3.0\n            ],\n            [\n                1.2,\n                1.5,\n                3.0\n            ]\n        ];\n        const colors = [];\n        for(let i = 0; i < starCount; i++){\n            const c = palette[Math.floor(Math.random() * palette.length)];\n            colors.push(...c);\n        }\n        geometry.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_3__.Float32BufferAttribute(colors, 3));\n        const originalColors = geometry.attributes.color.array.slice();\n        const timers = new Float32Array(starCount);\n        const sparkColors = new Float32Array(starCount * 3);\n        const sparkleDuration = 180;\n        // --- SQUARE STARS USING POINTS ---\n        const material = new three__WEBPACK_IMPORTED_MODULE_3__.PointsMaterial({\n            size: 3.5,\n            sizeAttenuation: true,\n            vertexColors: true\n        });\n        const stars = new three__WEBPACK_IMPORTED_MODULE_3__.Points(geometry, material);\n        scene.add(stars);\n        // Add glow sprites to each star and animate them based on distance\n        const glowMap = new three__WEBPACK_IMPORTED_MODULE_3__.TextureLoader().load(\"https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/sprites/glow.png\");\n        const glowSprites = [];\n        const glowMaterial = new three__WEBPACK_IMPORTED_MODULE_3__.SpriteMaterial({\n            map: glowMap,\n            color: 0xffffff,\n            opacity: 0.18,\n            blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending,\n            depthWrite: false\n        });\n        for(let i = 0; i < starCount; i++){\n            const glow = new three__WEBPACK_IMPORTED_MODULE_3__.Sprite(glowMaterial.clone());\n            glow.position.set(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2]);\n            glow.scale.set(10, 10, 1);\n            scene.add(glow);\n            glowSprites.push(glow);\n        }\n        // Add close stars to separate scene\n        let closeStars;\n        if (closePositions.length > 0) {\n            closeStars = new three__WEBPACK_IMPORTED_MODULE_3__.Points(closeGeometry, material.clone());\n            closeStarsScene.add(closeStars);\n        }\n        let targetY = 0;\n        const damping = 0.05;\n        const onScroll = ()=>{\n            const pct = window.scrollY / (document.body.scrollHeight - window.innerHeight);\n            targetY = pct * Math.PI * 2;\n        };\n        window.addEventListener(\"scroll\", onScroll);\n        // --- Shooting Stars ---\n        const tailLength = 32; // Increase for longer tails\n        const shootingStars = [];\n        let shootingStarCooldown = 0;\n        // Spawn a shooting star with a stunning glowing tail\n        function spawnShootingStar() {\n            // Pick a random direction on the sphere for the spawn location\n            const dir = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();\n            // Ensure shooting stars never spawn close to the camera (at least 70% of max distance)\n            const minDist = starMaxDistance * 0.7;\n            const maxDist = starMaxDistance * 1.0;\n            const dist = minDist + Math.random() * (maxDist - minDist);\n            const spawnPos = dir.clone().multiplyScalar(dist);\n            // Tangential velocity: perpendicular to dir\n            let tangent = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1);\n            tangent = tangent.sub(tangent.clone().projectOnVector(dir)).normalize();\n            // Mix in a small radial component (inward or outward)\n            const tangentialSpeed = starSpeed * (2.5 + Math.random() * 2.5); // much faster\n            const radialSpeed = starSpeed * (Math.random() - 0.5) * 0.3; // more dramatic\n            const velocity = tangent.multiplyScalar(tangentialSpeed).add(dir.clone().multiplyScalar(radialSpeed));\n            // Stunning color gradient for the head\n            const vibrantColors = [\n                0xffe066,\n                0xff66cc,\n                0x66ccff,\n                0xffffff,\n                0x80ffea,\n                0xfff2cc,\n                0xffc080,\n                0x80c0ff,\n                0xff80b3\n            ];\n            const color = vibrantColors[Math.floor(Math.random() * vibrantColors.length)];\n            // Star brightness and size (always small and subtle)\n            const brightness = 2.5 + Math.random() * 1.5;\n            const geo = new three__WEBPACK_IMPORTED_MODULE_3__.SphereGeometry(0.7 + Math.random() * 0.5, 16, 16); // Small sphere\n            const mat = new three__WEBPACK_IMPORTED_MODULE_3__.MeshPhysicalMaterial({\n                color: color,\n                emissive: color,\n                emissiveIntensity: 14.0,\n                metalness: 0.7,\n                roughness: 0.3,\n                transmission: 0.7,\n                opacity: 0.98,\n                transparent: true,\n                clearcoat: 0.8,\n                clearcoatRoughness: 0.2\n            });\n            const star = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(geo, mat);\n            // Add a large, intense bloom sprite for extra bloom\n            const spriteMap = new three__WEBPACK_IMPORTED_MODULE_3__.TextureLoader().load(\"https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/sprites/glow.png\");\n            const spriteMaterial = new three__WEBPACK_IMPORTED_MODULE_3__.SpriteMaterial({\n                map: spriteMap,\n                color: 0xffffff,\n                opacity: 1.0,\n                blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n            });\n            const sprite = new three__WEBPACK_IMPORTED_MODULE_3__.Sprite(spriteMaterial);\n            sprite.scale.set(70, 70, 1); // Large for bloom\n            sprite.position.copy(star.position);\n            star.add(sprite);\n            // Add a colored sprite for color pop\n            const colorSpriteMaterial = new three__WEBPACK_IMPORTED_MODULE_3__.SpriteMaterial({\n                map: spriteMap,\n                color: color,\n                opacity: 0.6,\n                blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n            });\n            const colorSprite = new three__WEBPACK_IMPORTED_MODULE_3__.Sprite(colorSpriteMaterial);\n            colorSprite.scale.set(34, 34, 1);\n            colorSprite.position.copy(star.position);\n            star.add(colorSprite);\n            // Add dynamic spark burst at the head\n            const sparkCount = 18 + Math.floor(Math.random() * 8);\n            const sparkGroup = new three__WEBPACK_IMPORTED_MODULE_3__.Group();\n            for(let i = 0; i < sparkCount; i++){\n                const sparkMat = new three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial({\n                    color: vibrantColors[Math.floor(Math.random() * vibrantColors.length)],\n                    transparent: true,\n                    opacity: 0.8\n                });\n                const sparkGeo = new three__WEBPACK_IMPORTED_MODULE_3__.SphereGeometry(0.07 + Math.random() * 0.06, 8, 8);\n                const spark = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(sparkGeo, sparkMat);\n                const angle = i / sparkCount * Math.PI * 2;\n                spark.position.set(Math.cos(angle) * 1.2, Math.sin(angle) * 1.2, Math.random() * 0.4 - 0.2);\n                sparkGroup.add(spark);\n            }\n            sparkGroup.name = \"sparkBurst\";\n            star.add(sparkGroup);\n            star.position.copy(spawnPos);\n            star.velocity = velocity;\n            star.normalizedLife = 0.0;\n            star.normalizedLifetime = 80 + Math.random() * 80; // Longer, more dramatic\n            star.age = 0;\n            // --- Stunning Meteor Tail (very long, multi-color, glowing, fading, and 3D curve) ---\n            const trailSegments = tailLength * 3; // Even longer tail\n            const trailPoints = [];\n            for(let i = 0; i < trailSegments; i++){\n                // Add a 3D spiral/curve for more depth\n                const spiral = Math.sin(i * 0.25) * 8;\n                const curve = Math.cos(i * 0.15) * 4;\n                const pt = star.position.clone().add(new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(spiral, curve, -i * 3));\n                trailPoints.push(pt);\n            }\n            const tailGeo = new three__WEBPACK_IMPORTED_MODULE_3__.BufferGeometry().setFromPoints(trailPoints);\n            // Per-vertex color (multi-color rainbow gradient)\n            const tailColors = [];\n            for(let i = 0; i < trailSegments; i++){\n                // Alpha fades out along the tail\n                const alpha = (1 - i / (trailSegments - 1)) * 0.99;\n                // Rainbow gradient\n                const rainbow = [\n                    0xffe066,\n                    0xff66cc,\n                    0x66ccff,\n                    0xffffff,\n                    0x80ffea,\n                    0xfff2cc,\n                    0xffc080,\n                    0x80c0ff,\n                    0xff80b3\n                ];\n                const gradColor = rainbow[Math.floor(i / trailSegments * rainbow.length)];\n                tailColors.push((gradColor >> 16 & 255) / 255, (gradColor >> 8 & 255) / 255, (gradColor & 255) / 255, alpha);\n            }\n            tailGeo.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_3__.Float32BufferAttribute(tailColors, 4));\n            // Additive blending for glow + BLOOMED TAIL\n            const tailMat = new three__WEBPACK_IMPORTED_MODULE_3__.LineBasicMaterial({\n                vertexColors: true,\n                transparent: true,\n                opacity: 1.0,\n                blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n            });\n            const tail = new three__WEBPACK_IMPORTED_MODULE_3__.Line(tailGeo, tailMat);\n            tail.position.copy(star.position);\n            // Add a bloom sprite to the tail's head for extra glow\n            const tailGlowMap = new three__WEBPACK_IMPORTED_MODULE_3__.TextureLoader().load(\"https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/sprites/glow.png\");\n            const tailGlowMat = new three__WEBPACK_IMPORTED_MODULE_3__.SpriteMaterial({\n                map: tailGlowMap,\n                color: 0xffffff,\n                opacity: 0.88,\n                blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n            });\n            const tailGlow = new three__WEBPACK_IMPORTED_MODULE_3__.Sprite(tailGlowMat);\n            tailGlow.scale.set(50, 50, 1); // Larger for more bloom\n            tailGlow.position.copy(star.position);\n            star.add(tailGlow); // Attach to star so it follows head\n            // Add to scene\n            scene.add(star);\n            scene.add(tail);\n            shootingStars.push({\n                mesh: star,\n                tail,\n                velocity: star.velocity,\n                dir,\n                age: 0,\n                normalizedLifetime: star.normalizedLifetime,\n                trailPoints,\n                color,\n                brightness,\n                hasFragmented: false\n            });\n        }\n        const animate = ()=>{\n            try {\n                requestAnimationFrame(animate);\n                // Render main scene with bloom\n                composer.render();\n                // Overlay close stars with chromatic aberration (only close stars get CA)\n                if (closeStars) {\n                    caComposer.render();\n                }\n                camera.rotation.y += (targetY - camera.rotation.y) * damping;\n                // Move the virtual camera position in the direction the camera is facing\n                const forward = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();\n                camera.getWorldDirection(forward);\n                virtualCameraPos.add(forward.multiplyScalar(starSpeed));\n                // Offset all stars by -virtualCameraPos (floating origin)\n                for(let i = 0; i < positions.length; i += 3){\n                    geometry.attributes.position.array[i] = positions[i] - virtualCameraPos.x;\n                    geometry.attributes.position.array[i + 1] = positions[i + 1] - virtualCameraPos.y;\n                    geometry.attributes.position.array[i + 2] = positions[i + 2] - virtualCameraPos.z;\n                    // Animate glow sprite for distant/close effect\n                    const glow = glowSprites[i / 3];\n                    const starPos = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(positions[i] - virtualCameraPos.x, positions[i + 1] - virtualCameraPos.y, positions[i + 2] - virtualCameraPos.z);\n                    const dist = starPos.length();\n                    // If close, reduce/hide glow, if far, make glow big and bright\n                    if (dist < 400) {\n                        glow.material.opacity = 0.06 + 0.08 * Math.random(); // subtle flicker\n                        glow.scale.set(7, 7, 1);\n                    } else if (dist > 1200) {\n                        glow.material.opacity = 0.38 + 0.18 * Math.random(); // intense\n                        glow.scale.set(32, 32, 1);\n                    } else {\n                        // interpolate\n                        const t = (dist - 400) / (1200 - 400);\n                        glow.material.opacity = 0.08 + 0.3 * t + 0.08 * Math.random();\n                        const s = 7 + (32 - 7) * t;\n                        glow.scale.set(s, s, 1);\n                    }\n                    glow.position.copy(starPos);\n                }\n                if (closeStars && closeGeometry && closePositions.length > 0) {\n                    for(let i = 0; i < closePositions.length; i += 3){\n                        closeGeometry.attributes.position.array[i] = closePositions[i] - virtualCameraPos.x;\n                        closeGeometry.attributes.position.array[i + 1] = closePositions[i + 1] - virtualCameraPos.y;\n                        closeGeometry.attributes.position.array[i + 2] = closePositions[i + 2] - virtualCameraPos.z;\n                    }\n                    closeGeometry.attributes.position.needsUpdate = true;\n                }\n                geometry.attributes.position.needsUpdate = true;\n                // --- Shooting star spawning ---\n                if (shootingStarCooldown <= 0 && Math.random() < 0.1) {\n                    spawnShootingStar();\n                    if (camera) {\n                        const shakeStrength = 0.06 + Math.random() * 0.04;\n                        camera.position.x += (Math.random() - 0.5) * shakeStrength;\n                        camera.position.y += (Math.random() - 0.5) * shakeStrength;\n                    }\n                    shootingStarCooldown = 10 + Math.random() * 10;\n                } else if (shootingStarCooldown > 0) {\n                    shootingStarCooldown--;\n                }\n                // Animate and clean up shooting stars\n                for(let i = shootingStars.length - 1; i >= 0; i--){\n                    const obj = shootingStars[i];\n                    // Animate spark burst (fade and expand)\n                    if (obj.mesh.children) {\n                        const sparks = obj.mesh.children.find((child)=>child.name === \"sparkBurst\");\n                        if (sparks) {\n                            for(let j = 0; j < sparks.children.length; j++){\n                                const spark = sparks.children[j];\n                                spark.material.opacity *= 0.96; // Fade\n                                spark.scale.multiplyScalar(1.03); // Expand\n                            }\n                        }\n                    }\n                    // Animate tail shimmer and color cycling\n                    if (obj.tail && obj.trailPoints) {\n                        const time = performance.now() * 0.001;\n                        const tailGeo = obj.tail.geometry;\n                        const tailColors = tailGeo.getAttribute(\"color\");\n                        for(let k = 0; k < tailColors.count; k++){\n                            // Cycle hue\n                            let r = tailColors.getX(k), g = tailColors.getY(k), b = tailColors.getZ(k);\n                            // Convert to HSL\n                            const max = Math.max(r, g, b), min = Math.min(r, g, b);\n                            let h, s, l;\n                            l = (max + min) / 2;\n                            if (max === min) {\n                                h = s = 0;\n                            } else {\n                                const d = max - min;\n                                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n                                switch(max){\n                                    case r:\n                                        h = (g - b) / d + (g < b ? 6 : 0);\n                                        break;\n                                    case g:\n                                        h = (b - r) / d + 2;\n                                        break;\n                                    case b:\n                                        h = (r - g) / d + 4;\n                                        break;\n                                }\n                                h /= 6;\n                            }\n                            h = (h + 0.25 * Math.sin(time + k * 0.2)) % 1.0; // Animate hue\n                            // Convert back to RGB\n                            let q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n                            let p = 2 * l - q;\n                            let tr = h + 1 / 3, tg = h, tb = h - 1 / 3;\n                            const hue2rgb = (p, q, t)=>{\n                                if (t < 0) t += 1;\n                                if (t > 1) t -= 1;\n                                if (t < 1 / 6) return p + (q - p) * 6 * t;\n                                if (t < 1 / 2) return q;\n                                if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n                                return p;\n                            };\n                            tailColors.setX(k, hue2rgb(p, q, tr));\n                            tailColors.setY(k, hue2rgb(p, q, tg));\n                            tailColors.setZ(k, hue2rgb(p, q, tb));\n                            // Shimmer: modulate alpha\n                            tailColors.setW(k, tailColors.getW(k) * (0.97 + 0.03 * Math.sin(time * 8 + k)));\n                        }\n                        tailColors.needsUpdate = true;\n                    }\n                    // Straight-line trajectory\n                    obj.mesh.position.add(obj.velocity);\n                    obj.tail.position.copy(obj.mesh.position);\n                    // Animate tail (no lerp, just drag)\n                    obj.age++;\n                    const normalizedLife = obj.age / obj.normalizedLifetime;\n                    obj.trailPoints.unshift(obj.mesh.position.clone());\n                    if (obj.trailPoints.length > tailLength * 3) obj.trailPoints.pop();\n                    let tailGrow = Math.min(1, normalizedLife / 0.3);\n                    let activeSegments = Math.floor(obj.trailPoints.length * tailGrow);\n                    if (activeSegments < 2) activeSegments = 2;\n                    const visibleTrail = obj.trailPoints.slice(0, activeSegments);\n                    obj.tail.geometry.setFromPoints(visibleTrail);\n                    const tailColors = obj.tail.geometry.getAttribute(\"color\");\n                    for(let j = 0; j < visibleTrail.length; j++){\n                        let alpha = (1 - j / (visibleTrail.length - 1)) * 0.95;\n                        alpha *= 0.92 + 0.08 * Math.sin(Date.now() * 0.015 + j * 0.5);\n                        let rainbow = [\n                            0xffc080,\n                            0xffe080,\n                            0xffff80,\n                            0x80ffe6,\n                            0x80c0ff,\n                            0xc080ff\n                        ];\n                        let gradColor = rainbow[j % rainbow.length];\n                        if (normalizedLife > 0.7) alpha *= Math.max(0, 1 - (normalizedLife - 0.7 - 0.2) / 0.3);\n                        tailColors.setXYZW(j, (gradColor >> 16 & 255) / 255, (gradColor >> 8 & 255) / 255, (gradColor & 255) / 255, alpha);\n                    }\n                    tailColors.needsUpdate = true;\n                    // Animate head\n                    let headColor;\n                    if (normalizedLife < 0.5) {\n                        headColor = new three__WEBPACK_IMPORTED_MODULE_3__.Color(obj.color).lerp(new three__WEBPACK_IMPORTED_MODULE_3__.Color(0xffc080), normalizedLife * 2);\n                    } else {\n                        headColor = new three__WEBPACK_IMPORTED_MODULE_3__.Color(0xffc080).lerp(new three__WEBPACK_IMPORTED_MODULE_3__.Color(0xff4000), (normalizedLife - 0.5) * 2);\n                    }\n                    let flicker = 0.95 + 0.13 * Math.sin(Date.now() * 0.07 + Math.random() * 10);\n                    headColor.multiplyScalar(flicker);\n                    obj.mesh.material.color.copy(headColor);\n                    let scale = 1 + 2.2 * Math.sin(Math.PI * normalizedLife);\n                    let distToCam = obj.mesh.position.length();\n                    let dofBlur = distToCam < starMaxDistance * 0.7 ? 0.7 : 1.0;\n                    obj.mesh.scale.set(scale * dofBlur, scale * dofBlur, scale * dofBlur);\n                    // Sparkle burst\n                    if (normalizedLife >= 1 && !obj.hasFragmented) {\n                        // --- SPECTACULAR EXPLOSION (very rare) ---\n                        const spectacular = Math.random() < 0.02; // 2% chance\n                        const burstCount = spectacular ? 120 + Math.floor(Math.random() * 60) : 18 + Math.floor(Math.random() * 8);\n                        const palette = spectacular ? [\n                            0xffe066,\n                            0xff66cc,\n                            0x66ccff,\n                            0xffffff,\n                            0x80ffea,\n                            0xfff2cc,\n                            0xffc080,\n                            0x80c0ff,\n                            0xff80b3,\n                            0xff0000,\n                            0x00ff00,\n                            0x0000ff,\n                            0xffff00,\n                            0x00ffff,\n                            0xff00ff,\n                            0xff8800,\n                            0x00ff88,\n                            0x8800ff\n                        ] : [\n                            0xffffff,\n                            0xfff6c0,\n                            0xffe066,\n                            0xffc080,\n                            0x80c0ff\n                        ];\n                        for(let s = 0; s < burstCount; s++){\n                            const color = palette[Math.floor(Math.random() * palette.length)];\n                            const size = spectacular ? 1.2 + Math.random() * 2.2 : 0.7 + Math.random() * 0.8;\n                            const sparkleGeo = new three__WEBPACK_IMPORTED_MODULE_3__.SphereGeometry(size, 8, 8);\n                            const sparkleMat = new three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial({\n                                color,\n                                transparent: true,\n                                opacity: spectacular ? 0.92 : 0.7,\n                                blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n                            });\n                            const sparkle = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(sparkleGeo, sparkleMat);\n                            sparkle.position.copy(obj.mesh.position);\n                            // Spectacular: huge, fast, random directions; normal: moderate\n                            const spd = spectacular ? 4 + Math.random() * 8 : 2 + Math.random() * 2;\n                            const sparkleVel = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize().multiplyScalar(spd);\n                            sparkle.userData = {\n                                velocity: sparkleVel,\n                                age: 0,\n                                spectacular,\n                                maxAge: spectacular ? 80 + Math.random() * 40 : 40 + Math.random() * 20\n                            }; // <-- LONGER LIFE\n                            scene.add(sparkle);\n                            if (!window._sparkles) window._sparkles = [];\n                            window._sparkles.push(sparkle);\n                        }\n                        if (spectacular) {\n                            // Add a big flash\n                            const flashGeo = new three__WEBPACK_IMPORTED_MODULE_3__.SphereGeometry(6, 24, 24);\n                            const flashMat = new three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial({\n                                color: 0xffffff,\n                                transparent: true,\n                                opacity: 0.8,\n                                blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n                            });\n                            const flash = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(flashGeo, flashMat);\n                            flash.position.copy(obj.mesh.position);\n                            scene.add(flash);\n                            if (!window._starFlashes) window._starFlashes = [];\n                            window._starFlashes.push({\n                                mesh: flash,\n                                age: 0\n                            });\n                        }\n                        // Fragmented trail logic (keep as before)\n                        const fragVel = obj.velocity.clone().applyAxisAngle(new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(0, 1, 0), (Math.random() - 0.5) * 0.3);\n                        const fragStar = obj.mesh.clone();\n                        fragStar.position.copy(obj.mesh.position);\n                        fragStar.velocity = fragVel;\n                        fragStar.normalizedLife = normalizedLife;\n                        fragStar.normalizedLifetime = obj.normalizedLifetime * (0.5 + Math.random() * 0.5);\n                        fragStar.age = obj.age;\n                        fragStar.material = obj.mesh.material.clone();\n                        const fragTrailPoints = obj.trailPoints.slice();\n                        const fragTailGeo = new three__WEBPACK_IMPORTED_MODULE_3__.BufferGeometry().setFromPoints(fragTrailPoints);\n                        fragTailGeo.setAttribute(\"color\", obj.tail.geometry.getAttribute(\"color\").clone());\n                        const fragTailMat = obj.tail.material.clone();\n                        const fragTail = new three__WEBPACK_IMPORTED_MODULE_3__.Line(fragTailGeo, fragTailMat);\n                        fragTail.position.copy(fragStar.position);\n                        scene.add(fragStar);\n                        scene.add(fragTail);\n                        shootingStars.push({\n                            mesh: fragStar,\n                            tail: fragTail,\n                            velocity: fragStar.velocity,\n                            dir: obj.dir,\n                            age: fragStar.age,\n                            normalizedLifetime: fragStar.normalizedLifetime,\n                            trailPoints: fragTrailPoints,\n                            color: obj.color,\n                            brightness: obj.brightness,\n                            hasFragmented: true\n                        });\n                        obj.hasFragmented = true;\n                    }\n                    // Spark burst\n                    if (!obj.hasSparked && normalizedLife > 0.95 && Math.random() < 0.1) {\n                        for(let s = 0; s < 8 + Math.floor(Math.random() * 8); s++){\n                            const sparkGeo = new three__WEBPACK_IMPORTED_MODULE_3__.SphereGeometry(0.5 + Math.random() * 0.5, 8, 8);\n                            const sparkMat = new three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial({\n                                color: 0xfff6c0,\n                                transparent: true,\n                                opacity: 1,\n                                blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n                            });\n                            const spark = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(sparkGeo, sparkMat);\n                            spark.position.copy(obj.mesh.position);\n                            spark.sparkVel = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize().multiplyScalar(0.5 + Math.random() * 1.2);\n                            spark.sparkLife = 12 + Math.random() * 10;\n                            spark.sparkAge = 0;\n                            scene.add(spark);\n                            if (!window._starSparks) window._starSparks = [];\n                            window._starSparks.push(spark);\n                        }\n                        obj.hasSparked = true;\n                    }\n                    // Flash\n                    if (!obj.hasFlashed && normalizedLife > 0.98 && Math.random() < 0.2) {\n                        const flashGeo = new three__WEBPACK_IMPORTED_MODULE_3__.SphereGeometry(1, 16, 16);\n                        const flashMat = new three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial({\n                            color: 0xffffee,\n                            transparent: true,\n                            opacity: 0.8,\n                            blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n                        });\n                        const flash = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(flashGeo, flashMat);\n                        flash.position.copy(obj.mesh.position);\n                        scene.add(flash);\n                        if (!window._starFlashes) window._starFlashes = [];\n                        window._starFlashes.push({\n                            mesh: flash,\n                            age: 0\n                        });\n                        obj.hasFlashed = true;\n                    }\n                    // Fade out as it gets far away\n                    const dist = obj.mesh.position.distanceTo(camera.position);\n                    const fadeStart = starMaxDistance * 0.5;\n                    if (dist > fadeStart) {\n                        const fade = 1 - (dist - fadeStart) / (starMaxDistance - fadeStart);\n                        obj.mesh.material.opacity = Math.max(0, fade);\n                        obj.mesh.material.transparent = true;\n                        obj.tail.material.opacity = Math.max(0, fade * 0.8);\n                        obj.tail.material.transparent = true;\n                    }\n                    // Remove when out of bounds or fully faded or life ended\n                    if (normalizedLife >= 1.0 || dist > starMaxDistance || obj.mesh.material.opacity <= 0.01) {\n                        scene.remove(obj.mesh);\n                        scene.remove(obj.tail);\n                        shootingStars.splice(i, 1);\n                    }\n                }\n                // Animate sparks\n                if (window._starSparks) {\n                    for(let i = window._starSparks.length - 1; i >= 0; i--){\n                        const spark = window._starSparks[i];\n                        spark.position.add(spark.sparkVel);\n                        spark.sparkAge++;\n                        spark.material.opacity *= 0.92;\n                        if (spark.sparkAge > spark.sparkLife) {\n                            scene.remove(spark);\n                            window._starSparks.splice(i, 1);\n                        }\n                    }\n                }\n                // Animate explosion particles (sparkles)\n                if (window._sparkles) {\n                    for(let i = window._sparkles.length - 1; i >= 0; i--){\n                        const sparkle = window._sparkles[i];\n                        sparkle.position.add(sparkle.userData.velocity);\n                        sparkle.userData.age++;\n                        sparkle.material.opacity *= 0.97;\n                        if (sparkle.userData.age > (sparkle.userData.maxAge || 40)) {\n                            scene.remove(sparkle);\n                            window._sparkles.splice(i, 1);\n                        }\n                    }\n                }\n                // Animate flashes\n                if (window._starFlashes) {\n                    for(let i = window._starFlashes.length - 1; i >= 0; i--){\n                        const flash = window._starFlashes[i];\n                        flash.mesh.scale.multiplyScalar(1.15);\n                        flash.mesh.material.opacity *= 0.85;\n                        flash.age++;\n                        if (flash.age > 10) {\n                            scene.remove(flash.mesh);\n                            window._starFlashes.splice(i, 1);\n                        }\n                    }\n                }\n                // --- Starfield logic ---\n                const sqDist = starMaxDistance * starMaxDistance;\n                for(let i = 0; i < positions.length; i += 3){\n                    const dx = positions[i] - virtualCameraPos.x;\n                    const dy = positions[i + 1] - virtualCameraPos.y;\n                    const dz = positions[i + 2] - virtualCameraPos.z;\n                    if (dx * dx + dy * dy + dz * dz > sqDist) {\n                        // Place in a thick spherical shell around the virtual camera, never too close\n                        const minRadius = starMaxDistance * 0.8;\n                        const maxRadius = starMaxDistance;\n                        const r = minRadius + Math.random() * (maxRadius - minRadius);\n                        const theta = Math.random() * 2 * Math.PI;\n                        const phi = Math.acos(2 * Math.random() - 1);\n                        positions[i] = virtualCameraPos.x + r * Math.sin(phi) * Math.cos(theta);\n                        positions[i + 1] = virtualCameraPos.y + r * Math.sin(phi) * Math.sin(theta);\n                        positions[i + 2] = virtualCameraPos.z + r * Math.cos(phi);\n                    }\n                }\n                // geometry.attributes.position.needsUpdate = true; // Already set above\n                // Robust starfield color update to prevent stuck white dots\n                const colArr = geometry.attributes.color.array;\n                for(let i = 0; i < positions.length; i += 3){\n                    const idx = i / 3;\n                    const dx = positions[i] - virtualCameraPos.x;\n                    const dy = positions[i + 1] - virtualCameraPos.y;\n                    const dz = positions[i + 2] - virtualCameraPos.z;\n                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);\n                    if (timers[idx] > 0) {\n                        timers[idx]--;\n                        if (timers[idx] === 0) {\n                            // Timer expired, restore color\n                            sparkColors[i] = originalColors[i];\n                            sparkColors[i + 1] = originalColors[i + 1];\n                            sparkColors[i + 2] = originalColors[i + 2];\n                            colArr[i] = originalColors[i];\n                            colArr[i + 1] = originalColors[i + 1];\n                            colArr[i + 2] = originalColors[i + 2];\n                        } else {\n                            colArr[i] = sparkColors[i];\n                            colArr[i + 1] = sparkColors[i + 1];\n                            colArr[i + 2] = sparkColors[i + 2];\n                        }\n                    } else if (dist > starMaxDistance * 0.3 && Math.random() < 0.05) {\n                        timers[idx] = sparkleDuration;\n                        const c = palette[Math.floor(Math.random() * palette.length)];\n                        sparkColors[i] = c[0];\n                        sparkColors[i + 1] = c[1];\n                        sparkColors[i + 2] = c[2];\n                        colArr[i] = sparkColors[i];\n                        colArr[i + 1] = sparkColors[i + 1];\n                        colArr[i + 2] = sparkColors[i + 2];\n                    } else {\n                        sparkColors[i] = originalColors[i];\n                        sparkColors[i + 1] = originalColors[i + 1];\n                        sparkColors[i + 2] = originalColors[i + 2];\n                        colArr[i] = originalColors[i];\n                        colArr[i + 1] = originalColors[i + 1];\n                        colArr[i + 2] = originalColors[i + 2];\n                    }\n                }\n                geometry.attributes.color.needsUpdate = true;\n                composer.render();\n            } catch (err) {\n                // Defensive: log error with context\n                console.error(\"Starfield animation error:\", err);\n            }\n        };\n        animate(); // Start the render loop\n        const onResize = ()=>{\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n        };\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: mountRef\n    }, void 0, false, {\n        fileName: \"/home/kayosdev/Websites/Portfolio/components/Starfield.jsx\",\n        lineNumber: 655,\n        columnNumber: 10\n    }, undefined);\n};\n_s(Starfield, \"V9/qkEdV8GfsDZk7lMTA1T8g5Ps=\");\n_c = Starfield;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Starfield);\nvar _c;\n$RefreshReg$(_c, \"Starfield\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvU3RhcmZpZWxkLmpzeD9mMWEyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCB7IEVmZmVjdENvbXBvc2VyIH0gZnJvbSAndGhyZWUvZXhhbXBsZXMvanNtL3Bvc3Rwcm9jZXNzaW5nL0VmZmVjdENvbXBvc2VyJztcbmltcG9ydCB7IFVucmVhbEJsb29tUGFzcyB9IGZyb20gJ3RocmVlL2V4YW1wbGVzL2pzbS9wb3N0cHJvY2Vzc2luZy9VbnJlYWxCbG9vbVBhc3MnO1xuaW1wb3J0IHsgUmVuZGVyUGFzcyB9IGZyb20gJ3RocmVlL2V4YW1wbGVzL2pzbS9wb3N0cHJvY2Vzc2luZy9SZW5kZXJQYXNzJztcbmltcG9ydCB7IENocm9tYXRpY0FiZXJyYXRpb25QYXNzIH0gZnJvbSAnLi9DaHJvbWF0aWNBYmVycmF0aW9uUGFzcyc7XG5cbmNvbnN0IFN0YXJmaWVsZCA9ICgpID0+IHtcbiAgY29uc3QgbW91bnRSZWYgPSB1c2VSZWYobnVsbClcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIERlZmVuc2l2ZTogYWx3YXlzIHVzZSAuY3VycmVudCBmb3IgcmVmc1xuICAgIGlmICghbW91bnRSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgIGNvbnN0IG1vdW50ID0gbW91bnRSZWYuY3VycmVudFxuICAgIG1vdW50LnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJ1xuICAgIG1vdW50LnN0eWxlLnRvcCA9ICcwJ1xuICAgIG1vdW50LnN0eWxlLmxlZnQgPSAnMCdcbiAgICBtb3VudC5zdHlsZS53aWR0aCA9ICcxMDAlJ1xuICAgIG1vdW50LnN0eWxlLmhlaWdodCA9ICcxMDAlJ1xuICAgIG1vdW50LnN0eWxlLnpJbmRleCA9ICcwJ1xuXG4gICAgLy8gU2NlbmUgJiBSZW5kZXJlclxuICAgIGNvbnN0IHNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKClcbiAgICBjb25zdCBjYW1lcmEgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoNzUsIHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmlubmVySGVpZ2h0LCAwLjEsIDUwMDApXG4gICAgY2FtZXJhLnBvc2l0aW9uLnNldCgwLCAwLCAwKTtcbiAgICAvLyBWaXJ0dWFsIHBvc2l0aW9uIHRvIHNpbXVsYXRlIGluZmluaXRlIHRyYXZlbFxuICAgIGxldCB2aXJ0dWFsQ2FtZXJhUG9zID0gbmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMCk7XG4gICAgY29uc3QgcmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcih7IGFudGlhbGlhczogdHJ1ZSB9KVxuICAgIHJlbmRlcmVyLnNldFBpeGVsUmF0aW8od2luZG93LmRldmljZVBpeGVsUmF0aW8pXG4gICAgcmVuZGVyZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KVxuICAgIHJlbmRlcmVyLnNldENsZWFyQ29sb3IoMHgwMDAwMDAsIDEpO1xuICAgIG1vdW50LmFwcGVuZENoaWxkKHJlbmRlcmVyLmRvbUVsZW1lbnQpXG5cbiAgICAvLyAtLS0gUE9TVFBST0NFU1NJTkcgLS0tXG4gICAgLy8gQ29tcG9zZXJcbiAgICBjb25zdCBjb21wb3NlciA9IG5ldyBFZmZlY3RDb21wb3NlcihyZW5kZXJlcik7XG4gICAgY29tcG9zZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICAvLyBSZW5kZXIgcGFzc1xuICAgIGNvbnN0IHJlbmRlclBhc3MgPSBuZXcgUmVuZGVyUGFzcyhzY2VuZSwgY2FtZXJhKTtcbiAgICBjb21wb3Nlci5hZGRQYXNzKHJlbmRlclBhc3MpO1xuICAgIC8vIFVucmVhbCBCbG9vbSBQYXNzXG4gICAgLy8gLS0tIEJMT09NIChNQVgpIC0tLVxuICAgIGNvbnN0IGJsb29tUGFzcyA9IG5ldyBVbnJlYWxCbG9vbVBhc3MoXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMih3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KSxcbiAgICAgIDIuNSwgLy8gc3RyZW5ndGggKG1heClcbiAgICAgIDEuMiwgLy8gcmFkaXVzIChtYXgpXG4gICAgICAwLjEyIC8vIHRocmVzaG9sZCAobG93ZXIgPSBtb3JlKVxuICAgICk7XG4gICAgY29tcG9zZXIuYWRkUGFzcyhibG9vbVBhc3MpO1xuXG4gICAgLy8gLS0tIENMT1NFIFNUQVJTOiBTZXBhcmF0ZSBTY2VuZSBmb3IgQ2hyb21hdGljIEFiZXJyYXRpb24gLS0tXG4gICAgY29uc3QgY2xvc2VTdGFyc1NjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7XG4gICAgY29uc3QgY2FQYXNzID0gbmV3IENocm9tYXRpY0FiZXJyYXRpb25QYXNzKG5ldyBUSFJFRS5WZWN0b3IyKDAuMDAwMiwgMC4wMDAyKSk7IC8vIGJhcmVseSB2aXNpYmxlXG4gICAgY29uc3QgY2FDb21wb3NlciA9IG5ldyBFZmZlY3RDb21wb3NlcihyZW5kZXJlcik7XG4gICAgY2FDb21wb3Nlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIGNvbnN0IGNhUmVuZGVyUGFzcyA9IG5ldyBSZW5kZXJQYXNzKGNsb3NlU3RhcnNTY2VuZSwgY2FtZXJhKTtcbiAgICBjYUNvbXBvc2VyLmFkZFBhc3MoY2FSZW5kZXJQYXNzKTtcbiAgICBjYUNvbXBvc2VyLmFkZFBhc3MoY2FQYXNzKTtcblxuICAgIC8vIC0tLSBIQU5ETEUgUkVTSVpFIEFORCBGVUxMU0NSRUVOIC0tLVxuICAgIGZ1bmN0aW9uIHJlc2l6ZUFsbCgpIHtcbiAgICAgIGNhbWVyYS5hc3BlY3QgPSB3aW5kb3cuaW5uZXJXaWR0aCAvIHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgIGNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgICByZW5kZXJlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgICAgY29tcG9zZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICAgIGNhQ29tcG9zZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICB9XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHJlc2l6ZUFsbCk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2Z1bGxzY3JlZW5jaGFuZ2UnLCByZXNpemVBbGwpO1xuXG4gICAgLy8gU3RhcmZpZWxkXG4gICAgY29uc3Qgc3RhckNvdW50ID0gMjAwMFxuICAgIGNvbnN0IHN0YXJNYXhEaXN0YW5jZSA9IDIwMDBcbiAgICBjb25zdCBzdGFyU3BlZWQgPSAxXG4gICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKVxuICAgIGNvbnN0IGNsb3NlR2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcbiAgICBjb25zdCBwb3NpdGlvbnMgPSBbXTtcbiAgICBjb25zdCBjbG9zZVBvc2l0aW9ucyA9IFtdO1xuICAgIGxldCBzdGFyc1BsYWNlZCA9IDA7XG4gICAgd2hpbGUgKHN0YXJzUGxhY2VkIDwgc3RhckNvdW50KSB7XG4gICAgICAvLyBXaXRoIDElIGNoYW5jZSwgc3Bhd24gYSBzdGFyIGNsdXN0ZXIgKDEwLTMwIHN0YXJzKVxuICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPCAwLjAxICYmIHN0YXJzUGxhY2VkIDwgc3RhckNvdW50IC0gMTApIHtcbiAgICAgICAgY29uc3QgY2x1c3RlclRoZXRhID0gTWF0aC5yYW5kb20oKSAqIDIgKiBNYXRoLlBJO1xuICAgICAgICBjb25zdCBjbHVzdGVyUGhpID0gTWF0aC5hY29zKDIgKiBNYXRoLnJhbmRvbSgpIC0gMSk7XG4gICAgICAgIGNvbnN0IGNsdXN0ZXJSID0gTWF0aC5yYW5kb20oKSAqIHN0YXJNYXhEaXN0YW5jZTtcbiAgICAgICAgY29uc3QgY2x1c3RlckNlbnRlciA9IFtcbiAgICAgICAgICBjbHVzdGVyUiAqIE1hdGguc2luKGNsdXN0ZXJQaGkpICogTWF0aC5jb3MoY2x1c3RlclRoZXRhKSxcbiAgICAgICAgICBjbHVzdGVyUiAqIE1hdGguc2luKGNsdXN0ZXJQaGkpICogTWF0aC5zaW4oY2x1c3RlclRoZXRhKSxcbiAgICAgICAgICBjbHVzdGVyUiAqIE1hdGguY29zKGNsdXN0ZXJQaGkpXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGNsdXN0ZXJTaXplID0gMTAgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyMCk7IC8vIDEwLTMwIHN0YXJzXG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgY2x1c3RlclNpemUgJiYgc3RhcnNQbGFjZWQgPCBzdGFyQ291bnQ7IGMrKykge1xuICAgICAgICAgIC8vIEVhY2ggc3RhciBpbiBjbHVzdGVyIGlzIHdpdGhpbiAzMCB1bml0cyBvZiBjZW50ZXJcbiAgICAgICAgICBjb25zdCBvZmZzZXRUaGV0YSA9IE1hdGgucmFuZG9tKCkgKiAyICogTWF0aC5QSTtcbiAgICAgICAgICBjb25zdCBvZmZzZXRQaGkgPSBNYXRoLmFjb3MoMiAqIE1hdGgucmFuZG9tKCkgLSAxKTtcbiAgICAgICAgICBjb25zdCBvZmZzZXRSID0gTWF0aC5yYW5kb20oKSAqIDMwOyAvLyBjbHVzdGVyIHJhZGl1c1xuICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKFxuICAgICAgICAgICAgY2x1c3RlckNlbnRlclswXSArIG9mZnNldFIgKiBNYXRoLnNpbihvZmZzZXRQaGkpICogTWF0aC5jb3Mob2Zmc2V0VGhldGEpLFxuICAgICAgICAgICAgY2x1c3RlckNlbnRlclsxXSArIG9mZnNldFIgKiBNYXRoLnNpbihvZmZzZXRQaGkpICogTWF0aC5zaW4ob2Zmc2V0VGhldGEpLFxuICAgICAgICAgICAgY2x1c3RlckNlbnRlclsyXSArIG9mZnNldFIgKiBNYXRoLmNvcyhvZmZzZXRQaGkpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzdGFyc1BsYWNlZCsrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb3JtYWwgc2luZ2xlIHN0YXJcbiAgICAgICAgY29uc3QgdGhldGEgPSBNYXRoLnJhbmRvbSgpICogMiAqIE1hdGguUEk7XG4gICAgICAgIGNvbnN0IHBoaSA9IE1hdGguYWNvcygyICogTWF0aC5yYW5kb20oKSAtIDEpO1xuICAgICAgICBjb25zdCByID0gTWF0aC5yYW5kb20oKSAqIHN0YXJNYXhEaXN0YW5jZTtcbiAgICAgICAgY29uc3QgeCA9IHIgKiBNYXRoLnNpbihwaGkpICogTWF0aC5jb3ModGhldGEpO1xuICAgICAgICBjb25zdCB5ID0gciAqIE1hdGguc2luKHBoaSkgKiBNYXRoLnNpbih0aGV0YSk7XG4gICAgICAgIGNvbnN0IHogPSByICogTWF0aC5jb3MocGhpKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goeCwgeSwgeik7XG4gICAgICAgIC8vIElmIGNsb3NlLCBhbHNvIGFkZCB0byBjbG9zZVBvc2l0aW9uc1xuICAgICAgICBpZiAociA8IDQwMCkge1xuICAgICAgICAgIGNsb3NlUG9zaXRpb25zLnB1c2goeCwgeSwgeik7XG4gICAgICAgIH1cbiAgICAgICAgc3RhcnNQbGFjZWQrKztcbiAgICAgIH1cbiAgICB9XG4gICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBUSFJFRS5GbG9hdDMyQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9ucywgMykpXG4gICAgaWYgKGNsb3NlUG9zaXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIGNsb3NlR2VvbWV0cnkuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBUSFJFRS5GbG9hdDMyQnVmZmVyQXR0cmlidXRlKGNsb3NlUG9zaXRpb25zLCAzKSk7XG4gICAgfVxuXG4gICAgLy8gQ1JBWlkgQkxPT006IEFsbCBzdGFycyBhcmUgZXh0cmVtZWx5IGJyaWdodCAoY29sb3IgaW50ZW5zaXR5ID4xKVxuICAgIGNvbnN0IHBhbGV0dGUgPSBbXG4gICAgICBbMy4wLCAxLjUsIDEuNV0sXG4gICAgICBbMy4wLCAyLjI1LCAxLjJdLFxuICAgICAgWzMuMCwgMy4wLCAyLjddLFxuICAgICAgWzMuMCwgMy4wLCAzLjBdLFxuICAgICAgWzEuMiwgMS41LCAzLjBdLFxuICAgIF07XG4gICAgY29uc3QgY29sb3JzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFyQ291bnQ7IGkrKykge1xuICAgICAgY29uc3QgYyA9IHBhbGV0dGVbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcGFsZXR0ZS5sZW5ndGgpXTtcbiAgICAgIGNvbG9ycy5wdXNoKC4uLmMpO1xuICAgIH1cbiAgICBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2NvbG9yJywgbmV3IFRIUkVFLkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoY29sb3JzLCAzKSk7XG5cbiAgICBjb25zdCBvcmlnaW5hbENvbG9ycyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3IuYXJyYXkuc2xpY2UoKVxuICAgIGNvbnN0IHRpbWVycyA9IG5ldyBGbG9hdDMyQXJyYXkoc3RhckNvdW50KVxuICAgIGNvbnN0IHNwYXJrQ29sb3JzID0gbmV3IEZsb2F0MzJBcnJheShzdGFyQ291bnQgKiAzKVxuICAgIGNvbnN0IHNwYXJrbGVEdXJhdGlvbiA9IDE4MFxuXG4gICAgLy8gLS0tIFNRVUFSRSBTVEFSUyBVU0lORyBQT0lOVFMgLS0tXG5jb25zdCBtYXRlcmlhbCA9IG5ldyBUSFJFRS5Qb2ludHNNYXRlcmlhbCh7IHNpemU6IDMuNSwgc2l6ZUF0dGVudWF0aW9uOiB0cnVlLCB2ZXJ0ZXhDb2xvcnM6IHRydWUgfSk7XG5jb25zdCBzdGFycyA9IG5ldyBUSFJFRS5Qb2ludHMoZ2VvbWV0cnksIG1hdGVyaWFsKTtcbnNjZW5lLmFkZChzdGFycyk7XG4vLyBBZGQgZ2xvdyBzcHJpdGVzIHRvIGVhY2ggc3RhciBhbmQgYW5pbWF0ZSB0aGVtIGJhc2VkIG9uIGRpc3RhbmNlXG5jb25zdCBnbG93TWFwID0gbmV3IFRIUkVFLlRleHR1cmVMb2FkZXIoKS5sb2FkKCdodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vbXJkb29iL3RocmVlLmpzL21hc3Rlci9leGFtcGxlcy90ZXh0dXJlcy9zcHJpdGVzL2dsb3cucG5nJyk7XG5jb25zdCBnbG93U3ByaXRlcyA9IFtdO1xuY29uc3QgZ2xvd01hdGVyaWFsID0gbmV3IFRIUkVFLlNwcml0ZU1hdGVyaWFsKHsgbWFwOiBnbG93TWFwLCBjb2xvcjogMHhmZmZmZmYsIG9wYWNpdHk6IDAuMTgsIGJsZW5kaW5nOiBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nLCBkZXB0aFdyaXRlOiBmYWxzZSB9KTtcbmZvciAobGV0IGkgPSAwOyBpIDwgc3RhckNvdW50OyBpKyspIHtcbiAgY29uc3QgZ2xvdyA9IG5ldyBUSFJFRS5TcHJpdGUoZ2xvd01hdGVyaWFsLmNsb25lKCkpO1xuICBnbG93LnBvc2l0aW9uLnNldChwb3NpdGlvbnNbaSozXSwgcG9zaXRpb25zW2kqMysxXSwgcG9zaXRpb25zW2kqMysyXSk7XG4gIGdsb3cuc2NhbGUuc2V0KDEwLCAxMCwgMSk7XG4gIHNjZW5lLmFkZChnbG93KTtcbiAgZ2xvd1Nwcml0ZXMucHVzaChnbG93KTtcbn1cbi8vIEFkZCBjbG9zZSBzdGFycyB0byBzZXBhcmF0ZSBzY2VuZVxubGV0IGNsb3NlU3RhcnM7XG5pZiAoY2xvc2VQb3NpdGlvbnMubGVuZ3RoID4gMCkge1xuICBjbG9zZVN0YXJzID0gbmV3IFRIUkVFLlBvaW50cyhjbG9zZUdlb21ldHJ5LCBtYXRlcmlhbC5jbG9uZSgpKTtcbiAgY2xvc2VTdGFyc1NjZW5lLmFkZChjbG9zZVN0YXJzKTtcbn1cblxuICAgIGxldCB0YXJnZXRZID0gMFxuICAgIGNvbnN0IGRhbXBpbmcgPSAwLjA1XG4gICAgY29uc3Qgb25TY3JvbGwgPSAoKSA9PiB7XG4gICAgICBjb25zdCBwY3QgPSB3aW5kb3cuc2Nyb2xsWSAvIChkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCAtIHdpbmRvdy5pbm5lckhlaWdodClcbiAgICAgIHRhcmdldFkgPSBwY3QgKiBNYXRoLlBJICogMlxuICAgIH1cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25TY3JvbGwpXG5cblxuICAgIC8vIC0tLSBTaG9vdGluZyBTdGFycyAtLS1cbiAgICBjb25zdCB0YWlsTGVuZ3RoID0gMzI7IC8vIEluY3JlYXNlIGZvciBsb25nZXIgdGFpbHNcbiAgICBjb25zdCBzaG9vdGluZ1N0YXJzID0gW107XG4gICAgbGV0IHNob290aW5nU3RhckNvb2xkb3duID0gMDtcbiAgICAvLyBTcGF3biBhIHNob290aW5nIHN0YXIgd2l0aCBhIHN0dW5uaW5nIGdsb3dpbmcgdGFpbFxuICAgIGZ1bmN0aW9uIHNwYXduU2hvb3RpbmdTdGFyKCkge1xuICAgICAgLy8gUGljayBhIHJhbmRvbSBkaXJlY3Rpb24gb24gdGhlIHNwaGVyZSBmb3IgdGhlIHNwYXduIGxvY2F0aW9uXG4gICAgICBjb25zdCBkaXIgPSBuZXcgVEhSRUUuVmVjdG9yMyhNYXRoLnJhbmRvbSgpKjItMSwgTWF0aC5yYW5kb20oKSoyLTEsIE1hdGgucmFuZG9tKCkqMi0xKS5ub3JtYWxpemUoKTtcbiAgICAgIC8vIEVuc3VyZSBzaG9vdGluZyBzdGFycyBuZXZlciBzcGF3biBjbG9zZSB0byB0aGUgY2FtZXJhIChhdCBsZWFzdCA3MCUgb2YgbWF4IGRpc3RhbmNlKVxuICAgICAgY29uc3QgbWluRGlzdCA9IHN0YXJNYXhEaXN0YW5jZSAqIDAuNztcbiAgICAgIGNvbnN0IG1heERpc3QgPSBzdGFyTWF4RGlzdGFuY2UgKiAxLjA7XG4gICAgICBjb25zdCBkaXN0ID0gbWluRGlzdCArIE1hdGgucmFuZG9tKCkgKiAobWF4RGlzdCAtIG1pbkRpc3QpO1xuICAgICAgY29uc3Qgc3Bhd25Qb3MgPSBkaXIuY2xvbmUoKS5tdWx0aXBseVNjYWxhcihkaXN0KTtcbiAgICAgIC8vIFRhbmdlbnRpYWwgdmVsb2NpdHk6IHBlcnBlbmRpY3VsYXIgdG8gZGlyXG4gICAgICBsZXQgdGFuZ2VudCA9IG5ldyBUSFJFRS5WZWN0b3IzKE1hdGgucmFuZG9tKCkqMi0xLCBNYXRoLnJhbmRvbSgpKjItMSwgTWF0aC5yYW5kb20oKSoyLTEpO1xuICAgICAgdGFuZ2VudCA9IHRhbmdlbnQuc3ViKHRhbmdlbnQuY2xvbmUoKS5wcm9qZWN0T25WZWN0b3IoZGlyKSkubm9ybWFsaXplKCk7XG4gICAgICAvLyBNaXggaW4gYSBzbWFsbCByYWRpYWwgY29tcG9uZW50IChpbndhcmQgb3Igb3V0d2FyZClcbiAgICAgIGNvbnN0IHRhbmdlbnRpYWxTcGVlZCA9IHN0YXJTcGVlZCAqICgyLjUgKyBNYXRoLnJhbmRvbSgpICogMi41KTsgLy8gbXVjaCBmYXN0ZXJcbiAgICAgIGNvbnN0IHJhZGlhbFNwZWVkID0gc3RhclNwZWVkICogKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMC4zOyAvLyBtb3JlIGRyYW1hdGljXG4gICAgICBjb25zdCB2ZWxvY2l0eSA9IHRhbmdlbnQubXVsdGlwbHlTY2FsYXIodGFuZ2VudGlhbFNwZWVkKS5hZGQoZGlyLmNsb25lKCkubXVsdGlwbHlTY2FsYXIocmFkaWFsU3BlZWQpKTtcblxuICAgICAgLy8gU3R1bm5pbmcgY29sb3IgZ3JhZGllbnQgZm9yIHRoZSBoZWFkXG4gICAgICBjb25zdCB2aWJyYW50Q29sb3JzID0gWzB4ZmZlMDY2LCAweGZmNjZjYywgMHg2NmNjZmYsIDB4ZmZmZmZmLCAweDgwZmZlYSwgMHhmZmYyY2MsIDB4ZmZjMDgwLCAweDgwYzBmZiwgMHhmZjgwYjNdO1xuICAgICAgY29uc3QgY29sb3IgPSB2aWJyYW50Q29sb3JzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSp2aWJyYW50Q29sb3JzLmxlbmd0aCldO1xuICAgICAgLy8gU3RhciBicmlnaHRuZXNzIGFuZCBzaXplIChhbHdheXMgc21hbGwgYW5kIHN1YnRsZSlcbiAgICAgIGNvbnN0IGJyaWdodG5lc3MgPSAyLjUgKyBNYXRoLnJhbmRvbSgpKjEuNTtcbiAgICAgIGNvbnN0IGdlbyA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeSgwLjcgKyBNYXRoLnJhbmRvbSgpKjAuNSwgMTYsIDE2KTsgLy8gU21hbGwgc3BoZXJlXG4gICAgICBjb25zdCBtYXQgPSBuZXcgVEhSRUUuTWVzaFBoeXNpY2FsTWF0ZXJpYWwoe1xuICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgIGVtaXNzaXZlOiBjb2xvcixcbiAgICAgICAgZW1pc3NpdmVJbnRlbnNpdHk6IDE0LjAsIC8vIEludGVuc2UgYmxvb21cbiAgICAgICAgbWV0YWxuZXNzOiAwLjcsXG4gICAgICAgIHJvdWdobmVzczogMC4zLFxuICAgICAgICB0cmFuc21pc3Npb246IDAuNyxcbiAgICAgICAgb3BhY2l0eTogMC45OCxcbiAgICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXG4gICAgICAgIGNsZWFyY29hdDogMC44LFxuICAgICAgICBjbGVhcmNvYXRSb3VnaG5lc3M6IDAuMixcbiAgICAgIH0pO1xuICAgICAgY29uc3Qgc3RhciA9IG5ldyBUSFJFRS5NZXNoKGdlbywgbWF0KTtcbiAgICAgIC8vIEFkZCBhIGxhcmdlLCBpbnRlbnNlIGJsb29tIHNwcml0ZSBmb3IgZXh0cmEgYmxvb21cbiAgICAgIGNvbnN0IHNwcml0ZU1hcCA9IG5ldyBUSFJFRS5UZXh0dXJlTG9hZGVyKCkubG9hZCgnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL21yZG9vYi90aHJlZS5qcy9tYXN0ZXIvZXhhbXBsZXMvdGV4dHVyZXMvc3ByaXRlcy9nbG93LnBuZycpO1xuICAgICAgY29uc3Qgc3ByaXRlTWF0ZXJpYWwgPSBuZXcgVEhSRUUuU3ByaXRlTWF0ZXJpYWwoeyBtYXA6IHNwcml0ZU1hcCwgY29sb3I6IDB4ZmZmZmZmLCBvcGFjaXR5OiAxLjAsIGJsZW5kaW5nOiBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nIH0pO1xuICAgICAgY29uc3Qgc3ByaXRlID0gbmV3IFRIUkVFLlNwcml0ZShzcHJpdGVNYXRlcmlhbCk7XG4gICAgICBzcHJpdGUuc2NhbGUuc2V0KDcwLCA3MCwgMSk7IC8vIExhcmdlIGZvciBibG9vbVxuICAgICAgc3ByaXRlLnBvc2l0aW9uLmNvcHkoc3Rhci5wb3NpdGlvbik7XG4gICAgICBzdGFyLmFkZChzcHJpdGUpO1xuICAgICAgLy8gQWRkIGEgY29sb3JlZCBzcHJpdGUgZm9yIGNvbG9yIHBvcFxuICAgICAgY29uc3QgY29sb3JTcHJpdGVNYXRlcmlhbCA9IG5ldyBUSFJFRS5TcHJpdGVNYXRlcmlhbCh7IG1hcDogc3ByaXRlTWFwLCBjb2xvcjogY29sb3IsIG9wYWNpdHk6IDAuNiwgYmxlbmRpbmc6IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmcgfSk7XG4gICAgICBjb25zdCBjb2xvclNwcml0ZSA9IG5ldyBUSFJFRS5TcHJpdGUoY29sb3JTcHJpdGVNYXRlcmlhbCk7XG4gICAgICBjb2xvclNwcml0ZS5zY2FsZS5zZXQoMzQsIDM0LCAxKTtcbiAgICAgIGNvbG9yU3ByaXRlLnBvc2l0aW9uLmNvcHkoc3Rhci5wb3NpdGlvbik7XG4gICAgICBzdGFyLmFkZChjb2xvclNwcml0ZSk7XG4gICAgICAvLyBBZGQgZHluYW1pYyBzcGFyayBidXJzdCBhdCB0aGUgaGVhZFxuICAgICAgY29uc3Qgc3BhcmtDb3VudCA9IDE4ICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKjgpO1xuICAgICAgY29uc3Qgc3BhcmtHcm91cCA9IG5ldyBUSFJFRS5Hcm91cCgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGFya0NvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3Qgc3BhcmtNYXQgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoeyBjb2xvcjogdmlicmFudENvbG9yc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqdmlicmFudENvbG9ycy5sZW5ndGgpXSwgdHJhbnNwYXJlbnQ6IHRydWUsIG9wYWNpdHk6IDAuOCB9KTtcbiAgICAgICAgY29uc3Qgc3BhcmtHZW8gPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoMC4wNyArIE1hdGgucmFuZG9tKCkqMC4wNiwgOCwgOCk7XG4gICAgICAgIGNvbnN0IHNwYXJrID0gbmV3IFRIUkVFLk1lc2goc3BhcmtHZW8sIHNwYXJrTWF0KTtcbiAgICAgICAgY29uc3QgYW5nbGUgPSAoaSAvIHNwYXJrQ291bnQpICogTWF0aC5QSSAqIDI7XG4gICAgICAgIHNwYXJrLnBvc2l0aW9uLnNldChNYXRoLmNvcyhhbmdsZSkqMS4yLCBNYXRoLnNpbihhbmdsZSkqMS4yLCBNYXRoLnJhbmRvbSgpKjAuNC0wLjIpO1xuICAgICAgICBzcGFya0dyb3VwLmFkZChzcGFyayk7XG4gICAgICB9XG4gICAgICBzcGFya0dyb3VwLm5hbWUgPSAnc3BhcmtCdXJzdCc7XG4gICAgICBzdGFyLmFkZChzcGFya0dyb3VwKTtcbiAgICAgIHN0YXIucG9zaXRpb24uY29weShzcGF3blBvcyk7XG4gICAgICBzdGFyLnZlbG9jaXR5ID0gdmVsb2NpdHk7XG4gICAgICBzdGFyLm5vcm1hbGl6ZWRMaWZlID0gMC4wO1xuICAgICAgc3Rhci5ub3JtYWxpemVkTGlmZXRpbWUgPSA4MCArIE1hdGgucmFuZG9tKCkgKiA4MDsgLy8gTG9uZ2VyLCBtb3JlIGRyYW1hdGljXG4gICAgICBzdGFyLmFnZSA9IDA7XG4gICAgICAvLyAtLS0gU3R1bm5pbmcgTWV0ZW9yIFRhaWwgKHZlcnkgbG9uZywgbXVsdGktY29sb3IsIGdsb3dpbmcsIGZhZGluZywgYW5kIDNEIGN1cnZlKSAtLS1cbiAgICAgIGNvbnN0IHRyYWlsU2VnbWVudHMgPSB0YWlsTGVuZ3RoICogMzsgLy8gRXZlbiBsb25nZXIgdGFpbFxuICAgICAgY29uc3QgdHJhaWxQb2ludHMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhaWxTZWdtZW50czsgaSsrKSB7XG4gICAgICAgIC8vIEFkZCBhIDNEIHNwaXJhbC9jdXJ2ZSBmb3IgbW9yZSBkZXB0aFxuICAgICAgICBjb25zdCBzcGlyYWwgPSBNYXRoLnNpbihpICogMC4yNSkgKiA4O1xuICAgICAgICBjb25zdCBjdXJ2ZSA9IE1hdGguY29zKGkgKiAwLjE1KSAqIDQ7XG4gICAgICAgIGNvbnN0IHB0ID0gc3Rhci5wb3NpdGlvbi5jbG9uZSgpLmFkZChuZXcgVEhSRUUuVmVjdG9yMyhzcGlyYWwsIGN1cnZlLCAtaSAqIDMpKTtcbiAgICAgICAgdHJhaWxQb2ludHMucHVzaChwdCk7XG4gICAgICB9XG4gICAgICBjb25zdCB0YWlsR2VvID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCkuc2V0RnJvbVBvaW50cyh0cmFpbFBvaW50cyk7XG4gICAgICAvLyBQZXItdmVydGV4IGNvbG9yIChtdWx0aS1jb2xvciByYWluYm93IGdyYWRpZW50KVxuICAgICAgY29uc3QgdGFpbENvbG9ycyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFpbFNlZ21lbnRzOyBpKyspIHtcbiAgICAgICAgLy8gQWxwaGEgZmFkZXMgb3V0IGFsb25nIHRoZSB0YWlsXG4gICAgICAgIGNvbnN0IGFscGhhID0gKDEgLSBpIC8gKHRyYWlsU2VnbWVudHMgLSAxKSkgKiAwLjk5O1xuICAgICAgICAvLyBSYWluYm93IGdyYWRpZW50XG4gICAgICAgIGNvbnN0IHJhaW5ib3cgPSBbMHhmZmUwNjYsIDB4ZmY2NmNjLCAweDY2Y2NmZiwgMHhmZmZmZmYsIDB4ODBmZmVhLCAweGZmZjJjYywgMHhmZmMwODAsIDB4ODBjMGZmLCAweGZmODBiM107XG4gICAgICAgIGNvbnN0IGdyYWRDb2xvciA9IHJhaW5ib3dbTWF0aC5mbG9vcigoaSAvIHRyYWlsU2VnbWVudHMpICogcmFpbmJvdy5sZW5ndGgpXTtcbiAgICAgICAgdGFpbENvbG9ycy5wdXNoKChncmFkQ29sb3IgPj4gMTYgJiAyNTUpIC8gMjU1LCAoZ3JhZENvbG9yID4+IDggJiAyNTUpIC8gMjU1LCAoZ3JhZENvbG9yICYgMjU1KSAvIDI1NSwgYWxwaGEpO1xuICAgICAgfVxuICAgICAgdGFpbEdlby5zZXRBdHRyaWJ1dGUoJ2NvbG9yJywgbmV3IFRIUkVFLkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodGFpbENvbG9ycywgNCkpO1xuICAgICAgLy8gQWRkaXRpdmUgYmxlbmRpbmcgZm9yIGdsb3cgKyBCTE9PTUVEIFRBSUxcbiAgICAgIGNvbnN0IHRhaWxNYXQgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoeyB2ZXJ0ZXhDb2xvcnM6IHRydWUsIHRyYW5zcGFyZW50OiB0cnVlLCBvcGFjaXR5OiAxLjAsIGJsZW5kaW5nOiBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nIH0pO1xuICAgICAgY29uc3QgdGFpbCA9IG5ldyBUSFJFRS5MaW5lKHRhaWxHZW8sIHRhaWxNYXQpO1xuICAgICAgdGFpbC5wb3NpdGlvbi5jb3B5KHN0YXIucG9zaXRpb24pO1xuICAgICAgLy8gQWRkIGEgYmxvb20gc3ByaXRlIHRvIHRoZSB0YWlsJ3MgaGVhZCBmb3IgZXh0cmEgZ2xvd1xuICAgICAgY29uc3QgdGFpbEdsb3dNYXAgPSBuZXcgVEhSRUUuVGV4dHVyZUxvYWRlcigpLmxvYWQoJ2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9tcmRvb2IvdGhyZWUuanMvbWFzdGVyL2V4YW1wbGVzL3RleHR1cmVzL3Nwcml0ZXMvZ2xvdy5wbmcnKTtcbiAgICAgIGNvbnN0IHRhaWxHbG93TWF0ID0gbmV3IFRIUkVFLlNwcml0ZU1hdGVyaWFsKHsgbWFwOiB0YWlsR2xvd01hcCwgY29sb3I6IDB4ZmZmZmZmLCBvcGFjaXR5OiAwLjg4LCBibGVuZGluZzogVEhSRUUuQWRkaXRpdmVCbGVuZGluZyB9KTtcbiAgICAgIGNvbnN0IHRhaWxHbG93ID0gbmV3IFRIUkVFLlNwcml0ZSh0YWlsR2xvd01hdCk7XG4gICAgICB0YWlsR2xvdy5zY2FsZS5zZXQoNTAsIDUwLCAxKTsgLy8gTGFyZ2VyIGZvciBtb3JlIGJsb29tXG4gICAgICB0YWlsR2xvdy5wb3NpdGlvbi5jb3B5KHN0YXIucG9zaXRpb24pO1xuICAgICAgc3Rhci5hZGQodGFpbEdsb3cpOyAvLyBBdHRhY2ggdG8gc3RhciBzbyBpdCBmb2xsb3dzIGhlYWRcbiAgICAgIC8vIEFkZCB0byBzY2VuZVxuICAgICAgc2NlbmUuYWRkKHN0YXIpO1xuICAgICAgc2NlbmUuYWRkKHRhaWwpO1xuICAgICAgc2hvb3RpbmdTdGFycy5wdXNoKHsgbWVzaDogc3RhciwgdGFpbCwgdmVsb2NpdHk6IHN0YXIudmVsb2NpdHksIGRpciwgYWdlOiAwLCBub3JtYWxpemVkTGlmZXRpbWU6IHN0YXIubm9ybWFsaXplZExpZmV0aW1lLCB0cmFpbFBvaW50cywgY29sb3IsIGJyaWdodG5lc3MsIGhhc0ZyYWdtZW50ZWQ6IGZhbHNlIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGFuaW1hdGUgPSAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuICAgICAgLy8gUmVuZGVyIG1haW4gc2NlbmUgd2l0aCBibG9vbVxuICAgICAgY29tcG9zZXIucmVuZGVyKCk7XG4gICAgICAvLyBPdmVybGF5IGNsb3NlIHN0YXJzIHdpdGggY2hyb21hdGljIGFiZXJyYXRpb24gKG9ubHkgY2xvc2Ugc3RhcnMgZ2V0IENBKVxuICAgICAgaWYgKGNsb3NlU3RhcnMpIHtcbiAgICAgICAgY2FDb21wb3Nlci5yZW5kZXIoKTtcbiAgICAgIH1cblxuICAgICAgY2FtZXJhLnJvdGF0aW9uLnkgKz0gKHRhcmdldFkgLSBjYW1lcmEucm90YXRpb24ueSkgKiBkYW1waW5nO1xuICAgICAgLy8gTW92ZSB0aGUgdmlydHVhbCBjYW1lcmEgcG9zaXRpb24gaW4gdGhlIGRpcmVjdGlvbiB0aGUgY2FtZXJhIGlzIGZhY2luZ1xuICAgICAgY29uc3QgZm9yd2FyZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICBjYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oZm9yd2FyZCk7XG4gICAgICB2aXJ0dWFsQ2FtZXJhUG9zLmFkZChmb3J3YXJkLm11bHRpcGx5U2NhbGFyKHN0YXJTcGVlZCkpO1xuICAgICAgLy8gT2Zmc2V0IGFsbCBzdGFycyBieSAtdmlydHVhbENhbWVyYVBvcyAoZmxvYXRpbmcgb3JpZ2luKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3NpdGlvbnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheVtpXSA9IHBvc2l0aW9uc1tpXSAtIHZpcnR1YWxDYW1lcmFQb3MueDtcbiAgICAgICAgZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheVtpKzFdID0gcG9zaXRpb25zW2krMV0gLSB2aXJ0dWFsQ2FtZXJhUG9zLnk7XG4gICAgICAgIGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXlbaSsyXSA9IHBvc2l0aW9uc1tpKzJdIC0gdmlydHVhbENhbWVyYVBvcy56O1xuICAgICAgICAvLyBBbmltYXRlIGdsb3cgc3ByaXRlIGZvciBkaXN0YW50L2Nsb3NlIGVmZmVjdFxuICAgICAgICBjb25zdCBnbG93ID0gZ2xvd1Nwcml0ZXNbaS8zXTtcbiAgICAgICAgY29uc3Qgc3RhclBvcyA9IG5ldyBUSFJFRS5WZWN0b3IzKHBvc2l0aW9uc1tpXSAtIHZpcnR1YWxDYW1lcmFQb3MueCwgcG9zaXRpb25zW2krMV0gLSB2aXJ0dWFsQ2FtZXJhUG9zLnksIHBvc2l0aW9uc1tpKzJdIC0gdmlydHVhbENhbWVyYVBvcy56KTtcbiAgICAgICAgY29uc3QgZGlzdCA9IHN0YXJQb3MubGVuZ3RoKCk7XG4gICAgICAgIC8vIElmIGNsb3NlLCByZWR1Y2UvaGlkZSBnbG93LCBpZiBmYXIsIG1ha2UgZ2xvdyBiaWcgYW5kIGJyaWdodFxuICAgICAgICBpZiAoZGlzdCA8IDQwMCkge1xuICAgICAgICAgIGdsb3cubWF0ZXJpYWwub3BhY2l0eSA9IDAuMDYgKyAwLjA4ICogTWF0aC5yYW5kb20oKTsgLy8gc3VidGxlIGZsaWNrZXJcbiAgICAgICAgICBnbG93LnNjYWxlLnNldCg3LCA3LCAxKTtcbiAgICAgICAgfSBlbHNlIGlmIChkaXN0ID4gMTIwMCkge1xuICAgICAgICAgIGdsb3cubWF0ZXJpYWwub3BhY2l0eSA9IDAuMzggKyAwLjE4ICogTWF0aC5yYW5kb20oKTsgLy8gaW50ZW5zZVxuICAgICAgICAgIGdsb3cuc2NhbGUuc2V0KDMyLCAzMiwgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaW50ZXJwb2xhdGVcbiAgICAgICAgICBjb25zdCB0ID0gKGRpc3QtNDAwKS8oMTIwMC00MDApO1xuICAgICAgICAgIGdsb3cubWF0ZXJpYWwub3BhY2l0eSA9IDAuMDggKyAwLjMqdCArIDAuMDggKiBNYXRoLnJhbmRvbSgpO1xuICAgICAgICAgIGNvbnN0IHMgPSA3ICsgKDMyLTcpKnQ7XG4gICAgICAgICAgZ2xvdy5zY2FsZS5zZXQocywgcywgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2xvdy5wb3NpdGlvbi5jb3B5KHN0YXJQb3MpO1xuICAgICAgfVxuICAgICAgaWYgKGNsb3NlU3RhcnMgJiYgY2xvc2VHZW9tZXRyeSAmJiBjbG9zZVBvc2l0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2xvc2VQb3NpdGlvbnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICBjbG9zZUdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXlbaV0gPSBjbG9zZVBvc2l0aW9uc1tpXSAtIHZpcnR1YWxDYW1lcmFQb3MueDtcbiAgICAgICAgICBjbG9zZUdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXlbaSsxXSA9IGNsb3NlUG9zaXRpb25zW2krMV0gLSB2aXJ0dWFsQ2FtZXJhUG9zLnk7XG4gICAgICAgICAgY2xvc2VHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5W2krMl0gPSBjbG9zZVBvc2l0aW9uc1tpKzJdIC0gdmlydHVhbENhbWVyYVBvcy56O1xuICAgICAgICB9XG4gICAgICAgIGNsb3NlR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgLy8gLS0tIFNob290aW5nIHN0YXIgc3Bhd25pbmcgLS0tXG4gICAgICBpZiAoc2hvb3RpbmdTdGFyQ29vbGRvd24gPD0gMCAmJiBNYXRoLnJhbmRvbSgpIDwgMC4xKSB7XG4gICAgICAgIHNwYXduU2hvb3RpbmdTdGFyKCk7XG4gICAgICAgIGlmIChjYW1lcmEpIHtcbiAgICAgICAgICBjb25zdCBzaGFrZVN0cmVuZ3RoID0gMC4wNiArIE1hdGgucmFuZG9tKCkqMC4wNDtcbiAgICAgICAgICBjYW1lcmEucG9zaXRpb24ueCArPSAoTWF0aC5yYW5kb20oKS0wLjUpKnNoYWtlU3RyZW5ndGg7XG4gICAgICAgICAgY2FtZXJhLnBvc2l0aW9uLnkgKz0gKE1hdGgucmFuZG9tKCktMC41KSpzaGFrZVN0cmVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHNob290aW5nU3RhckNvb2xkb3duID0gMTAgKyBNYXRoLnJhbmRvbSgpICogMTA7XG4gICAgICB9IGVsc2UgaWYgKHNob290aW5nU3RhckNvb2xkb3duID4gMCkge1xuICAgICAgICBzaG9vdGluZ1N0YXJDb29sZG93bi0tO1xuICAgICAgfVxuICAgICAgLy8gQW5pbWF0ZSBhbmQgY2xlYW4gdXAgc2hvb3Rpbmcgc3RhcnNcbiAgICAgIGZvciAobGV0IGkgPSBzaG9vdGluZ1N0YXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHNob290aW5nU3RhcnNbaV07XG4gICAgICAgIC8vIEFuaW1hdGUgc3BhcmsgYnVyc3QgKGZhZGUgYW5kIGV4cGFuZClcbiAgICAgICAgaWYgKG9iai5tZXNoLmNoaWxkcmVuKSB7XG4gICAgICAgICAgY29uc3Qgc3BhcmtzID0gb2JqLm1lc2guY2hpbGRyZW4uZmluZChjaGlsZCA9PiBjaGlsZC5uYW1lID09PSAnc3BhcmtCdXJzdCcpO1xuICAgICAgICAgIGlmIChzcGFya3MpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3BhcmtzLmNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHNwYXJrID0gc3BhcmtzLmNoaWxkcmVuW2pdO1xuICAgICAgICAgICAgICBzcGFyay5tYXRlcmlhbC5vcGFjaXR5ICo9IDAuOTY7IC8vIEZhZGVcbiAgICAgICAgICAgICAgc3Bhcmsuc2NhbGUubXVsdGlwbHlTY2FsYXIoMS4wMyk7IC8vIEV4cGFuZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBbmltYXRlIHRhaWwgc2hpbW1lciBhbmQgY29sb3IgY3ljbGluZ1xuICAgICAgICBpZiAob2JqLnRhaWwgJiYgb2JqLnRyYWlsUG9pbnRzKSB7XG4gICAgICAgICAgY29uc3QgdGltZSA9IHBlcmZvcm1hbmNlLm5vdygpICogMC4wMDE7XG4gICAgICAgICAgY29uc3QgdGFpbEdlbyA9IG9iai50YWlsLmdlb21ldHJ5O1xuICAgICAgICAgIGNvbnN0IHRhaWxDb2xvcnMgPSB0YWlsR2VvLmdldEF0dHJpYnV0ZSgnY29sb3InKTtcbiAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHRhaWxDb2xvcnMuY291bnQ7IGsrKykge1xuICAgICAgICAgICAgLy8gQ3ljbGUgaHVlXG4gICAgICAgICAgICBsZXQgciA9IHRhaWxDb2xvcnMuZ2V0WChrKSwgZyA9IHRhaWxDb2xvcnMuZ2V0WShrKSwgYiA9IHRhaWxDb2xvcnMuZ2V0WihrKTtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gSFNMXG4gICAgICAgICAgICBjb25zdCBtYXggPSBNYXRoLm1heChyLGcsYiksIG1pbiA9IE1hdGgubWluKHIsZyxiKTtcbiAgICAgICAgICAgIGxldCBoLHMsbDtcbiAgICAgICAgICAgIGwgPSAobWF4K21pbikvMjtcbiAgICAgICAgICAgIGlmIChtYXggPT09IG1pbikge2ggPSBzID0gMDt9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCBkID0gbWF4LW1pbjtcbiAgICAgICAgICAgICAgcyA9IGwgPiAwLjUgPyBkLygyLW1heC1taW4pIDogZC8obWF4K21pbik7XG4gICAgICAgICAgICAgIHN3aXRjaChtYXgpe1xuICAgICAgICAgICAgICAgIGNhc2UgcjogaCA9IChnLWIpL2QgKyAoZzxiPzY6MCk7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgZzogaCA9IChiLXIpL2QgKyAyOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIGI6IGggPSAoci1nKS9kICsgNDsgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaC89NjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGggPSAoaCArIDAuMjUqTWF0aC5zaW4odGltZSArIGsqMC4yKSkgJSAxLjA7IC8vIEFuaW1hdGUgaHVlXG4gICAgICAgICAgICAvLyBDb252ZXJ0IGJhY2sgdG8gUkdCXG4gICAgICAgICAgICBsZXQgcSA9IGwgPCAwLjUgPyBsKigxK3MpIDogbCtzLWwqcztcbiAgICAgICAgICAgIGxldCBwID0gMipsLXE7XG4gICAgICAgICAgICBsZXQgdHIgPSBoKzEvMywgdGcgPSBoLCB0YiA9IGgtMS8zO1xuICAgICAgICAgICAgY29uc3QgaHVlMnJnYiA9IChwLHEsdCkgPT4ge1xuICAgICAgICAgICAgICBpZiAodDwwKSB0Kz0xOyBpZiAodD4xKSB0LT0xO1xuICAgICAgICAgICAgICBpZiAodDwxLzYpIHJldHVybiBwKyhxLXApKjYqdDtcbiAgICAgICAgICAgICAgaWYgKHQ8MS8yKSByZXR1cm4gcTtcbiAgICAgICAgICAgICAgaWYgKHQ8Mi8zKSByZXR1cm4gcCsocS1wKSooMi8zLXQpKjY7XG4gICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRhaWxDb2xvcnMuc2V0WChrLCBodWUycmdiKHAscSx0cikpO1xuICAgICAgICAgICAgdGFpbENvbG9ycy5zZXRZKGssIGh1ZTJyZ2IocCxxLHRnKSk7XG4gICAgICAgICAgICB0YWlsQ29sb3JzLnNldFooaywgaHVlMnJnYihwLHEsdGIpKTtcbiAgICAgICAgICAgIC8vIFNoaW1tZXI6IG1vZHVsYXRlIGFscGhhXG4gICAgICAgICAgICB0YWlsQ29sb3JzLnNldFcoaywgdGFpbENvbG9ycy5nZXRXKGspICogKDAuOTcgKyAwLjAzKk1hdGguc2luKHRpbWUqOCArIGspKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRhaWxDb2xvcnMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0cmFpZ2h0LWxpbmUgdHJhamVjdG9yeVxuICAgICAgICBvYmoubWVzaC5wb3NpdGlvbi5hZGQob2JqLnZlbG9jaXR5KTtcbiAgICAgICAgb2JqLnRhaWwucG9zaXRpb24uY29weShvYmoubWVzaC5wb3NpdGlvbik7XG4gICAgICAgIC8vIEFuaW1hdGUgdGFpbCAobm8gbGVycCwganVzdCBkcmFnKVxuICAgICAgICBvYmouYWdlKys7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRMaWZlID0gb2JqLmFnZSAvIG9iai5ub3JtYWxpemVkTGlmZXRpbWU7XG4gICAgICAgIG9iai50cmFpbFBvaW50cy51bnNoaWZ0KG9iai5tZXNoLnBvc2l0aW9uLmNsb25lKCkpO1xuICAgICAgICBpZiAob2JqLnRyYWlsUG9pbnRzLmxlbmd0aCA+IHRhaWxMZW5ndGggKiAzKSBvYmoudHJhaWxQb2ludHMucG9wKCk7XG4gICAgICAgIGxldCB0YWlsR3JvdyA9IE1hdGgubWluKDEsIG5vcm1hbGl6ZWRMaWZlIC8gMC4zKTtcbiAgICAgICAgbGV0IGFjdGl2ZVNlZ21lbnRzID0gTWF0aC5mbG9vcihvYmoudHJhaWxQb2ludHMubGVuZ3RoICogdGFpbEdyb3cpO1xuICAgICAgICBpZiAoYWN0aXZlU2VnbWVudHMgPCAyKSBhY3RpdmVTZWdtZW50cyA9IDI7XG4gICAgICAgIGNvbnN0IHZpc2libGVUcmFpbCA9IG9iai50cmFpbFBvaW50cy5zbGljZSgwLCBhY3RpdmVTZWdtZW50cyk7XG4gICAgICAgIG9iai50YWlsLmdlb21ldHJ5LnNldEZyb21Qb2ludHModmlzaWJsZVRyYWlsKTtcbiAgICAgICAgY29uc3QgdGFpbENvbG9ycyA9IG9iai50YWlsLmdlb21ldHJ5LmdldEF0dHJpYnV0ZSgnY29sb3InKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2aXNpYmxlVHJhaWwubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBsZXQgYWxwaGEgPSAoMSAtIGogLyAodmlzaWJsZVRyYWlsLmxlbmd0aCAtIDEpKSAqIDAuOTU7XG4gICAgICAgICAgYWxwaGEgKj0gMC45MiArIDAuMDggKiBNYXRoLnNpbihEYXRlLm5vdygpKjAuMDE1ICsgaiowLjUpO1xuICAgICAgICAgIGxldCByYWluYm93ID0gWzB4ZmZjMDgwLCAweGZmZTA4MCwgMHhmZmZmODAsIDB4ODBmZmU2LCAweDgwYzBmZiwgMHhjMDgwZmZdO1xuICAgICAgICAgIGxldCBncmFkQ29sb3IgPSByYWluYm93W2ogJSByYWluYm93Lmxlbmd0aF07XG4gICAgICAgICAgaWYgKG5vcm1hbGl6ZWRMaWZlID4gMC43KSBhbHBoYSAqPSBNYXRoLm1heCgwLCAxIC0gKG5vcm1hbGl6ZWRMaWZlIC0gMC43IC0gMC4yKSAvIDAuMyk7XG4gICAgICAgICAgdGFpbENvbG9ycy5zZXRYWVpXKGosIChncmFkQ29sb3IgPj4gMTYgJiAyNTUpIC8gMjU1LCAoZ3JhZENvbG9yID4+IDggJiAyNTUpIC8gMjU1LCAoZ3JhZENvbG9yICYgMjU1KSAvIDI1NSwgYWxwaGEpO1xuICAgICAgICB9XG4gICAgICAgIHRhaWxDb2xvcnMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAvLyBBbmltYXRlIGhlYWRcbiAgICAgICAgbGV0IGhlYWRDb2xvcjtcbiAgICAgICAgaWYgKG5vcm1hbGl6ZWRMaWZlIDwgMC41KSB7XG4gICAgICAgICAgaGVhZENvbG9yID0gbmV3IFRIUkVFLkNvbG9yKG9iai5jb2xvcikubGVycChuZXcgVEhSRUUuQ29sb3IoMHhmZmMwODApLCBub3JtYWxpemVkTGlmZSoyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoZWFkQ29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoMHhmZmMwODApLmxlcnAobmV3IFRIUkVFLkNvbG9yKDB4ZmY0MDAwKSwgKG5vcm1hbGl6ZWRMaWZlLTAuNSkqMik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZsaWNrZXIgPSAwLjk1ICsgMC4xMyAqIE1hdGguc2luKERhdGUubm93KCkqMC4wNyArIE1hdGgucmFuZG9tKCkqMTApO1xuICAgICAgICBoZWFkQ29sb3IubXVsdGlwbHlTY2FsYXIoZmxpY2tlcik7XG4gICAgICAgIG9iai5tZXNoLm1hdGVyaWFsLmNvbG9yLmNvcHkoaGVhZENvbG9yKTtcbiAgICAgICAgbGV0IHNjYWxlID0gMSArIDIuMiAqIE1hdGguc2luKE1hdGguUEkgKiBub3JtYWxpemVkTGlmZSk7XG4gICAgICAgIGxldCBkaXN0VG9DYW0gPSBvYmoubWVzaC5wb3NpdGlvbi5sZW5ndGgoKTtcbiAgICAgICAgbGV0IGRvZkJsdXIgPSBkaXN0VG9DYW0gPCBzdGFyTWF4RGlzdGFuY2UgKiAwLjcgPyAwLjcgOiAxLjA7XG4gICAgICAgIG9iai5tZXNoLnNjYWxlLnNldChzY2FsZSAqIGRvZkJsdXIsIHNjYWxlICogZG9mQmx1ciwgc2NhbGUgKiBkb2ZCbHVyKTtcbiAgICAgICAgLy8gU3BhcmtsZSBidXJzdFxuICAgICAgICBpZiAobm9ybWFsaXplZExpZmUgPj0gMSAmJiAhb2JqLmhhc0ZyYWdtZW50ZWQpIHtcbiAgICAgICAgICAvLyAtLS0gU1BFQ1RBQ1VMQVIgRVhQTE9TSU9OICh2ZXJ5IHJhcmUpIC0tLVxuICAgICAgICAgIGNvbnN0IHNwZWN0YWN1bGFyID0gTWF0aC5yYW5kb20oKSA8IDAuMDI7IC8vIDIlIGNoYW5jZVxuICAgICAgICAgIGNvbnN0IGJ1cnN0Q291bnQgPSBzcGVjdGFjdWxhciA/IDEyMCArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSo2MCkgOiAxOCArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSo4KTtcbiAgICAgICAgICBjb25zdCBwYWxldHRlID0gc3BlY3RhY3VsYXJcbiAgICAgICAgICAgID8gWzB4ZmZlMDY2LCAweGZmNjZjYywgMHg2NmNjZmYsIDB4ZmZmZmZmLCAweDgwZmZlYSwgMHhmZmYyY2MsIDB4ZmZjMDgwLCAweDgwYzBmZiwgMHhmZjgwYjMsIDB4ZmYwMDAwLCAweDAwZmYwMCwgMHgwMDAwZmYsIDB4ZmZmZjAwLCAweDAwZmZmZiwgMHhmZjAwZmYsIDB4ZmY4ODAwLCAweDAwZmY4OCwgMHg4ODAwZmZdXG4gICAgICAgICAgICA6IFsweGZmZmZmZiwgMHhmZmY2YzAsIDB4ZmZlMDY2LCAweGZmYzA4MCwgMHg4MGMwZmZdO1xuICAgICAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgYnVyc3RDb3VudDsgcysrKSB7XG4gICAgICAgICAgICBjb25zdCBjb2xvciA9IHBhbGV0dGVbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKnBhbGV0dGUubGVuZ3RoKV07XG4gICAgICAgICAgICBjb25zdCBzaXplID0gc3BlY3RhY3VsYXIgPyAoMS4yICsgTWF0aC5yYW5kb20oKSoyLjIpIDogKDAuNyArIE1hdGgucmFuZG9tKCkqMC44KTtcbiAgICAgICAgICAgIGNvbnN0IHNwYXJrbGVHZW8gPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoc2l6ZSwgOCwgOCk7XG4gICAgICAgICAgICBjb25zdCBzcGFya2xlTWF0ID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHsgY29sb3IsIHRyYW5zcGFyZW50OiB0cnVlLCBvcGFjaXR5OiBzcGVjdGFjdWxhciA/IDAuOTIgOiAwLjcsIGJsZW5kaW5nOiBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nIH0pO1xuICAgICAgICAgICAgY29uc3Qgc3BhcmtsZSA9IG5ldyBUSFJFRS5NZXNoKHNwYXJrbGVHZW8sIHNwYXJrbGVNYXQpO1xuICAgICAgICAgICAgc3BhcmtsZS5wb3NpdGlvbi5jb3B5KG9iai5tZXNoLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIC8vIFNwZWN0YWN1bGFyOiBodWdlLCBmYXN0LCByYW5kb20gZGlyZWN0aW9uczsgbm9ybWFsOiBtb2RlcmF0ZVxuICAgICAgICAgICAgY29uc3Qgc3BkID0gc3BlY3RhY3VsYXIgPyAoNCArIE1hdGgucmFuZG9tKCkqOCkgOiAoMiArIE1hdGgucmFuZG9tKCkqMik7XG4gICAgICAgICAgICBjb25zdCBzcGFya2xlVmVsID0gbmV3IFRIUkVFLlZlY3RvcjMoTWF0aC5yYW5kb20oKS0wLjUsIE1hdGgucmFuZG9tKCktMC41LCBNYXRoLnJhbmRvbSgpLTAuNSkubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoc3BkKTtcbiAgICAgICAgICAgIHNwYXJrbGUudXNlckRhdGEgPSB7IHZlbG9jaXR5OiBzcGFya2xlVmVsLCBhZ2U6IDAsIHNwZWN0YWN1bGFyLCBtYXhBZ2U6IHNwZWN0YWN1bGFyID8gODAgKyBNYXRoLnJhbmRvbSgpKjQwIDogNDAgKyBNYXRoLnJhbmRvbSgpKjIwIH07IC8vIDwtLSBMT05HRVIgTElGRVxuICAgICAgICAgICAgc2NlbmUuYWRkKHNwYXJrbGUpO1xuICAgICAgICAgICAgaWYgKCF3aW5kb3cuX3NwYXJrbGVzKSB3aW5kb3cuX3NwYXJrbGVzID0gW107XG4gICAgICAgICAgICB3aW5kb3cuX3NwYXJrbGVzLnB1c2goc3BhcmtsZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzcGVjdGFjdWxhcikge1xuICAgICAgICAgICAgLy8gQWRkIGEgYmlnIGZsYXNoXG4gICAgICAgICAgICBjb25zdCBmbGFzaEdlbyA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeSg2LCAyNCwgMjQpO1xuICAgICAgICAgICAgY29uc3QgZmxhc2hNYXQgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoeyBjb2xvcjogMHhmZmZmZmYsIHRyYW5zcGFyZW50OiB0cnVlLCBvcGFjaXR5OiAwLjgsIGJsZW5kaW5nOiBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nIH0pO1xuICAgICAgICAgICAgY29uc3QgZmxhc2ggPSBuZXcgVEhSRUUuTWVzaChmbGFzaEdlbywgZmxhc2hNYXQpO1xuICAgICAgICAgICAgZmxhc2gucG9zaXRpb24uY29weShvYmoubWVzaC5wb3NpdGlvbik7XG4gICAgICAgICAgICBzY2VuZS5hZGQoZmxhc2gpO1xuICAgICAgICAgICAgaWYgKCF3aW5kb3cuX3N0YXJGbGFzaGVzKSB3aW5kb3cuX3N0YXJGbGFzaGVzID0gW107XG4gICAgICAgICAgICB3aW5kb3cuX3N0YXJGbGFzaGVzLnB1c2goeyBtZXNoOiBmbGFzaCwgYWdlOiAwIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBGcmFnbWVudGVkIHRyYWlsIGxvZ2ljIChrZWVwIGFzIGJlZm9yZSlcbiAgICAgICAgICBjb25zdCBmcmFnVmVsID0gb2JqLnZlbG9jaXR5LmNsb25lKCkuYXBwbHlBeGlzQW5nbGUobmV3IFRIUkVFLlZlY3RvcjMoMCwxLDApLCAoTWF0aC5yYW5kb20oKS0wLjUpKjAuMyk7XG4gICAgICAgICAgY29uc3QgZnJhZ1N0YXIgPSBvYmoubWVzaC5jbG9uZSgpO1xuICAgICAgICAgIGZyYWdTdGFyLnBvc2l0aW9uLmNvcHkob2JqLm1lc2gucG9zaXRpb24pO1xuICAgICAgICAgIGZyYWdTdGFyLnZlbG9jaXR5ID0gZnJhZ1ZlbDtcbiAgICAgICAgICBmcmFnU3Rhci5ub3JtYWxpemVkTGlmZSA9IG5vcm1hbGl6ZWRMaWZlO1xuICAgICAgICAgIGZyYWdTdGFyLm5vcm1hbGl6ZWRMaWZldGltZSA9IG9iai5ub3JtYWxpemVkTGlmZXRpbWUgKiAoMC41ICsgTWF0aC5yYW5kb20oKSowLjUpO1xuICAgICAgICAgIGZyYWdTdGFyLmFnZSA9IG9iai5hZ2U7XG4gICAgICAgICAgZnJhZ1N0YXIubWF0ZXJpYWwgPSBvYmoubWVzaC5tYXRlcmlhbC5jbG9uZSgpO1xuICAgICAgICAgIGNvbnN0IGZyYWdUcmFpbFBvaW50cyA9IG9iai50cmFpbFBvaW50cy5zbGljZSgpO1xuICAgICAgICAgIGNvbnN0IGZyYWdUYWlsR2VvID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCkuc2V0RnJvbVBvaW50cyhmcmFnVHJhaWxQb2ludHMpO1xuICAgICAgICAgIGZyYWdUYWlsR2VvLnNldEF0dHJpYnV0ZSgnY29sb3InLCBvYmoudGFpbC5nZW9tZXRyeS5nZXRBdHRyaWJ1dGUoJ2NvbG9yJykuY2xvbmUoKSk7XG4gICAgICAgICAgY29uc3QgZnJhZ1RhaWxNYXQgPSBvYmoudGFpbC5tYXRlcmlhbC5jbG9uZSgpO1xuICAgICAgICAgIGNvbnN0IGZyYWdUYWlsID0gbmV3IFRIUkVFLkxpbmUoZnJhZ1RhaWxHZW8sIGZyYWdUYWlsTWF0KTtcbiAgICAgICAgICBmcmFnVGFpbC5wb3NpdGlvbi5jb3B5KGZyYWdTdGFyLnBvc2l0aW9uKTtcbiAgICAgICAgICBzY2VuZS5hZGQoZnJhZ1N0YXIpO1xuICAgICAgICAgIHNjZW5lLmFkZChmcmFnVGFpbCk7XG4gICAgICAgICAgc2hvb3RpbmdTdGFycy5wdXNoKHsgbWVzaDogZnJhZ1N0YXIsIHRhaWw6IGZyYWdUYWlsLCB2ZWxvY2l0eTogZnJhZ1N0YXIudmVsb2NpdHksIGRpcjogb2JqLmRpciwgYWdlOiBmcmFnU3Rhci5hZ2UsIG5vcm1hbGl6ZWRMaWZldGltZTogZnJhZ1N0YXIubm9ybWFsaXplZExpZmV0aW1lLCB0cmFpbFBvaW50czogZnJhZ1RyYWlsUG9pbnRzLCBjb2xvcjogb2JqLmNvbG9yLCBicmlnaHRuZXNzOiBvYmouYnJpZ2h0bmVzcywgaGFzRnJhZ21lbnRlZDogdHJ1ZSB9KTtcbiAgICAgICAgICBvYmouaGFzRnJhZ21lbnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3BhcmsgYnVyc3RcbiAgICAgICAgaWYgKCFvYmouaGFzU3BhcmtlZCAmJiBub3JtYWxpemVkTGlmZSA+IDAuOTUgJiYgTWF0aC5yYW5kb20oKSA8IDAuMSkge1xuICAgICAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgOCArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSo4KTsgcysrKSB7XG4gICAgICAgICAgICBjb25zdCBzcGFya0dlbyA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeSgwLjUgKyBNYXRoLnJhbmRvbSgpKjAuNSwgOCwgOCk7XG4gICAgICAgICAgICBjb25zdCBzcGFya01hdCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7IGNvbG9yOiAweGZmZjZjMCwgdHJhbnNwYXJlbnQ6IHRydWUsIG9wYWNpdHk6IDEsIGJsZW5kaW5nOiBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nIH0pO1xuICAgICAgICAgICAgY29uc3Qgc3BhcmsgPSBuZXcgVEhSRUUuTWVzaChzcGFya0dlbywgc3BhcmtNYXQpO1xuICAgICAgICAgICAgc3BhcmsucG9zaXRpb24uY29weShvYmoubWVzaC5wb3NpdGlvbik7XG4gICAgICAgICAgICBzcGFyay5zcGFya1ZlbCA9IG5ldyBUSFJFRS5WZWN0b3IzKE1hdGgucmFuZG9tKCktMC41LCBNYXRoLnJhbmRvbSgpLTAuNSwgTWF0aC5yYW5kb20oKS0wLjUpLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKDAuNSArIE1hdGgucmFuZG9tKCkqMS4yKTtcbiAgICAgICAgICAgIHNwYXJrLnNwYXJrTGlmZSA9IDEyICsgTWF0aC5yYW5kb20oKSoxMDtcbiAgICAgICAgICAgIHNwYXJrLnNwYXJrQWdlID0gMDtcbiAgICAgICAgICAgIHNjZW5lLmFkZChzcGFyayk7XG4gICAgICAgICAgICBpZiAoIXdpbmRvdy5fc3RhclNwYXJrcykgd2luZG93Ll9zdGFyU3BhcmtzID0gW107XG4gICAgICAgICAgICB3aW5kb3cuX3N0YXJTcGFya3MucHVzaChzcGFyayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9iai5oYXNTcGFya2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGbGFzaFxuICAgICAgICBpZiAoIW9iai5oYXNGbGFzaGVkICYmIG5vcm1hbGl6ZWRMaWZlID4gMC45OCAmJiBNYXRoLnJhbmRvbSgpIDwgMC4yKSB7XG4gICAgICAgICAgY29uc3QgZmxhc2hHZW8gPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoMSwgMTYsIDE2KTtcbiAgICAgICAgICBjb25zdCBmbGFzaE1hdCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7IGNvbG9yOiAweGZmZmZlZSwgdHJhbnNwYXJlbnQ6IHRydWUsIG9wYWNpdHk6IDAuOCwgYmxlbmRpbmc6IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmcgfSk7XG4gICAgICAgICAgY29uc3QgZmxhc2ggPSBuZXcgVEhSRUUuTWVzaChmbGFzaEdlbywgZmxhc2hNYXQpO1xuICAgICAgICAgIGZsYXNoLnBvc2l0aW9uLmNvcHkob2JqLm1lc2gucG9zaXRpb24pO1xuICAgICAgICAgIHNjZW5lLmFkZChmbGFzaCk7XG4gICAgICAgICAgaWYgKCF3aW5kb3cuX3N0YXJGbGFzaGVzKSB3aW5kb3cuX3N0YXJGbGFzaGVzID0gW107XG4gICAgICAgICAgd2luZG93Ll9zdGFyRmxhc2hlcy5wdXNoKHsgbWVzaDogZmxhc2gsIGFnZTogMCB9KTtcbiAgICAgICAgICBvYmouaGFzRmxhc2hlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmFkZSBvdXQgYXMgaXQgZ2V0cyBmYXIgYXdheVxuICAgICAgICBjb25zdCBkaXN0ID0gb2JqLm1lc2gucG9zaXRpb24uZGlzdGFuY2VUbyhjYW1lcmEucG9zaXRpb24pO1xuICAgICAgICBjb25zdCBmYWRlU3RhcnQgPSBzdGFyTWF4RGlzdGFuY2UgKiAwLjU7XG4gICAgICAgIGlmIChkaXN0ID4gZmFkZVN0YXJ0KSB7XG4gICAgICAgICAgY29uc3QgZmFkZSA9IDEgLSAoZGlzdCAtIGZhZGVTdGFydCkgLyAoc3Rhck1heERpc3RhbmNlIC0gZmFkZVN0YXJ0KTtcbiAgICAgICAgICBvYmoubWVzaC5tYXRlcmlhbC5vcGFjaXR5ID0gTWF0aC5tYXgoMCwgZmFkZSk7XG4gICAgICAgICAgb2JqLm1lc2gubWF0ZXJpYWwudHJhbnNwYXJlbnQgPSB0cnVlO1xuICAgICAgICAgIG9iai50YWlsLm1hdGVyaWFsLm9wYWNpdHkgPSBNYXRoLm1heCgwLCBmYWRlICogMC44KTtcbiAgICAgICAgICBvYmoudGFpbC5tYXRlcmlhbC50cmFuc3BhcmVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHdoZW4gb3V0IG9mIGJvdW5kcyBvciBmdWxseSBmYWRlZCBvciBsaWZlIGVuZGVkXG4gICAgICAgIGlmIChub3JtYWxpemVkTGlmZSA+PSAxLjAgfHwgZGlzdCA+IHN0YXJNYXhEaXN0YW5jZSB8fCBvYmoubWVzaC5tYXRlcmlhbC5vcGFjaXR5IDw9IDAuMDEpIHtcbiAgICAgICAgICBzY2VuZS5yZW1vdmUob2JqLm1lc2gpO1xuICAgICAgICAgIHNjZW5lLnJlbW92ZShvYmoudGFpbCk7XG4gICAgICAgICAgc2hvb3RpbmdTdGFycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEFuaW1hdGUgc3BhcmtzXG4gICAgICBpZiAod2luZG93Ll9zdGFyU3BhcmtzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB3aW5kb3cuX3N0YXJTcGFya3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBjb25zdCBzcGFyayA9IHdpbmRvdy5fc3RhclNwYXJrc1tpXTtcbiAgICAgICAgICBzcGFyay5wb3NpdGlvbi5hZGQoc3Bhcmsuc3BhcmtWZWwpO1xuICAgICAgICAgIHNwYXJrLnNwYXJrQWdlKys7XG4gICAgICAgICAgc3BhcmsubWF0ZXJpYWwub3BhY2l0eSAqPSAwLjkyO1xuICAgICAgICAgIGlmIChzcGFyay5zcGFya0FnZSA+IHNwYXJrLnNwYXJrTGlmZSkge1xuICAgICAgICAgICAgc2NlbmUucmVtb3ZlKHNwYXJrKTtcbiAgICAgICAgICAgIHdpbmRvdy5fc3RhclNwYXJrcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBBbmltYXRlIGV4cGxvc2lvbiBwYXJ0aWNsZXMgKHNwYXJrbGVzKVxuICAgICAgaWYgKHdpbmRvdy5fc3BhcmtsZXMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHdpbmRvdy5fc3BhcmtsZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBjb25zdCBzcGFya2xlID0gd2luZG93Ll9zcGFya2xlc1tpXTtcbiAgICAgICAgICBzcGFya2xlLnBvc2l0aW9uLmFkZChzcGFya2xlLnVzZXJEYXRhLnZlbG9jaXR5KTtcbiAgICAgICAgICBzcGFya2xlLnVzZXJEYXRhLmFnZSsrO1xuICAgICAgICAgIHNwYXJrbGUubWF0ZXJpYWwub3BhY2l0eSAqPSAwLjk3O1xuICAgICAgICAgIGlmIChzcGFya2xlLnVzZXJEYXRhLmFnZSA+IChzcGFya2xlLnVzZXJEYXRhLm1heEFnZSB8fCA0MCkpIHtcbiAgICAgICAgICAgIHNjZW5lLnJlbW92ZShzcGFya2xlKTtcbiAgICAgICAgICAgIHdpbmRvdy5fc3BhcmtsZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQW5pbWF0ZSBmbGFzaGVzXG4gICAgICBpZiAod2luZG93Ll9zdGFyRmxhc2hlcykge1xuICAgICAgICBmb3IgKGxldCBpID0gd2luZG93Ll9zdGFyRmxhc2hlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGNvbnN0IGZsYXNoID0gd2luZG93Ll9zdGFyRmxhc2hlc1tpXTtcbiAgICAgICAgICBmbGFzaC5tZXNoLnNjYWxlLm11bHRpcGx5U2NhbGFyKDEuMTUpO1xuICAgICAgICAgIGZsYXNoLm1lc2gubWF0ZXJpYWwub3BhY2l0eSAqPSAwLjg1O1xuICAgICAgICAgIGZsYXNoLmFnZSsrO1xuICAgICAgICAgIGlmIChmbGFzaC5hZ2UgPiAxMCkge1xuICAgICAgICAgICAgc2NlbmUucmVtb3ZlKGZsYXNoLm1lc2gpO1xuICAgICAgICAgICAgd2luZG93Ll9zdGFyRmxhc2hlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIC0tLSBTdGFyZmllbGQgbG9naWMgLS0tXG4gICAgICBjb25zdCBzcURpc3QgPSBzdGFyTWF4RGlzdGFuY2UgKiBzdGFyTWF4RGlzdGFuY2U7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc2l0aW9ucy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICBjb25zdCBkeCA9IHBvc2l0aW9uc1tpXSAtIHZpcnR1YWxDYW1lcmFQb3MueDtcbiAgICAgICAgY29uc3QgZHkgPSBwb3NpdGlvbnNbaSArIDFdIC0gdmlydHVhbENhbWVyYVBvcy55O1xuICAgICAgICBjb25zdCBkeiA9IHBvc2l0aW9uc1tpICsgMl0gLSB2aXJ0dWFsQ2FtZXJhUG9zLno7XG4gICAgICAgIGlmIChkeCpkeCArIGR5KmR5ICsgZHoqZHogPiBzcURpc3QpIHtcbiAgICAgICAgICAvLyBQbGFjZSBpbiBhIHRoaWNrIHNwaGVyaWNhbCBzaGVsbCBhcm91bmQgdGhlIHZpcnR1YWwgY2FtZXJhLCBuZXZlciB0b28gY2xvc2VcbiAgICAgICAgICBjb25zdCBtaW5SYWRpdXMgPSBzdGFyTWF4RGlzdGFuY2UgKiAwLjg7XG4gICAgICAgICAgY29uc3QgbWF4UmFkaXVzID0gc3Rhck1heERpc3RhbmNlO1xuICAgICAgICAgIGNvbnN0IHIgPSBtaW5SYWRpdXMgKyBNYXRoLnJhbmRvbSgpICogKG1heFJhZGl1cyAtIG1pblJhZGl1cyk7XG4gICAgICAgICAgY29uc3QgdGhldGEgPSBNYXRoLnJhbmRvbSgpICogMiAqIE1hdGguUEk7XG4gICAgICAgICAgY29uc3QgcGhpID0gTWF0aC5hY29zKDIgKiBNYXRoLnJhbmRvbSgpIC0gMSk7XG4gICAgICAgICAgcG9zaXRpb25zW2ldID0gdmlydHVhbENhbWVyYVBvcy54ICsgciAqIE1hdGguc2luKHBoaSkgKiBNYXRoLmNvcyh0aGV0YSk7XG4gICAgICAgICAgcG9zaXRpb25zW2krMV0gPSB2aXJ0dWFsQ2FtZXJhUG9zLnkgKyByICogTWF0aC5zaW4ocGhpKSAqIE1hdGguc2luKHRoZXRhKTtcbiAgICAgICAgICBwb3NpdGlvbnNbaSsyXSA9IHZpcnR1YWxDYW1lcmFQb3MueiArIHIgKiBNYXRoLmNvcyhwaGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTsgLy8gQWxyZWFkeSBzZXQgYWJvdmVcblxuICAgICAgLy8gUm9idXN0IHN0YXJmaWVsZCBjb2xvciB1cGRhdGUgdG8gcHJldmVudCBzdHVjayB3aGl0ZSBkb3RzXG4gICAgICBjb25zdCBjb2xBcnIgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLmNvbG9yLmFycmF5O1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3NpdGlvbnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gaSAvIDM7XG4gICAgICAgIGNvbnN0IGR4ID0gcG9zaXRpb25zW2ldIC0gdmlydHVhbENhbWVyYVBvcy54O1xuICAgICAgICBjb25zdCBkeSA9IHBvc2l0aW9uc1tpICsgMV0gLSB2aXJ0dWFsQ2FtZXJhUG9zLnk7XG4gICAgICAgIGNvbnN0IGR6ID0gcG9zaXRpb25zW2kgKyAyXSAtIHZpcnR1YWxDYW1lcmFQb3MuejtcbiAgICAgICAgY29uc3QgZGlzdCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSArIGR6ICogZHopO1xuICAgICAgICBpZiAodGltZXJzW2lkeF0gPiAwKSB7XG4gICAgICAgICAgdGltZXJzW2lkeF0tLTtcbiAgICAgICAgICBpZiAodGltZXJzW2lkeF0gPT09IDApIHtcbiAgICAgICAgICAgIC8vIFRpbWVyIGV4cGlyZWQsIHJlc3RvcmUgY29sb3JcbiAgICAgICAgICAgIHNwYXJrQ29sb3JzW2ldID0gb3JpZ2luYWxDb2xvcnNbaV07XG4gICAgICAgICAgICBzcGFya0NvbG9yc1tpKzFdID0gb3JpZ2luYWxDb2xvcnNbaSsxXTtcbiAgICAgICAgICAgIHNwYXJrQ29sb3JzW2krMl0gPSBvcmlnaW5hbENvbG9yc1tpKzJdO1xuICAgICAgICAgICAgY29sQXJyW2ldID0gb3JpZ2luYWxDb2xvcnNbaV07XG4gICAgICAgICAgICBjb2xBcnJbaSsxXSA9IG9yaWdpbmFsQ29sb3JzW2krMV07XG4gICAgICAgICAgICBjb2xBcnJbaSsyXSA9IG9yaWdpbmFsQ29sb3JzW2krMl07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbEFycltpXSA9IHNwYXJrQ29sb3JzW2ldO1xuICAgICAgICAgICAgY29sQXJyW2krMV0gPSBzcGFya0NvbG9yc1tpKzFdO1xuICAgICAgICAgICAgY29sQXJyW2krMl0gPSBzcGFya0NvbG9yc1tpKzJdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChkaXN0ID4gc3Rhck1heERpc3RhbmNlICogMC4zICYmIE1hdGgucmFuZG9tKCkgPCAwLjA1KSB7XG4gICAgICAgICAgdGltZXJzW2lkeF0gPSBzcGFya2xlRHVyYXRpb247XG4gICAgICAgICAgY29uc3QgYyA9IHBhbGV0dGVbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcGFsZXR0ZS5sZW5ndGgpXTtcbiAgICAgICAgICBzcGFya0NvbG9yc1tpXSA9IGNbMF07XG4gICAgICAgICAgc3BhcmtDb2xvcnNbaSsxXSA9IGNbMV07XG4gICAgICAgICAgc3BhcmtDb2xvcnNbaSsyXSA9IGNbMl07XG4gICAgICAgICAgY29sQXJyW2ldID0gc3BhcmtDb2xvcnNbaV07XG4gICAgICAgICAgY29sQXJyW2krMV0gPSBzcGFya0NvbG9yc1tpKzFdO1xuICAgICAgICAgIGNvbEFycltpKzJdID0gc3BhcmtDb2xvcnNbaSsyXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzcGFya0NvbG9yc1tpXSA9IG9yaWdpbmFsQ29sb3JzW2ldO1xuICAgICAgICAgIHNwYXJrQ29sb3JzW2krMV0gPSBvcmlnaW5hbENvbG9yc1tpKzFdO1xuICAgICAgICAgIHNwYXJrQ29sb3JzW2krMl0gPSBvcmlnaW5hbENvbG9yc1tpKzJdO1xuICAgICAgICAgIGNvbEFycltpXSA9IG9yaWdpbmFsQ29sb3JzW2ldO1xuICAgICAgICAgIGNvbEFycltpKzFdID0gb3JpZ2luYWxDb2xvcnNbaSsxXTtcbiAgICAgICAgICBjb2xBcnJbaSsyXSA9IG9yaWdpbmFsQ29sb3JzW2krMl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3IubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICBjb21wb3Nlci5yZW5kZXIoKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBEZWZlbnNpdmU6IGxvZyBlcnJvciB3aXRoIGNvbnRleHRcbiAgICAgICAgY29uc29sZS5lcnJvcignU3RhcmZpZWxkIGFuaW1hdGlvbiBlcnJvcjonLCBlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBhbmltYXRlKCk7IC8vIFN0YXJ0IHRoZSByZW5kZXIgbG9vcFxuXG4gICAgY29uc3Qgb25SZXNpemUgPSAoKSA9PiB7XG4gICAgICBjYW1lcmEuYXNwZWN0ID0gd2luZG93LmlubmVyV2lkdGggLyB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICBjYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgIH1cbiAgfSwgW10pXG5cbiAgcmV0dXJuIDxkaXYgcmVmPXttb3VudFJlZn0gLz5cbn1cbmV4cG9ydCBkZWZhdWx0IFN0YXJmaWVsZFxuXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJUSFJFRSIsIkVmZmVjdENvbXBvc2VyIiwiVW5yZWFsQmxvb21QYXNzIiwiUmVuZGVyUGFzcyIsIkNocm9tYXRpY0FiZXJyYXRpb25QYXNzIiwiU3RhcmZpZWxkIiwibW91bnRSZWYiLCJjdXJyZW50IiwibW91bnQiLCJzdHlsZSIsInBvc2l0aW9uIiwidG9wIiwibGVmdCIsIndpZHRoIiwiaGVpZ2h0IiwiekluZGV4Iiwic2NlbmUiLCJTY2VuZSIsImNhbWVyYSIsIlBlcnNwZWN0aXZlQ2FtZXJhIiwid2luZG93IiwiaW5uZXJXaWR0aCIsImlubmVySGVpZ2h0Iiwic2V0IiwidmlydHVhbENhbWVyYVBvcyIsIlZlY3RvcjMiLCJyZW5kZXJlciIsIldlYkdMUmVuZGVyZXIiLCJhbnRpYWxpYXMiLCJzZXRQaXhlbFJhdGlvIiwiZGV2aWNlUGl4ZWxSYXRpbyIsInNldFNpemUiLCJzZXRDbGVhckNvbG9yIiwiYXBwZW5kQ2hpbGQiLCJkb21FbGVtZW50IiwiY29tcG9zZXIiLCJyZW5kZXJQYXNzIiwiYWRkUGFzcyIsImJsb29tUGFzcyIsIlZlY3RvcjIiLCJjbG9zZVN0YXJzU2NlbmUiLCJjYVBhc3MiLCJjYUNvbXBvc2VyIiwiY2FSZW5kZXJQYXNzIiwicmVzaXplQWxsIiwiYXNwZWN0IiwidXBkYXRlUHJvamVjdGlvbk1hdHJpeCIsImFkZEV2ZW50TGlzdGVuZXIiLCJzdGFyQ291bnQiLCJzdGFyTWF4RGlzdGFuY2UiLCJzdGFyU3BlZWQiLCJnZW9tZXRyeSIsIkJ1ZmZlckdlb21ldHJ5IiwiY2xvc2VHZW9tZXRyeSIsInBvc2l0aW9ucyIsImNsb3NlUG9zaXRpb25zIiwic3RhcnNQbGFjZWQiLCJNYXRoIiwicmFuZG9tIiwiY2x1c3RlclRoZXRhIiwiUEkiLCJjbHVzdGVyUGhpIiwiYWNvcyIsImNsdXN0ZXJSIiwiY2x1c3RlckNlbnRlciIsInNpbiIsImNvcyIsImNsdXN0ZXJTaXplIiwiZmxvb3IiLCJjIiwib2Zmc2V0VGhldGEiLCJvZmZzZXRQaGkiLCJvZmZzZXRSIiwicHVzaCIsInRoZXRhIiwicGhpIiwiciIsIngiLCJ5IiwieiIsInNldEF0dHJpYnV0ZSIsIkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUiLCJsZW5ndGgiLCJwYWxldHRlIiwiY29sb3JzIiwiaSIsIm9yaWdpbmFsQ29sb3JzIiwiYXR0cmlidXRlcyIsImNvbG9yIiwiYXJyYXkiLCJzbGljZSIsInRpbWVycyIsIkZsb2F0MzJBcnJheSIsInNwYXJrQ29sb3JzIiwic3BhcmtsZUR1cmF0aW9uIiwibWF0ZXJpYWwiLCJQb2ludHNNYXRlcmlhbCIsInNpemUiLCJzaXplQXR0ZW51YXRpb24iLCJ2ZXJ0ZXhDb2xvcnMiLCJzdGFycyIsIlBvaW50cyIsImFkZCIsImdsb3dNYXAiLCJUZXh0dXJlTG9hZGVyIiwibG9hZCIsImdsb3dTcHJpdGVzIiwiZ2xvd01hdGVyaWFsIiwiU3ByaXRlTWF0ZXJpYWwiLCJtYXAiLCJvcGFjaXR5IiwiYmxlbmRpbmciLCJBZGRpdGl2ZUJsZW5kaW5nIiwiZGVwdGhXcml0ZSIsImdsb3ciLCJTcHJpdGUiLCJjbG9uZSIsInNjYWxlIiwiY2xvc2VTdGFycyIsInRhcmdldFkiLCJkYW1waW5nIiwib25TY3JvbGwiLCJwY3QiLCJzY3JvbGxZIiwiZG9jdW1lbnQiLCJib2R5Iiwic2Nyb2xsSGVpZ2h0IiwidGFpbExlbmd0aCIsInNob290aW5nU3RhcnMiLCJzaG9vdGluZ1N0YXJDb29sZG93biIsInNwYXduU2hvb3RpbmdTdGFyIiwiZGlyIiwibm9ybWFsaXplIiwibWluRGlzdCIsIm1heERpc3QiLCJkaXN0Iiwic3Bhd25Qb3MiLCJtdWx0aXBseVNjYWxhciIsInRhbmdlbnQiLCJzdWIiLCJwcm9qZWN0T25WZWN0b3IiLCJ0YW5nZW50aWFsU3BlZWQiLCJyYWRpYWxTcGVlZCIsInZlbG9jaXR5IiwidmlicmFudENvbG9ycyIsImJyaWdodG5lc3MiLCJnZW8iLCJTcGhlcmVHZW9tZXRyeSIsIm1hdCIsIk1lc2hQaHlzaWNhbE1hdGVyaWFsIiwiZW1pc3NpdmUiLCJlbWlzc2l2ZUludGVuc2l0eSIsIm1ldGFsbmVzcyIsInJvdWdobmVzcyIsInRyYW5zbWlzc2lvbiIsInRyYW5zcGFyZW50IiwiY2xlYXJjb2F0IiwiY2xlYXJjb2F0Um91Z2huZXNzIiwic3RhciIsIk1lc2giLCJzcHJpdGVNYXAiLCJzcHJpdGVNYXRlcmlhbCIsInNwcml0ZSIsImNvcHkiLCJjb2xvclNwcml0ZU1hdGVyaWFsIiwiY29sb3JTcHJpdGUiLCJzcGFya0NvdW50Iiwic3BhcmtHcm91cCIsIkdyb3VwIiwic3BhcmtNYXQiLCJNZXNoQmFzaWNNYXRlcmlhbCIsInNwYXJrR2VvIiwic3BhcmsiLCJhbmdsZSIsIm5hbWUiLCJub3JtYWxpemVkTGlmZSIsIm5vcm1hbGl6ZWRMaWZldGltZSIsImFnZSIsInRyYWlsU2VnbWVudHMiLCJ0cmFpbFBvaW50cyIsInNwaXJhbCIsImN1cnZlIiwicHQiLCJ0YWlsR2VvIiwic2V0RnJvbVBvaW50cyIsInRhaWxDb2xvcnMiLCJhbHBoYSIsInJhaW5ib3ciLCJncmFkQ29sb3IiLCJ0YWlsTWF0IiwiTGluZUJhc2ljTWF0ZXJpYWwiLCJ0YWlsIiwiTGluZSIsInRhaWxHbG93TWFwIiwidGFpbEdsb3dNYXQiLCJ0YWlsR2xvdyIsIm1lc2giLCJoYXNGcmFnbWVudGVkIiwiYW5pbWF0ZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInJlbmRlciIsInJvdGF0aW9uIiwiZm9yd2FyZCIsImdldFdvcmxkRGlyZWN0aW9uIiwic3RhclBvcyIsInQiLCJzIiwibmVlZHNVcGRhdGUiLCJzaGFrZVN0cmVuZ3RoIiwib2JqIiwiY2hpbGRyZW4iLCJzcGFya3MiLCJmaW5kIiwiY2hpbGQiLCJqIiwidGltZSIsInBlcmZvcm1hbmNlIiwibm93IiwiZ2V0QXR0cmlidXRlIiwiayIsImNvdW50IiwiZ2V0WCIsImciLCJnZXRZIiwiYiIsImdldFoiLCJtYXgiLCJtaW4iLCJoIiwibCIsImQiLCJxIiwicCIsInRyIiwidGciLCJ0YiIsImh1ZTJyZ2IiLCJzZXRYIiwic2V0WSIsInNldFoiLCJzZXRXIiwiZ2V0VyIsInVuc2hpZnQiLCJwb3AiLCJ0YWlsR3JvdyIsImFjdGl2ZVNlZ21lbnRzIiwidmlzaWJsZVRyYWlsIiwiRGF0ZSIsInNldFhZWlciLCJoZWFkQ29sb3IiLCJDb2xvciIsImxlcnAiLCJmbGlja2VyIiwiZGlzdFRvQ2FtIiwiZG9mQmx1ciIsInNwZWN0YWN1bGFyIiwiYnVyc3RDb3VudCIsInNwYXJrbGVHZW8iLCJzcGFya2xlTWF0Iiwic3BhcmtsZSIsInNwZCIsInNwYXJrbGVWZWwiLCJ1c2VyRGF0YSIsIm1heEFnZSIsIl9zcGFya2xlcyIsImZsYXNoR2VvIiwiZmxhc2hNYXQiLCJmbGFzaCIsIl9zdGFyRmxhc2hlcyIsImZyYWdWZWwiLCJhcHBseUF4aXNBbmdsZSIsImZyYWdTdGFyIiwiZnJhZ1RyYWlsUG9pbnRzIiwiZnJhZ1RhaWxHZW8iLCJmcmFnVGFpbE1hdCIsImZyYWdUYWlsIiwiaGFzU3BhcmtlZCIsInNwYXJrVmVsIiwic3BhcmtMaWZlIiwic3BhcmtBZ2UiLCJfc3RhclNwYXJrcyIsImhhc0ZsYXNoZWQiLCJkaXN0YW5jZVRvIiwiZmFkZVN0YXJ0IiwiZmFkZSIsInJlbW92ZSIsInNwbGljZSIsInNxRGlzdCIsImR4IiwiZHkiLCJkeiIsIm1pblJhZGl1cyIsIm1heFJhZGl1cyIsImNvbEFyciIsImlkeCIsInNxcnQiLCJlcnIiLCJjb25zb2xlIiwiZXJyb3IiLCJvblJlc2l6ZSIsImRpdiIsInJlZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/Starfield.jsx\n"));

/***/ })

});