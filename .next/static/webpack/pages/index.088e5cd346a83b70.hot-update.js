"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./components/Starfield.jsx":
/*!**********************************!*\
  !*** ./components/Starfield.jsx ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var three_examples_jsm_postprocessing_EffectComposer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three/examples/jsm/postprocessing/EffectComposer */ \"./node_modules/three/examples/jsm/postprocessing/EffectComposer.js\");\n/* harmony import */ var three_examples_jsm_postprocessing_UnrealBloomPass__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three/examples/jsm/postprocessing/UnrealBloomPass */ \"./node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js\");\n/* harmony import */ var three_examples_jsm_postprocessing_RenderPass__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three/examples/jsm/postprocessing/RenderPass */ \"./node_modules/three/examples/jsm/postprocessing/RenderPass.js\");\n/* harmony import */ var three_examples_jsm_postprocessing_FilmPass__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! three/examples/jsm/postprocessing/FilmPass */ \"./node_modules/three/examples/jsm/postprocessing/FilmPass.js\");\n/* harmony import */ var _ChromaticAberrationPass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ChromaticAberrationPass */ \"./components/ChromaticAberrationPass.js\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\n\nconst Starfield = ()=>{\n    _s();\n    const mountRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // Defensive: always use .current for refs\n        if (!mountRef.current) return;\n        const mount = mountRef.current;\n        mount.style.position = \"fixed\";\n        mount.style.top = \"0\";\n        mount.style.left = \"0\";\n        mount.style.width = \"100%\";\n        mount.style.height = \"100%\";\n        mount.style.zIndex = \"0\";\n        // Scene & Renderer\n        const scene = new three__WEBPACK_IMPORTED_MODULE_3__.Scene();\n        const camera = new three__WEBPACK_IMPORTED_MODULE_3__.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);\n        camera.position.set(0, 0, 0);\n        // Virtual position to simulate infinite travel\n        let virtualCameraPos = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(0, 0, 0);\n        const renderer = new three__WEBPACK_IMPORTED_MODULE_3__.WebGLRenderer({\n            antialias: false\n        }) // We'll use FXAA instead\n        ;\n        renderer.setPixelRatio(window.devicePixelRatio);\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        renderer.setClearColor(0x000000, 1);\n        if (\"outputColorSpace\" in renderer) {\n            renderer.outputColorSpace = three__WEBPACK_IMPORTED_MODULE_3__.SRGBColorSpace;\n        }\n        // Create a render target for the composer with correct color space\n        const renderTarget = new three__WEBPACK_IMPORTED_MODULE_3__.WebGLRenderTarget(window.innerWidth, window.innerHeight, {\n            colorSpace: three__WEBPACK_IMPORTED_MODULE_3__.SRGBColorSpace,\n            type: three__WEBPACK_IMPORTED_MODULE_3__.UnsignedByteType\n        });\n        renderer.toneMapping = three__WEBPACK_IMPORTED_MODULE_3__.NoToneMapping;\n        renderer.autoClear = true;\n        mount.appendChild(renderer.domElement);\n        // --- MAIN STARFIELD POST-PROCESSING ---\n        const composer = new three_examples_jsm_postprocessing_EffectComposer__WEBPACK_IMPORTED_MODULE_4__.EffectComposer(renderer, renderTarget);\n        composer.setSize(window.innerWidth, window.innerHeight);\n        const renderPass = new three_examples_jsm_postprocessing_RenderPass__WEBPACK_IMPORTED_MODULE_5__.RenderPass(scene, camera);\n        renderPass.clear = true;\n        composer.addPass(renderPass);\n        // UnrealBloomPass: \"crazy\" bloom\n        const bloomPass = new three_examples_jsm_postprocessing_UnrealBloomPass__WEBPACK_IMPORTED_MODULE_6__.UnrealBloomPass(new three__WEBPACK_IMPORTED_MODULE_3__.Vector2(window.innerWidth, window.innerHeight), 3.5, 1.6, 0.01 // threshold\n        );\n        composer.addPass(bloomPass);\n        // FilmPass\n        const filmPass = new three_examples_jsm_postprocessing_FilmPass__WEBPACK_IMPORTED_MODULE_7__.FilmPass(0.0, 0.0, 648, false // grayscale\n        );\n        composer.addPass(filmPass);\n        // --- SHOOTING STAR POST-PROCESSING ONLY ---\n        // Separate scene and composer for shooting stars\n        const shootingStarScene = new three__WEBPACK_IMPORTED_MODULE_3__.Scene();\n        const shootingStarComposer = new three_examples_jsm_postprocessing_EffectComposer__WEBPACK_IMPORTED_MODULE_4__.EffectComposer(renderer);\n        shootingStarComposer.setSize(window.innerWidth, window.innerHeight);\n        const shootingStarRenderPass = new three_examples_jsm_postprocessing_RenderPass__WEBPACK_IMPORTED_MODULE_5__.RenderPass(shootingStarScene, camera);\n        shootingStarComposer.addPass(shootingStarRenderPass);\n        // Intense bloom for shooting stars\n        const shootingStarBloomPass = new three_examples_jsm_postprocessing_UnrealBloomPass__WEBPACK_IMPORTED_MODULE_6__.UnrealBloomPass(new three__WEBPACK_IMPORTED_MODULE_3__.Vector2(window.innerWidth, window.innerHeight), 4.0, 2.0, 0.0 // all bright\n        );\n        shootingStarComposer.addPass(shootingStarBloomPass);\n        // --- CLOSE STARS: Separate Scene for Chromatic Aberration ---\n        const closeStarsScene = new three__WEBPACK_IMPORTED_MODULE_3__.Scene();\n        const caPass = new _ChromaticAberrationPass__WEBPACK_IMPORTED_MODULE_2__.ChromaticAberrationPass(new three__WEBPACK_IMPORTED_MODULE_3__.Vector2(0.0002, 0.0002)); // barely visible\n        const caComposer = new three_examples_jsm_postprocessing_EffectComposer__WEBPACK_IMPORTED_MODULE_4__.EffectComposer(renderer);\n        caComposer.setSize(window.innerWidth, window.innerHeight);\n        const caRenderPass = new three_examples_jsm_postprocessing_RenderPass__WEBPACK_IMPORTED_MODULE_5__.RenderPass(closeStarsScene, camera);\n        caComposer.addPass(caRenderPass);\n        caComposer.addPass(caPass);\n        // --- HANDLE RESIZE AND FULLSCREEN ---\n        function resizeAll() {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n            // Main composer\n            composer.setSize(window.innerWidth, window.innerHeight);\n            // Other composers\n            shootingStarComposer.setSize(window.innerWidth, window.innerHeight);\n            caComposer.setSize(window.innerWidth, window.innerHeight);\n        }\n        window.addEventListener(\"resize\", resizeAll);\n        window.addEventListener(\"fullscreenchange\", resizeAll);\n        // Starfield\n        const starCount = 5000;\n        const starMaxDistance = 2000;\n        const starMinDistance = 1200 // minimum distance from camera\n        ;\n        const starSpeed = 1;\n        const geometry = new three__WEBPACK_IMPORTED_MODULE_3__.BufferGeometry();\n        const closeGeometry = new three__WEBPACK_IMPORTED_MODULE_3__.BufferGeometry();\n        const positions = [];\n        const closePositions = [];\n        let starsPlaced = 0;\n        while(starsPlaced < starCount){\n            // With 1% chance, spawn a star cluster (10-30 stars)\n            if (Math.random() < 0.01 && starsPlaced < starCount - 10) {\n                const clusterTheta = Math.random() * 2 * Math.PI;\n                const clusterPhi = Math.acos(2 * Math.random() - 1);\n                const clusterR = starMinDistance + Math.random() * (starMaxDistance - starMinDistance);\n                const clusterCenter = [\n                    clusterR * Math.sin(clusterPhi) * Math.cos(clusterTheta),\n                    clusterR * Math.sin(clusterPhi) * Math.sin(clusterTheta),\n                    clusterR * Math.cos(clusterPhi)\n                ];\n                const clusterSize = 10 + Math.floor(Math.random() * 20); // 10-30 stars\n                for(let c = 0; c < clusterSize && starsPlaced < starCount; c++){\n                    // Each star in cluster is within 30 units of center\n                    const offsetTheta = Math.random() * 2 * Math.PI;\n                    const offsetPhi = Math.acos(2 * Math.random() - 1);\n                    const offsetR = Math.random() * 30; // cluster radius\n                    positions.push(clusterCenter[0] + offsetR * Math.sin(offsetPhi) * Math.cos(offsetTheta), clusterCenter[1] + offsetR * Math.sin(offsetPhi) * Math.sin(offsetTheta), clusterCenter[2] + offsetR * Math.cos(offsetPhi));\n                    starsPlaced++;\n                }\n            } else {\n                // Normal single star\n                const theta = Math.random() * 2 * Math.PI;\n                const phi = Math.acos(2 * Math.random() - 1);\n                const r = starMinDistance + Math.random() * (starMaxDistance - starMinDistance);\n                const x = r * Math.sin(phi) * Math.cos(theta);\n                const y = r * Math.sin(phi) * Math.sin(theta);\n                const z = r * Math.cos(phi);\n                positions.push(x, y, z);\n                // If close, also add to closePositions\n                if (r < 400) {\n                    closePositions.push(x, y, z);\n                }\n                starsPlaced++;\n            }\n        }\n        geometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_3__.Float32BufferAttribute(positions, 3));\n        if (closePositions.length > 0) {\n            closeGeometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_3__.Float32BufferAttribute(closePositions, 3));\n        }\n        // CRAZY BLOOM: All stars are extremely bright (color intensity >1)\n        const palette = [\n            [\n                1.0,\n                0.5,\n                0.5\n            ],\n            [\n                1.0,\n                0.75,\n                0.4\n            ],\n            [\n                1.0,\n                1.0,\n                0.9\n            ],\n            [\n                1.0,\n                1.0,\n                1.0\n            ],\n            [\n                0.4,\n                0.5,\n                1.0\n            ]\n        ];\n        const colors = [];\n        for(let i = 0; i < starCount; i++){\n            const c = palette[Math.floor(Math.random() * palette.length)];\n            colors.push(...c);\n        }\n        geometry.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_3__.Float32BufferAttribute(colors, 3));\n        const originalColors = geometry.attributes.color.array.slice();\n        const timers = new Float32Array(starCount);\n        const sparkColors = new Float32Array(starCount * 3);\n        const sparkleDuration = 180;\n        // --- SQUARE STARS USING POINTS ---\n        const material = new three__WEBPACK_IMPORTED_MODULE_3__.PointsMaterial({\n            size: 10,\n            sizeAttenuation: false,\n            vertexColors: true\n        });\n        const stars = new three__WEBPACK_IMPORTED_MODULE_3__.Points(geometry, material);\n        scene.add(stars);\n        // Add glow sprites to each star and animate them based on distance\n        const glowMap = new three__WEBPACK_IMPORTED_MODULE_3__.TextureLoader().load(\"/glow.png\");\n        const glowSprites = [];\n        const glowMaterial = new three__WEBPACK_IMPORTED_MODULE_3__.SpriteMaterial({\n            map: glowMap,\n            color: 0xffffff,\n            opacity: 0.18,\n            blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending,\n            depthWrite: false,\n            transparent: true\n        });\n        for(let i = 0; i < starCount; i++){\n            const glow = new three__WEBPACK_IMPORTED_MODULE_3__.Sprite(glowMaterial.clone());\n            glow.position.set(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2]);\n            glow.scale.set(10, 10, 1);\n            scene.add(glow);\n            glowSprites.push(glow);\n        }\n        // Add close stars to separate scene\n        let closeStars;\n        if (closePositions.length > 0) {\n            closeStars = new three__WEBPACK_IMPORTED_MODULE_3__.Points(closeGeometry, material.clone());\n            closeStarsScene.add(closeStars);\n        }\n        let targetY = 0;\n        const damping = 0.05;\n        const onScroll = ()=>{\n            const pct = window.scrollY / (document.body.scrollHeight - window.innerHeight);\n            targetY = pct * Math.PI * 2;\n        };\n        window.addEventListener(\"scroll\", onScroll);\n        // --- Shooting Stars ---\n        const tailLength = 32; // Increase for longer tails\n        const shootingStars = [];\n        let shootingStarCooldown = 0;\n        // Spawn a shooting star with a stunning glowing tail\n        function spawnShootingStar() {\n            // Pick a random direction on the sphere for the spawn location\n            const dir = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();\n            // Ensure shooting stars never spawn close to the camera (at least 70% of max distance)\n            const minDist = starMaxDistance * 0.7;\n            const maxDist = starMaxDistance * 1.0;\n            const dist = minDist + Math.random() * (maxDist - minDist);\n            const spawnPos = dir.clone().multiplyScalar(dist);\n            // Tangential velocity: perpendicular to dir\n            let tangent = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1);\n            tangent = tangent.sub(tangent.clone().projectOnVector(dir)).normalize();\n            // Mix in a small radial component (inward or outward)\n            const tangentialSpeed = starSpeed * (2.5 + Math.random() * 2.5); // much faster\n            const radialSpeed = starSpeed * (Math.random() - 0.5) * 0.3; // more dramatic\n            const velocity = tangent.multiplyScalar(tangentialSpeed).add(dir.clone().multiplyScalar(radialSpeed));\n            // Stunning color gradient for the head\n            const vibrantColors = [\n                0xffe066,\n                0xff66cc,\n                0x66ccff,\n                0xffffff,\n                0x80ffea,\n                0xfff2cc,\n                0xffc080,\n                0x80c0ff,\n                0xff80b3\n            ];\n            const color = vibrantColors[Math.floor(Math.random() * vibrantColors.length)];\n            // Star brightness and size (always small and subtle)\n            const brightness = 2.5 + Math.random() * 1.5;\n            const geo = new three__WEBPACK_IMPORTED_MODULE_3__.SphereGeometry(0.7 + Math.random() * 0.5, 16, 16); // Small sphere\n            const mat = new three__WEBPACK_IMPORTED_MODULE_3__.MeshPhysicalMaterial({\n                color: color,\n                emissive: color,\n                emissiveIntensity: 14.0,\n                metalness: 0.7,\n                roughness: 0.3,\n                transmission: 0.7,\n                opacity: 0.98,\n                transparent: true,\n                clearcoat: 0.8,\n                clearcoatRoughness: 0.2\n            });\n            const star = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(geo, mat);\n            // Add a large, intense bloom sprite for extra bloom\n            const spriteMap = new three__WEBPACK_IMPORTED_MODULE_3__.TextureLoader().load(\"/glow.png\");\n            const spriteMaterial = new three__WEBPACK_IMPORTED_MODULE_3__.SpriteMaterial({\n                map: spriteMap,\n                color: 0xffffff,\n                opacity: 1.0,\n                blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n            });\n            const sprite = new three__WEBPACK_IMPORTED_MODULE_3__.Sprite(spriteMaterial);\n            sprite.scale.set(70, 70, 1); // Large for bloom\n            sprite.position.copy(star.position);\n            star.add(sprite);\n            // Add a colored sprite for color pop\n            const colorSpriteMaterial = new three__WEBPACK_IMPORTED_MODULE_3__.SpriteMaterial({\n                map: spriteMap,\n                color: color,\n                opacity: 0.6,\n                blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n            });\n            const colorSprite = new three__WEBPACK_IMPORTED_MODULE_3__.Sprite(colorSpriteMaterial);\n            colorSprite.scale.set(34, 34, 1);\n            colorSprite.position.copy(star.position);\n            star.add(colorSprite);\n            // Add to both main scene and shootingStarScene\n            scene.add(star);\n            shootingStarScene.add(star);\n            // Add dynamic spark burst at the head\n            const sparkCount = 18 + Math.floor(Math.random() * 8);\n            const sparkGroup = new three__WEBPACK_IMPORTED_MODULE_3__.Group();\n            for(let i = 0; i < sparkCount; i++){\n                const sparkMat = new three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial({\n                    color: vibrantColors[Math.floor(Math.random() * vibrantColors.length)],\n                    transparent: true,\n                    opacity: 0.8\n                });\n                const sparkGeo = new three__WEBPACK_IMPORTED_MODULE_3__.SphereGeometry(0.07 + Math.random() * 0.06, 8, 8);\n                const spark = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(sparkGeo, sparkMat);\n                const angle = i / sparkCount * Math.PI * 2;\n                spark.position.set(Math.cos(angle) * 1.2, Math.sin(angle) * 1.2, Math.random() * 0.4 - 0.2);\n                sparkGroup.add(spark);\n            }\n            sparkGroup.name = \"sparkBurst\";\n            star.add(sparkGroup);\n            star.position.copy(spawnPos);\n            star.velocity = velocity;\n            star.normalizedLife = 0.0;\n            star.normalizedLifetime = 80 + Math.random() * 80; // Longer, more dramatic\n            star.age = 0;\n            // --- Stunning Meteor Tail (very long, multi-color, glowing, fading, and 3D curve) ---\n            const trailSegments = tailLength * 3;\n            const trailPoints = [];\n            for(let i = 0; i < trailSegments; i++){\n                // Add a 3D spiral/curve for more depth\n                const spiral = Math.sin(i * 0.25) * 8;\n                const curve = Math.cos(i * 0.15) * 4;\n                const pt = star.position.clone().add(new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(spiral, curve, -i * 3));\n                trailPoints.push(pt);\n            }\n            const tailGeo = new three__WEBPACK_IMPORTED_MODULE_3__.BufferGeometry().setFromPoints(trailPoints);\n            // Per-vertex color (multi-color rainbow gradient)\n            const tailColors = [];\n            for(let i = 0; i < trailSegments; i++){\n                // Alpha fades out along the tail\n                const alpha = (1 - i / (trailSegments - 1)) * 0.99;\n                // Rainbow gradient\n                const rainbow = [\n                    0xffe066,\n                    0xff66cc,\n                    0x66ccff,\n                    0xffffff,\n                    0x80ffea,\n                    0xfff2cc,\n                    0xffc080,\n                    0x80c0ff,\n                    0xff80b3\n                ];\n                const gradColor = rainbow[Math.floor(i / trailSegments * rainbow.length)];\n                tailColors.push((gradColor >> 16 & 255) / 255, (gradColor >> 8 & 255) / 255, (gradColor & 255) / 255, alpha);\n            }\n            tailGeo.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_3__.Float32BufferAttribute(tailColors, 4));\n            // Additive blending for glow + BLOOMED TAIL\n            const tailMat = new three__WEBPACK_IMPORTED_MODULE_3__.LineBasicMaterial({\n                vertexColors: true,\n                transparent: true,\n                opacity: 1.0,\n                blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n            });\n            // --- TAILS ---\n            // 1. Crisp tail for main scene\n            const tailMatMain = new three__WEBPACK_IMPORTED_MODULE_3__.LineBasicMaterial({\n                vertexColors: true,\n                transparent: true,\n                opacity: 1.0,\n                blending: three__WEBPACK_IMPORTED_MODULE_3__.NormalBlending\n            });\n            const tailMain = new three__WEBPACK_IMPORTED_MODULE_3__.Line(tailGeo.clone(), tailMatMain);\n            tailMain.position.copy(star.position);\n            scene.add(tailMain);\n            // 2. Intense bloom tail for shootingStarScene\n            const tailMatBloom = new three__WEBPACK_IMPORTED_MODULE_3__.LineBasicMaterial({\n                vertexColors: true,\n                transparent: true,\n                opacity: 1.0,\n                blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n            });\n            const tailBloom = new three__WEBPACK_IMPORTED_MODULE_3__.Line(tailGeo, tailMatBloom);\n            tailBloom.position.copy(star.position);\n            // Add a bloom sprite to the tail's head for extra glow\n            const tailGlowMap = new three__WEBPACK_IMPORTED_MODULE_3__.TextureLoader().load(\"/glow.png\");\n            const tailGlowMat = new three__WEBPACK_IMPORTED_MODULE_3__.SpriteMaterial({\n                map: tailGlowMap,\n                color: 0xffffff,\n                opacity: 0.88,\n                blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n            });\n            const tailGlow = new three__WEBPACK_IMPORTED_MODULE_3__.Sprite(tailGlowMat);\n            tailGlow.scale.set(50, 50, 1); // Larger for more bloom\n            tailGlow.position.copy(star.position);\n            tailBloom.add(tailGlow);\n            shootingStarScene.add(tailBloom);\n            // Add star to both scenes\n            scene.add(star);\n            shootingStarScene.add(star);\n            shootingStars.push({\n                mesh: star,\n                tail: tailMain,\n                tailBloom,\n                velocity: star.velocity,\n                dir,\n                age: 0,\n                normalizedLifetime: star.normalizedLifetime,\n                trailPoints,\n                color,\n                brightness,\n                hasFragmented: false\n            });\n        }\n        // Create an animation ID reference for cleanup\n        let animationId;\n        const animate = ()=>{\n            // Store the animation ID for cleanup\n            animationId = requestAnimationFrame(animate);\n            // Update star positions relative to virtual camera\n            for(let i = 0; i < positions.length; i += 3){\n                geometry.attributes.position.array[i] = positions[i] - virtualCameraPos.x;\n                geometry.attributes.position.array[i + 1] = positions[i + 1] - virtualCameraPos.y;\n                geometry.attributes.position.array[i + 2] = positions[i + 2] - virtualCameraPos.z;\n            }\n            geometry.attributes.position.needsUpdate = true;\n            // Update glow sprite positions\n            for(let i = 0; i < glowSprites.length; i++){\n                const idx = i * 3;\n                glowSprites[i].position.set(positions[idx] - virtualCameraPos.x, positions[idx + 1] - virtualCameraPos.y, positions[idx + 2] - virtualCameraPos.z);\n            }\n            // --- POST-PROCESSING PIPELINE ---\n            // --- POST-PROCESSING PIPELINE ---\n            composer.render(); // Only RenderPass enabled for debugging\n            // (bloom, FXAA, FilmPass are NOT added)\n            // shootingStarComposer, caComposer remain disabled for now\n            camera.rotation.y += (targetY - camera.rotation.y) * damping;\n            // Move the virtual camera position in the direction the camera is facing\n            const forward = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();\n            camera.getWorldDirection(forward);\n            virtualCameraPos.add(forward.multiplyScalar(starSpeed));\n            // Intense color (oversaturated, brightened) -- must be inside the for loop over stars\n            const colorAttr = geometry.attributes.color;\n            for(let i = 0; i < positions.length; i += 3){\n                const origR = colorAttr.array[i];\n                const origG = colorAttr.array[i + 1];\n                const origB = colorAttr.array[i + 2];\n                const dist = Math.sqrt(Math.pow(positions[i] - virtualCameraPos.x, 2) + Math.pow(positions[i + 1] - virtualCameraPos.y, 2) + Math.pow(positions[i + 2] - virtualCameraPos.z, 2));\n                const intenseR = Math.min(origR * 2.5, 1.0), intenseG = Math.min(origG * 2.5, 1.0), intenseB = Math.min(origB * 2.5, 1.0);\n                // Fade factor: 0 = close, 1 = far\n                let fadeT = (dist - 200) / (starMaxDistance * 0.9 - 200);\n                fadeT = Math.max(0, Math.min(1, fadeT));\n                // Ease for smoothness\n                fadeT = Math.pow(fadeT, 1.5);\n                // Lerp between original and intense color\n                colorAttr.array[i] = origR * (1 - fadeT) + intenseR * fadeT;\n                colorAttr.array[i + 1] = origG * (1 - fadeT) + intenseG * fadeT;\n                colorAttr.array[i + 2] = origB * (1 - fadeT) + intenseB * fadeT;\n            }\n            colorAttr.needsUpdate = true;\n            // If you have glow logic per-star, move that inside the loop as well, or handle after\n            if (closeStars && closeGeometry && closePositions.length > 0) {\n                for(let i = 0; i < closePositions.length; i += 3){\n                    closeGeometry.attributes.position.array[i] = closePositions[i] - virtualCameraPos.x;\n                    closeGeometry.attributes.position.array[i + 1] = closePositions[i + 1] - virtualCameraPos.y;\n                    closeGeometry.attributes.position.array[i + 2] = closePositions[i + 2] - virtualCameraPos.z;\n                }\n                closeGeometry.attributes.position.needsUpdate = true;\n            }\n            geometry.attributes.position.needsUpdate = true;\n            // Update shooting star cooldown\n            if (shootingStarCooldown <= 0 && Math.random() < 0.02) {\n                spawnShootingStar();\n                shootingStarCooldown = 30 + Math.random() * 60;\n            } else if (shootingStarCooldown > 0) {\n                shootingStarCooldown--;\n            }\n            // --- Shooting star spawning ---\n            if (shootingStarCooldown <= 0 && Math.random() < 0.1) {\n                spawnShootingStar();\n                if (camera) {\n                    const shakeStrength = 0.06 + Math.random() * 0.04;\n                    camera.position.x += (Math.random() - 0.5) * shakeStrength;\n                    camera.position.y += (Math.random() - 0.5) * shakeStrength;\n                }\n                shootingStarCooldown = 10 + Math.random() * 10;\n            } else if (shootingStarCooldown > 0) {\n                shootingStarCooldown--;\n            }\n            // Animate and clean up shooting stars\n            for(let i = shootingStars.length - 1; i >= 0; i--){\n                const obj = shootingStars[i];\n                // Animate spark burst (fade and expand)\n                if (obj.mesh.children) {\n                    const sparks = obj.mesh.children.find((child)=>child.name === \"sparkBurst\");\n                    if (sparks) {\n                        for(let j = 0; j < sparks.children.length; j++){\n                            const spark = sparks.children[j];\n                            spark.material.opacity *= 0.96; // Fade\n                            spark.scale.multiplyScalar(1.03); // Expand\n                        }\n                    }\n                }\n                // Animate tail shimmer and color cycling\n                if (obj.tail && obj.trailPoints) {\n                    const time = performance.now() * 0.001;\n                    const tailGeo = obj.tail.geometry;\n                    const tailColors = tailGeo.getAttribute(\"color\");\n                    for(let k = 0; k < tailColors.count; k++){\n                        // Cycle hue\n                        let r = tailColors.getX(k), g = tailColors.getY(k), b = tailColors.getZ(k);\n                        // Convert to HSL\n                        const max = Math.max(r, g, b), min = Math.min(r, g, b);\n                        let h, s, l;\n                        l = (max + min) / 2;\n                        if (max === min) {\n                            h = s = 0;\n                        } else {\n                            const d = max - min;\n                            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n                            switch(max){\n                                case r:\n                                    h = (g - b) / d + (g < b ? 6 : 0);\n                                    break;\n                                case g:\n                                    h = (b - r) / d + 2;\n                                    break;\n                                case b:\n                                    h = (r - g) / d + 4;\n                                    break;\n                            }\n                            h /= 6;\n                        }\n                        h = (h + 0.25 * Math.sin(time + k * 0.2)) % 1.0; // Animate hue\n                        // Convert back to RGB\n                        let q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n                        let p = 2 * l - q;\n                        let tr = h + 1 / 3, tg = h, tb = h - 1 / 3;\n                        const hue2rgb = (p, q, t)=>{\n                            if (t < 0) t += 1;\n                            if (t > 1) t -= 1;\n                            if (t < 1 / 6) return p + (q - p) * 6 * t;\n                            if (t < 1 / 2) return q;\n                            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n                            return p;\n                        };\n                        tailColors.setX(k, hue2rgb(p, q, tr));\n                        tailColors.setY(k, hue2rgb(p, q, tg));\n                        tailColors.setZ(k, hue2rgb(p, q, tb));\n                        // Shimmer: modulate alpha\n                        tailColors.setW(k, tailColors.getW(k) * (0.97 + 0.03 * Math.sin(time * 8 + k)));\n                    }\n                    tailColors.needsUpdate = true;\n                }\n                // Straight-line trajectory\n                obj.mesh.position.add(obj.velocity);\n                obj.tail.position.copy(obj.mesh.position);\n                if (obj.tailBloom) obj.tailBloom.position.copy(obj.mesh.position);\n                // Animate tail (no lerp, just drag)\n                // COMPLETE MESS VERY HACKY FIX LATER OR DONT?????\n                obj.age++;\n                const normalizedLife = obj.age / obj.normalizedLifetime;\n                obj.trailPoints.unshift(obj.mesh.position.clone());\n                if (obj.trailPoints.length > tailLength * 3) obj.trailPoints.pop();\n                let tailGrow = Math.min(1, normalizedLife / 0.3);\n                let activeSegments = Math.floor(obj.trailPoints.length * tailGrow);\n                if (activeSegments < 2) activeSegments = 2;\n                const visibleTrail = obj.trailPoints.slice(0, activeSegments);\n                obj.tail.geometry.setFromPoints(visibleTrail);\n                if (obj.tailBloom) obj.tailBloom.geometry.setFromPoints(visibleTrail);\n                const tailColors = obj.tail.geometry.getAttribute(\"color\");\n                let tailColorsBloom = obj.tailBloom ? obj.tailBloom.geometry.getAttribute(\"color\") : null;\n                for(let j = 0; j < visibleTrail.length; j++){\n                    let alpha = (1 - j / (visibleTrail.length - 1)) * 0.95;\n                    alpha *= 0.92 + 0.08 * Math.sin(Date.now() * 0.015 + j * 0.5);\n                    let rainbow = [\n                        0xffc080,\n                        0xffe080,\n                        0xffff80,\n                        0x80ffe6,\n                        0x80c0ff,\n                        0xc080ff\n                    ];\n                    let gradColor = rainbow[j % rainbow.length];\n                    if (normalizedLife > 0.7) alpha *= Math.max(0, 1 - (normalizedLife - 0.7 - 0.2) / 0.3);\n                    tailColors.setXYZW(j, (gradColor >> 16 & 255) / 255, (gradColor >> 8 & 255) / 255, (gradColor & 255) / 255, alpha);\n                    if (tailColorsBloom) tailColorsBloom.setXYZW(j, (gradColor >> 16 & 255) / 255, (gradColor >> 8 & 255) / 255, (gradColor & 255) / 255, alpha);\n                }\n                tailColors.needsUpdate = true;\n                // Animate head\n                let headColor;\n                if (normalizedLife < 0.5) {\n                    headColor = new three__WEBPACK_IMPORTED_MODULE_3__.Color(obj.color).lerp(new three__WEBPACK_IMPORTED_MODULE_3__.Color(0xffc080), normalizedLife * 2);\n                } else {\n                    headColor = new three__WEBPACK_IMPORTED_MODULE_3__.Color(0xffc080).lerp(new three__WEBPACK_IMPORTED_MODULE_3__.Color(0xff4000), (normalizedLife - 0.5) * 2);\n                }\n                let flicker = 0.95 + 0.13 * Math.sin(Date.now() * 0.07 + Math.random() * 10);\n                headColor.multiplyScalar(flicker);\n                obj.mesh.material.color.copy(headColor);\n                let scale = 1 + 2.2 * Math.sin(Math.PI * normalizedLife);\n                let distToCam = obj.mesh.position.length();\n                let dofBlur = distToCam < starMaxDistance * 0.7 ? 0.7 : 1.0;\n                obj.mesh.scale.set(scale * dofBlur, scale * dofBlur, scale * dofBlur);\n                // Sparkle burst\n                if (normalizedLife >= 1 && !obj.hasFragmented) {\n                    // --- SPECTACULAR EXPLOSION (very rare) ---\n                    const spectacular = Math.random() < 0.02; // 2% chance\n                    const burstCount = spectacular ? 120 + Math.floor(Math.random() * 60) : 18 + Math.floor(Math.random() * 8);\n                    const palette = spectacular ? [\n                        0xffe066,\n                        0xff66cc,\n                        0x66ccff,\n                        0xffffff,\n                        0x80ffea,\n                        0xfff2cc,\n                        0xffc080,\n                        0x80c0ff,\n                        0xff80b3,\n                        0xff0000,\n                        0x00ff00,\n                        0x0000ff,\n                        0xffff00,\n                        0x00ffff,\n                        0xff00ff,\n                        0xff8800,\n                        0x00ff88,\n                        0x8800ff\n                    ] : [\n                        0xffffff,\n                        0xfff6c0,\n                        0xffe066,\n                        0xffc080,\n                        0x80c0ff\n                    ];\n                    for(let s = 0; s < burstCount; s++){\n                        const color = palette[Math.floor(Math.random() * palette.length)];\n                        const size = spectacular ? 1.2 + Math.random() * 2.2 : 0.7 + Math.random() * 0.8;\n                        const sparkleGeo = new three__WEBPACK_IMPORTED_MODULE_3__.SphereGeometry(size, 8, 8);\n                        const sparkleMat = new three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial({\n                            color,\n                            transparent: true,\n                            opacity: spectacular ? 0.92 : 0.7,\n                            blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n                        });\n                        const sparkle = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(sparkleGeo, sparkleMat);\n                        sparkle.position.copy(obj.mesh.position);\n                        // Spectacular: huge, fast, random directions; normal: moderate\n                        const spd = spectacular ? 4 + Math.random() * 8 : 2 + Math.random() * 2;\n                        const sparkleVel = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize().multiplyScalar(spd);\n                        sparkle.userData = {\n                            velocity: sparkleVel,\n                            age: 0,\n                            spectacular,\n                            maxAge: spectacular ? 80 + Math.random() * 40 : 40 + Math.random() * 20\n                        }; // <-- LONGER LIFE\n                        scene.add(sparkle);\n                        if (!window._sparkles) window._sparkles = [];\n                        window._sparkles.push(sparkle);\n                    }\n                    if (spectacular) {\n                        // Add a big flash\n                        const flashGeo = new three__WEBPACK_IMPORTED_MODULE_3__.SphereGeometry(6, 24, 24);\n                        const flashMat = new three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial({\n                            color: 0xffffff,\n                            transparent: true,\n                            opacity: 0.8,\n                            blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n                        });\n                        const flash = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(flashGeo, flashMat);\n                        flash.position.copy(obj.mesh.position);\n                        scene.add(flash);\n                        if (!window._starFlashes) window._starFlashes = [];\n                        window._starFlashes.push({\n                            mesh: flash,\n                            age: 0\n                        });\n                    }\n                    // Fragmented trail logic (keep as before)\n                    const fragVel = obj.velocity.clone().applyAxisAngle(new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(0, 1, 0), (Math.random() - 0.5) * 0.3);\n                    const fragStar = obj.mesh.clone();\n                    fragStar.position.copy(obj.mesh.position);\n                    fragStar.velocity = fragVel;\n                    fragStar.normalizedLife = normalizedLife;\n                    fragStar.normalizedLifetime = obj.normalizedLifetime * (0.5 + Math.random() * 0.5);\n                    fragStar.age = obj.age;\n                    fragStar.material = obj.mesh.material.clone();\n                    const fragTrailPoints = obj.trailPoints.slice();\n                    const fragTailGeo = new three__WEBPACK_IMPORTED_MODULE_3__.BufferGeometry().setFromPoints(fragTrailPoints);\n                    fragTailGeo.setAttribute(\"color\", obj.tail.geometry.getAttribute(\"color\").clone());\n                    const fragTailMat = obj.tail.material.clone();\n                    const fragTail = new three__WEBPACK_IMPORTED_MODULE_3__.Line(fragTailGeo, fragTailMat);\n                    fragTail.position.copy(fragStar.position);\n                    scene.add(fragStar);\n                    scene.add(fragTail);\n                    shootingStars.push({\n                        mesh: fragStar,\n                        tail: fragTail,\n                        velocity: fragStar.velocity,\n                        dir: obj.dir,\n                        age: fragStar.age,\n                        normalizedLifetime: fragStar.normalizedLifetime,\n                        trailPoints: fragTrailPoints,\n                        color: obj.color,\n                        brightness: obj.brightness,\n                        hasFragmented: true\n                    });\n                    obj.hasFragmented = true;\n                }\n                // Spark burst\n                if (!obj.hasSparked && normalizedLife > 0.95 && Math.random() < 0.1) {\n                    for(let s = 0; s < 8 + Math.floor(Math.random() * 8); s++){\n                        const sparkGeo = new three__WEBPACK_IMPORTED_MODULE_3__.SphereGeometry(0.5 + Math.random() * 0.5, 8, 8);\n                        const sparkMat = new three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial({\n                            color: 0xfff6c0,\n                            transparent: true,\n                            opacity: 1,\n                            blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n                        });\n                        const spark = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(sparkGeo, sparkMat);\n                        spark.position.copy(obj.mesh.position);\n                        spark.sparkVel = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize().multiplyScalar(0.5 + Math.random() * 1.2);\n                        spark.sparkLife = 12 + Math.random() * 10;\n                        spark.sparkAge = 0;\n                        scene.add(spark);\n                        if (!window._starSparks) window._starSparks = [];\n                        window._starSparks.push(spark);\n                    }\n                    obj.hasSparked = true;\n                }\n                // Flash\n                if (!obj.hasFlashed && normalizedLife > 0.98 && Math.random() < 0.2) {\n                    const flashGeo = new three__WEBPACK_IMPORTED_MODULE_3__.SphereGeometry(1, 16, 16);\n                    const flashMat = new three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial({\n                        color: 0xffffee,\n                        transparent: true,\n                        opacity: 0.8,\n                        blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n                    });\n                    const flash = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(flashGeo, flashMat);\n                    flash.position.copy(obj.mesh.position);\n                    scene.add(flash);\n                    if (!window._starFlashes) window._starFlashes = [];\n                    window._starFlashes.push({\n                        mesh: flash,\n                        age: 0\n                    });\n                    obj.hasFlashed = true;\n                }\n                // Fade out as it gets far away\n                const dist = obj.mesh.position.distanceTo(camera.position);\n                const fadeStart = starMaxDistance * 0.5;\n                if (dist > fadeStart) {\n                    const fade = 1 - (dist - fadeStart) / (starMaxDistance - fadeStart);\n                    obj.mesh.material.opacity = Math.max(0, fade);\n                    obj.mesh.material.transparent = true;\n                    obj.tail.material.opacity = Math.max(0, fade * 0.8);\n                    obj.tail.material.transparent = true;\n                }\n                // Remove when out of bounds or fully faded or life ended\n                // Fade tail after explosion\n                if ((normalizedLife >= 1.0 || dist > starMaxDistance || obj.mesh.material.opacity <= 0.01) && !obj.tailFading) {\n                    scene.remove(obj.mesh);\n                    // Start tail fade-out ghost\n                    obj.tailFading = true;\n                    obj.tailFadeAge = 0;\n                    if (!window._fadingTails) window._fadingTails = [];\n                    window._fadingTails.push({\n                        tail: obj.tail,\n                        tailBloom: obj.tailBloom,\n                        age: 0\n                    });\n                    shootingStars.splice(i, 1);\n                }\n            }\n            // Animate sparks\n            if (window._starSparks) {\n                for(let i = window._starSparks.length - 1; i >= 0; i--){\n                    const spark = window._starSparks[i];\n                    spark.position.add(spark.sparkVel);\n                    spark.sparkAge++;\n                    spark.material.opacity *= 0.92;\n                    if (spark.sparkAge > spark.sparkLife) {\n                        scene.remove(spark);\n                        window._starSparks.splice(i, 1);\n                    }\n                }\n            }\n            // Animate explosion particles (sparkles)\n            if (window._sparkles) {\n                for(let i = window._sparkles.length - 1; i >= 0; i--){\n                    const sparkle = window._sparkles[i];\n                    sparkle.position.add(sparkle.userData.velocity);\n                    sparkle.userData.age++;\n                    sparkle.material.opacity *= 0.97;\n                    if (sparkle.userData.age > (sparkle.userData.maxAge || 40)) {\n                        scene.remove(sparkle);\n                        window._sparkles.splice(i, 1);\n                    }\n                }\n            }\n            // Animate fading tails (ghosts)\n            if (window._fadingTails) {\n                for(let i = window._fadingTails.length - 1; i >= 0; i--){\n                    const ghost = window._fadingTails[i];\n                    if (ghost.tail) {\n                        ghost.tail.material.opacity *= 0.92;\n                        if (ghost.tail.material.opacity < 0.01) {\n                            scene.remove(ghost.tail);\n                            window._fadingTails.splice(i, 1);\n                            continue;\n                        }\n                    }\n                    if (ghost.tailBloom) {\n                        ghost.tailBloom.material.opacity *= 0.92;\n                        if (ghost.tailBloom.material.opacity < 0.01) {\n                            shootingStarScene.remove(ghost.tailBloom);\n                            ghost.tailBloom = null;\n                        }\n                    }\n                    ghost.age++;\n                }\n            }\n            // Animate flashes\n            if (window._starFlashes) {\n                for(let i = window._starFlashes.length - 1; i >= 0; i--){\n                    const flash = window._starFlashes[i];\n                    flash.mesh.scale.multiplyScalar(1.15);\n                    flash.mesh.material.opacity *= 0.85;\n                    flash.age++;\n                    if (flash.age > 10) {\n                        scene.remove(flash.mesh);\n                        window._starFlashes.splice(i, 1);\n                    }\n                }\n            }\n            // --- Starfield logic ---\n            const sqDist = starMaxDistance * starMaxDistance;\n            for(let i = 0; i < positions.length; i += 3){\n                const dx = positions[i] - virtualCameraPos.x;\n                const dy = positions[i + 1] - virtualCameraPos.y;\n                const dz = positions[i + 2] - virtualCameraPos.z;\n                if (dx * dx + dy * dy + dz * dz > sqDist) {\n                    // Place in a thick spherical shell around the virtual camera, never too close\n                    const minRadius = starMaxDistance * 0.8;\n                    const maxRadius = starMaxDistance;\n                    const r = minRadius + Math.random() * (maxRadius - minRadius);\n                    const theta = Math.random() * 2 * Math.PI;\n                    const phi = Math.acos(2 * Math.random() - 1);\n                    positions[i] = virtualCameraPos.x + r * Math.sin(phi) * Math.cos(theta);\n                    positions[i + 1] = virtualCameraPos.y + r * Math.sin(phi) * Math.sin(theta);\n                    positions[i + 2] = virtualCameraPos.z + r * Math.cos(phi);\n                }\n            }\n            // geometry.attributes.position.needsUpdate = true; // Already set above\n            // Robust starfield color update to prevent stuck white dots\n            // This works NO TOUCHY\n            const colArr = geometry.attributes.color.array;\n            for(let i = 0; i < positions.length; i += 3){\n                const idx = i / 3;\n                const dx = positions[i] - virtualCameraPos.x;\n                const dy = positions[i + 1] - virtualCameraPos.y;\n                const dz = positions[i + 2] - virtualCameraPos.z;\n                const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);\n                if (timers[idx] > 0) {\n                    timers[idx]--;\n                    if (timers[idx] === 0) {\n                        // Timer expired, restore color\n                        sparkColors[i] = originalColors[i];\n                        sparkColors[i + 1] = originalColors[i + 1];\n                        sparkColors[i + 2] = originalColors[i + 2];\n                        colArr[i] = originalColors[i];\n                        colArr[i + 1] = originalColors[i + 1];\n                        colArr[i + 2] = originalColors[i + 2];\n                    } else {\n                        colArr[i] = sparkColors[i];\n                        colArr[i + 1] = sparkColors[i + 1];\n                        colArr[i + 2] = sparkColors[i + 2];\n                    }\n                } else if (dist > starMaxDistance * 0.3 && Math.random() < 0.05) {\n                    timers[idx] = sparkleDuration;\n                    const c = palette[Math.floor(Math.random() * palette.length)];\n                    sparkColors[i] = c[0];\n                    sparkColors[i + 1] = c[1];\n                    sparkColors[i + 2] = c[2];\n                    colArr[i] = sparkColors[i];\n                    colArr[i + 1] = sparkColors[i + 1];\n                    colArr[i + 2] = sparkColors[i + 2];\n                } else {\n                    sparkColors[i] = originalColors[i];\n                    sparkColors[i + 1] = originalColors[i + 1];\n                    sparkColors[i + 2] = originalColors[i + 2];\n                    colArr[i] = originalColors[i];\n                    colArr[i + 1] = originalColors[i + 1];\n                    colArr[i + 2] = originalColors[i + 2];\n                }\n            }\n            geometry.attributes.color.needsUpdate = true;\n        };\n        // Start the animation loop\n        animate();\n        // Handle window resize\n        const onResize = ()=>{\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n            shootingStarComposer.setSize(window.innerWidth, window.innerHeight);\n            caComposer.setSize(window.innerWidth, window.innerHeight);\n        };\n        // Add event listener for resize\n        window.addEventListener(\"resize\", onResize);\n        // Clean up function\n        return ()=>{\n            window.removeEventListener(\"resize\", onResize);\n            window.removeEventListener(\"resize\", resizeAll);\n            window.removeEventListener(\"fullscreenchange\", resizeAll);\n            window.removeEventListener(\"scroll\", onScroll);\n            // Cancel the animation frame using the stored ID\n            if (animationId) {\n                cancelAnimationFrame(animationId);\n            }\n            // Dispose composers\n            if (composer) composer.dispose();\n            if (shootingStarComposer) shootingStarComposer.dispose();\n            if (caComposer) caComposer.dispose();\n            // Clean up Three.js resources\n            if (renderer) {\n                renderer.dispose();\n                if (mount && mount.contains(renderer.domElement)) {\n                    mount.removeChild(renderer.domElement);\n                }\n            }\n        };\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: mountRef\n    }, void 0, false, {\n        fileName: \"/home/kayosdev/Websites/Portfolio/components/Starfield.jsx\",\n        lineNumber: 799,\n        columnNumber: 10\n    }, undefined);\n};\n_s(Starfield, \"V9/qkEdV8GfsDZk7lMTA1T8g5Ps=\");\n_c = Starfield;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Starfield);\nvar _c;\n$RefreshReg$(_c, \"Starfield\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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ckN4QyxPQUFPeVQsbUJBQW1CLENBQUMsb0JBQW9CalI7WUFDL0N4QyxPQUFPeVQsbUJBQW1CLENBQUMsVUFBVWxNO1lBQ3JDLGlEQUFpRDtZQUNqRCxJQUFJaUYsYUFBYTtnQkFDZmtILHFCQUFxQmxIO1lBQ3ZCO1lBQ0Esb0JBQW9CO1lBQ3BCLElBQUkvSyxVQUFVQSxTQUFTa1MsT0FBTztZQUM5QixJQUFJMVIsc0JBQXNCQSxxQkFBcUIwUixPQUFPO1lBQ3RELElBQUlyUixZQUFZQSxXQUFXcVIsT0FBTztZQUNsQyw4QkFBOEI7WUFDOUIsSUFBSXJULFVBQVU7Z0JBQ1pBLFNBQVNxVCxPQUFPO2dCQUNoQixJQUFJdlUsU0FBU0EsTUFBTXdVLFFBQVEsQ0FBQ3RULFNBQVNrQixVQUFVLEdBQUc7b0JBQ2hEcEMsTUFBTXlVLFdBQVcsQ0FBQ3ZULFNBQVNrQixVQUFVO2dCQUN2QztZQUNGO1FBQ0Y7SUFDRixHQUFHLEVBQUU7SUFFTCxxQkFBTyw4REFBQ3NTO1FBQUlDLEtBQUs3VTs7Ozs7O0FBQ25CO0dBcnhCTUQ7S0FBQUE7QUF1eEJOLCtEQUFlQSxTQUFTQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvU3RhcmZpZWxkLmpzeD9mMWEyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCB7IEVmZmVjdENvbXBvc2VyIH0gZnJvbSAndGhyZWUvZXhhbXBsZXMvanNtL3Bvc3Rwcm9jZXNzaW5nL0VmZmVjdENvbXBvc2VyJztcbmltcG9ydCB7IFVucmVhbEJsb29tUGFzcyB9IGZyb20gJ3RocmVlL2V4YW1wbGVzL2pzbS9wb3N0cHJvY2Vzc2luZy9VbnJlYWxCbG9vbVBhc3MnO1xuaW1wb3J0IHsgUmVuZGVyUGFzcyB9IGZyb20gJ3RocmVlL2V4YW1wbGVzL2pzbS9wb3N0cHJvY2Vzc2luZy9SZW5kZXJQYXNzJztcbmltcG9ydCB7IFNoYWRlclBhc3MgfSBmcm9tICd0aHJlZS9leGFtcGxlcy9qc20vcG9zdHByb2Nlc3NpbmcvU2hhZGVyUGFzcyc7XG5pbXBvcnQgeyBGWEFBU2hhZGVyIH0gZnJvbSAndGhyZWUvZXhhbXBsZXMvanNtL3NoYWRlcnMvRlhBQVNoYWRlcic7XG5pbXBvcnQgeyBGaWxtUGFzcyB9IGZyb20gJ3RocmVlL2V4YW1wbGVzL2pzbS9wb3N0cHJvY2Vzc2luZy9GaWxtUGFzcyc7XG5pbXBvcnQgeyBDaHJvbWF0aWNBYmVycmF0aW9uUGFzcyB9IGZyb20gJy4vQ2hyb21hdGljQWJlcnJhdGlvblBhc3MnO1xuXG5jb25zdCBTdGFyZmllbGQgPSAoKSA9PiB7XG4gIGNvbnN0IG1vdW50UmVmID0gdXNlUmVmKG51bGwpXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBEZWZlbnNpdmU6IGFsd2F5cyB1c2UgLmN1cnJlbnQgZm9yIHJlZnNcbiAgICBpZiAoIW1vdW50UmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICBjb25zdCBtb3VudCA9IG1vdW50UmVmLmN1cnJlbnRcbiAgICBtb3VudC5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCdcbiAgICBtb3VudC5zdHlsZS50b3AgPSAnMCdcbiAgICBtb3VudC5zdHlsZS5sZWZ0ID0gJzAnXG4gICAgbW91bnQuc3R5bGUud2lkdGggPSAnMTAwJSdcbiAgICBtb3VudC5zdHlsZS5oZWlnaHQgPSAnMTAwJSdcbiAgICBtb3VudC5zdHlsZS56SW5kZXggPSAnMCdcblxuICAgIC8vIFNjZW5lICYgUmVuZGVyZXJcbiAgICBjb25zdCBzY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpXG4gICAgY29uc3QgY2FtZXJhID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKDc1LCB3aW5kb3cuaW5uZXJXaWR0aCAvIHdpbmRvdy5pbm5lckhlaWdodCwgMC4xLCA1MDAwKVxuICAgIGNhbWVyYS5wb3NpdGlvbi5zZXQoMCwgMCwgMCk7XG4gICAgLy8gVmlydHVhbCBwb3NpdGlvbiB0byBzaW11bGF0ZSBpbmZpbml0ZSB0cmF2ZWxcbiAgICBsZXQgdmlydHVhbENhbWVyYVBvcyA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDApO1xuICAgIGNvbnN0IHJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoeyBhbnRpYWxpYXM6IGZhbHNlIH0pIC8vIFdlJ2xsIHVzZSBGWEFBIGluc3RlYWRcbiAgICByZW5kZXJlci5zZXRQaXhlbFJhdGlvKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKVxuICAgIHJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodClcbiAgICByZW5kZXJlci5zZXRDbGVhckNvbG9yKDB4MDAwMDAwLCAxKTtcbiAgICBpZiAoJ291dHB1dENvbG9yU3BhY2UnIGluIHJlbmRlcmVyKSB7XG4gICAgICByZW5kZXJlci5vdXRwdXRDb2xvclNwYWNlID0gVEhSRUUuU1JHQkNvbG9yU3BhY2U7XG4gICAgfVxuICAgIC8vIENyZWF0ZSBhIHJlbmRlciB0YXJnZXQgZm9yIHRoZSBjb21wb3NlciB3aXRoIGNvcnJlY3QgY29sb3Igc3BhY2VcbiAgICBjb25zdCByZW5kZXJUYXJnZXQgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCwge1xuICAgICAgY29sb3JTcGFjZTogVEhSRUUuU1JHQkNvbG9yU3BhY2UsXG4gICAgICB0eXBlOiBUSFJFRS5VbnNpZ25lZEJ5dGVUeXBlXG4gICAgfSk7XG4gICAgcmVuZGVyZXIudG9uZU1hcHBpbmcgPSBUSFJFRS5Ob1RvbmVNYXBwaW5nO1xuICAgIHJlbmRlcmVyLmF1dG9DbGVhciA9IHRydWU7XG4gICAgbW91bnQuYXBwZW5kQ2hpbGQocmVuZGVyZXIuZG9tRWxlbWVudClcblxuICAgIC8vIC0tLSBNQUlOIFNUQVJGSUVMRCBQT1NULVBST0NFU1NJTkcgLS0tXG4gICAgY29uc3QgY29tcG9zZXIgPSBuZXcgRWZmZWN0Q29tcG9zZXIocmVuZGVyZXIsIHJlbmRlclRhcmdldCk7XG4gICAgY29tcG9zZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICBjb25zdCByZW5kZXJQYXNzID0gbmV3IFJlbmRlclBhc3Moc2NlbmUsIGNhbWVyYSk7XG4gICAgcmVuZGVyUGFzcy5jbGVhciA9IHRydWU7XG4gICAgY29tcG9zZXIuYWRkUGFzcyhyZW5kZXJQYXNzKTtcbiAgICAvLyBVbnJlYWxCbG9vbVBhc3M6IFwiY3JhenlcIiBibG9vbVxuICAgIGNvbnN0IGJsb29tUGFzcyA9IG5ldyBVbnJlYWxCbG9vbVBhc3MoXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMih3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KSxcbiAgICAgIDMuNSwgLy8gaW50ZW5zaXR5XG4gICAgICAxLjYsIC8vIHJhZGl1c1xuICAgICAgMC4wMSAvLyB0aHJlc2hvbGRcbiAgICApO1xuICAgIGNvbXBvc2VyLmFkZFBhc3MoYmxvb21QYXNzKTtcblxuICAgIC8vIEZpbG1QYXNzXG4gICAgY29uc3QgZmlsbVBhc3MgPSBuZXcgRmlsbVBhc3MoXG4gICAgICAwLjAsIC8vIG5vaXNlIGludGVuc2l0eSAod2FzIDAuNylcbiAgICAgIDAuMCwgLy8gc2NhbmxpbmUgaW50ZW5zaXR5ICh3YXMgMC4wOClcbiAgICAgIDY0OCwgLy8gc2NhbmxpbmUgY291bnRcbiAgICAgIGZhbHNlIC8vIGdyYXlzY2FsZVxuICAgICk7XG4gICAgY29tcG9zZXIuYWRkUGFzcyhmaWxtUGFzcyk7XG5cbiAgICBcbiAgICAvLyAtLS0gU0hPT1RJTkcgU1RBUiBQT1NULVBST0NFU1NJTkcgT05MWSAtLS1cbiAgICAvLyBTZXBhcmF0ZSBzY2VuZSBhbmQgY29tcG9zZXIgZm9yIHNob290aW5nIHN0YXJzXG4gICAgY29uc3Qgc2hvb3RpbmdTdGFyU2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcbiAgICBjb25zdCBzaG9vdGluZ1N0YXJDb21wb3NlciA9IG5ldyBFZmZlY3RDb21wb3NlcihyZW5kZXJlcik7XG4gICAgc2hvb3RpbmdTdGFyQ29tcG9zZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICBjb25zdCBzaG9vdGluZ1N0YXJSZW5kZXJQYXNzID0gbmV3IFJlbmRlclBhc3Moc2hvb3RpbmdTdGFyU2NlbmUsIGNhbWVyYSk7XG4gICAgc2hvb3RpbmdTdGFyQ29tcG9zZXIuYWRkUGFzcyhzaG9vdGluZ1N0YXJSZW5kZXJQYXNzKTtcbiAgICAvLyBJbnRlbnNlIGJsb29tIGZvciBzaG9vdGluZyBzdGFyc1xuICAgIGNvbnN0IHNob290aW5nU3RhckJsb29tUGFzcyA9IG5ldyBVbnJlYWxCbG9vbVBhc3MoXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMih3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KSxcbiAgICAgIDQuMCwgLy8gc3Ryb25nXG4gICAgICAyLjAsIC8vIHdpZGVcbiAgICAgIDAuMCAvLyBhbGwgYnJpZ2h0XG4gICAgKTtcbiAgICBzaG9vdGluZ1N0YXJDb21wb3Nlci5hZGRQYXNzKHNob290aW5nU3RhckJsb29tUGFzcyk7XG5cbiAgICAvLyAtLS0gQ0xPU0UgU1RBUlM6IFNlcGFyYXRlIFNjZW5lIGZvciBDaHJvbWF0aWMgQWJlcnJhdGlvbiAtLS1cbiAgICBjb25zdCBjbG9zZVN0YXJzU2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcbiAgICBjb25zdCBjYVBhc3MgPSBuZXcgQ2hyb21hdGljQWJlcnJhdGlvblBhc3MobmV3IFRIUkVFLlZlY3RvcjIoMC4wMDAyLCAwLjAwMDIpKTsgLy8gYmFyZWx5IHZpc2libGVcbiAgICBjb25zdCBjYUNvbXBvc2VyID0gbmV3IEVmZmVjdENvbXBvc2VyKHJlbmRlcmVyKTtcbiAgICBjYUNvbXBvc2VyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgY29uc3QgY2FSZW5kZXJQYXNzID0gbmV3IFJlbmRlclBhc3MoY2xvc2VTdGFyc1NjZW5lLCBjYW1lcmEpO1xuICAgIGNhQ29tcG9zZXIuYWRkUGFzcyhjYVJlbmRlclBhc3MpO1xuICAgIGNhQ29tcG9zZXIuYWRkUGFzcyhjYVBhc3MpO1xuXG4gICAgLy8gLS0tIEhBTkRMRSBSRVNJWkUgQU5EIEZVTExTQ1JFRU4gLS0tXG4gICAgZnVuY3Rpb24gcmVzaXplQWxsKCkge1xuICAgICAgY2FtZXJhLmFzcGVjdCA9IHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAgIHJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG5cbiAgICAgIC8vIE1haW4gY29tcG9zZXJcbiAgICAgIGNvbXBvc2VyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgICAvLyBPdGhlciBjb21wb3NlcnNcbiAgICAgIHNob290aW5nU3RhckNvbXBvc2VyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgICBjYUNvbXBvc2VyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgfVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCByZXNpemVBbGwpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdmdWxsc2NyZWVuY2hhbmdlJywgcmVzaXplQWxsKTtcblxuICAgIC8vIFN0YXJmaWVsZFxuICAgIGNvbnN0IHN0YXJDb3VudCA9IDUwMDBcbiAgICBjb25zdCBzdGFyTWF4RGlzdGFuY2UgPSAyMDAwXG4gICAgY29uc3Qgc3Rhck1pbkRpc3RhbmNlID0gMTIwMCAvLyBtaW5pbXVtIGRpc3RhbmNlIGZyb20gY2FtZXJhXG4gICAgY29uc3Qgc3RhclNwZWVkID0gMVxuICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KClcbiAgICBjb25zdCBjbG9zZUdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XG4gICAgY29uc3QgcG9zaXRpb25zID0gW107XG4gICAgY29uc3QgY2xvc2VQb3NpdGlvbnMgPSBbXTtcbiAgICBsZXQgc3RhcnNQbGFjZWQgPSAwO1xuICAgIHdoaWxlIChzdGFyc1BsYWNlZCA8IHN0YXJDb3VudCkge1xuICAgICAgLy8gV2l0aCAxJSBjaGFuY2UsIHNwYXduIGEgc3RhciBjbHVzdGVyICgxMC0zMCBzdGFycylcbiAgICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgMC4wMSAmJiBzdGFyc1BsYWNlZCA8IHN0YXJDb3VudCAtIDEwKSB7XG4gICAgICAgIGNvbnN0IGNsdXN0ZXJUaGV0YSA9IE1hdGgucmFuZG9tKCkgKiAyICogTWF0aC5QSTtcbiAgICAgICAgY29uc3QgY2x1c3RlclBoaSA9IE1hdGguYWNvcygyICogTWF0aC5yYW5kb20oKSAtIDEpO1xuICAgICAgICBjb25zdCBjbHVzdGVyUiA9IHN0YXJNaW5EaXN0YW5jZSArIE1hdGgucmFuZG9tKCkgKiAoc3Rhck1heERpc3RhbmNlIC0gc3Rhck1pbkRpc3RhbmNlKTtcbiAgICAgICAgY29uc3QgY2x1c3RlckNlbnRlciA9IFtcbiAgICAgICAgICBjbHVzdGVyUiAqIE1hdGguc2luKGNsdXN0ZXJQaGkpICogTWF0aC5jb3MoY2x1c3RlclRoZXRhKSxcbiAgICAgICAgICBjbHVzdGVyUiAqIE1hdGguc2luKGNsdXN0ZXJQaGkpICogTWF0aC5zaW4oY2x1c3RlclRoZXRhKSxcbiAgICAgICAgICBjbHVzdGVyUiAqIE1hdGguY29zKGNsdXN0ZXJQaGkpXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGNsdXN0ZXJTaXplID0gMTAgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyMCk7IC8vIDEwLTMwIHN0YXJzXG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgY2x1c3RlclNpemUgJiYgc3RhcnNQbGFjZWQgPCBzdGFyQ291bnQ7IGMrKykge1xuICAgICAgICAgIC8vIEVhY2ggc3RhciBpbiBjbHVzdGVyIGlzIHdpdGhpbiAzMCB1bml0cyBvZiBjZW50ZXJcbiAgICAgICAgICBjb25zdCBvZmZzZXRUaGV0YSA9IE1hdGgucmFuZG9tKCkgKiAyICogTWF0aC5QSTtcbiAgICAgICAgICBjb25zdCBvZmZzZXRQaGkgPSBNYXRoLmFjb3MoMiAqIE1hdGgucmFuZG9tKCkgLSAxKTtcbiAgICAgICAgICBjb25zdCBvZmZzZXRSID0gTWF0aC5yYW5kb20oKSAqIDMwOyAvLyBjbHVzdGVyIHJhZGl1c1xuICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKFxuICAgICAgICAgICAgY2x1c3RlckNlbnRlclswXSArIG9mZnNldFIgKiBNYXRoLnNpbihvZmZzZXRQaGkpICogTWF0aC5jb3Mob2Zmc2V0VGhldGEpLFxuICAgICAgICAgICAgY2x1c3RlckNlbnRlclsxXSArIG9mZnNldFIgKiBNYXRoLnNpbihvZmZzZXRQaGkpICogTWF0aC5zaW4ob2Zmc2V0VGhldGEpLFxuICAgICAgICAgICAgY2x1c3RlckNlbnRlclsyXSArIG9mZnNldFIgKiBNYXRoLmNvcyhvZmZzZXRQaGkpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzdGFyc1BsYWNlZCsrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb3JtYWwgc2luZ2xlIHN0YXJcbiAgICAgICAgY29uc3QgdGhldGEgPSBNYXRoLnJhbmRvbSgpICogMiAqIE1hdGguUEk7XG4gICAgICAgIGNvbnN0IHBoaSA9IE1hdGguYWNvcygyICogTWF0aC5yYW5kb20oKSAtIDEpO1xuICAgICAgICBjb25zdCByID0gc3Rhck1pbkRpc3RhbmNlICsgTWF0aC5yYW5kb20oKSAqIChzdGFyTWF4RGlzdGFuY2UgLSBzdGFyTWluRGlzdGFuY2UpO1xuICAgICAgICBjb25zdCB4ID0gciAqIE1hdGguc2luKHBoaSkgKiBNYXRoLmNvcyh0aGV0YSk7XG4gICAgICAgIGNvbnN0IHkgPSByICogTWF0aC5zaW4ocGhpKSAqIE1hdGguc2luKHRoZXRhKTtcbiAgICAgICAgY29uc3QgeiA9IHIgKiBNYXRoLmNvcyhwaGkpO1xuICAgICAgICBwb3NpdGlvbnMucHVzaCh4LCB5LCB6KTtcbiAgICAgICAgLy8gSWYgY2xvc2UsIGFsc28gYWRkIHRvIGNsb3NlUG9zaXRpb25zXG4gICAgICAgIGlmIChyIDwgNDAwKSB7XG4gICAgICAgICAgY2xvc2VQb3NpdGlvbnMucHVzaCh4LCB5LCB6KTtcbiAgICAgICAgfVxuICAgICAgICBzdGFyc1BsYWNlZCsrO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25zLCAzKSlcbiAgICBpZiAoY2xvc2VQb3NpdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgY2xvc2VHZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoY2xvc2VQb3NpdGlvbnMsIDMpKTtcbiAgICB9XG5cbiAgICAvLyBDUkFaWSBCTE9PTTogQWxsIHN0YXJzIGFyZSBleHRyZW1lbHkgYnJpZ2h0IChjb2xvciBpbnRlbnNpdHkgPjEpXG4gICAgY29uc3QgcGFsZXR0ZSA9IFtcbiAgICAgIFsxLjAsIDAuNSwgMC41XSxcbiAgICAgIFsxLjAsIDAuNzUsIDAuNF0sXG4gICAgICBbMS4wLCAxLjAsIDAuOV0sXG4gICAgICBbMS4wLCAxLjAsIDEuMF0sXG4gICAgICBbMC40LCAwLjUsIDEuMF0sXG4gICAgXTtcbiAgICBjb25zdCBjb2xvcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXJDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBjID0gcGFsZXR0ZVtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBwYWxldHRlLmxlbmd0aCldO1xuICAgICAgY29sb3JzLnB1c2goLi4uYyk7XG4gICAgfVxuICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnY29sb3InLCBuZXcgVEhSRUUuRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShjb2xvcnMsIDMpKTtcblxuICAgIGNvbnN0IG9yaWdpbmFsQ29sb3JzID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvci5hcnJheS5zbGljZSgpXG4gICAgY29uc3QgdGltZXJzID0gbmV3IEZsb2F0MzJBcnJheShzdGFyQ291bnQpXG4gICAgY29uc3Qgc3BhcmtDb2xvcnMgPSBuZXcgRmxvYXQzMkFycmF5KHN0YXJDb3VudCAqIDMpXG4gICAgY29uc3Qgc3BhcmtsZUR1cmF0aW9uID0gMTgwXG5cbiAgICAvLyAtLS0gU1FVQVJFIFNUQVJTIFVTSU5HIFBPSU5UUyAtLS1cbmNvbnN0IG1hdGVyaWFsID0gbmV3IFRIUkVFLlBvaW50c01hdGVyaWFsKHsgc2l6ZTogMTAsIHNpemVBdHRlbnVhdGlvbjogZmFsc2UsIHZlcnRleENvbG9yczogdHJ1ZSB9KTtcbmNvbnN0IHN0YXJzID0gbmV3IFRIUkVFLlBvaW50cyhnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuc2NlbmUuYWRkKHN0YXJzKTtcbi8vIEFkZCBnbG93IHNwcml0ZXMgdG8gZWFjaCBzdGFyIGFuZCBhbmltYXRlIHRoZW0gYmFzZWQgb24gZGlzdGFuY2VcbmNvbnN0IGdsb3dNYXAgPSBuZXcgVEhSRUUuVGV4dHVyZUxvYWRlcigpLmxvYWQoJy9nbG93LnBuZycpO1xuY29uc3QgZ2xvd1Nwcml0ZXMgPSBbXTtcbmNvbnN0IGdsb3dNYXRlcmlhbCA9IG5ldyBUSFJFRS5TcHJpdGVNYXRlcmlhbCh7IG1hcDogZ2xvd01hcCwgY29sb3I6IDB4ZmZmZmZmLCBvcGFjaXR5OiAwLjE4LCBibGVuZGluZzogVEhSRUUuQWRkaXRpdmVCbGVuZGluZywgZGVwdGhXcml0ZTogZmFsc2UsIHRyYW5zcGFyZW50OiB0cnVlIH0pO1xuZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFyQ291bnQ7IGkrKykge1xuICBjb25zdCBnbG93ID0gbmV3IFRIUkVFLlNwcml0ZShnbG93TWF0ZXJpYWwuY2xvbmUoKSk7XG4gIGdsb3cucG9zaXRpb24uc2V0KHBvc2l0aW9uc1tpKjNdLCBwb3NpdGlvbnNbaSozKzFdLCBwb3NpdGlvbnNbaSozKzJdKTtcbiAgZ2xvdy5zY2FsZS5zZXQoMTAsIDEwLCAxKTtcbiAgc2NlbmUuYWRkKGdsb3cpO1xuICBnbG93U3ByaXRlcy5wdXNoKGdsb3cpO1xufVxuLy8gQWRkIGNsb3NlIHN0YXJzIHRvIHNlcGFyYXRlIHNjZW5lXG5sZXQgY2xvc2VTdGFycztcbmlmIChjbG9zZVBvc2l0aW9ucy5sZW5ndGggPiAwKSB7XG4gIGNsb3NlU3RhcnMgPSBuZXcgVEhSRUUuUG9pbnRzKGNsb3NlR2VvbWV0cnksIG1hdGVyaWFsLmNsb25lKCkpO1xuICBjbG9zZVN0YXJzU2NlbmUuYWRkKGNsb3NlU3RhcnMpO1xufVxuXG4gICAgbGV0IHRhcmdldFkgPSAwXG4gICAgY29uc3QgZGFtcGluZyA9IDAuMDVcbiAgICBjb25zdCBvblNjcm9sbCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHBjdCA9IHdpbmRvdy5zY3JvbGxZIC8gKGRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0IC0gd2luZG93LmlubmVySGVpZ2h0KVxuICAgICAgdGFyZ2V0WSA9IHBjdCAqIE1hdGguUEkgKiAyXG4gICAgfVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBvblNjcm9sbClcblxuXG4gICAgLy8gLS0tIFNob290aW5nIFN0YXJzIC0tLVxuICAgIGNvbnN0IHRhaWxMZW5ndGggPSAzMjsgLy8gSW5jcmVhc2UgZm9yIGxvbmdlciB0YWlsc1xuICAgIGNvbnN0IHNob290aW5nU3RhcnMgPSBbXTtcbiAgICBsZXQgc2hvb3RpbmdTdGFyQ29vbGRvd24gPSAwO1xuICAgIC8vIFNwYXduIGEgc2hvb3Rpbmcgc3RhciB3aXRoIGEgc3R1bm5pbmcgZ2xvd2luZyB0YWlsXG4gICAgZnVuY3Rpb24gc3Bhd25TaG9vdGluZ1N0YXIoKSB7XG4gICAgICAvLyBQaWNrIGEgcmFuZG9tIGRpcmVjdGlvbiBvbiB0aGUgc3BoZXJlIGZvciB0aGUgc3Bhd24gbG9jYXRpb25cbiAgICAgIGNvbnN0IGRpciA9IG5ldyBUSFJFRS5WZWN0b3IzKE1hdGgucmFuZG9tKCkqMi0xLCBNYXRoLnJhbmRvbSgpKjItMSwgTWF0aC5yYW5kb20oKSoyLTEpLm5vcm1hbGl6ZSgpO1xuICAgICAgLy8gRW5zdXJlIHNob290aW5nIHN0YXJzIG5ldmVyIHNwYXduIGNsb3NlIHRvIHRoZSBjYW1lcmEgKGF0IGxlYXN0IDcwJSBvZiBtYXggZGlzdGFuY2UpXG4gICAgICBjb25zdCBtaW5EaXN0ID0gc3Rhck1heERpc3RhbmNlICogMC43O1xuICAgICAgY29uc3QgbWF4RGlzdCA9IHN0YXJNYXhEaXN0YW5jZSAqIDEuMDtcbiAgICAgIGNvbnN0IGRpc3QgPSBtaW5EaXN0ICsgTWF0aC5yYW5kb20oKSAqIChtYXhEaXN0IC0gbWluRGlzdCk7XG4gICAgICBjb25zdCBzcGF3blBvcyA9IGRpci5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKGRpc3QpO1xuICAgICAgLy8gVGFuZ2VudGlhbCB2ZWxvY2l0eTogcGVycGVuZGljdWxhciB0byBkaXJcbiAgICAgIGxldCB0YW5nZW50ID0gbmV3IFRIUkVFLlZlY3RvcjMoTWF0aC5yYW5kb20oKSoyLTEsIE1hdGgucmFuZG9tKCkqMi0xLCBNYXRoLnJhbmRvbSgpKjItMSk7XG4gICAgICB0YW5nZW50ID0gdGFuZ2VudC5zdWIodGFuZ2VudC5jbG9uZSgpLnByb2plY3RPblZlY3RvcihkaXIpKS5ub3JtYWxpemUoKTtcbiAgICAgIC8vIE1peCBpbiBhIHNtYWxsIHJhZGlhbCBjb21wb25lbnQgKGlud2FyZCBvciBvdXR3YXJkKVxuICAgICAgY29uc3QgdGFuZ2VudGlhbFNwZWVkID0gc3RhclNwZWVkICogKDIuNSArIE1hdGgucmFuZG9tKCkgKiAyLjUpOyAvLyBtdWNoIGZhc3RlclxuICAgICAgY29uc3QgcmFkaWFsU3BlZWQgPSBzdGFyU3BlZWQgKiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAwLjM7IC8vIG1vcmUgZHJhbWF0aWNcbiAgICAgIGNvbnN0IHZlbG9jaXR5ID0gdGFuZ2VudC5tdWx0aXBseVNjYWxhcih0YW5nZW50aWFsU3BlZWQpLmFkZChkaXIuY2xvbmUoKS5tdWx0aXBseVNjYWxhcihyYWRpYWxTcGVlZCkpO1xuXG4gICAgICAvLyBTdHVubmluZyBjb2xvciBncmFkaWVudCBmb3IgdGhlIGhlYWRcbiAgICAgIGNvbnN0IHZpYnJhbnRDb2xvcnMgPSBbMHhmZmUwNjYsIDB4ZmY2NmNjLCAweDY2Y2NmZiwgMHhmZmZmZmYsIDB4ODBmZmVhLCAweGZmZjJjYywgMHhmZmMwODAsIDB4ODBjMGZmLCAweGZmODBiM107XG4gICAgICBjb25zdCBjb2xvciA9IHZpYnJhbnRDb2xvcnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKnZpYnJhbnRDb2xvcnMubGVuZ3RoKV07XG4gICAgICAvLyBTdGFyIGJyaWdodG5lc3MgYW5kIHNpemUgKGFsd2F5cyBzbWFsbCBhbmQgc3VidGxlKVxuICAgICAgY29uc3QgYnJpZ2h0bmVzcyA9IDIuNSArIE1hdGgucmFuZG9tKCkqMS41O1xuICAgICAgY29uc3QgZ2VvID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KDAuNyArIE1hdGgucmFuZG9tKCkqMC41LCAxNiwgMTYpOyAvLyBTbWFsbCBzcGhlcmVcbiAgICAgIGNvbnN0IG1hdCA9IG5ldyBUSFJFRS5NZXNoUGh5c2ljYWxNYXRlcmlhbCh7XG4gICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgZW1pc3NpdmU6IGNvbG9yLFxuICAgICAgICBlbWlzc2l2ZUludGVuc2l0eTogMTQuMCwgLy8gSW50ZW5zZSBibG9vbVxuICAgICAgICBtZXRhbG5lc3M6IDAuNyxcbiAgICAgICAgcm91Z2huZXNzOiAwLjMsXG4gICAgICAgIHRyYW5zbWlzc2lvbjogMC43LFxuICAgICAgICBvcGFjaXR5OiAwLjk4LFxuICAgICAgICB0cmFuc3BhcmVudDogdHJ1ZSxcbiAgICAgICAgY2xlYXJjb2F0OiAwLjgsXG4gICAgICAgIGNsZWFyY29hdFJvdWdobmVzczogMC4yLFxuICAgICAgfSk7XG4gICAgICBjb25zdCBzdGFyID0gbmV3IFRIUkVFLk1lc2goZ2VvLCBtYXQpO1xuICAgICAgLy8gQWRkIGEgbGFyZ2UsIGludGVuc2UgYmxvb20gc3ByaXRlIGZvciBleHRyYSBibG9vbVxuICAgICAgY29uc3Qgc3ByaXRlTWFwID0gbmV3IFRIUkVFLlRleHR1cmVMb2FkZXIoKS5sb2FkKCcvZ2xvdy5wbmcnKTtcbiAgICAgIGNvbnN0IHNwcml0ZU1hdGVyaWFsID0gbmV3IFRIUkVFLlNwcml0ZU1hdGVyaWFsKHsgbWFwOiBzcHJpdGVNYXAsIGNvbG9yOiAweGZmZmZmZiwgb3BhY2l0eTogMS4wLCBibGVuZGluZzogVEhSRUUuQWRkaXRpdmVCbGVuZGluZyB9KTtcbiAgICAgIGNvbnN0IHNwcml0ZSA9IG5ldyBUSFJFRS5TcHJpdGUoc3ByaXRlTWF0ZXJpYWwpO1xuICAgICAgc3ByaXRlLnNjYWxlLnNldCg3MCwgNzAsIDEpOyAvLyBMYXJnZSBmb3IgYmxvb21cbiAgICAgIHNwcml0ZS5wb3NpdGlvbi5jb3B5KHN0YXIucG9zaXRpb24pO1xuICAgICAgc3Rhci5hZGQoc3ByaXRlKTtcbiAgICAgIC8vIEFkZCBhIGNvbG9yZWQgc3ByaXRlIGZvciBjb2xvciBwb3BcbiAgICAgIGNvbnN0IGNvbG9yU3ByaXRlTWF0ZXJpYWwgPSBuZXcgVEhSRUUuU3ByaXRlTWF0ZXJpYWwoeyBtYXA6IHNwcml0ZU1hcCwgY29sb3I6IGNvbG9yLCBvcGFjaXR5OiAwLjYsIGJsZW5kaW5nOiBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nIH0pO1xuICAgICAgY29uc3QgY29sb3JTcHJpdGUgPSBuZXcgVEhSRUUuU3ByaXRlKGNvbG9yU3ByaXRlTWF0ZXJpYWwpO1xuICAgICAgY29sb3JTcHJpdGUuc2NhbGUuc2V0KDM0LCAzNCwgMSk7XG4gICAgICBjb2xvclNwcml0ZS5wb3NpdGlvbi5jb3B5KHN0YXIucG9zaXRpb24pO1xuICAgICAgc3Rhci5hZGQoY29sb3JTcHJpdGUpO1xuICAgICAgLy8gQWRkIHRvIGJvdGggbWFpbiBzY2VuZSBhbmQgc2hvb3RpbmdTdGFyU2NlbmVcbiAgICAgIHNjZW5lLmFkZChzdGFyKTtcbiAgICAgIHNob290aW5nU3RhclNjZW5lLmFkZChzdGFyKTtcbiAgICAgIC8vIEFkZCBkeW5hbWljIHNwYXJrIGJ1cnN0IGF0IHRoZSBoZWFkXG4gICAgICBjb25zdCBzcGFya0NvdW50ID0gMTggKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqOCk7XG4gICAgICBjb25zdCBzcGFya0dyb3VwID0gbmV3IFRIUkVFLkdyb3VwKCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwYXJrQ291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBzcGFya01hdCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7IGNvbG9yOiB2aWJyYW50Q29sb3JzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSp2aWJyYW50Q29sb3JzLmxlbmd0aCldLCB0cmFuc3BhcmVudDogdHJ1ZSwgb3BhY2l0eTogMC44IH0pO1xuICAgICAgICBjb25zdCBzcGFya0dlbyA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeSgwLjA3ICsgTWF0aC5yYW5kb20oKSowLjA2LCA4LCA4KTtcbiAgICAgICAgY29uc3Qgc3BhcmsgPSBuZXcgVEhSRUUuTWVzaChzcGFya0dlbywgc3BhcmtNYXQpO1xuICAgICAgICBjb25zdCBhbmdsZSA9IChpIC8gc3BhcmtDb3VudCkgKiBNYXRoLlBJICogMjtcbiAgICAgICAgc3BhcmsucG9zaXRpb24uc2V0KE1hdGguY29zKGFuZ2xlKSoxLjIsIE1hdGguc2luKGFuZ2xlKSoxLjIsIE1hdGgucmFuZG9tKCkqMC40LTAuMik7XG4gICAgICAgIHNwYXJrR3JvdXAuYWRkKHNwYXJrKTtcbiAgICAgIH1cbiAgICAgIHNwYXJrR3JvdXAubmFtZSA9ICdzcGFya0J1cnN0JztcbiAgICAgIHN0YXIuYWRkKHNwYXJrR3JvdXApO1xuICAgICAgc3Rhci5wb3NpdGlvbi5jb3B5KHNwYXduUG9zKTtcbiAgICAgIHN0YXIudmVsb2NpdHkgPSB2ZWxvY2l0eTtcbiAgICAgIHN0YXIubm9ybWFsaXplZExpZmUgPSAwLjA7XG4gICAgICBzdGFyLm5vcm1hbGl6ZWRMaWZldGltZSA9IDgwICsgTWF0aC5yYW5kb20oKSAqIDgwOyAvLyBMb25nZXIsIG1vcmUgZHJhbWF0aWNcbiAgICAgIHN0YXIuYWdlID0gMDtcbiAgICAgIC8vIC0tLSBTdHVubmluZyBNZXRlb3IgVGFpbCAodmVyeSBsb25nLCBtdWx0aS1jb2xvciwgZ2xvd2luZywgZmFkaW5nLCBhbmQgM0QgY3VydmUpIC0tLVxuICAgICAgY29uc3QgdHJhaWxTZWdtZW50cyA9IHRhaWxMZW5ndGggKiAzOyBcbiAgICAgIGNvbnN0IHRyYWlsUG9pbnRzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYWlsU2VnbWVudHM7IGkrKykge1xuICAgICAgICAvLyBBZGQgYSAzRCBzcGlyYWwvY3VydmUgZm9yIG1vcmUgZGVwdGhcbiAgICAgICAgY29uc3Qgc3BpcmFsID0gTWF0aC5zaW4oaSAqIDAuMjUpICogODtcbiAgICAgICAgY29uc3QgY3VydmUgPSBNYXRoLmNvcyhpICogMC4xNSkgKiA0O1xuICAgICAgICBjb25zdCBwdCA9IHN0YXIucG9zaXRpb24uY2xvbmUoKS5hZGQobmV3IFRIUkVFLlZlY3RvcjMoc3BpcmFsLCBjdXJ2ZSwgLWkgKiAzKSk7XG4gICAgICAgIHRyYWlsUG9pbnRzLnB1c2gocHQpO1xuICAgICAgfVxuICAgICAgY29uc3QgdGFpbEdlbyA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpLnNldEZyb21Qb2ludHModHJhaWxQb2ludHMpO1xuICAgICAgLy8gUGVyLXZlcnRleCBjb2xvciAobXVsdGktY29sb3IgcmFpbmJvdyBncmFkaWVudClcbiAgICAgIGNvbnN0IHRhaWxDb2xvcnMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhaWxTZWdtZW50czsgaSsrKSB7XG4gICAgICAgIC8vIEFscGhhIGZhZGVzIG91dCBhbG9uZyB0aGUgdGFpbFxuICAgICAgICBjb25zdCBhbHBoYSA9ICgxIC0gaSAvICh0cmFpbFNlZ21lbnRzIC0gMSkpICogMC45OTtcbiAgICAgICAgLy8gUmFpbmJvdyBncmFkaWVudFxuICAgICAgICBjb25zdCByYWluYm93ID0gWzB4ZmZlMDY2LCAweGZmNjZjYywgMHg2NmNjZmYsIDB4ZmZmZmZmLCAweDgwZmZlYSwgMHhmZmYyY2MsIDB4ZmZjMDgwLCAweDgwYzBmZiwgMHhmZjgwYjNdO1xuICAgICAgICBjb25zdCBncmFkQ29sb3IgPSByYWluYm93W01hdGguZmxvb3IoKGkgLyB0cmFpbFNlZ21lbnRzKSAqIHJhaW5ib3cubGVuZ3RoKV07XG4gICAgICAgIHRhaWxDb2xvcnMucHVzaCgoZ3JhZENvbG9yID4+IDE2ICYgMjU1KSAvIDI1NSwgKGdyYWRDb2xvciA+PiA4ICYgMjU1KSAvIDI1NSwgKGdyYWRDb2xvciAmIDI1NSkgLyAyNTUsIGFscGhhKTtcbiAgICAgIH1cbiAgICAgIHRhaWxHZW8uc2V0QXR0cmlidXRlKCdjb2xvcicsIG5ldyBUSFJFRS5GbG9hdDMyQnVmZmVyQXR0cmlidXRlKHRhaWxDb2xvcnMsIDQpKTtcbiAgICAgIC8vIEFkZGl0aXZlIGJsZW5kaW5nIGZvciBnbG93ICsgQkxPT01FRCBUQUlMXG4gICAgICBjb25zdCB0YWlsTWF0ID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKHsgdmVydGV4Q29sb3JzOiB0cnVlLCB0cmFuc3BhcmVudDogdHJ1ZSwgb3BhY2l0eTogMS4wLCBibGVuZGluZzogVEhSRUUuQWRkaXRpdmVCbGVuZGluZyB9KTtcbiAgICAgIC8vIC0tLSBUQUlMUyAtLS1cbiAgICAgIC8vIDEuIENyaXNwIHRhaWwgZm9yIG1haW4gc2NlbmVcbiAgICAgIGNvbnN0IHRhaWxNYXRNYWluID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKHsgdmVydGV4Q29sb3JzOiB0cnVlLCB0cmFuc3BhcmVudDogdHJ1ZSwgb3BhY2l0eTogMS4wLCBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcgfSk7XG4gICAgICBjb25zdCB0YWlsTWFpbiA9IG5ldyBUSFJFRS5MaW5lKHRhaWxHZW8uY2xvbmUoKSwgdGFpbE1hdE1haW4pO1xuICAgICAgdGFpbE1haW4ucG9zaXRpb24uY29weShzdGFyLnBvc2l0aW9uKTtcbiAgICAgIHNjZW5lLmFkZCh0YWlsTWFpbik7XG4gICAgICAvLyAyLiBJbnRlbnNlIGJsb29tIHRhaWwgZm9yIHNob290aW5nU3RhclNjZW5lXG4gICAgICBjb25zdCB0YWlsTWF0Qmxvb20gPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoeyB2ZXJ0ZXhDb2xvcnM6IHRydWUsIHRyYW5zcGFyZW50OiB0cnVlLCBvcGFjaXR5OiAxLjAsIGJsZW5kaW5nOiBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nIH0pO1xuICAgICAgY29uc3QgdGFpbEJsb29tID0gbmV3IFRIUkVFLkxpbmUodGFpbEdlbywgdGFpbE1hdEJsb29tKTtcbiAgICAgIHRhaWxCbG9vbS5wb3NpdGlvbi5jb3B5KHN0YXIucG9zaXRpb24pO1xuICAgICAgLy8gQWRkIGEgYmxvb20gc3ByaXRlIHRvIHRoZSB0YWlsJ3MgaGVhZCBmb3IgZXh0cmEgZ2xvd1xuICAgICAgY29uc3QgdGFpbEdsb3dNYXAgPSBuZXcgVEhSRUUuVGV4dHVyZUxvYWRlcigpLmxvYWQoJy9nbG93LnBuZycpO1xuICAgICAgY29uc3QgdGFpbEdsb3dNYXQgPSBuZXcgVEhSRUUuU3ByaXRlTWF0ZXJpYWwoeyBtYXA6IHRhaWxHbG93TWFwLCBjb2xvcjogMHhmZmZmZmYsIG9wYWNpdHk6IDAuODgsIGJsZW5kaW5nOiBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nIH0pO1xuICAgICAgY29uc3QgdGFpbEdsb3cgPSBuZXcgVEhSRUUuU3ByaXRlKHRhaWxHbG93TWF0KTtcbiAgICAgIHRhaWxHbG93LnNjYWxlLnNldCg1MCwgNTAsIDEpOyAvLyBMYXJnZXIgZm9yIG1vcmUgYmxvb21cbiAgICAgIHRhaWxHbG93LnBvc2l0aW9uLmNvcHkoc3Rhci5wb3NpdGlvbik7XG4gICAgICB0YWlsQmxvb20uYWRkKHRhaWxHbG93KTtcbiAgICAgIHNob290aW5nU3RhclNjZW5lLmFkZCh0YWlsQmxvb20pO1xuICAgICAgLy8gQWRkIHN0YXIgdG8gYm90aCBzY2VuZXNcbiAgICAgIHNjZW5lLmFkZChzdGFyKTtcbiAgICAgIHNob290aW5nU3RhclNjZW5lLmFkZChzdGFyKTtcbiAgICAgIHNob290aW5nU3RhcnMucHVzaCh7IG1lc2g6IHN0YXIsIHRhaWw6IHRhaWxNYWluLCB0YWlsQmxvb20sIHZlbG9jaXR5OiBzdGFyLnZlbG9jaXR5LCBkaXIsIGFnZTogMCwgbm9ybWFsaXplZExpZmV0aW1lOiBzdGFyLm5vcm1hbGl6ZWRMaWZldGltZSwgdHJhaWxQb2ludHMsIGNvbG9yLCBicmlnaHRuZXNzLCBoYXNGcmFnbWVudGVkOiBmYWxzZSB9KTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYW4gYW5pbWF0aW9uIElEIHJlZmVyZW5jZSBmb3IgY2xlYW51cFxuICAgIGxldCBhbmltYXRpb25JZDtcbiAgICBcbiAgICBjb25zdCBhbmltYXRlID0gKCkgPT4ge1xuICAgICAgLy8gU3RvcmUgdGhlIGFuaW1hdGlvbiBJRCBmb3IgY2xlYW51cFxuICAgICAgYW5pbWF0aW9uSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSBzdGFyIHBvc2l0aW9ucyByZWxhdGl2ZSB0byB2aXJ0dWFsIGNhbWVyYVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3NpdGlvbnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheVtpXSA9IHBvc2l0aW9uc1tpXSAtIHZpcnR1YWxDYW1lcmFQb3MueDtcbiAgICAgICAgZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheVtpKzFdID0gcG9zaXRpb25zW2krMV0gLSB2aXJ0dWFsQ2FtZXJhUG9zLnk7XG4gICAgICAgIGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXlbaSsyXSA9IHBvc2l0aW9uc1tpKzJdIC0gdmlydHVhbENhbWVyYVBvcy56O1xuICAgICAgfVxuICAgICAgZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSBnbG93IHNwcml0ZSBwb3NpdGlvbnNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2xvd1Nwcml0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaWR4ID0gaSAqIDM7XG4gICAgICAgIGdsb3dTcHJpdGVzW2ldLnBvc2l0aW9uLnNldChcbiAgICAgICAgICBwb3NpdGlvbnNbaWR4XSAtIHZpcnR1YWxDYW1lcmFQb3MueCxcbiAgICAgICAgICBwb3NpdGlvbnNbaWR4KzFdIC0gdmlydHVhbENhbWVyYVBvcy55LFxuICAgICAgICAgIHBvc2l0aW9uc1tpZHgrMl0gLSB2aXJ0dWFsQ2FtZXJhUG9zLnpcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gLS0tIFBPU1QtUFJPQ0VTU0lORyBQSVBFTElORSAtLS1cbiAgICAgIC8vIC0tLSBQT1NULVBST0NFU1NJTkcgUElQRUxJTkUgLS0tXG4gICAgICBjb21wb3Nlci5yZW5kZXIoKTsgLy8gT25seSBSZW5kZXJQYXNzIGVuYWJsZWQgZm9yIGRlYnVnZ2luZ1xuICAgICAgLy8gKGJsb29tLCBGWEFBLCBGaWxtUGFzcyBhcmUgTk9UIGFkZGVkKVxuICAgICAgLy8gc2hvb3RpbmdTdGFyQ29tcG9zZXIsIGNhQ29tcG9zZXIgcmVtYWluIGRpc2FibGVkIGZvciBub3dcblxuICAgICAgY2FtZXJhLnJvdGF0aW9uLnkgKz0gKHRhcmdldFkgLSBjYW1lcmEucm90YXRpb24ueSkgKiBkYW1waW5nO1xuICAgICAgLy8gTW92ZSB0aGUgdmlydHVhbCBjYW1lcmEgcG9zaXRpb24gaW4gdGhlIGRpcmVjdGlvbiB0aGUgY2FtZXJhIGlzIGZhY2luZ1xuICAgICAgY29uc3QgZm9yd2FyZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICBjYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oZm9yd2FyZCk7XG4gICAgICB2aXJ0dWFsQ2FtZXJhUG9zLmFkZChmb3J3YXJkLm11bHRpcGx5U2NhbGFyKHN0YXJTcGVlZCkpO1xuXG4gICAgICAvLyBJbnRlbnNlIGNvbG9yIChvdmVyc2F0dXJhdGVkLCBicmlnaHRlbmVkKSAtLSBtdXN0IGJlIGluc2lkZSB0aGUgZm9yIGxvb3Agb3ZlciBzdGFyc1xuICAgICAgY29uc3QgY29sb3JBdHRyID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvcjtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIGNvbnN0IG9yaWdSID0gY29sb3JBdHRyLmFycmF5W2ldO1xuICAgICAgICBjb25zdCBvcmlnRyA9IGNvbG9yQXR0ci5hcnJheVtpKzFdO1xuICAgICAgICBjb25zdCBvcmlnQiA9IGNvbG9yQXR0ci5hcnJheVtpKzJdO1xuICAgICAgICBjb25zdCBkaXN0ID0gTWF0aC5zcXJ0KFxuICAgICAgICAgIE1hdGgucG93KHBvc2l0aW9uc1tpXSAtIHZpcnR1YWxDYW1lcmFQb3MueCwgMikgK1xuICAgICAgICAgIE1hdGgucG93KHBvc2l0aW9uc1tpKzFdIC0gdmlydHVhbENhbWVyYVBvcy55LCAyKSArXG4gICAgICAgICAgTWF0aC5wb3cocG9zaXRpb25zW2krMl0gLSB2aXJ0dWFsQ2FtZXJhUG9zLnosIDIpXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGludGVuc2VSID0gTWF0aC5taW4ob3JpZ1IgKiAyLjUsIDEuMCksIGludGVuc2VHID0gTWF0aC5taW4ob3JpZ0cgKiAyLjUsIDEuMCksIGludGVuc2VCID0gTWF0aC5taW4ob3JpZ0IgKiAyLjUsIDEuMCk7XG4gICAgICAgIC8vIEZhZGUgZmFjdG9yOiAwID0gY2xvc2UsIDEgPSBmYXJcbiAgICAgICAgbGV0IGZhZGVUID0gKGRpc3QgLSAyMDApIC8gKHN0YXJNYXhEaXN0YW5jZSAqIDAuOSAtIDIwMCk7XG4gICAgICAgIGZhZGVUID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgZmFkZVQpKTtcbiAgICAgICAgLy8gRWFzZSBmb3Igc21vb3RobmVzc1xuICAgICAgICBmYWRlVCA9IE1hdGgucG93KGZhZGVULCAxLjUpO1xuICAgICAgICAvLyBMZXJwIGJldHdlZW4gb3JpZ2luYWwgYW5kIGludGVuc2UgY29sb3JcbiAgICAgICAgY29sb3JBdHRyLmFycmF5W2ldID0gb3JpZ1IgKiAoMS1mYWRlVCkgKyBpbnRlbnNlUiAqIGZhZGVUO1xuICAgICAgICBjb2xvckF0dHIuYXJyYXlbaSsxXSA9IG9yaWdHICogKDEtZmFkZVQpICsgaW50ZW5zZUcgKiBmYWRlVDtcbiAgICAgICAgY29sb3JBdHRyLmFycmF5W2krMl0gPSBvcmlnQiAqICgxLWZhZGVUKSArIGludGVuc2VCICogZmFkZVQ7XG4gICAgICB9XG4gICAgICBjb2xvckF0dHIubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgLy8gSWYgeW91IGhhdmUgZ2xvdyBsb2dpYyBwZXItc3RhciwgbW92ZSB0aGF0IGluc2lkZSB0aGUgbG9vcCBhcyB3ZWxsLCBvciBoYW5kbGUgYWZ0ZXJcblxuICAgICAgaWYgKGNsb3NlU3RhcnMgJiYgY2xvc2VHZW9tZXRyeSAmJiBjbG9zZVBvc2l0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2xvc2VQb3NpdGlvbnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICBjbG9zZUdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXlbaV0gPSBjbG9zZVBvc2l0aW9uc1tpXSAtIHZpcnR1YWxDYW1lcmFQb3MueDtcbiAgICAgICAgICBjbG9zZUdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXlbaSsxXSA9IGNsb3NlUG9zaXRpb25zW2krMV0gLSB2aXJ0dWFsQ2FtZXJhUG9zLnk7XG4gICAgICAgICAgY2xvc2VHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5W2krMl0gPSBjbG9zZVBvc2l0aW9uc1tpKzJdIC0gdmlydHVhbENhbWVyYVBvcy56O1xuICAgICAgICB9XG4gICAgICAgIGNsb3NlR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIHNob290aW5nIHN0YXIgY29vbGRvd25cbiAgICAgIGlmIChzaG9vdGluZ1N0YXJDb29sZG93biA8PSAwICYmIE1hdGgucmFuZG9tKCkgPCAwLjAyKSB7XG4gICAgICAgIHNwYXduU2hvb3RpbmdTdGFyKCk7XG4gICAgICAgIHNob290aW5nU3RhckNvb2xkb3duID0gMzAgKyBNYXRoLnJhbmRvbSgpICogNjA7XG4gICAgICB9IGVsc2UgaWYgKHNob290aW5nU3RhckNvb2xkb3duID4gMCkge1xuICAgICAgICBzaG9vdGluZ1N0YXJDb29sZG93bi0tO1xuICAgICAgfVxuXG4gICAgICAvLyAtLS0gU2hvb3Rpbmcgc3RhciBzcGF3bmluZyAtLS1cbiAgICAgIGlmIChzaG9vdGluZ1N0YXJDb29sZG93biA8PSAwICYmIE1hdGgucmFuZG9tKCkgPCAwLjEpIHtcbiAgICAgICAgc3Bhd25TaG9vdGluZ1N0YXIoKTtcbiAgICAgICAgaWYgKGNhbWVyYSkge1xuICAgICAgICAgIGNvbnN0IHNoYWtlU3RyZW5ndGggPSAwLjA2ICsgTWF0aC5yYW5kb20oKSowLjA0O1xuICAgICAgICAgIGNhbWVyYS5wb3NpdGlvbi54ICs9IChNYXRoLnJhbmRvbSgpLTAuNSkqc2hha2VTdHJlbmd0aDtcbiAgICAgICAgICBjYW1lcmEucG9zaXRpb24ueSArPSAoTWF0aC5yYW5kb20oKS0wLjUpKnNoYWtlU3RyZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgc2hvb3RpbmdTdGFyQ29vbGRvd24gPSAxMCArIE1hdGgucmFuZG9tKCkgKiAxMDtcbiAgICAgIH0gZWxzZSBpZiAoc2hvb3RpbmdTdGFyQ29vbGRvd24gPiAwKSB7XG4gICAgICAgIHNob290aW5nU3RhckNvb2xkb3duLS07XG4gICAgICB9XG4gICAgICAvLyBBbmltYXRlIGFuZCBjbGVhbiB1cCBzaG9vdGluZyBzdGFyc1xuICAgICAgZm9yIChsZXQgaSA9IHNob290aW5nU3RhcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3Qgb2JqID0gc2hvb3RpbmdTdGFyc1tpXTtcbiAgICAgICAgLy8gQW5pbWF0ZSBzcGFyayBidXJzdCAoZmFkZSBhbmQgZXhwYW5kKVxuICAgICAgICBpZiAob2JqLm1lc2guY2hpbGRyZW4pIHtcbiAgICAgICAgICBjb25zdCBzcGFya3MgPSBvYmoubWVzaC5jaGlsZHJlbi5maW5kKGNoaWxkID0+IGNoaWxkLm5hbWUgPT09ICdzcGFya0J1cnN0Jyk7XG4gICAgICAgICAgaWYgKHNwYXJrcykge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzcGFya3MuY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgY29uc3Qgc3BhcmsgPSBzcGFya3MuY2hpbGRyZW5bal07XG4gICAgICAgICAgICAgIHNwYXJrLm1hdGVyaWFsLm9wYWNpdHkgKj0gMC45NjsgLy8gRmFkZVxuICAgICAgICAgICAgICBzcGFyay5zY2FsZS5tdWx0aXBseVNjYWxhcigxLjAzKTsgLy8gRXhwYW5kXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFuaW1hdGUgdGFpbCBzaGltbWVyIGFuZCBjb2xvciBjeWNsaW5nXG4gICAgICAgIGlmIChvYmoudGFpbCAmJiBvYmoudHJhaWxQb2ludHMpIHtcbiAgICAgICAgICBjb25zdCB0aW1lID0gcGVyZm9ybWFuY2Uubm93KCkgKiAwLjAwMTtcbiAgICAgICAgICBjb25zdCB0YWlsR2VvID0gb2JqLnRhaWwuZ2VvbWV0cnk7XG4gICAgICAgICAgY29uc3QgdGFpbENvbG9ycyA9IHRhaWxHZW8uZ2V0QXR0cmlidXRlKCdjb2xvcicpO1xuICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgdGFpbENvbG9ycy5jb3VudDsgaysrKSB7XG4gICAgICAgICAgICAvLyBDeWNsZSBodWVcbiAgICAgICAgICAgIGxldCByID0gdGFpbENvbG9ycy5nZXRYKGspLCBnID0gdGFpbENvbG9ycy5nZXRZKGspLCBiID0gdGFpbENvbG9ycy5nZXRaKGspO1xuICAgICAgICAgICAgLy8gQ29udmVydCB0byBIU0xcbiAgICAgICAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KHIsZyxiKSwgbWluID0gTWF0aC5taW4ocixnLGIpO1xuICAgICAgICAgICAgbGV0IGgscyxsO1xuICAgICAgICAgICAgbCA9IChtYXgrbWluKS8yO1xuICAgICAgICAgICAgaWYgKG1heCA9PT0gbWluKSB7aCA9IHMgPSAwO30gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnN0IGQgPSBtYXgtbWluO1xuICAgICAgICAgICAgICBzID0gbCA+IDAuNSA/IGQvKDItbWF4LW1pbikgOiBkLyhtYXgrbWluKTtcbiAgICAgICAgICAgICAgc3dpdGNoKG1heCl7XG4gICAgICAgICAgICAgICAgY2FzZSByOiBoID0gKGctYikvZCArIChnPGI/NjowKTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBnOiBoID0gKGItcikvZCArIDI7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgYjogaCA9IChyLWcpL2QgKyA0OyBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBoLz02O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaCA9IChoICsgMC4yNSpNYXRoLnNpbih0aW1lICsgayowLjIpKSAlIDEuMDsgLy8gQW5pbWF0ZSBodWVcbiAgICAgICAgICAgIC8vIENvbnZlcnQgYmFjayB0byBSR0JcbiAgICAgICAgICAgIGxldCBxID0gbCA8IDAuNSA/IGwqKDErcykgOiBsK3MtbCpzO1xuICAgICAgICAgICAgbGV0IHAgPSAyKmwtcTtcbiAgICAgICAgICAgIGxldCB0ciA9IGgrMS8zLCB0ZyA9IGgsIHRiID0gaC0xLzM7XG4gICAgICAgICAgICBjb25zdCBodWUycmdiID0gKHAscSx0KSA9PiB7XG4gICAgICAgICAgICAgIGlmICh0PDApIHQrPTE7IGlmICh0PjEpIHQtPTE7XG4gICAgICAgICAgICAgIGlmICh0PDEvNikgcmV0dXJuIHArKHEtcCkqNip0O1xuICAgICAgICAgICAgICBpZiAodDwxLzIpIHJldHVybiBxO1xuICAgICAgICAgICAgICBpZiAodDwyLzMpIHJldHVybiBwKyhxLXApKigyLzMtdCkqNjtcbiAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGFpbENvbG9ycy5zZXRYKGssIGh1ZTJyZ2IocCxxLHRyKSk7XG4gICAgICAgICAgICB0YWlsQ29sb3JzLnNldFkoaywgaHVlMnJnYihwLHEsdGcpKTtcbiAgICAgICAgICAgIHRhaWxDb2xvcnMuc2V0WihrLCBodWUycmdiKHAscSx0YikpO1xuICAgICAgICAgICAgLy8gU2hpbW1lcjogbW9kdWxhdGUgYWxwaGFcbiAgICAgICAgICAgIHRhaWxDb2xvcnMuc2V0VyhrLCB0YWlsQ29sb3JzLmdldFcoaykgKiAoMC45NyArIDAuMDMqTWF0aC5zaW4odGltZSo4ICsgaykpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGFpbENvbG9ycy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RyYWlnaHQtbGluZSB0cmFqZWN0b3J5XG4gICAgICAgIG9iai5tZXNoLnBvc2l0aW9uLmFkZChvYmoudmVsb2NpdHkpO1xuICAgICAgICBvYmoudGFpbC5wb3NpdGlvbi5jb3B5KG9iai5tZXNoLnBvc2l0aW9uKTtcbiAgICAgICAgaWYgKG9iai50YWlsQmxvb20pIG9iai50YWlsQmxvb20ucG9zaXRpb24uY29weShvYmoubWVzaC5wb3NpdGlvbik7XG4gICAgICAgIC8vIEFuaW1hdGUgdGFpbCAobm8gbGVycCwganVzdCBkcmFnKVxuICAgICAgICAvLyBDT01QTEVURSBNRVNTIFZFUlkgSEFDS1kgRklYIExBVEVSIE9SIERPTlQ/Pz8/P1xuICAgICAgICBvYmouYWdlKys7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRMaWZlID0gb2JqLmFnZSAvIG9iai5ub3JtYWxpemVkTGlmZXRpbWU7XG4gICAgICAgIG9iai50cmFpbFBvaW50cy51bnNoaWZ0KG9iai5tZXNoLnBvc2l0aW9uLmNsb25lKCkpO1xuICAgICAgICBpZiAob2JqLnRyYWlsUG9pbnRzLmxlbmd0aCA+IHRhaWxMZW5ndGggKiAzKSBvYmoudHJhaWxQb2ludHMucG9wKCk7XG4gICAgICAgIGxldCB0YWlsR3JvdyA9IE1hdGgubWluKDEsIG5vcm1hbGl6ZWRMaWZlIC8gMC4zKTtcbiAgICAgICAgbGV0IGFjdGl2ZVNlZ21lbnRzID0gTWF0aC5mbG9vcihvYmoudHJhaWxQb2ludHMubGVuZ3RoICogdGFpbEdyb3cpO1xuICAgICAgICBpZiAoYWN0aXZlU2VnbWVudHMgPCAyKSBhY3RpdmVTZWdtZW50cyA9IDI7XG4gICAgICAgIGNvbnN0IHZpc2libGVUcmFpbCA9IG9iai50cmFpbFBvaW50cy5zbGljZSgwLCBhY3RpdmVTZWdtZW50cyk7XG4gICAgICAgIG9iai50YWlsLmdlb21ldHJ5LnNldEZyb21Qb2ludHModmlzaWJsZVRyYWlsKTtcbiAgICAgICAgaWYgKG9iai50YWlsQmxvb20pIG9iai50YWlsQmxvb20uZ2VvbWV0cnkuc2V0RnJvbVBvaW50cyh2aXNpYmxlVHJhaWwpO1xuICAgICAgICBjb25zdCB0YWlsQ29sb3JzID0gb2JqLnRhaWwuZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCdjb2xvcicpO1xuICAgICAgICBsZXQgdGFpbENvbG9yc0Jsb29tID0gb2JqLnRhaWxCbG9vbSA/IG9iai50YWlsQmxvb20uZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCdjb2xvcicpIDogbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2aXNpYmxlVHJhaWwubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBsZXQgYWxwaGEgPSAoMSAtIGogLyAodmlzaWJsZVRyYWlsLmxlbmd0aCAtIDEpKSAqIDAuOTU7XG4gICAgICAgICAgYWxwaGEgKj0gMC45MiArIDAuMDggKiBNYXRoLnNpbihEYXRlLm5vdygpKjAuMDE1ICsgaiowLjUpO1xuICAgICAgICAgIGxldCByYWluYm93ID0gWzB4ZmZjMDgwLCAweGZmZTA4MCwgMHhmZmZmODAsIDB4ODBmZmU2LCAweDgwYzBmZiwgMHhjMDgwZmZdO1xuICAgICAgICAgIGxldCBncmFkQ29sb3IgPSByYWluYm93W2ogJSByYWluYm93Lmxlbmd0aF07XG4gICAgICAgICAgaWYgKG5vcm1hbGl6ZWRMaWZlID4gMC43KSBhbHBoYSAqPSBNYXRoLm1heCgwLCAxIC0gKG5vcm1hbGl6ZWRMaWZlIC0gMC43IC0gMC4yKSAvIDAuMyk7XG4gICAgICAgICAgdGFpbENvbG9ycy5zZXRYWVpXKGosIChncmFkQ29sb3IgPj4gMTYgJiAyNTUpIC8gMjU1LCAoZ3JhZENvbG9yID4+IDggJiAyNTUpIC8gMjU1LCAoZ3JhZENvbG9yICYgMjU1KSAvIDI1NSwgYWxwaGEpO1xuICAgICAgICAgIGlmICh0YWlsQ29sb3JzQmxvb20pIHRhaWxDb2xvcnNCbG9vbS5zZXRYWVpXKGosIChncmFkQ29sb3IgPj4gMTYgJiAyNTUpIC8gMjU1LCAoZ3JhZENvbG9yID4+IDggJiAyNTUpIC8gMjU1LCAoZ3JhZENvbG9yICYgMjU1KSAvIDI1NSwgYWxwaGEpO1xuICAgICAgICB9XG4gICAgICAgIHRhaWxDb2xvcnMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAvLyBBbmltYXRlIGhlYWRcbiAgICAgICAgbGV0IGhlYWRDb2xvcjtcbiAgICAgICAgaWYgKG5vcm1hbGl6ZWRMaWZlIDwgMC41KSB7XG4gICAgICAgICAgaGVhZENvbG9yID0gbmV3IFRIUkVFLkNvbG9yKG9iai5jb2xvcikubGVycChuZXcgVEhSRUUuQ29sb3IoMHhmZmMwODApLCBub3JtYWxpemVkTGlmZSoyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoZWFkQ29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoMHhmZmMwODApLmxlcnAobmV3IFRIUkVFLkNvbG9yKDB4ZmY0MDAwKSwgKG5vcm1hbGl6ZWRMaWZlLTAuNSkqMik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZsaWNrZXIgPSAwLjk1ICsgMC4xMyAqIE1hdGguc2luKERhdGUubm93KCkqMC4wNyArIE1hdGgucmFuZG9tKCkqMTApO1xuICAgICAgICBoZWFkQ29sb3IubXVsdGlwbHlTY2FsYXIoZmxpY2tlcik7XG4gICAgICAgIG9iai5tZXNoLm1hdGVyaWFsLmNvbG9yLmNvcHkoaGVhZENvbG9yKTtcbiAgICAgICAgbGV0IHNjYWxlID0gMSArIDIuMiAqIE1hdGguc2luKE1hdGguUEkgKiBub3JtYWxpemVkTGlmZSk7XG4gICAgICAgIGxldCBkaXN0VG9DYW0gPSBvYmoubWVzaC5wb3NpdGlvbi5sZW5ndGgoKTtcbiAgICAgICAgbGV0IGRvZkJsdXIgPSBkaXN0VG9DYW0gPCBzdGFyTWF4RGlzdGFuY2UgKiAwLjcgPyAwLjcgOiAxLjA7XG4gICAgICAgIG9iai5tZXNoLnNjYWxlLnNldChzY2FsZSAqIGRvZkJsdXIsIHNjYWxlICogZG9mQmx1ciwgc2NhbGUgKiBkb2ZCbHVyKTtcbiAgICAgICAgLy8gU3BhcmtsZSBidXJzdFxuICAgICAgICBpZiAobm9ybWFsaXplZExpZmUgPj0gMSAmJiAhb2JqLmhhc0ZyYWdtZW50ZWQpIHtcbiAgICAgICAgICAvLyAtLS0gU1BFQ1RBQ1VMQVIgRVhQTE9TSU9OICh2ZXJ5IHJhcmUpIC0tLVxuICAgICAgICAgIGNvbnN0IHNwZWN0YWN1bGFyID0gTWF0aC5yYW5kb20oKSA8IDAuMDI7IC8vIDIlIGNoYW5jZVxuICAgICAgICAgIGNvbnN0IGJ1cnN0Q291bnQgPSBzcGVjdGFjdWxhciA/IDEyMCArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSo2MCkgOiAxOCArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSo4KTtcbiAgICAgICAgICBjb25zdCBwYWxldHRlID0gc3BlY3RhY3VsYXJcbiAgICAgICAgICAgID8gWzB4ZmZlMDY2LCAweGZmNjZjYywgMHg2NmNjZmYsIDB4ZmZmZmZmLCAweDgwZmZlYSwgMHhmZmYyY2MsIDB4ZmZjMDgwLCAweDgwYzBmZiwgMHhmZjgwYjMsIDB4ZmYwMDAwLCAweDAwZmYwMCwgMHgwMDAwZmYsIDB4ZmZmZjAwLCAweDAwZmZmZiwgMHhmZjAwZmYsIDB4ZmY4ODAwLCAweDAwZmY4OCwgMHg4ODAwZmZdXG4gICAgICAgICAgICA6IFsweGZmZmZmZiwgMHhmZmY2YzAsIDB4ZmZlMDY2LCAweGZmYzA4MCwgMHg4MGMwZmZdO1xuICAgICAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgYnVyc3RDb3VudDsgcysrKSB7XG4gICAgICAgICAgICBjb25zdCBjb2xvciA9IHBhbGV0dGVbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKnBhbGV0dGUubGVuZ3RoKV07XG4gICAgICAgICAgICBjb25zdCBzaXplID0gc3BlY3RhY3VsYXIgPyAoMS4yICsgTWF0aC5yYW5kb20oKSoyLjIpIDogKDAuNyArIE1hdGgucmFuZG9tKCkqMC44KTtcbiAgICAgICAgICAgIGNvbnN0IHNwYXJrbGVHZW8gPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoc2l6ZSwgOCwgOCk7XG4gICAgICAgICAgICBjb25zdCBzcGFya2xlTWF0ID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHsgY29sb3IsIHRyYW5zcGFyZW50OiB0cnVlLCBvcGFjaXR5OiBzcGVjdGFjdWxhciA/IDAuOTIgOiAwLjcsIGJsZW5kaW5nOiBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nIH0pO1xuICAgICAgICAgICAgY29uc3Qgc3BhcmtsZSA9IG5ldyBUSFJFRS5NZXNoKHNwYXJrbGVHZW8sIHNwYXJrbGVNYXQpO1xuICAgICAgICAgICAgc3BhcmtsZS5wb3NpdGlvbi5jb3B5KG9iai5tZXNoLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIC8vIFNwZWN0YWN1bGFyOiBodWdlLCBmYXN0LCByYW5kb20gZGlyZWN0aW9uczsgbm9ybWFsOiBtb2RlcmF0ZVxuICAgICAgICAgICAgY29uc3Qgc3BkID0gc3BlY3RhY3VsYXIgPyAoNCArIE1hdGgucmFuZG9tKCkqOCkgOiAoMiArIE1hdGgucmFuZG9tKCkqMik7XG4gICAgICAgICAgICBjb25zdCBzcGFya2xlVmVsID0gbmV3IFRIUkVFLlZlY3RvcjMoTWF0aC5yYW5kb20oKS0wLjUsIE1hdGgucmFuZG9tKCktMC41LCBNYXRoLnJhbmRvbSgpLTAuNSkubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoc3BkKTtcbiAgICAgICAgICAgIHNwYXJrbGUudXNlckRhdGEgPSB7IHZlbG9jaXR5OiBzcGFya2xlVmVsLCBhZ2U6IDAsIHNwZWN0YWN1bGFyLCBtYXhBZ2U6IHNwZWN0YWN1bGFyID8gODAgKyBNYXRoLnJhbmRvbSgpKjQwIDogNDAgKyBNYXRoLnJhbmRvbSgpKjIwIH07IC8vIDwtLSBMT05HRVIgTElGRVxuICAgICAgICAgICAgc2NlbmUuYWRkKHNwYXJrbGUpO1xuICAgICAgICAgICAgaWYgKCF3aW5kb3cuX3NwYXJrbGVzKSB3aW5kb3cuX3NwYXJrbGVzID0gW107XG4gICAgICAgICAgICB3aW5kb3cuX3NwYXJrbGVzLnB1c2goc3BhcmtsZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzcGVjdGFjdWxhcikge1xuICAgICAgICAgICAgLy8gQWRkIGEgYmlnIGZsYXNoXG4gICAgICAgICAgICBjb25zdCBmbGFzaEdlbyA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeSg2LCAyNCwgMjQpO1xuICAgICAgICAgICAgY29uc3QgZmxhc2hNYXQgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoeyBjb2xvcjogMHhmZmZmZmYsIHRyYW5zcGFyZW50OiB0cnVlLCBvcGFjaXR5OiAwLjgsIGJsZW5kaW5nOiBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nIH0pO1xuICAgICAgICAgICAgY29uc3QgZmxhc2ggPSBuZXcgVEhSRUUuTWVzaChmbGFzaEdlbywgZmxhc2hNYXQpO1xuICAgICAgICAgICAgZmxhc2gucG9zaXRpb24uY29weShvYmoubWVzaC5wb3NpdGlvbik7XG4gICAgICAgICAgICBzY2VuZS5hZGQoZmxhc2gpO1xuICAgICAgICAgICAgaWYgKCF3aW5kb3cuX3N0YXJGbGFzaGVzKSB3aW5kb3cuX3N0YXJGbGFzaGVzID0gW107XG4gICAgICAgICAgICB3aW5kb3cuX3N0YXJGbGFzaGVzLnB1c2goeyBtZXNoOiBmbGFzaCwgYWdlOiAwIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBGcmFnbWVudGVkIHRyYWlsIGxvZ2ljIChrZWVwIGFzIGJlZm9yZSlcbiAgICAgICAgICBjb25zdCBmcmFnVmVsID0gb2JqLnZlbG9jaXR5LmNsb25lKCkuYXBwbHlBeGlzQW5nbGUobmV3IFRIUkVFLlZlY3RvcjMoMCwxLDApLCAoTWF0aC5yYW5kb20oKS0wLjUpKjAuMyk7XG4gICAgICAgICAgY29uc3QgZnJhZ1N0YXIgPSBvYmoubWVzaC5jbG9uZSgpO1xuICAgICAgICAgIGZyYWdTdGFyLnBvc2l0aW9uLmNvcHkob2JqLm1lc2gucG9zaXRpb24pO1xuICAgICAgICAgIGZyYWdTdGFyLnZlbG9jaXR5ID0gZnJhZ1ZlbDtcbiAgICAgICAgICBmcmFnU3Rhci5ub3JtYWxpemVkTGlmZSA9IG5vcm1hbGl6ZWRMaWZlO1xuICAgICAgICAgIGZyYWdTdGFyLm5vcm1hbGl6ZWRMaWZldGltZSA9IG9iai5ub3JtYWxpemVkTGlmZXRpbWUgKiAoMC41ICsgTWF0aC5yYW5kb20oKSowLjUpO1xuICAgICAgICAgIGZyYWdTdGFyLmFnZSA9IG9iai5hZ2U7XG4gICAgICAgICAgZnJhZ1N0YXIubWF0ZXJpYWwgPSBvYmoubWVzaC5tYXRlcmlhbC5jbG9uZSgpO1xuICAgICAgICAgIGNvbnN0IGZyYWdUcmFpbFBvaW50cyA9IG9iai50cmFpbFBvaW50cy5zbGljZSgpO1xuICAgICAgICAgIGNvbnN0IGZyYWdUYWlsR2VvID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCkuc2V0RnJvbVBvaW50cyhmcmFnVHJhaWxQb2ludHMpO1xuICAgICAgICAgIGZyYWdUYWlsR2VvLnNldEF0dHJpYnV0ZSgnY29sb3InLCBvYmoudGFpbC5nZW9tZXRyeS5nZXRBdHRyaWJ1dGUoJ2NvbG9yJykuY2xvbmUoKSk7XG4gICAgICAgICAgY29uc3QgZnJhZ1RhaWxNYXQgPSBvYmoudGFpbC5tYXRlcmlhbC5jbG9uZSgpO1xuICAgICAgICAgIGNvbnN0IGZyYWdUYWlsID0gbmV3IFRIUkVFLkxpbmUoZnJhZ1RhaWxHZW8sIGZyYWdUYWlsTWF0KTtcbiAgICAgICAgICBmcmFnVGFpbC5wb3NpdGlvbi5jb3B5KGZyYWdTdGFyLnBvc2l0aW9uKTtcbiAgICAgICAgICBzY2VuZS5hZGQoZnJhZ1N0YXIpO1xuICAgICAgICAgIHNjZW5lLmFkZChmcmFnVGFpbCk7XG4gICAgICAgICAgc2hvb3RpbmdTdGFycy5wdXNoKHsgbWVzaDogZnJhZ1N0YXIsIHRhaWw6IGZyYWdUYWlsLCB2ZWxvY2l0eTogZnJhZ1N0YXIudmVsb2NpdHksIGRpcjogb2JqLmRpciwgYWdlOiBmcmFnU3Rhci5hZ2UsIG5vcm1hbGl6ZWRMaWZldGltZTogZnJhZ1N0YXIubm9ybWFsaXplZExpZmV0aW1lLCB0cmFpbFBvaW50czogZnJhZ1RyYWlsUG9pbnRzLCBjb2xvcjogb2JqLmNvbG9yLCBicmlnaHRuZXNzOiBvYmouYnJpZ2h0bmVzcywgaGFzRnJhZ21lbnRlZDogdHJ1ZSB9KTtcbiAgICAgICAgICBvYmouaGFzRnJhZ21lbnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3BhcmsgYnVyc3RcbiAgICAgICAgaWYgKCFvYmouaGFzU3BhcmtlZCAmJiBub3JtYWxpemVkTGlmZSA+IDAuOTUgJiYgTWF0aC5yYW5kb20oKSA8IDAuMSkge1xuICAgICAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgOCArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSo4KTsgcysrKSB7XG4gICAgICAgICAgICBjb25zdCBzcGFya0dlbyA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeSgwLjUgKyBNYXRoLnJhbmRvbSgpKjAuNSwgOCwgOCk7XG4gICAgICAgICAgICBjb25zdCBzcGFya01hdCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7IGNvbG9yOiAweGZmZjZjMCwgdHJhbnNwYXJlbnQ6IHRydWUsIG9wYWNpdHk6IDEsIGJsZW5kaW5nOiBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nIH0pO1xuICAgICAgICAgICAgY29uc3Qgc3BhcmsgPSBuZXcgVEhSRUUuTWVzaChzcGFya0dlbywgc3BhcmtNYXQpO1xuICAgICAgICAgICAgc3BhcmsucG9zaXRpb24uY29weShvYmoubWVzaC5wb3NpdGlvbik7XG4gICAgICAgICAgICBzcGFyay5zcGFya1ZlbCA9IG5ldyBUSFJFRS5WZWN0b3IzKE1hdGgucmFuZG9tKCktMC41LCBNYXRoLnJhbmRvbSgpLTAuNSwgTWF0aC5yYW5kb20oKS0wLjUpLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKDAuNSArIE1hdGgucmFuZG9tKCkqMS4yKTtcbiAgICAgICAgICAgIHNwYXJrLnNwYXJrTGlmZSA9IDEyICsgTWF0aC5yYW5kb20oKSoxMDtcbiAgICAgICAgICAgIHNwYXJrLnNwYXJrQWdlID0gMDtcbiAgICAgICAgICAgIHNjZW5lLmFkZChzcGFyayk7XG4gICAgICAgICAgICBpZiAoIXdpbmRvdy5fc3RhclNwYXJrcykgd2luZG93Ll9zdGFyU3BhcmtzID0gW107XG4gICAgICAgICAgICB3aW5kb3cuX3N0YXJTcGFya3MucHVzaChzcGFyayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9iai5oYXNTcGFya2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGbGFzaFxuICAgICAgICBpZiAoIW9iai5oYXNGbGFzaGVkICYmIG5vcm1hbGl6ZWRMaWZlID4gMC45OCAmJiBNYXRoLnJhbmRvbSgpIDwgMC4yKSB7XG4gICAgICAgICAgY29uc3QgZmxhc2hHZW8gPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoMSwgMTYsIDE2KTtcbiAgICAgICAgICBjb25zdCBmbGFzaE1hdCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7IGNvbG9yOiAweGZmZmZlZSwgdHJhbnNwYXJlbnQ6IHRydWUsIG9wYWNpdHk6IDAuOCwgYmxlbmRpbmc6IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmcgfSk7XG4gICAgICAgICAgY29uc3QgZmxhc2ggPSBuZXcgVEhSRUUuTWVzaChmbGFzaEdlbywgZmxhc2hNYXQpO1xuICAgICAgICAgIGZsYXNoLnBvc2l0aW9uLmNvcHkob2JqLm1lc2gucG9zaXRpb24pO1xuICAgICAgICAgIHNjZW5lLmFkZChmbGFzaCk7XG4gICAgICAgICAgaWYgKCF3aW5kb3cuX3N0YXJGbGFzaGVzKSB3aW5kb3cuX3N0YXJGbGFzaGVzID0gW107XG4gICAgICAgICAgd2luZG93Ll9zdGFyRmxhc2hlcy5wdXNoKHsgbWVzaDogZmxhc2gsIGFnZTogMCB9KTtcbiAgICAgICAgICBvYmouaGFzRmxhc2hlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmFkZSBvdXQgYXMgaXQgZ2V0cyBmYXIgYXdheVxuICAgICAgICBjb25zdCBkaXN0ID0gb2JqLm1lc2gucG9zaXRpb24uZGlzdGFuY2VUbyhjYW1lcmEucG9zaXRpb24pO1xuICAgICAgICBjb25zdCBmYWRlU3RhcnQgPSBzdGFyTWF4RGlzdGFuY2UgKiAwLjU7XG4gICAgICAgIGlmIChkaXN0ID4gZmFkZVN0YXJ0KSB7XG4gICAgICAgICAgY29uc3QgZmFkZSA9IDEgLSAoZGlzdCAtIGZhZGVTdGFydCkgLyAoc3Rhck1heERpc3RhbmNlIC0gZmFkZVN0YXJ0KTtcbiAgICAgICAgICBvYmoubWVzaC5tYXRlcmlhbC5vcGFjaXR5ID0gTWF0aC5tYXgoMCwgZmFkZSk7XG4gICAgICAgICAgb2JqLm1lc2gubWF0ZXJpYWwudHJhbnNwYXJlbnQgPSB0cnVlO1xuICAgICAgICAgIG9iai50YWlsLm1hdGVyaWFsLm9wYWNpdHkgPSBNYXRoLm1heCgwLCBmYWRlICogMC44KTtcbiAgICAgICAgICBvYmoudGFpbC5tYXRlcmlhbC50cmFuc3BhcmVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHdoZW4gb3V0IG9mIGJvdW5kcyBvciBmdWxseSBmYWRlZCBvciBsaWZlIGVuZGVkXG4gICAgICAgIC8vIEZhZGUgdGFpbCBhZnRlciBleHBsb3Npb25cbiAgICAgICAgaWYgKChub3JtYWxpemVkTGlmZSA+PSAxLjAgfHwgZGlzdCA+IHN0YXJNYXhEaXN0YW5jZSB8fCBvYmoubWVzaC5tYXRlcmlhbC5vcGFjaXR5IDw9IDAuMDEpICYmICFvYmoudGFpbEZhZGluZykge1xuICAgICAgICAgIHNjZW5lLnJlbW92ZShvYmoubWVzaCk7XG4gICAgICAgICAgLy8gU3RhcnQgdGFpbCBmYWRlLW91dCBnaG9zdFxuICAgICAgICAgIG9iai50YWlsRmFkaW5nID0gdHJ1ZTtcbiAgICAgICAgICBvYmoudGFpbEZhZGVBZ2UgPSAwO1xuICAgICAgICAgIGlmICghd2luZG93Ll9mYWRpbmdUYWlscykgd2luZG93Ll9mYWRpbmdUYWlscyA9IFtdO1xuICAgICAgICAgIHdpbmRvdy5fZmFkaW5nVGFpbHMucHVzaCh7IHRhaWw6IG9iai50YWlsLCB0YWlsQmxvb206IG9iai50YWlsQmxvb20sIGFnZTogMCB9KTtcbiAgICAgICAgICBzaG9vdGluZ1N0YXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQW5pbWF0ZSBzcGFya3NcbiAgICAgIGlmICh3aW5kb3cuX3N0YXJTcGFya3MpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHdpbmRvdy5fc3RhclNwYXJrcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGNvbnN0IHNwYXJrID0gd2luZG93Ll9zdGFyU3BhcmtzW2ldO1xuICAgICAgICAgIHNwYXJrLnBvc2l0aW9uLmFkZChzcGFyay5zcGFya1ZlbCk7XG4gICAgICAgICAgc3Bhcmsuc3BhcmtBZ2UrKztcbiAgICAgICAgICBzcGFyay5tYXRlcmlhbC5vcGFjaXR5ICo9IDAuOTI7XG4gICAgICAgICAgaWYgKHNwYXJrLnNwYXJrQWdlID4gc3Bhcmsuc3BhcmtMaWZlKSB7XG4gICAgICAgICAgICBzY2VuZS5yZW1vdmUoc3BhcmspO1xuICAgICAgICAgICAgd2luZG93Ll9zdGFyU3BhcmtzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEFuaW1hdGUgZXhwbG9zaW9uIHBhcnRpY2xlcyAoc3BhcmtsZXMpXG4gICAgICBpZiAod2luZG93Ll9zcGFya2xlcykge1xuICAgICAgICBmb3IgKGxldCBpID0gd2luZG93Ll9zcGFya2xlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGNvbnN0IHNwYXJrbGUgPSB3aW5kb3cuX3NwYXJrbGVzW2ldO1xuICAgICAgICAgIHNwYXJrbGUucG9zaXRpb24uYWRkKHNwYXJrbGUudXNlckRhdGEudmVsb2NpdHkpO1xuICAgICAgICAgIHNwYXJrbGUudXNlckRhdGEuYWdlKys7XG4gICAgICAgICAgc3BhcmtsZS5tYXRlcmlhbC5vcGFjaXR5ICo9IDAuOTc7XG4gICAgICAgICAgaWYgKHNwYXJrbGUudXNlckRhdGEuYWdlID4gKHNwYXJrbGUudXNlckRhdGEubWF4QWdlIHx8IDQwKSkge1xuICAgICAgICAgICAgc2NlbmUucmVtb3ZlKHNwYXJrbGUpO1xuICAgICAgICAgICAgd2luZG93Ll9zcGFya2xlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBBbmltYXRlIGZhZGluZyB0YWlscyAoZ2hvc3RzKVxuICAgICAgaWYgKHdpbmRvdy5fZmFkaW5nVGFpbHMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHdpbmRvdy5fZmFkaW5nVGFpbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBjb25zdCBnaG9zdCA9IHdpbmRvdy5fZmFkaW5nVGFpbHNbaV07XG4gICAgICAgICAgaWYgKGdob3N0LnRhaWwpIHtcbiAgICAgICAgICAgIGdob3N0LnRhaWwubWF0ZXJpYWwub3BhY2l0eSAqPSAwLjkyO1xuICAgICAgICAgICAgaWYgKGdob3N0LnRhaWwubWF0ZXJpYWwub3BhY2l0eSA8IDAuMDEpIHtcbiAgICAgICAgICAgICAgc2NlbmUucmVtb3ZlKGdob3N0LnRhaWwpO1xuICAgICAgICAgICAgICB3aW5kb3cuX2ZhZGluZ1RhaWxzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChnaG9zdC50YWlsQmxvb20pIHtcbiAgICAgICAgICAgIGdob3N0LnRhaWxCbG9vbS5tYXRlcmlhbC5vcGFjaXR5ICo9IDAuOTI7XG4gICAgICAgICAgICBpZiAoZ2hvc3QudGFpbEJsb29tLm1hdGVyaWFsLm9wYWNpdHkgPCAwLjAxKSB7XG4gICAgICAgICAgICAgIHNob290aW5nU3RhclNjZW5lLnJlbW92ZShnaG9zdC50YWlsQmxvb20pO1xuICAgICAgICAgICAgICBnaG9zdC50YWlsQmxvb20gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBnaG9zdC5hZ2UrKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBBbmltYXRlIGZsYXNoZXNcbiAgICAgIGlmICh3aW5kb3cuX3N0YXJGbGFzaGVzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB3aW5kb3cuX3N0YXJGbGFzaGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgY29uc3QgZmxhc2ggPSB3aW5kb3cuX3N0YXJGbGFzaGVzW2ldO1xuICAgICAgICAgIGZsYXNoLm1lc2guc2NhbGUubXVsdGlwbHlTY2FsYXIoMS4xNSk7XG4gICAgICAgICAgZmxhc2gubWVzaC5tYXRlcmlhbC5vcGFjaXR5ICo9IDAuODU7XG4gICAgICAgICAgZmxhc2guYWdlKys7XG4gICAgICAgICAgaWYgKGZsYXNoLmFnZSA+IDEwKSB7XG4gICAgICAgICAgICBzY2VuZS5yZW1vdmUoZmxhc2gubWVzaCk7XG4gICAgICAgICAgICB3aW5kb3cuX3N0YXJGbGFzaGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gLS0tIFN0YXJmaWVsZCBsb2dpYyAtLS1cbiAgICAgIGNvbnN0IHNxRGlzdCA9IHN0YXJNYXhEaXN0YW5jZSAqIHN0YXJNYXhEaXN0YW5jZTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIGNvbnN0IGR4ID0gcG9zaXRpb25zW2ldIC0gdmlydHVhbENhbWVyYVBvcy54O1xuICAgICAgICBjb25zdCBkeSA9IHBvc2l0aW9uc1tpICsgMV0gLSB2aXJ0dWFsQ2FtZXJhUG9zLnk7XG4gICAgICAgIGNvbnN0IGR6ID0gcG9zaXRpb25zW2kgKyAyXSAtIHZpcnR1YWxDYW1lcmFQb3MuejtcbiAgICAgICAgaWYgKGR4KmR4ICsgZHkqZHkgKyBkeipkeiA+IHNxRGlzdCkge1xuICAgICAgICAgIC8vIFBsYWNlIGluIGEgdGhpY2sgc3BoZXJpY2FsIHNoZWxsIGFyb3VuZCB0aGUgdmlydHVhbCBjYW1lcmEsIG5ldmVyIHRvbyBjbG9zZVxuICAgICAgICAgIGNvbnN0IG1pblJhZGl1cyA9IHN0YXJNYXhEaXN0YW5jZSAqIDAuODtcbiAgICAgICAgICBjb25zdCBtYXhSYWRpdXMgPSBzdGFyTWF4RGlzdGFuY2U7XG4gICAgICAgICAgY29uc3QgciA9IG1pblJhZGl1cyArIE1hdGgucmFuZG9tKCkgKiAobWF4UmFkaXVzIC0gbWluUmFkaXVzKTtcbiAgICAgICAgICBjb25zdCB0aGV0YSA9IE1hdGgucmFuZG9tKCkgKiAyICogTWF0aC5QSTtcbiAgICAgICAgICBjb25zdCBwaGkgPSBNYXRoLmFjb3MoMiAqIE1hdGgucmFuZG9tKCkgLSAxKTtcbiAgICAgICAgICBwb3NpdGlvbnNbaV0gPSB2aXJ0dWFsQ2FtZXJhUG9zLnggKyByICogTWF0aC5zaW4ocGhpKSAqIE1hdGguY29zKHRoZXRhKTtcbiAgICAgICAgICBwb3NpdGlvbnNbaSsxXSA9IHZpcnR1YWxDYW1lcmFQb3MueSArIHIgKiBNYXRoLnNpbihwaGkpICogTWF0aC5zaW4odGhldGEpO1xuICAgICAgICAgIHBvc2l0aW9uc1tpKzJdID0gdmlydHVhbENhbWVyYVBvcy56ICsgciAqIE1hdGguY29zKHBoaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlOyAvLyBBbHJlYWR5IHNldCBhYm92ZVxuICBcbiAgICAgIC8vIFJvYnVzdCBzdGFyZmllbGQgY29sb3IgdXBkYXRlIHRvIHByZXZlbnQgc3R1Y2sgd2hpdGUgZG90c1xuICAgICAgLy8gVGhpcyB3b3JrcyBOTyBUT1VDSFlcbiAgICAgIGNvbnN0IGNvbEFyciA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3IuYXJyYXk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc2l0aW9ucy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICBjb25zdCBpZHggPSBpIC8gMztcbiAgICAgICAgY29uc3QgZHggPSBwb3NpdGlvbnNbaV0gLSB2aXJ0dWFsQ2FtZXJhUG9zLng7XG4gICAgICAgIGNvbnN0IGR5ID0gcG9zaXRpb25zW2kgKyAxXSAtIHZpcnR1YWxDYW1lcmFQb3MueTtcbiAgICAgICAgY29uc3QgZHogPSBwb3NpdGlvbnNbaSArIDJdIC0gdmlydHVhbENhbWVyYVBvcy56O1xuICAgICAgICBjb25zdCBkaXN0ID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkeik7XG4gICAgICAgIGlmICh0aW1lcnNbaWR4XSA+IDApIHtcbiAgICAgICAgICB0aW1lcnNbaWR4XS0tO1xuICAgICAgICAgIGlmICh0aW1lcnNbaWR4XSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gVGltZXIgZXhwaXJlZCwgcmVzdG9yZSBjb2xvclxuICAgICAgICAgICAgc3BhcmtDb2xvcnNbaV0gPSBvcmlnaW5hbENvbG9yc1tpXTtcbiAgICAgICAgICAgIHNwYXJrQ29sb3JzW2krMV0gPSBvcmlnaW5hbENvbG9yc1tpKzFdO1xuICAgICAgICAgICAgc3BhcmtDb2xvcnNbaSsyXSA9IG9yaWdpbmFsQ29sb3JzW2krMl07XG4gICAgICAgICAgICBjb2xBcnJbaV0gPSBvcmlnaW5hbENvbG9yc1tpXTtcbiAgICAgICAgICAgIGNvbEFycltpKzFdID0gb3JpZ2luYWxDb2xvcnNbaSsxXTtcbiAgICAgICAgICAgIGNvbEFycltpKzJdID0gb3JpZ2luYWxDb2xvcnNbaSsyXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29sQXJyW2ldID0gc3BhcmtDb2xvcnNbaV07XG4gICAgICAgICAgICBjb2xBcnJbaSsxXSA9IHNwYXJrQ29sb3JzW2krMV07XG4gICAgICAgICAgICBjb2xBcnJbaSsyXSA9IHNwYXJrQ29sb3JzW2krMl07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRpc3QgPiBzdGFyTWF4RGlzdGFuY2UgKiAwLjMgJiYgTWF0aC5yYW5kb20oKSA8IDAuMDUpIHtcbiAgICAgICAgICB0aW1lcnNbaWR4XSA9IHNwYXJrbGVEdXJhdGlvbjtcbiAgICAgICAgICBjb25zdCBjID0gcGFsZXR0ZVtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBwYWxldHRlLmxlbmd0aCldO1xuICAgICAgICAgIHNwYXJrQ29sb3JzW2ldID0gY1swXTtcbiAgICAgICAgICBzcGFya0NvbG9yc1tpKzFdID0gY1sxXTtcbiAgICAgICAgICBzcGFya0NvbG9yc1tpKzJdID0gY1syXTtcbiAgICAgICAgICBjb2xBcnJbaV0gPSBzcGFya0NvbG9yc1tpXTtcbiAgICAgICAgICBjb2xBcnJbaSsxXSA9IHNwYXJrQ29sb3JzW2krMV07XG4gICAgICAgICAgY29sQXJyW2krMl0gPSBzcGFya0NvbG9yc1tpKzJdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNwYXJrQ29sb3JzW2ldID0gb3JpZ2luYWxDb2xvcnNbaV07XG4gICAgICAgICAgc3BhcmtDb2xvcnNbaSsxXSA9IG9yaWdpbmFsQ29sb3JzW2krMV07XG4gICAgICAgICAgc3BhcmtDb2xvcnNbaSsyXSA9IG9yaWdpbmFsQ29sb3JzW2krMl07XG4gICAgICAgICAgY29sQXJyW2ldID0gb3JpZ2luYWxDb2xvcnNbaV07XG4gICAgICAgICAgY29sQXJyW2krMV0gPSBvcmlnaW5hbENvbG9yc1tpKzFdO1xuICAgICAgICAgIGNvbEFycltpKzJdID0gb3JpZ2luYWxDb2xvcnNbaSsyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvci5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfTtcbiAgICBcbiAgICAvLyBTdGFydCB0aGUgYW5pbWF0aW9uIGxvb3BcbiAgICBhbmltYXRlKCk7XG4gICAgXG4gICAgLy8gSGFuZGxlIHdpbmRvdyByZXNpemVcbiAgICBjb25zdCBvblJlc2l6ZSA9ICgpID0+IHtcbiAgICAgIGNhbWVyYS5hc3BlY3QgPSB3aW5kb3cuaW5uZXJXaWR0aCAvIHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgIGNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgICByZW5kZXJlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgICAgc2hvb3RpbmdTdGFyQ29tcG9zZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICAgIGNhQ29tcG9zZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICB9O1xuICAgIFxuICAgIC8vIEFkZCBldmVudCBsaXN0ZW5lciBmb3IgcmVzaXplXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uUmVzaXplKTtcbiAgICBcbiAgICAvLyBDbGVhbiB1cCBmdW5jdGlvblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25SZXNpemUpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHJlc2l6ZUFsbCk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZnVsbHNjcmVlbmNoYW5nZScsIHJlc2l6ZUFsbCk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25TY3JvbGwpO1xuICAgICAgLy8gQ2FuY2VsIHRoZSBhbmltYXRpb24gZnJhbWUgdXNpbmcgdGhlIHN0b3JlZCBJRFxuICAgICAgaWYgKGFuaW1hdGlvbklkKSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbklkKTtcbiAgICAgIH1cbiAgICAgIC8vIERpc3Bvc2UgY29tcG9zZXJzXG4gICAgICBpZiAoY29tcG9zZXIpIGNvbXBvc2VyLmRpc3Bvc2UoKTtcbiAgICAgIGlmIChzaG9vdGluZ1N0YXJDb21wb3Nlcikgc2hvb3RpbmdTdGFyQ29tcG9zZXIuZGlzcG9zZSgpO1xuICAgICAgaWYgKGNhQ29tcG9zZXIpIGNhQ29tcG9zZXIuZGlzcG9zZSgpO1xuICAgICAgLy8gQ2xlYW4gdXAgVGhyZWUuanMgcmVzb3VyY2VzXG4gICAgICBpZiAocmVuZGVyZXIpIHtcbiAgICAgICAgcmVuZGVyZXIuZGlzcG9zZSgpO1xuICAgICAgICBpZiAobW91bnQgJiYgbW91bnQuY29udGFpbnMocmVuZGVyZXIuZG9tRWxlbWVudCkpIHtcbiAgICAgICAgICBtb3VudC5yZW1vdmVDaGlsZChyZW5kZXJlci5kb21FbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKVxuXG4gIHJldHVybiA8ZGl2IHJlZj17bW91bnRSZWZ9IC8+O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgU3RhcmZpZWxkO1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlRWZmZWN0IiwidXNlUmVmIiwiVEhSRUUiLCJFZmZlY3RDb21wb3NlciIsIlVucmVhbEJsb29tUGFzcyIsIlJlbmRlclBhc3MiLCJTaGFkZXJQYXNzIiwiRlhBQVNoYWRlciIsIkZpbG1QYXNzIiwiQ2hyb21hdGljQWJlcnJhdGlvblBhc3MiLCJTdGFyZmllbGQiLCJtb3VudFJlZiIsImN1cnJlbnQiLCJtb3VudCIsInN0eWxlIiwicG9zaXRpb24iLCJ0b3AiLCJsZWZ0Iiwid2lkdGgiLCJoZWlnaHQiLCJ6SW5kZXgiLCJzY2VuZSIsIlNjZW5lIiwiY2FtZXJhIiwiUGVyc3BlY3RpdmVDYW1lcmEiLCJ3aW5kb3ciLCJpbm5lcldpZHRoIiwiaW5uZXJIZWlnaHQiLCJzZXQiLCJ2aXJ0dWFsQ2FtZXJhUG9zIiwiVmVjdG9yMyIsInJlbmRlcmVyIiwiV2ViR0xSZW5kZXJlciIsImFudGlhbGlhcyIsInNldFBpeGVsUmF0aW8iLCJkZXZpY2VQaXhlbFJhdGlvIiwic2V0U2l6ZSIsInNldENsZWFyQ29sb3IiLCJvdXRwdXRDb2xvclNwYWNlIiwiU1JHQkNvbG9yU3BhY2UiLCJyZW5kZXJUYXJnZXQiLCJXZWJHTFJlbmRlclRhcmdldCIsImNvbG9yU3BhY2UiLCJ0eXBlIiwiVW5zaWduZWRCeXRlVHlwZSIsInRvbmVNYXBwaW5nIiwiTm9Ub25lTWFwcGluZyIsImF1dG9DbGVhciIsImFwcGVuZENoaWxkIiwiZG9tRWxlbWVudCIsImNvbXBvc2VyIiwicmVuZGVyUGFzcyIsImNsZWFyIiwiYWRkUGFzcyIsImJsb29tUGFzcyIsIlZlY3RvcjIiLCJmaWxtUGFzcyIsInNob290aW5nU3RhclNjZW5lIiwic2hvb3RpbmdTdGFyQ29tcG9zZXIiLCJzaG9vdGluZ1N0YXJSZW5kZXJQYXNzIiwic2hvb3RpbmdTdGFyQmxvb21QYXNzIiwiY2xvc2VTdGFyc1NjZW5lIiwiY2FQYXNzIiwiY2FDb21wb3NlciIsImNhUmVuZGVyUGFzcyIsInJlc2l6ZUFsbCIsImFzcGVjdCIsInVwZGF0ZVByb2plY3Rpb25NYXRyaXgiLCJhZGRFdmVudExpc3RlbmVyIiwic3RhckNvdW50Iiwic3Rhck1heERpc3RhbmNlIiwic3Rhck1pbkRpc3RhbmNlIiwic3RhclNwZWVkIiwiZ2VvbWV0cnkiLCJCdWZmZXJHZW9tZXRyeSIsImNsb3NlR2VvbWV0cnkiLCJwb3NpdGlvbnMiLCJjbG9zZVBvc2l0aW9ucyIsInN0YXJzUGxhY2VkIiwiTWF0aCIsInJhbmRvbSIsImNsdXN0ZXJUaGV0YSIsIlBJIiwiY2x1c3RlclBoaSIsImFjb3MiLCJjbHVzdGVyUiIsImNsdXN0ZXJDZW50ZXIiLCJzaW4iLCJjb3MiLCJjbHVzdGVyU2l6ZSIsImZsb29yIiwiYyIsIm9mZnNldFRoZXRhIiwib2Zmc2V0UGhpIiwib2Zmc2V0UiIsInB1c2giLCJ0aGV0YSIsInBoaSIsInIiLCJ4IiwieSIsInoiLCJzZXRBdHRyaWJ1dGUiLCJGbG9hdDMyQnVmZmVyQXR0cmlidXRlIiwibGVuZ3RoIiwicGFsZXR0ZSIsImNvbG9ycyIsImkiLCJvcmlnaW5hbENvbG9ycyIsImF0dHJpYnV0ZXMiLCJjb2xvciIsImFycmF5Iiwic2xpY2UiLCJ0aW1lcnMiLCJGbG9hdDMyQXJyYXkiLCJzcGFya0NvbG9ycyIsInNwYXJrbGVEdXJhdGlvbiIsIm1hdGVyaWFsIiwiUG9pbnRzTWF0ZXJpYWwiLCJzaXplIiwic2l6ZUF0dGVudWF0aW9uIiwidmVydGV4Q29sb3JzIiwic3RhcnMiLCJQb2ludHMiLCJhZGQiLCJnbG93TWFwIiwiVGV4dHVyZUxvYWRlciIsImxvYWQiLCJnbG93U3ByaXRlcyIsImdsb3dNYXRlcmlhbCIsIlNwcml0ZU1hdGVyaWFsIiwibWFwIiwib3BhY2l0eSIsImJsZW5kaW5nIiwiQWRkaXRpdmVCbGVuZGluZyIsImRlcHRoV3JpdGUiLCJ0cmFuc3BhcmVudCIsImdsb3ciLCJTcHJpdGUiLCJjbG9uZSIsInNjYWxlIiwiY2xvc2VTdGFycyIsInRhcmdldFkiLCJkYW1waW5nIiwib25TY3JvbGwiLCJwY3QiLCJzY3JvbGxZIiwiZG9jdW1lbnQiLCJib2R5Iiwic2Nyb2xsSGVpZ2h0IiwidGFpbExlbmd0aCIsInNob290aW5nU3RhcnMiLCJzaG9vdGluZ1N0YXJDb29sZG93biIsInNwYXduU2hvb3RpbmdTdGFyIiwiZGlyIiwibm9ybWFsaXplIiwibWluRGlzdCIsIm1heERpc3QiLCJkaXN0Iiwic3Bhd25Qb3MiLCJtdWx0aXBseVNjYWxhciIsInRhbmdlbnQiLCJzdWIiLCJwcm9qZWN0T25WZWN0b3IiLCJ0YW5nZW50aWFsU3BlZWQiLCJyYWRpYWxTcGVlZCIsInZlbG9jaXR5IiwidmlicmFudENvbG9ycyIsImJyaWdodG5lc3MiLCJnZW8iLCJTcGhlcmVHZW9tZXRyeSIsIm1hdCIsIk1lc2hQaHlzaWNhbE1hdGVyaWFsIiwiZW1pc3NpdmUiLCJlbWlzc2l2ZUludGVuc2l0eSIsIm1ldGFsbmVzcyIsInJvdWdobmVzcyIsInRyYW5zbWlzc2lvbiIsImNsZWFyY29hdCIsImNsZWFyY29hdFJvdWdobmVzcyIsInN0YXIiLCJNZXNoIiwic3ByaXRlTWFwIiwic3ByaXRlTWF0ZXJpYWwiLCJzcHJpdGUiLCJjb3B5IiwiY29sb3JTcHJpdGVNYXRlcmlhbCIsImNvbG9yU3ByaXRlIiwic3BhcmtDb3VudCIsInNwYXJrR3JvdXAiLCJHcm91cCIsInNwYXJrTWF0IiwiTWVzaEJhc2ljTWF0ZXJpYWwiLCJzcGFya0dlbyIsInNwYXJrIiwiYW5nbGUiLCJuYW1lIiwibm9ybWFsaXplZExpZmUiLCJub3JtYWxpemVkTGlmZXRpbWUiLCJhZ2UiLCJ0cmFpbFNlZ21lbnRzIiwidHJhaWxQb2ludHMiLCJzcGlyYWwiLCJjdXJ2ZSIsInB0IiwidGFpbEdlbyIsInNldEZyb21Qb2ludHMiLCJ0YWlsQ29sb3JzIiwiYWxwaGEiLCJyYWluYm93IiwiZ3JhZENvbG9yIiwidGFpbE1hdCIsIkxpbmVCYXNpY01hdGVyaWFsIiwidGFpbE1hdE1haW4iLCJOb3JtYWxCbGVuZGluZyIsInRhaWxNYWluIiwiTGluZSIsInRhaWxNYXRCbG9vbSIsInRhaWxCbG9vbSIsInRhaWxHbG93TWFwIiwidGFpbEdsb3dNYXQiLCJ0YWlsR2xvdyIsIm1lc2giLCJ0YWlsIiwiaGFzRnJhZ21lbnRlZCIsImFuaW1hdGlvbklkIiwiYW5pbWF0ZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm5lZWRzVXBkYXRlIiwiaWR4IiwicmVuZGVyIiwicm90YXRpb24iLCJmb3J3YXJkIiwiZ2V0V29ybGREaXJlY3Rpb24iLCJjb2xvckF0dHIiLCJvcmlnUiIsIm9yaWdHIiwib3JpZ0IiLCJzcXJ0IiwicG93IiwiaW50ZW5zZVIiLCJtaW4iLCJpbnRlbnNlRyIsImludGVuc2VCIiwiZmFkZVQiLCJtYXgiLCJzaGFrZVN0cmVuZ3RoIiwib2JqIiwiY2hpbGRyZW4iLCJzcGFya3MiLCJmaW5kIiwiY2hpbGQiLCJqIiwidGltZSIsInBlcmZvcm1hbmNlIiwibm93IiwiZ2V0QXR0cmlidXRlIiwiayIsImNvdW50IiwiZ2V0WCIsImciLCJnZXRZIiwiYiIsImdldFoiLCJoIiwicyIsImwiLCJkIiwicSIsInAiLCJ0ciIsInRnIiwidGIiLCJodWUycmdiIiwidCIsInNldFgiLCJzZXRZIiwic2V0WiIsInNldFciLCJnZXRXIiwidW5zaGlmdCIsInBvcCIsInRhaWxHcm93IiwiYWN0aXZlU2VnbWVudHMiLCJ2aXNpYmxlVHJhaWwiLCJ0YWlsQ29sb3JzQmxvb20iLCJEYXRlIiwic2V0WFlaVyIsImhlYWRDb2xvciIsIkNvbG9yIiwibGVycCIsImZsaWNrZXIiLCJkaXN0VG9DYW0iLCJkb2ZCbHVyIiwic3BlY3RhY3VsYXIiLCJidXJzdENvdW50Iiwic3BhcmtsZUdlbyIsInNwYXJrbGVNYXQiLCJzcGFya2xlIiwic3BkIiwic3BhcmtsZVZlbCIsInVzZXJEYXRhIiwibWF4QWdlIiwiX3NwYXJrbGVzIiwiZmxhc2hHZW8iLCJmbGFzaE1hdCIsImZsYXNoIiwiX3N0YXJGbGFzaGVzIiwiZnJhZ1ZlbCIsImFwcGx5QXhpc0FuZ2xlIiwiZnJhZ1N0YXIiLCJmcmFnVHJhaWxQb2ludHMiLCJmcmFnVGFpbEdlbyIsImZyYWdUYWlsTWF0IiwiZnJhZ1RhaWwiLCJoYXNTcGFya2VkIiwic3BhcmtWZWwiLCJzcGFya0xpZmUiLCJzcGFya0FnZSIsIl9zdGFyU3BhcmtzIiwiaGFzRmxhc2hlZCIsImRpc3RhbmNlVG8iLCJmYWRlU3RhcnQiLCJmYWRlIiwidGFpbEZhZGluZyIsInJlbW92ZSIsInRhaWxGYWRlQWdlIiwiX2ZhZGluZ1RhaWxzIiwic3BsaWNlIiwiZ2hvc3QiLCJzcURpc3QiLCJkeCIsImR5IiwiZHoiLCJtaW5SYWRpdXMiLCJtYXhSYWRpdXMiLCJjb2xBcnIiLCJvblJlc2l6ZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImRpc3Bvc2UiLCJjb250YWlucyIsInJlbW92ZUNoaWxkIiwiZGl2IiwicmVmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/Starfield.jsx\n"));

/***/ })

});