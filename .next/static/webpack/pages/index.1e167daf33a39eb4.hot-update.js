"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./components/Starfield.jsx":
/*!**********************************!*\
  !*** ./components/Starfield.jsx ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var three_examples_jsm_postprocessing_EffectComposer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three/examples/jsm/postprocessing/EffectComposer */ \"./node_modules/three/examples/jsm/postprocessing/EffectComposer.js\");\n/* harmony import */ var three_examples_jsm_postprocessing_UnrealBloomPass__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three/examples/jsm/postprocessing/UnrealBloomPass */ \"./node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js\");\n/* harmony import */ var three_examples_jsm_postprocessing_RenderPass__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three/examples/jsm/postprocessing/RenderPass */ \"./node_modules/three/examples/jsm/postprocessing/RenderPass.js\");\n/* harmony import */ var _ChromaticAberrationPass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ChromaticAberrationPass */ \"./components/ChromaticAberrationPass.js\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\nconst Starfield = ()=>{\n    _s();\n    const mountRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // Defensive: always use .current for refs\n        if (!mountRef.current) return;\n        const mount = mountRef.current;\n        mount.style.position = \"fixed\";\n        mount.style.top = \"0\";\n        mount.style.left = \"0\";\n        mount.style.width = \"100%\";\n        mount.style.height = \"100%\";\n        mount.style.zIndex = \"0\";\n        // Scene & Renderer\n        const scene = new three__WEBPACK_IMPORTED_MODULE_3__.Scene();\n        const camera = new three__WEBPACK_IMPORTED_MODULE_3__.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);\n        camera.position.set(0, 0, 0);\n        // Virtual position to simulate infinite travel\n        let virtualCameraPos = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(0, 0, 0);\n        const renderer = new three__WEBPACK_IMPORTED_MODULE_3__.WebGLRenderer({\n            antialias: true\n        });\n        renderer.setPixelRatio(window.devicePixelRatio);\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        renderer.setClearColor(0x000000, 1);\n        mount.appendChild(renderer.domElement);\n        // --- POSTPROCESSING ---\n        // Composer\n        const composer = new three_examples_jsm_postprocessing_EffectComposer__WEBPACK_IMPORTED_MODULE_4__.EffectComposer(renderer);\n        composer.setSize(window.innerWidth, window.innerHeight);\n        // Render pass\n        const renderPass = new three_examples_jsm_postprocessing_RenderPass__WEBPACK_IMPORTED_MODULE_5__.RenderPass(scene, camera);\n        composer.addPass(renderPass);\n        // Unreal Bloom Pass\n        // --- BLOOM (MAX) ---\n        const bloomPass = new three_examples_jsm_postprocessing_UnrealBloomPass__WEBPACK_IMPORTED_MODULE_6__.UnrealBloomPass(new three__WEBPACK_IMPORTED_MODULE_3__.Vector2(window.innerWidth, window.innerHeight), 2.5, 1.2, 0.12 // threshold (lower = more)\n        );\n        composer.addPass(bloomPass);\n        // --- CLOSE STARS: Separate Scene for Chromatic Aberration ---\n        const closeStarsScene = new three__WEBPACK_IMPORTED_MODULE_3__.Scene();\n        const caPass = new _ChromaticAberrationPass__WEBPACK_IMPORTED_MODULE_2__.ChromaticAberrationPass(new three__WEBPACK_IMPORTED_MODULE_3__.Vector2(0.0002, 0.0002)); // barely visible\n        const caComposer = new three_examples_jsm_postprocessing_EffectComposer__WEBPACK_IMPORTED_MODULE_4__.EffectComposer(renderer);\n        caComposer.setSize(window.innerWidth, window.innerHeight);\n        const caRenderPass = new three_examples_jsm_postprocessing_RenderPass__WEBPACK_IMPORTED_MODULE_5__.RenderPass(closeStarsScene, camera);\n        caComposer.addPass(caRenderPass);\n        caComposer.addPass(caPass);\n        // --- HANDLE RESIZE AND FULLSCREEN ---\n        function resizeAll() {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n            composer.setSize(window.innerWidth, window.innerHeight);\n            caComposer.setSize(window.innerWidth, window.innerHeight);\n        }\n        window.addEventListener(\"resize\", resizeAll);\n        window.addEventListener(\"fullscreenchange\", resizeAll);\n        // Starfield\n        const starCount = 3000;\n        const starMaxDistance = 2000;\n        const starSpeed = 1;\n        const geometry = new three__WEBPACK_IMPORTED_MODULE_3__.BufferGeometry();\n        const closeGeometry = new three__WEBPACK_IMPORTED_MODULE_3__.BufferGeometry();\n        const positions = [];\n        const closePositions = [];\n        let starsPlaced = 0;\n        while(starsPlaced < starCount){\n            // With 1% chance, spawn a star cluster (10-30 stars)\n            if (Math.random() < 0.01 && starsPlaced < starCount - 10) {\n                const clusterTheta = Math.random() * 2 * Math.PI;\n                const clusterPhi = Math.acos(2 * Math.random() - 1);\n                const clusterR = Math.random() * starMaxDistance;\n                const clusterCenter = [\n                    clusterR * Math.sin(clusterPhi) * Math.cos(clusterTheta),\n                    clusterR * Math.sin(clusterPhi) * Math.sin(clusterTheta),\n                    clusterR * Math.cos(clusterPhi)\n                ];\n                const clusterSize = 10 + Math.floor(Math.random() * 20); // 10-30 stars\n                for(let c = 0; c < clusterSize && starsPlaced < starCount; c++){\n                    // Each star in cluster is within 30 units of center\n                    const offsetTheta = Math.random() * 2 * Math.PI;\n                    const offsetPhi = Math.acos(2 * Math.random() - 1);\n                    const offsetR = Math.random() * 30; // cluster radius\n                    positions.push(clusterCenter[0] + offsetR * Math.sin(offsetPhi) * Math.cos(offsetTheta), clusterCenter[1] + offsetR * Math.sin(offsetPhi) * Math.sin(offsetTheta), clusterCenter[2] + offsetR * Math.cos(offsetPhi));\n                    starsPlaced++;\n                }\n            } else {\n                // Normal single star\n                const theta = Math.random() * 2 * Math.PI;\n                const phi = Math.acos(2 * Math.random() - 1);\n                const r = Math.random() * starMaxDistance;\n                const x = r * Math.sin(phi) * Math.cos(theta);\n                const y = r * Math.sin(phi) * Math.sin(theta);\n                const z = r * Math.cos(phi);\n                positions.push(x, y, z);\n                // If close, also add to closePositions\n                if (r < 400) {\n                    closePositions.push(x, y, z);\n                }\n                starsPlaced++;\n            }\n        }\n        geometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_3__.Float32BufferAttribute(positions, 3));\n        if (closePositions.length > 0) {\n            closeGeometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_3__.Float32BufferAttribute(closePositions, 3));\n        }\n        // CRAZY BLOOM: All stars are extremely bright (color intensity >1)\n        const palette = [\n            [\n                3.0,\n                1.5,\n                1.5\n            ],\n            [\n                3.0,\n                2.25,\n                1.2\n            ],\n            [\n                3.0,\n                3.0,\n                2.7\n            ],\n            [\n                3.0,\n                3.0,\n                3.0\n            ],\n            [\n                1.2,\n                1.5,\n                3.0\n            ]\n        ];\n        const colors = [];\n        for(let i = 0; i < starCount; i++){\n            const c = palette[Math.floor(Math.random() * palette.length)];\n            colors.push(...c);\n        }\n        geometry.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_3__.Float32BufferAttribute(colors, 3));\n        const originalColors = geometry.attributes.color.array.slice();\n        const timers = new Float32Array(starCount);\n        const sparkColors = new Float32Array(starCount * 3);\n        const sparkleDuration = 180;\n        // --- SQUARE STARS USING POINTS ---\n        const material = new three__WEBPACK_IMPORTED_MODULE_3__.PointsMaterial({\n            size: 3.5,\n            sizeAttenuation: true,\n            vertexColors: true\n        });\n        const stars = new three__WEBPACK_IMPORTED_MODULE_3__.Points(geometry, material);\n        scene.add(stars);\n        // Add glow sprites to each star and animate them based on distance\n        const glowMap = new three__WEBPACK_IMPORTED_MODULE_3__.TextureLoader().load(\"https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/sprites/glow.png\");\n        const glowSprites = [];\n        const glowMaterial = new three__WEBPACK_IMPORTED_MODULE_3__.SpriteMaterial({\n            map: glowMap,\n            color: 0xffffff,\n            opacity: 0.18,\n            blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending,\n            depthWrite: false\n        });\n        for(let i = 0; i < starCount; i++){\n            const glow = new three__WEBPACK_IMPORTED_MODULE_3__.Sprite(glowMaterial.clone());\n            glow.position.set(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2]);\n            glow.scale.set(10, 10, 1);\n            scene.add(glow);\n            glowSprites.push(glow);\n        }\n        // Add close stars to separate scene\n        let closeStars;\n        if (closePositions.length > 0) {\n            closeStars = new three__WEBPACK_IMPORTED_MODULE_3__.Points(closeGeometry, material.clone());\n            closeStarsScene.add(closeStars);\n        }\n        let targetY = 0;\n        const damping = 0.05;\n        const onScroll = ()=>{\n            const pct = window.scrollY / (document.body.scrollHeight - window.innerHeight);\n            targetY = pct * Math.PI * 2;\n        };\n        window.addEventListener(\"scroll\", onScroll);\n        // --- Shooting Stars ---\n        const tailLength = 32; // Increase for longer tails\n        const shootingStars = [];\n        let shootingStarCooldown = 0;\n        // Spawn a shooting star with a stunning glowing tail\n        function spawnShootingStar() {\n            // Pick a random direction on the sphere for the spawn location\n            const dir = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();\n            // Ensure shooting stars never spawn close to the camera (at least 70% of max distance)\n            const minDist = starMaxDistance * 0.7;\n            const maxDist = starMaxDistance * 1.0;\n            const dist = minDist + Math.random() * (maxDist - minDist);\n            const spawnPos = dir.clone().multiplyScalar(dist);\n            // Tangential velocity: perpendicular to dir\n            let tangent = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1);\n            tangent = tangent.sub(tangent.clone().projectOnVector(dir)).normalize();\n            // Mix in a small radial component (inward or outward)\n            const tangentialSpeed = starSpeed * (2.5 + Math.random() * 2.5); // much faster\n            const radialSpeed = starSpeed * (Math.random() - 0.5) * 0.3; // more dramatic\n            const velocity = tangent.multiplyScalar(tangentialSpeed).add(dir.clone().multiplyScalar(radialSpeed));\n            // Stunning color gradient for the head\n            const vibrantColors = [\n                0xffe066,\n                0xff66cc,\n                0x66ccff,\n                0xffffff,\n                0x80ffea,\n                0xfff2cc,\n                0xffc080,\n                0x80c0ff,\n                0xff80b3\n            ];\n            const color = vibrantColors[Math.floor(Math.random() * vibrantColors.length)];\n            // Star brightness and size (always small and subtle)\n            const brightness = 2.5 + Math.random() * 1.5;\n            const geo = new three__WEBPACK_IMPORTED_MODULE_3__.SphereGeometry(0.7 + Math.random() * 0.5, 16, 16); // Small sphere\n            const mat = new three__WEBPACK_IMPORTED_MODULE_3__.MeshPhysicalMaterial({\n                color: color,\n                emissive: color,\n                emissiveIntensity: 2.5,\n                metalness: 0.7,\n                roughness: 0.3,\n                transmission: 0.7,\n                opacity: 0.98,\n                transparent: true,\n                clearcoat: 0.8,\n                clearcoatRoughness: 0.2\n            });\n            const star = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(geo, mat);\n            // Add a glowing sprite for extra glow\n            const spriteMap = new three__WEBPACK_IMPORTED_MODULE_3__.TextureLoader().load(\"https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/sprites/glow.png\");\n            const spriteMaterial = new three__WEBPACK_IMPORTED_MODULE_3__.SpriteMaterial({\n                map: spriteMap,\n                color: color,\n                opacity: 0.8,\n                blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n            });\n            const sprite = new three__WEBPACK_IMPORTED_MODULE_3__.Sprite(spriteMaterial);\n            sprite.scale.set(30, 30, 1);\n            sprite.position.copy(star.position);\n            star.add(sprite);\n            // Add dynamic spark burst at the head\n            const sparkCount = 18 + Math.floor(Math.random() * 8);\n            const sparkGroup = new three__WEBPACK_IMPORTED_MODULE_3__.Group();\n            for(let i = 0; i < sparkCount; i++){\n                const sparkMat = new three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial({\n                    color: vibrantColors[Math.floor(Math.random() * vibrantColors.length)],\n                    transparent: true,\n                    opacity: 0.8\n                });\n                const sparkGeo = new three__WEBPACK_IMPORTED_MODULE_3__.SphereGeometry(0.07 + Math.random() * 0.06, 8, 8);\n                const spark = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(sparkGeo, sparkMat);\n                const angle = i / sparkCount * Math.PI * 2;\n                spark.position.set(Math.cos(angle) * 1.2, Math.sin(angle) * 1.2, Math.random() * 0.4 - 0.2);\n                sparkGroup.add(spark);\n            }\n            sparkGroup.name = \"sparkBurst\";\n            star.add(sparkGroup);\n            star.position.copy(spawnPos);\n            star.velocity = velocity;\n            star.normalizedLife = 0.0;\n            star.normalizedLifetime = 80 + Math.random() * 80; // Longer, more dramatic\n            star.age = 0;\n            // --- Stunning Meteor Tail (very long, multi-color, glowing, fading, and 3D curve) ---\n            const trailSegments = tailLength * 3; // Even longer tail\n            const trailPoints = [];\n            for(let i = 0; i < trailSegments; i++){\n                // Add a 3D spiral/curve for more depth\n                const spiral = Math.sin(i * 0.25) * 8;\n                const curve = Math.cos(i * 0.15) * 4;\n                const pt = star.position.clone().add(new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(spiral, curve, -i * 3));\n                trailPoints.push(pt);\n            }\n            const tailGeo = new three__WEBPACK_IMPORTED_MODULE_3__.BufferGeometry().setFromPoints(trailPoints);\n            // Per-vertex color (multi-color rainbow gradient)\n            const tailColors = [];\n            for(let i = 0; i < trailSegments; i++){\n                // Alpha fades out along the tail\n                const alpha = (1 - i / (trailSegments - 1)) * 0.99;\n                // Rainbow gradient\n                const rainbow = [\n                    0xffe066,\n                    0xff66cc,\n                    0x66ccff,\n                    0xffffff,\n                    0x80ffea,\n                    0xfff2cc,\n                    0xffc080,\n                    0x80c0ff,\n                    0xff80b3\n                ];\n                const gradColor = rainbow[Math.floor(i / trailSegments * rainbow.length)];\n                tailColors.push((gradColor >> 16 & 255) / 255, (gradColor >> 8 & 255) / 255, (gradColor & 255) / 255, alpha);\n            }\n            tailGeo.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_3__.Float32BufferAttribute(tailColors, 4));\n            // Additive blending for glow + BLOOMED TAIL\n            const tailMat = new three__WEBPACK_IMPORTED_MODULE_3__.LineBasicMaterial({\n                vertexColors: true,\n                transparent: true,\n                opacity: 1.0,\n                blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n            });\n            const tail = new three__WEBPACK_IMPORTED_MODULE_3__.Line(tailGeo, tailMat);\n            tail.position.copy(star.position);\n            // Add a bloom sprite to the tail's head for extra glow\n            const tailGlowMap = new three__WEBPACK_IMPORTED_MODULE_3__.TextureLoader().load(\"https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/sprites/glow.png\");\n            const tailGlowMat = new three__WEBPACK_IMPORTED_MODULE_3__.SpriteMaterial({\n                map: tailGlowMap,\n                color: color,\n                opacity: 0.85,\n                blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n            });\n            const tailGlow = new three__WEBPACK_IMPORTED_MODULE_3__.Sprite(tailGlowMat);\n            tailGlow.scale.set(22, 22, 1);\n            tailGlow.position.copy(star.position);\n            star.add(tailGlow); // Attach to star so it follows head\n            // Add to scene\n            scene.add(star);\n            scene.add(tail);\n            shootingStars.push({\n                mesh: star,\n                tail,\n                velocity: star.velocity,\n                dir,\n                age: 0,\n                normalizedLifetime: star.normalizedLifetime,\n                trailPoints,\n                color,\n                brightness,\n                hasFragmented: false\n            });\n        }\n        const animate = ()=>{\n            try {\n                requestAnimationFrame(animate);\n                // Render main scene with bloom\n                composer.render();\n                // Overlay close stars with chromatic aberration (only close stars get CA)\n                if (closeStars) {\n                    caComposer.render();\n                }\n                camera.rotation.y += (targetY - camera.rotation.y) * damping;\n                // Move the virtual camera position in the direction the camera is facing\n                const forward = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();\n                camera.getWorldDirection(forward);\n                virtualCameraPos.add(forward.multiplyScalar(starSpeed));\n                // Offset all stars by -virtualCameraPos (floating origin)\n                for(let i = 0; i < positions.length; i += 3){\n                    geometry.attributes.position.array[i] = positions[i] - virtualCameraPos.x;\n                    geometry.attributes.position.array[i + 1] = positions[i + 1] - virtualCameraPos.y;\n                    geometry.attributes.position.array[i + 2] = positions[i + 2] - virtualCameraPos.z;\n                    // Animate glow sprite for distant/close effect\n                    const glow = glowSprites[i / 3];\n                    const starPos = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(positions[i] - virtualCameraPos.x, positions[i + 1] - virtualCameraPos.y, positions[i + 2] - virtualCameraPos.z);\n                    const dist = starPos.length();\n                    // If close, reduce/hide glow, if far, make glow big and bright\n                    if (dist < 400) {\n                        glow.material.opacity = 0.06 + 0.08 * Math.random(); // subtle flicker\n                        glow.scale.set(7, 7, 1);\n                    } else if (dist > 1200) {\n                        glow.material.opacity = 0.38 + 0.18 * Math.random(); // intense\n                        glow.scale.set(32, 32, 1);\n                    } else {\n                        // interpolate\n                        const t = (dist - 400) / (1200 - 400);\n                        glow.material.opacity = 0.08 + 0.3 * t + 0.08 * Math.random();\n                        const s = 7 + (32 - 7) * t;\n                        glow.scale.set(s, s, 1);\n                    }\n                    glow.position.copy(starPos);\n                }\n                if (closeStars && closeGeometry && closePositions.length > 0) {\n                    for(let i = 0; i < closePositions.length; i += 3){\n                        closeGeometry.attributes.position.array[i] = closePositions[i] - virtualCameraPos.x;\n                        closeGeometry.attributes.position.array[i + 1] = closePositions[i + 1] - virtualCameraPos.y;\n                        closeGeometry.attributes.position.array[i + 2] = closePositions[i + 2] - virtualCameraPos.z;\n                    }\n                    closeGeometry.attributes.position.needsUpdate = true;\n                }\n                geometry.attributes.position.needsUpdate = true;\n                // --- Shooting star spawning ---\n                if (shootingStarCooldown <= 0 && Math.random() < 0.1) {\n                    spawnShootingStar();\n                    if (camera) {\n                        const shakeStrength = 0.06 + Math.random() * 0.04;\n                        camera.position.x += (Math.random() - 0.5) * shakeStrength;\n                        camera.position.y += (Math.random() - 0.5) * shakeStrength;\n                    }\n                    shootingStarCooldown = 10 + Math.random() * 10;\n                } else if (shootingStarCooldown > 0) {\n                    shootingStarCooldown--;\n                }\n                // Animate and clean up shooting stars\n                for(let i = shootingStars.length - 1; i >= 0; i--){\n                    const obj = shootingStars[i];\n                    // Animate spark burst (fade and expand)\n                    if (obj.mesh.children) {\n                        const sparks = obj.mesh.children.find((child)=>child.name === \"sparkBurst\");\n                        if (sparks) {\n                            for(let j = 0; j < sparks.children.length; j++){\n                                const spark = sparks.children[j];\n                                spark.material.opacity *= 0.96; // Fade\n                                spark.scale.multiplyScalar(1.03); // Expand\n                            }\n                        }\n                    }\n                    // Animate tail shimmer and color cycling\n                    if (obj.tail && obj.trailPoints) {\n                        const time = performance.now() * 0.001;\n                        const tailGeo = obj.tail.geometry;\n                        const tailColors = tailGeo.getAttribute(\"color\");\n                        for(let k = 0; k < tailColors.count; k++){\n                            // Cycle hue\n                            let r = tailColors.getX(k), g = tailColors.getY(k), b = tailColors.getZ(k);\n                            // Convert to HSL\n                            const max = Math.max(r, g, b), min = Math.min(r, g, b);\n                            let h, s, l;\n                            l = (max + min) / 2;\n                            if (max === min) {\n                                h = s = 0;\n                            } else {\n                                const d = max - min;\n                                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n                                switch(max){\n                                    case r:\n                                        h = (g - b) / d + (g < b ? 6 : 0);\n                                        break;\n                                    case g:\n                                        h = (b - r) / d + 2;\n                                        break;\n                                    case b:\n                                        h = (r - g) / d + 4;\n                                        break;\n                                }\n                                h /= 6;\n                            }\n                            h = (h + 0.25 * Math.sin(time + k * 0.2)) % 1.0; // Animate hue\n                            // Convert back to RGB\n                            let q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n                            let p = 2 * l - q;\n                            let tr = h + 1 / 3, tg = h, tb = h - 1 / 3;\n                            const hue2rgb = (p, q, t)=>{\n                                if (t < 0) t += 1;\n                                if (t > 1) t -= 1;\n                                if (t < 1 / 6) return p + (q - p) * 6 * t;\n                                if (t < 1 / 2) return q;\n                                if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n                                return p;\n                            };\n                            tailColors.setX(k, hue2rgb(p, q, tr));\n                            tailColors.setY(k, hue2rgb(p, q, tg));\n                            tailColors.setZ(k, hue2rgb(p, q, tb));\n                            // Shimmer: modulate alpha\n                            tailColors.setW(k, tailColors.getW(k) * (0.97 + 0.03 * Math.sin(time * 8 + k)));\n                        }\n                        tailColors.needsUpdate = true;\n                    }\n                    // Straight-line trajectory\n                    obj.mesh.position.add(obj.velocity);\n                    obj.tail.position.copy(obj.mesh.position);\n                    // Animate tail (no lerp, just drag)\n                    obj.age++;\n                    const normalizedLife = obj.age / obj.normalizedLifetime;\n                    obj.trailPoints.unshift(obj.mesh.position.clone());\n                    if (obj.trailPoints.length > tailLength * 3) obj.trailPoints.pop();\n                    let tailGrow = Math.min(1, normalizedLife / 0.3);\n                    let activeSegments = Math.floor(obj.trailPoints.length * tailGrow);\n                    if (activeSegments < 2) activeSegments = 2;\n                    const visibleTrail = obj.trailPoints.slice(0, activeSegments);\n                    obj.tail.geometry.setFromPoints(visibleTrail);\n                    const tailColors = obj.tail.geometry.getAttribute(\"color\");\n                    for(let j = 0; j < visibleTrail.length; j++){\n                        let alpha = (1 - j / (visibleTrail.length - 1)) * 0.95;\n                        alpha *= 0.92 + 0.08 * Math.sin(Date.now() * 0.015 + j * 0.5);\n                        let rainbow = [\n                            0xffc080,\n                            0xffe080,\n                            0xffff80,\n                            0x80ffe6,\n                            0x80c0ff,\n                            0xc080ff\n                        ];\n                        let gradColor = rainbow[j % rainbow.length];\n                        if (normalizedLife > 0.7) alpha *= Math.max(0, 1 - (normalizedLife - 0.7 - 0.2) / 0.3);\n                        tailColors.setXYZW(j, (gradColor >> 16 & 255) / 255, (gradColor >> 8 & 255) / 255, (gradColor & 255) / 255, alpha);\n                    }\n                    tailColors.needsUpdate = true;\n                    // Animate head\n                    let headColor;\n                    if (normalizedLife < 0.5) {\n                        headColor = new three__WEBPACK_IMPORTED_MODULE_3__.Color(obj.color).lerp(new three__WEBPACK_IMPORTED_MODULE_3__.Color(0xffc080), normalizedLife * 2);\n                    } else {\n                        headColor = new three__WEBPACK_IMPORTED_MODULE_3__.Color(0xffc080).lerp(new three__WEBPACK_IMPORTED_MODULE_3__.Color(0xff4000), (normalizedLife - 0.5) * 2);\n                    }\n                    let flicker = 0.95 + 0.13 * Math.sin(Date.now() * 0.07 + Math.random() * 10);\n                    headColor.multiplyScalar(flicker);\n                    obj.mesh.material.color.copy(headColor);\n                    let scale = 1 + 2.2 * Math.sin(Math.PI * normalizedLife);\n                    let distToCam = obj.mesh.position.length();\n                    let dofBlur = distToCam < starMaxDistance * 0.7 ? 0.7 : 1.0;\n                    obj.mesh.scale.set(scale * dofBlur, scale * dofBlur, scale * dofBlur);\n                    // Sparkle burst\n                    if (normalizedLife >= 1 && !obj.hasFragmented) {\n                        // --- SPECTACULAR EXPLOSION (very rare) ---\n                        const spectacular = Math.random() < 0.02; // 2% chance\n                        const burstCount = spectacular ? 120 + Math.floor(Math.random() * 60) : 18 + Math.floor(Math.random() * 8);\n                        const palette = spectacular ? [\n                            0xffe066,\n                            0xff66cc,\n                            0x66ccff,\n                            0xffffff,\n                            0x80ffea,\n                            0xfff2cc,\n                            0xffc080,\n                            0x80c0ff,\n                            0xff80b3,\n                            0xff0000,\n                            0x00ff00,\n                            0x0000ff,\n                            0xffff00,\n                            0x00ffff,\n                            0xff00ff,\n                            0xff8800,\n                            0x00ff88,\n                            0x8800ff\n                        ] : [\n                            0xffffff,\n                            0xfff6c0,\n                            0xffe066,\n                            0xffc080,\n                            0x80c0ff\n                        ];\n                        for(let s = 0; s < burstCount; s++){\n                            const color = palette[Math.floor(Math.random() * palette.length)];\n                            const size = spectacular ? 1.2 + Math.random() * 2.2 : 0.7 + Math.random() * 0.8;\n                            const sparkleGeo = new three__WEBPACK_IMPORTED_MODULE_3__.SphereGeometry(size, 8, 8);\n                            const sparkleMat = new three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial({\n                                color,\n                                transparent: true,\n                                opacity: spectacular ? 0.92 : 0.7,\n                                blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n                            });\n                            const sparkle = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(sparkleGeo, sparkleMat);\n                            sparkle.position.copy(obj.mesh.position);\n                            // Spectacular: huge, fast, random directions; normal: moderate\n                            const spd = spectacular ? 4 + Math.random() * 8 : 2 + Math.random() * 2;\n                            const sparkleVel = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize().multiplyScalar(spd);\n                            sparkle.userData = {\n                                velocity: sparkleVel,\n                                age: 0,\n                                spectacular,\n                                maxAge: spectacular ? 80 + Math.random() * 40 : 40 + Math.random() * 20\n                            }; // <-- LONGER LIFE\n                            scene.add(sparkle);\n                            if (!window._sparkles) window._sparkles = [];\n                            window._sparkles.push(sparkle);\n                        }\n                        if (spectacular) {\n                            // Add a big flash\n                            const flashGeo = new three__WEBPACK_IMPORTED_MODULE_3__.SphereGeometry(6, 24, 24);\n                            const flashMat = new three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial({\n                                color: 0xffffff,\n                                transparent: true,\n                                opacity: 0.8,\n                                blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n                            });\n                            const flash = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(flashGeo, flashMat);\n                            flash.position.copy(obj.mesh.position);\n                            scene.add(flash);\n                            if (!window._starFlashes) window._starFlashes = [];\n                            window._starFlashes.push({\n                                mesh: flash,\n                                age: 0\n                            });\n                        }\n                        // Fragmented trail logic (keep as before)\n                        const fragVel = obj.velocity.clone().applyAxisAngle(new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(0, 1, 0), (Math.random() - 0.5) * 0.3);\n                        const fragStar = obj.mesh.clone();\n                        fragStar.position.copy(obj.mesh.position);\n                        fragStar.velocity = fragVel;\n                        fragStar.normalizedLife = normalizedLife;\n                        fragStar.normalizedLifetime = obj.normalizedLifetime * (0.5 + Math.random() * 0.5);\n                        fragStar.age = obj.age;\n                        fragStar.material = obj.mesh.material.clone();\n                        const fragTrailPoints = obj.trailPoints.slice();\n                        const fragTailGeo = new three__WEBPACK_IMPORTED_MODULE_3__.BufferGeometry().setFromPoints(fragTrailPoints);\n                        fragTailGeo.setAttribute(\"color\", obj.tail.geometry.getAttribute(\"color\").clone());\n                        const fragTailMat = obj.tail.material.clone();\n                        const fragTail = new three__WEBPACK_IMPORTED_MODULE_3__.Line(fragTailGeo, fragTailMat);\n                        fragTail.position.copy(fragStar.position);\n                        scene.add(fragStar);\n                        scene.add(fragTail);\n                        shootingStars.push({\n                            mesh: fragStar,\n                            tail: fragTail,\n                            velocity: fragStar.velocity,\n                            dir: obj.dir,\n                            age: fragStar.age,\n                            normalizedLifetime: fragStar.normalizedLifetime,\n                            trailPoints: fragTrailPoints,\n                            color: obj.color,\n                            brightness: obj.brightness,\n                            hasFragmented: true\n                        });\n                        obj.hasFragmented = true;\n                    }\n                    // Spark burst\n                    if (!obj.hasSparked && normalizedLife > 0.95 && Math.random() < 0.1) {\n                        for(let s = 0; s < 8 + Math.floor(Math.random() * 8); s++){\n                            const sparkGeo = new three__WEBPACK_IMPORTED_MODULE_3__.SphereGeometry(0.5 + Math.random() * 0.5, 8, 8);\n                            const sparkMat = new three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial({\n                                color: 0xfff6c0,\n                                transparent: true,\n                                opacity: 1,\n                                blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n                            });\n                            const spark = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(sparkGeo, sparkMat);\n                            spark.position.copy(obj.mesh.position);\n                            spark.sparkVel = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize().multiplyScalar(0.5 + Math.random() * 1.2);\n                            spark.sparkLife = 12 + Math.random() * 10;\n                            spark.sparkAge = 0;\n                            scene.add(spark);\n                            if (!window._starSparks) window._starSparks = [];\n                            window._starSparks.push(spark);\n                        }\n                        obj.hasSparked = true;\n                    }\n                    // Flash\n                    if (!obj.hasFlashed && normalizedLife > 0.98 && Math.random() < 0.2) {\n                        const flashGeo = new three__WEBPACK_IMPORTED_MODULE_3__.SphereGeometry(1, 16, 16);\n                        const flashMat = new three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial({\n                            color: 0xffffee,\n                            transparent: true,\n                            opacity: 0.8,\n                            blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n                        });\n                        const flash = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(flashGeo, flashMat);\n                        flash.position.copy(obj.mesh.position);\n                        scene.add(flash);\n                        if (!window._starFlashes) window._starFlashes = [];\n                        window._starFlashes.push({\n                            mesh: flash,\n                            age: 0\n                        });\n                        obj.hasFlashed = true;\n                    }\n                    // Fade out as it gets far away\n                    const dist = obj.mesh.position.distanceTo(camera.position);\n                    const fadeStart = starMaxDistance * 0.5;\n                    if (dist > fadeStart) {\n                        const fade = 1 - (dist - fadeStart) / (starMaxDistance - fadeStart);\n                        obj.mesh.material.opacity = Math.max(0, fade);\n                        obj.mesh.material.transparent = true;\n                        obj.tail.material.opacity = Math.max(0, fade * 0.8);\n                        obj.tail.material.transparent = true;\n                    }\n                    // Remove when out of bounds or fully faded or life ended\n                    if (normalizedLife >= 1.0 || dist > starMaxDistance || obj.mesh.material.opacity <= 0.01) {\n                        scene.remove(obj.mesh);\n                        scene.remove(obj.tail);\n                        shootingStars.splice(i, 1);\n                    }\n                }\n                // Animate sparks\n                if (window._starSparks) {\n                    for(let i = window._starSparks.length - 1; i >= 0; i--){\n                        const spark = window._starSparks[i];\n                        spark.position.add(spark.sparkVel);\n                        spark.sparkAge++;\n                        spark.material.opacity *= 0.92;\n                        if (spark.sparkAge > spark.sparkLife) {\n                            scene.remove(spark);\n                            window._starSparks.splice(i, 1);\n                        }\n                    }\n                }\n                // Animate explosion particles (sparkles)\n                if (window._sparkles) {\n                    for(let i = window._sparkles.length - 1; i >= 0; i--){\n                        const sparkle = window._sparkles[i];\n                        sparkle.position.add(sparkle.userData.velocity);\n                        sparkle.userData.age++;\n                        sparkle.material.opacity *= 0.97;\n                        if (sparkle.userData.age > (sparkle.userData.maxAge || 40)) {\n                            scene.remove(sparkle);\n                            window._sparkles.splice(i, 1);\n                        }\n                    }\n                }\n                // Animate flashes\n                if (window._starFlashes) {\n                    for(let i = window._starFlashes.length - 1; i >= 0; i--){\n                        const flash = window._starFlashes[i];\n                        flash.mesh.scale.multiplyScalar(1.15);\n                        flash.mesh.material.opacity *= 0.85;\n                        flash.age++;\n                        if (flash.age > 10) {\n                            scene.remove(flash.mesh);\n                            window._starFlashes.splice(i, 1);\n                        }\n                    }\n                }\n                // --- Starfield logic ---\n                const sqDist = starMaxDistance * starMaxDistance;\n                for(let i = 0; i < positions.length; i += 3){\n                    const dx = positions[i] - virtualCameraPos.x;\n                    const dy = positions[i + 1] - virtualCameraPos.y;\n                    const dz = positions[i + 2] - virtualCameraPos.z;\n                    if (dx * dx + dy * dy + dz * dz > sqDist) {\n                        // Place in a thick spherical shell around the virtual camera, never too close\n                        const minRadius = starMaxDistance * 0.8;\n                        const maxRadius = starMaxDistance;\n                        const r = minRadius + Math.random() * (maxRadius - minRadius);\n                        const theta = Math.random() * 2 * Math.PI;\n                        const phi = Math.acos(2 * Math.random() - 1);\n                        positions[i] = virtualCameraPos.x + r * Math.sin(phi) * Math.cos(theta);\n                        positions[i + 1] = virtualCameraPos.y + r * Math.sin(phi) * Math.sin(theta);\n                        positions[i + 2] = virtualCameraPos.z + r * Math.cos(phi);\n                    }\n                }\n                // geometry.attributes.position.needsUpdate = true; // Already set above\n                // Robust starfield color update to prevent stuck white dots\n                const colArr = geometry.attributes.color.array;\n                for(let i = 0; i < positions.length; i += 3){\n                    const idx = i / 3;\n                    const dx = positions[i] - virtualCameraPos.x;\n                    const dy = positions[i + 1] - virtualCameraPos.y;\n                    const dz = positions[i + 2] - virtualCameraPos.z;\n                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);\n                    if (timers[idx] > 0) {\n                        timers[idx]--;\n                        if (timers[idx] === 0) {\n                            // Timer expired, restore color\n                            sparkColors[i] = originalColors[i];\n                            sparkColors[i + 1] = originalColors[i + 1];\n                            sparkColors[i + 2] = originalColors[i + 2];\n                            colArr[i] = originalColors[i];\n                            colArr[i + 1] = originalColors[i + 1];\n                            colArr[i + 2] = originalColors[i + 2];\n                        } else {\n                            colArr[i] = sparkColors[i];\n                            colArr[i + 1] = sparkColors[i + 1];\n                            colArr[i + 2] = sparkColors[i + 2];\n                        }\n                    } else if (dist > starMaxDistance * 0.3 && Math.random() < 0.05) {\n                        timers[idx] = sparkleDuration;\n                        const c = palette[Math.floor(Math.random() * palette.length)];\n                        sparkColors[i] = c[0];\n                        sparkColors[i + 1] = c[1];\n                        sparkColors[i + 2] = c[2];\n                        colArr[i] = sparkColors[i];\n                        colArr[i + 1] = sparkColors[i + 1];\n                        colArr[i + 2] = sparkColors[i + 2];\n                    } else {\n                        sparkColors[i] = originalColors[i];\n                        sparkColors[i + 1] = originalColors[i + 1];\n                        sparkColors[i + 2] = originalColors[i + 2];\n                        colArr[i] = originalColors[i];\n                        colArr[i + 1] = originalColors[i + 1];\n                        colArr[i + 2] = originalColors[i + 2];\n                    }\n                }\n                geometry.attributes.color.needsUpdate = true;\n                composer.render();\n            } catch (err) {\n                // Defensive: log error with context\n                console.error(\"Starfield animation error:\", err);\n            }\n        };\n        animate(); // Start the render loop\n        const onResize = ()=>{\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n        };\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: mountRef\n    }, void 0, false, {\n        fileName: \"/home/kayosdev/Websites/Portfolio/components/Starfield.jsx\",\n        lineNumber: 649,\n        columnNumber: 10\n    }, undefined);\n};\n_s(Starfield, \"V9/qkEdV8GfsDZk7lMTA1T8g5Ps=\");\n_c = Starfield;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Starfield);\nvar _c;\n$RefreshReg$(_c, \"Starfield\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFFO3dCQUN0Q1EsV0FBVyxDQUFDUixJQUFFLEVBQUUsR0FBR0MsY0FBYyxDQUFDRCxJQUFFLEVBQUU7d0JBQ3RDOE0sTUFBTSxDQUFDOU0sRUFBRSxHQUFHQyxjQUFjLENBQUNELEVBQUU7d0JBQzdCOE0sTUFBTSxDQUFDOU0sSUFBRSxFQUFFLEdBQUdDLGNBQWMsQ0FBQ0QsSUFBRSxFQUFFO3dCQUNqQzhNLE1BQU0sQ0FBQzlNLElBQUUsRUFBRSxHQUFHQyxjQUFjLENBQUNELElBQUUsRUFBRTtvQkFDbkM7Z0JBQ0Y7Z0JBQ0FsQyxTQUFTb0MsVUFBVSxDQUFDQyxLQUFLLENBQUNxSCxXQUFXLEdBQUc7Z0JBQ3RDMUssU0FBU21LLE1BQU07WUFDakIsRUFBRSxPQUFPZ0csS0FBSztnQkFDWixvQ0FBb0M7Z0JBQ3BDQyxRQUFRQyxLQUFLLENBQUMsOEJBQThCRjtZQUM5QztRQUNGO1FBRUFsRyxXQUFXLHdCQUF3QjtRQUVuQyxNQUFNcUcsV0FBVztZQUNmdlIsT0FBTzJCLE1BQU0sR0FBR3pCLE9BQU9DLFVBQVUsR0FBR0QsT0FBT0UsV0FBVztZQUN0REosT0FBTzRCLHNCQUFzQjtRQUMvQjtJQUNGLEdBQUcsRUFBRTtJQUVMLHFCQUFPLDhEQUFDNFA7UUFBSUMsS0FBS3JTOzs7Ozs7QUFDbkI7R0Fsb0JNRDtLQUFBQTtBQW1vQk4sK0RBQWVBLFNBQVNBLEVBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9TdGFyZmllbGQuanN4P2YxYTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgRWZmZWN0Q29tcG9zZXIgfSBmcm9tICd0aHJlZS9leGFtcGxlcy9qc20vcG9zdHByb2Nlc3NpbmcvRWZmZWN0Q29tcG9zZXInO1xuaW1wb3J0IHsgVW5yZWFsQmxvb21QYXNzIH0gZnJvbSAndGhyZWUvZXhhbXBsZXMvanNtL3Bvc3Rwcm9jZXNzaW5nL1VucmVhbEJsb29tUGFzcyc7XG5pbXBvcnQgeyBSZW5kZXJQYXNzIH0gZnJvbSAndGhyZWUvZXhhbXBsZXMvanNtL3Bvc3Rwcm9jZXNzaW5nL1JlbmRlclBhc3MnO1xuaW1wb3J0IHsgQ2hyb21hdGljQWJlcnJhdGlvblBhc3MgfSBmcm9tICcuL0Nocm9tYXRpY0FiZXJyYXRpb25QYXNzJztcblxuY29uc3QgU3RhcmZpZWxkID0gKCkgPT4ge1xuICBjb25zdCBtb3VudFJlZiA9IHVzZVJlZihudWxsKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gRGVmZW5zaXZlOiBhbHdheXMgdXNlIC5jdXJyZW50IGZvciByZWZzXG4gICAgaWYgKCFtb3VudFJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgY29uc3QgbW91bnQgPSBtb3VudFJlZi5jdXJyZW50XG4gICAgbW91bnQuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnXG4gICAgbW91bnQuc3R5bGUudG9wID0gJzAnXG4gICAgbW91bnQuc3R5bGUubGVmdCA9ICcwJ1xuICAgIG1vdW50LnN0eWxlLndpZHRoID0gJzEwMCUnXG4gICAgbW91bnQuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnXG4gICAgbW91bnQuc3R5bGUuekluZGV4ID0gJzAnXG5cbiAgICAvLyBTY2VuZSAmIFJlbmRlcmVyXG4gICAgY29uc3Qgc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKVxuICAgIGNvbnN0IGNhbWVyYSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSg3NSwgd2luZG93LmlubmVyV2lkdGggLyB3aW5kb3cuaW5uZXJIZWlnaHQsIDAuMSwgNTAwMClcbiAgICBjYW1lcmEucG9zaXRpb24uc2V0KDAsIDAsIDApO1xuICAgIC8vIFZpcnR1YWwgcG9zaXRpb24gdG8gc2ltdWxhdGUgaW5maW5pdGUgdHJhdmVsXG4gICAgbGV0IHZpcnR1YWxDYW1lcmFQb3MgPSBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAwKTtcbiAgICBjb25zdCByZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKHsgYW50aWFsaWFzOiB0cnVlIH0pXG4gICAgcmVuZGVyZXIuc2V0UGl4ZWxSYXRpbyh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbylcbiAgICByZW5kZXJlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpXG4gICAgcmVuZGVyZXIuc2V0Q2xlYXJDb2xvcigweDAwMDAwMCwgMSk7XG4gICAgbW91bnQuYXBwZW5kQ2hpbGQocmVuZGVyZXIuZG9tRWxlbWVudClcblxuICAgIC8vIC0tLSBQT1NUUFJPQ0VTU0lORyAtLS1cbiAgICAvLyBDb21wb3NlclxuICAgIGNvbnN0IGNvbXBvc2VyID0gbmV3IEVmZmVjdENvbXBvc2VyKHJlbmRlcmVyKTtcbiAgICBjb21wb3Nlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIC8vIFJlbmRlciBwYXNzXG4gICAgY29uc3QgcmVuZGVyUGFzcyA9IG5ldyBSZW5kZXJQYXNzKHNjZW5lLCBjYW1lcmEpO1xuICAgIGNvbXBvc2VyLmFkZFBhc3MocmVuZGVyUGFzcyk7XG4gICAgLy8gVW5yZWFsIEJsb29tIFBhc3NcbiAgICAvLyAtLS0gQkxPT00gKE1BWCkgLS0tXG4gICAgY29uc3QgYmxvb21QYXNzID0gbmV3IFVucmVhbEJsb29tUGFzcyhcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpLFxuICAgICAgMi41LCAvLyBzdHJlbmd0aCAobWF4KVxuICAgICAgMS4yLCAvLyByYWRpdXMgKG1heClcbiAgICAgIDAuMTIgLy8gdGhyZXNob2xkIChsb3dlciA9IG1vcmUpXG4gICAgKTtcbiAgICBjb21wb3Nlci5hZGRQYXNzKGJsb29tUGFzcyk7XG5cbiAgICAvLyAtLS0gQ0xPU0UgU1RBUlM6IFNlcGFyYXRlIFNjZW5lIGZvciBDaHJvbWF0aWMgQWJlcnJhdGlvbiAtLS1cbiAgICBjb25zdCBjbG9zZVN0YXJzU2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcbiAgICBjb25zdCBjYVBhc3MgPSBuZXcgQ2hyb21hdGljQWJlcnJhdGlvblBhc3MobmV3IFRIUkVFLlZlY3RvcjIoMC4wMDAyLCAwLjAwMDIpKTsgLy8gYmFyZWx5IHZpc2libGVcbiAgICBjb25zdCBjYUNvbXBvc2VyID0gbmV3IEVmZmVjdENvbXBvc2VyKHJlbmRlcmVyKTtcbiAgICBjYUNvbXBvc2VyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgY29uc3QgY2FSZW5kZXJQYXNzID0gbmV3IFJlbmRlclBhc3MoY2xvc2VTdGFyc1NjZW5lLCBjYW1lcmEpO1xuICAgIGNhQ29tcG9zZXIuYWRkUGFzcyhjYVJlbmRlclBhc3MpO1xuICAgIGNhQ29tcG9zZXIuYWRkUGFzcyhjYVBhc3MpO1xuXG4gICAgLy8gLS0tIEhBTkRMRSBSRVNJWkUgQU5EIEZVTExTQ1JFRU4gLS0tXG4gICAgZnVuY3Rpb24gcmVzaXplQWxsKCkge1xuICAgICAgY2FtZXJhLmFzcGVjdCA9IHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAgIHJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgICBjb21wb3Nlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgICAgY2FDb21wb3Nlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIH1cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplQWxsKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZnVsbHNjcmVlbmNoYW5nZScsIHJlc2l6ZUFsbCk7XG5cbiAgICAvLyBTdGFyZmllbGRcbiAgICBjb25zdCBzdGFyQ291bnQgPSAzMDAwXG4gICAgY29uc3Qgc3Rhck1heERpc3RhbmNlID0gMjAwMFxuICAgIGNvbnN0IHN0YXJTcGVlZCA9IDFcbiAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpXG4gICAgY29uc3QgY2xvc2VHZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xuICAgIGNvbnN0IHBvc2l0aW9ucyA9IFtdO1xuICAgIGNvbnN0IGNsb3NlUG9zaXRpb25zID0gW107XG4gICAgbGV0IHN0YXJzUGxhY2VkID0gMDtcbiAgICB3aGlsZSAoc3RhcnNQbGFjZWQgPCBzdGFyQ291bnQpIHtcbiAgICAgIC8vIFdpdGggMSUgY2hhbmNlLCBzcGF3biBhIHN0YXIgY2x1c3RlciAoMTAtMzAgc3RhcnMpXG4gICAgICBpZiAoTWF0aC5yYW5kb20oKSA8IDAuMDEgJiYgc3RhcnNQbGFjZWQgPCBzdGFyQ291bnQgLSAxMCkge1xuICAgICAgICBjb25zdCBjbHVzdGVyVGhldGEgPSBNYXRoLnJhbmRvbSgpICogMiAqIE1hdGguUEk7XG4gICAgICAgIGNvbnN0IGNsdXN0ZXJQaGkgPSBNYXRoLmFjb3MoMiAqIE1hdGgucmFuZG9tKCkgLSAxKTtcbiAgICAgICAgY29uc3QgY2x1c3RlclIgPSBNYXRoLnJhbmRvbSgpICogc3Rhck1heERpc3RhbmNlO1xuICAgICAgICBjb25zdCBjbHVzdGVyQ2VudGVyID0gW1xuICAgICAgICAgIGNsdXN0ZXJSICogTWF0aC5zaW4oY2x1c3RlclBoaSkgKiBNYXRoLmNvcyhjbHVzdGVyVGhldGEpLFxuICAgICAgICAgIGNsdXN0ZXJSICogTWF0aC5zaW4oY2x1c3RlclBoaSkgKiBNYXRoLnNpbihjbHVzdGVyVGhldGEpLFxuICAgICAgICAgIGNsdXN0ZXJSICogTWF0aC5jb3MoY2x1c3RlclBoaSlcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgY2x1c3RlclNpemUgPSAxMCArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDIwKTsgLy8gMTAtMzAgc3RhcnNcbiAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBjbHVzdGVyU2l6ZSAmJiBzdGFyc1BsYWNlZCA8IHN0YXJDb3VudDsgYysrKSB7XG4gICAgICAgICAgLy8gRWFjaCBzdGFyIGluIGNsdXN0ZXIgaXMgd2l0aGluIDMwIHVuaXRzIG9mIGNlbnRlclxuICAgICAgICAgIGNvbnN0IG9mZnNldFRoZXRhID0gTWF0aC5yYW5kb20oKSAqIDIgKiBNYXRoLlBJO1xuICAgICAgICAgIGNvbnN0IG9mZnNldFBoaSA9IE1hdGguYWNvcygyICogTWF0aC5yYW5kb20oKSAtIDEpO1xuICAgICAgICAgIGNvbnN0IG9mZnNldFIgPSBNYXRoLnJhbmRvbSgpICogMzA7IC8vIGNsdXN0ZXIgcmFkaXVzXG4gICAgICAgICAgcG9zaXRpb25zLnB1c2goXG4gICAgICAgICAgICBjbHVzdGVyQ2VudGVyWzBdICsgb2Zmc2V0UiAqIE1hdGguc2luKG9mZnNldFBoaSkgKiBNYXRoLmNvcyhvZmZzZXRUaGV0YSksXG4gICAgICAgICAgICBjbHVzdGVyQ2VudGVyWzFdICsgb2Zmc2V0UiAqIE1hdGguc2luKG9mZnNldFBoaSkgKiBNYXRoLnNpbihvZmZzZXRUaGV0YSksXG4gICAgICAgICAgICBjbHVzdGVyQ2VudGVyWzJdICsgb2Zmc2V0UiAqIE1hdGguY29zKG9mZnNldFBoaSlcbiAgICAgICAgICApO1xuICAgICAgICAgIHN0YXJzUGxhY2VkKys7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vcm1hbCBzaW5nbGUgc3RhclxuICAgICAgICBjb25zdCB0aGV0YSA9IE1hdGgucmFuZG9tKCkgKiAyICogTWF0aC5QSTtcbiAgICAgICAgY29uc3QgcGhpID0gTWF0aC5hY29zKDIgKiBNYXRoLnJhbmRvbSgpIC0gMSk7XG4gICAgICAgIGNvbnN0IHIgPSBNYXRoLnJhbmRvbSgpICogc3Rhck1heERpc3RhbmNlO1xuICAgICAgICBjb25zdCB4ID0gciAqIE1hdGguc2luKHBoaSkgKiBNYXRoLmNvcyh0aGV0YSk7XG4gICAgICAgIGNvbnN0IHkgPSByICogTWF0aC5zaW4ocGhpKSAqIE1hdGguc2luKHRoZXRhKTtcbiAgICAgICAgY29uc3QgeiA9IHIgKiBNYXRoLmNvcyhwaGkpO1xuICAgICAgICBwb3NpdGlvbnMucHVzaCh4LCB5LCB6KTtcbiAgICAgICAgLy8gSWYgY2xvc2UsIGFsc28gYWRkIHRvIGNsb3NlUG9zaXRpb25zXG4gICAgICAgIGlmIChyIDwgNDAwKSB7XG4gICAgICAgICAgY2xvc2VQb3NpdGlvbnMucHVzaCh4LCB5LCB6KTtcbiAgICAgICAgfVxuICAgICAgICBzdGFyc1BsYWNlZCsrO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25zLCAzKSlcbiAgICBpZiAoY2xvc2VQb3NpdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgY2xvc2VHZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoY2xvc2VQb3NpdGlvbnMsIDMpKTtcbiAgICB9XG5cbiAgICAvLyBDUkFaWSBCTE9PTTogQWxsIHN0YXJzIGFyZSBleHRyZW1lbHkgYnJpZ2h0IChjb2xvciBpbnRlbnNpdHkgPjEpXG4gICAgY29uc3QgcGFsZXR0ZSA9IFtcbiAgICAgIFszLjAsIDEuNSwgMS41XSxcbiAgICAgIFszLjAsIDIuMjUsIDEuMl0sXG4gICAgICBbMy4wLCAzLjAsIDIuN10sXG4gICAgICBbMy4wLCAzLjAsIDMuMF0sXG4gICAgICBbMS4yLCAxLjUsIDMuMF0sXG4gICAgXTtcbiAgICBjb25zdCBjb2xvcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXJDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBjID0gcGFsZXR0ZVtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBwYWxldHRlLmxlbmd0aCldO1xuICAgICAgY29sb3JzLnB1c2goLi4uYyk7XG4gICAgfVxuICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnY29sb3InLCBuZXcgVEhSRUUuRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShjb2xvcnMsIDMpKTtcblxuICAgIGNvbnN0IG9yaWdpbmFsQ29sb3JzID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvci5hcnJheS5zbGljZSgpXG4gICAgY29uc3QgdGltZXJzID0gbmV3IEZsb2F0MzJBcnJheShzdGFyQ291bnQpXG4gICAgY29uc3Qgc3BhcmtDb2xvcnMgPSBuZXcgRmxvYXQzMkFycmF5KHN0YXJDb3VudCAqIDMpXG4gICAgY29uc3Qgc3BhcmtsZUR1cmF0aW9uID0gMTgwXG5cbiAgICAvLyAtLS0gU1FVQVJFIFNUQVJTIFVTSU5HIFBPSU5UUyAtLS1cbmNvbnN0IG1hdGVyaWFsID0gbmV3IFRIUkVFLlBvaW50c01hdGVyaWFsKHsgc2l6ZTogMy41LCBzaXplQXR0ZW51YXRpb246IHRydWUsIHZlcnRleENvbG9yczogdHJ1ZSB9KTtcbmNvbnN0IHN0YXJzID0gbmV3IFRIUkVFLlBvaW50cyhnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuc2NlbmUuYWRkKHN0YXJzKTtcbi8vIEFkZCBnbG93IHNwcml0ZXMgdG8gZWFjaCBzdGFyIGFuZCBhbmltYXRlIHRoZW0gYmFzZWQgb24gZGlzdGFuY2VcbmNvbnN0IGdsb3dNYXAgPSBuZXcgVEhSRUUuVGV4dHVyZUxvYWRlcigpLmxvYWQoJ2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9tcmRvb2IvdGhyZWUuanMvbWFzdGVyL2V4YW1wbGVzL3RleHR1cmVzL3Nwcml0ZXMvZ2xvdy5wbmcnKTtcbmNvbnN0IGdsb3dTcHJpdGVzID0gW107XG5jb25zdCBnbG93TWF0ZXJpYWwgPSBuZXcgVEhSRUUuU3ByaXRlTWF0ZXJpYWwoeyBtYXA6IGdsb3dNYXAsIGNvbG9yOiAweGZmZmZmZiwgb3BhY2l0eTogMC4xOCwgYmxlbmRpbmc6IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmcsIGRlcHRoV3JpdGU6IGZhbHNlIH0pO1xuZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFyQ291bnQ7IGkrKykge1xuICBjb25zdCBnbG93ID0gbmV3IFRIUkVFLlNwcml0ZShnbG93TWF0ZXJpYWwuY2xvbmUoKSk7XG4gIGdsb3cucG9zaXRpb24uc2V0KHBvc2l0aW9uc1tpKjNdLCBwb3NpdGlvbnNbaSozKzFdLCBwb3NpdGlvbnNbaSozKzJdKTtcbiAgZ2xvdy5zY2FsZS5zZXQoMTAsIDEwLCAxKTtcbiAgc2NlbmUuYWRkKGdsb3cpO1xuICBnbG93U3ByaXRlcy5wdXNoKGdsb3cpO1xufVxuLy8gQWRkIGNsb3NlIHN0YXJzIHRvIHNlcGFyYXRlIHNjZW5lXG5sZXQgY2xvc2VTdGFycztcbmlmIChjbG9zZVBvc2l0aW9ucy5sZW5ndGggPiAwKSB7XG4gIGNsb3NlU3RhcnMgPSBuZXcgVEhSRUUuUG9pbnRzKGNsb3NlR2VvbWV0cnksIG1hdGVyaWFsLmNsb25lKCkpO1xuICBjbG9zZVN0YXJzU2NlbmUuYWRkKGNsb3NlU3RhcnMpO1xufVxuXG4gICAgbGV0IHRhcmdldFkgPSAwXG4gICAgY29uc3QgZGFtcGluZyA9IDAuMDVcbiAgICBjb25zdCBvblNjcm9sbCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHBjdCA9IHdpbmRvdy5zY3JvbGxZIC8gKGRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0IC0gd2luZG93LmlubmVySGVpZ2h0KVxuICAgICAgdGFyZ2V0WSA9IHBjdCAqIE1hdGguUEkgKiAyXG4gICAgfVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBvblNjcm9sbClcblxuXG4gICAgLy8gLS0tIFNob290aW5nIFN0YXJzIC0tLVxuICAgIGNvbnN0IHRhaWxMZW5ndGggPSAzMjsgLy8gSW5jcmVhc2UgZm9yIGxvbmdlciB0YWlsc1xuICAgIGNvbnN0IHNob290aW5nU3RhcnMgPSBbXTtcbiAgICBsZXQgc2hvb3RpbmdTdGFyQ29vbGRvd24gPSAwO1xuICAgIC8vIFNwYXduIGEgc2hvb3Rpbmcgc3RhciB3aXRoIGEgc3R1bm5pbmcgZ2xvd2luZyB0YWlsXG4gICAgZnVuY3Rpb24gc3Bhd25TaG9vdGluZ1N0YXIoKSB7XG4gICAgICAvLyBQaWNrIGEgcmFuZG9tIGRpcmVjdGlvbiBvbiB0aGUgc3BoZXJlIGZvciB0aGUgc3Bhd24gbG9jYXRpb25cbiAgICAgIGNvbnN0IGRpciA9IG5ldyBUSFJFRS5WZWN0b3IzKE1hdGgucmFuZG9tKCkqMi0xLCBNYXRoLnJhbmRvbSgpKjItMSwgTWF0aC5yYW5kb20oKSoyLTEpLm5vcm1hbGl6ZSgpO1xuICAgICAgLy8gRW5zdXJlIHNob290aW5nIHN0YXJzIG5ldmVyIHNwYXduIGNsb3NlIHRvIHRoZSBjYW1lcmEgKGF0IGxlYXN0IDcwJSBvZiBtYXggZGlzdGFuY2UpXG4gICAgICBjb25zdCBtaW5EaXN0ID0gc3Rhck1heERpc3RhbmNlICogMC43O1xuICAgICAgY29uc3QgbWF4RGlzdCA9IHN0YXJNYXhEaXN0YW5jZSAqIDEuMDtcbiAgICAgIGNvbnN0IGRpc3QgPSBtaW5EaXN0ICsgTWF0aC5yYW5kb20oKSAqIChtYXhEaXN0IC0gbWluRGlzdCk7XG4gICAgICBjb25zdCBzcGF3blBvcyA9IGRpci5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKGRpc3QpO1xuICAgICAgLy8gVGFuZ2VudGlhbCB2ZWxvY2l0eTogcGVycGVuZGljdWxhciB0byBkaXJcbiAgICAgIGxldCB0YW5nZW50ID0gbmV3IFRIUkVFLlZlY3RvcjMoTWF0aC5yYW5kb20oKSoyLTEsIE1hdGgucmFuZG9tKCkqMi0xLCBNYXRoLnJhbmRvbSgpKjItMSk7XG4gICAgICB0YW5nZW50ID0gdGFuZ2VudC5zdWIodGFuZ2VudC5jbG9uZSgpLnByb2plY3RPblZlY3RvcihkaXIpKS5ub3JtYWxpemUoKTtcbiAgICAgIC8vIE1peCBpbiBhIHNtYWxsIHJhZGlhbCBjb21wb25lbnQgKGlud2FyZCBvciBvdXR3YXJkKVxuICAgICAgY29uc3QgdGFuZ2VudGlhbFNwZWVkID0gc3RhclNwZWVkICogKDIuNSArIE1hdGgucmFuZG9tKCkgKiAyLjUpOyAvLyBtdWNoIGZhc3RlclxuICAgICAgY29uc3QgcmFkaWFsU3BlZWQgPSBzdGFyU3BlZWQgKiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAwLjM7IC8vIG1vcmUgZHJhbWF0aWNcbiAgICAgIGNvbnN0IHZlbG9jaXR5ID0gdGFuZ2VudC5tdWx0aXBseVNjYWxhcih0YW5nZW50aWFsU3BlZWQpLmFkZChkaXIuY2xvbmUoKS5tdWx0aXBseVNjYWxhcihyYWRpYWxTcGVlZCkpO1xuXG4gICAgICAvLyBTdHVubmluZyBjb2xvciBncmFkaWVudCBmb3IgdGhlIGhlYWRcbiAgICAgIGNvbnN0IHZpYnJhbnRDb2xvcnMgPSBbMHhmZmUwNjYsIDB4ZmY2NmNjLCAweDY2Y2NmZiwgMHhmZmZmZmYsIDB4ODBmZmVhLCAweGZmZjJjYywgMHhmZmMwODAsIDB4ODBjMGZmLCAweGZmODBiM107XG4gICAgICBjb25zdCBjb2xvciA9IHZpYnJhbnRDb2xvcnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKnZpYnJhbnRDb2xvcnMubGVuZ3RoKV07XG4gICAgICAvLyBTdGFyIGJyaWdodG5lc3MgYW5kIHNpemUgKGFsd2F5cyBzbWFsbCBhbmQgc3VidGxlKVxuICAgICAgY29uc3QgYnJpZ2h0bmVzcyA9IDIuNSArIE1hdGgucmFuZG9tKCkqMS41O1xuICAgICAgY29uc3QgZ2VvID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KDAuNyArIE1hdGgucmFuZG9tKCkqMC41LCAxNiwgMTYpOyAvLyBTbWFsbCBzcGhlcmVcbiAgICAgIGNvbnN0IG1hdCA9IG5ldyBUSFJFRS5NZXNoUGh5c2ljYWxNYXRlcmlhbCh7XG4gICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgZW1pc3NpdmU6IGNvbG9yLFxuICAgICAgICBlbWlzc2l2ZUludGVuc2l0eTogMi41LFxuICAgICAgICBtZXRhbG5lc3M6IDAuNyxcbiAgICAgICAgcm91Z2huZXNzOiAwLjMsXG4gICAgICAgIHRyYW5zbWlzc2lvbjogMC43LFxuICAgICAgICBvcGFjaXR5OiAwLjk4LFxuICAgICAgICB0cmFuc3BhcmVudDogdHJ1ZSxcbiAgICAgICAgY2xlYXJjb2F0OiAwLjgsXG4gICAgICAgIGNsZWFyY29hdFJvdWdobmVzczogMC4yLFxuICAgICAgfSk7XG4gICAgICBjb25zdCBzdGFyID0gbmV3IFRIUkVFLk1lc2goZ2VvLCBtYXQpO1xuICAgICAgLy8gQWRkIGEgZ2xvd2luZyBzcHJpdGUgZm9yIGV4dHJhIGdsb3dcbiAgICAgIGNvbnN0IHNwcml0ZU1hcCA9IG5ldyBUSFJFRS5UZXh0dXJlTG9hZGVyKCkubG9hZCgnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL21yZG9vYi90aHJlZS5qcy9tYXN0ZXIvZXhhbXBsZXMvdGV4dHVyZXMvc3ByaXRlcy9nbG93LnBuZycpO1xuICAgICAgY29uc3Qgc3ByaXRlTWF0ZXJpYWwgPSBuZXcgVEhSRUUuU3ByaXRlTWF0ZXJpYWwoeyBtYXA6IHNwcml0ZU1hcCwgY29sb3I6IGNvbG9yLCBvcGFjaXR5OiAwLjgsIGJsZW5kaW5nOiBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nIH0pO1xuICAgICAgY29uc3Qgc3ByaXRlID0gbmV3IFRIUkVFLlNwcml0ZShzcHJpdGVNYXRlcmlhbCk7XG4gICAgICBzcHJpdGUuc2NhbGUuc2V0KDMwLCAzMCwgMSk7XG4gICAgICBzcHJpdGUucG9zaXRpb24uY29weShzdGFyLnBvc2l0aW9uKTtcbiAgICAgIHN0YXIuYWRkKHNwcml0ZSk7XG4gICAgICAvLyBBZGQgZHluYW1pYyBzcGFyayBidXJzdCBhdCB0aGUgaGVhZFxuICAgICAgY29uc3Qgc3BhcmtDb3VudCA9IDE4ICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKjgpO1xuICAgICAgY29uc3Qgc3BhcmtHcm91cCA9IG5ldyBUSFJFRS5Hcm91cCgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGFya0NvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3Qgc3BhcmtNYXQgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoeyBjb2xvcjogdmlicmFudENvbG9yc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqdmlicmFudENvbG9ycy5sZW5ndGgpXSwgdHJhbnNwYXJlbnQ6IHRydWUsIG9wYWNpdHk6IDAuOCB9KTtcbiAgICAgICAgY29uc3Qgc3BhcmtHZW8gPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoMC4wNyArIE1hdGgucmFuZG9tKCkqMC4wNiwgOCwgOCk7XG4gICAgICAgIGNvbnN0IHNwYXJrID0gbmV3IFRIUkVFLk1lc2goc3BhcmtHZW8sIHNwYXJrTWF0KTtcbiAgICAgICAgY29uc3QgYW5nbGUgPSAoaSAvIHNwYXJrQ291bnQpICogTWF0aC5QSSAqIDI7XG4gICAgICAgIHNwYXJrLnBvc2l0aW9uLnNldChNYXRoLmNvcyhhbmdsZSkqMS4yLCBNYXRoLnNpbihhbmdsZSkqMS4yLCBNYXRoLnJhbmRvbSgpKjAuNC0wLjIpO1xuICAgICAgICBzcGFya0dyb3VwLmFkZChzcGFyayk7XG4gICAgICB9XG4gICAgICBzcGFya0dyb3VwLm5hbWUgPSAnc3BhcmtCdXJzdCc7XG4gICAgICBzdGFyLmFkZChzcGFya0dyb3VwKTtcbiAgICAgIHN0YXIucG9zaXRpb24uY29weShzcGF3blBvcyk7XG4gICAgICBzdGFyLnZlbG9jaXR5ID0gdmVsb2NpdHk7XG4gICAgICBzdGFyLm5vcm1hbGl6ZWRMaWZlID0gMC4wO1xuICAgICAgc3Rhci5ub3JtYWxpemVkTGlmZXRpbWUgPSA4MCArIE1hdGgucmFuZG9tKCkgKiA4MDsgLy8gTG9uZ2VyLCBtb3JlIGRyYW1hdGljXG4gICAgICBzdGFyLmFnZSA9IDA7XG4gICAgICAvLyAtLS0gU3R1bm5pbmcgTWV0ZW9yIFRhaWwgKHZlcnkgbG9uZywgbXVsdGktY29sb3IsIGdsb3dpbmcsIGZhZGluZywgYW5kIDNEIGN1cnZlKSAtLS1cbiAgICAgIGNvbnN0IHRyYWlsU2VnbWVudHMgPSB0YWlsTGVuZ3RoICogMzsgLy8gRXZlbiBsb25nZXIgdGFpbFxuICAgICAgY29uc3QgdHJhaWxQb2ludHMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhaWxTZWdtZW50czsgaSsrKSB7XG4gICAgICAgIC8vIEFkZCBhIDNEIHNwaXJhbC9jdXJ2ZSBmb3IgbW9yZSBkZXB0aFxuICAgICAgICBjb25zdCBzcGlyYWwgPSBNYXRoLnNpbihpICogMC4yNSkgKiA4O1xuICAgICAgICBjb25zdCBjdXJ2ZSA9IE1hdGguY29zKGkgKiAwLjE1KSAqIDQ7XG4gICAgICAgIGNvbnN0IHB0ID0gc3Rhci5wb3NpdGlvbi5jbG9uZSgpLmFkZChuZXcgVEhSRUUuVmVjdG9yMyhzcGlyYWwsIGN1cnZlLCAtaSAqIDMpKTtcbiAgICAgICAgdHJhaWxQb2ludHMucHVzaChwdCk7XG4gICAgICB9XG4gICAgICBjb25zdCB0YWlsR2VvID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCkuc2V0RnJvbVBvaW50cyh0cmFpbFBvaW50cyk7XG4gICAgICAvLyBQZXItdmVydGV4IGNvbG9yIChtdWx0aS1jb2xvciByYWluYm93IGdyYWRpZW50KVxuICAgICAgY29uc3QgdGFpbENvbG9ycyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFpbFNlZ21lbnRzOyBpKyspIHtcbiAgICAgICAgLy8gQWxwaGEgZmFkZXMgb3V0IGFsb25nIHRoZSB0YWlsXG4gICAgICAgIGNvbnN0IGFscGhhID0gKDEgLSBpIC8gKHRyYWlsU2VnbWVudHMgLSAxKSkgKiAwLjk5O1xuICAgICAgICAvLyBSYWluYm93IGdyYWRpZW50XG4gICAgICAgIGNvbnN0IHJhaW5ib3cgPSBbMHhmZmUwNjYsIDB4ZmY2NmNjLCAweDY2Y2NmZiwgMHhmZmZmZmYsIDB4ODBmZmVhLCAweGZmZjJjYywgMHhmZmMwODAsIDB4ODBjMGZmLCAweGZmODBiM107XG4gICAgICAgIGNvbnN0IGdyYWRDb2xvciA9IHJhaW5ib3dbTWF0aC5mbG9vcigoaSAvIHRyYWlsU2VnbWVudHMpICogcmFpbmJvdy5sZW5ndGgpXTtcbiAgICAgICAgdGFpbENvbG9ycy5wdXNoKChncmFkQ29sb3IgPj4gMTYgJiAyNTUpIC8gMjU1LCAoZ3JhZENvbG9yID4+IDggJiAyNTUpIC8gMjU1LCAoZ3JhZENvbG9yICYgMjU1KSAvIDI1NSwgYWxwaGEpO1xuICAgICAgfVxuICAgICAgdGFpbEdlby5zZXRBdHRyaWJ1dGUoJ2NvbG9yJywgbmV3IFRIUkVFLkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodGFpbENvbG9ycywgNCkpO1xuICAgICAgLy8gQWRkaXRpdmUgYmxlbmRpbmcgZm9yIGdsb3cgKyBCTE9PTUVEIFRBSUxcbiAgICAgIGNvbnN0IHRhaWxNYXQgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoeyB2ZXJ0ZXhDb2xvcnM6IHRydWUsIHRyYW5zcGFyZW50OiB0cnVlLCBvcGFjaXR5OiAxLjAsIGJsZW5kaW5nOiBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nIH0pO1xuICAgICAgY29uc3QgdGFpbCA9IG5ldyBUSFJFRS5MaW5lKHRhaWxHZW8sIHRhaWxNYXQpO1xuICAgICAgdGFpbC5wb3NpdGlvbi5jb3B5KHN0YXIucG9zaXRpb24pO1xuICAgICAgLy8gQWRkIGEgYmxvb20gc3ByaXRlIHRvIHRoZSB0YWlsJ3MgaGVhZCBmb3IgZXh0cmEgZ2xvd1xuICAgICAgY29uc3QgdGFpbEdsb3dNYXAgPSBuZXcgVEhSRUUuVGV4dHVyZUxvYWRlcigpLmxvYWQoJ2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9tcmRvb2IvdGhyZWUuanMvbWFzdGVyL2V4YW1wbGVzL3RleHR1cmVzL3Nwcml0ZXMvZ2xvdy5wbmcnKTtcbiAgICAgIGNvbnN0IHRhaWxHbG93TWF0ID0gbmV3IFRIUkVFLlNwcml0ZU1hdGVyaWFsKHsgbWFwOiB0YWlsR2xvd01hcCwgY29sb3I6IGNvbG9yLCBvcGFjaXR5OiAwLjg1LCBibGVuZGluZzogVEhSRUUuQWRkaXRpdmVCbGVuZGluZyB9KTtcbiAgICAgIGNvbnN0IHRhaWxHbG93ID0gbmV3IFRIUkVFLlNwcml0ZSh0YWlsR2xvd01hdCk7XG4gICAgICB0YWlsR2xvdy5zY2FsZS5zZXQoMjIsIDIyLCAxKTtcbiAgICAgIHRhaWxHbG93LnBvc2l0aW9uLmNvcHkoc3Rhci5wb3NpdGlvbik7XG4gICAgICBzdGFyLmFkZCh0YWlsR2xvdyk7IC8vIEF0dGFjaCB0byBzdGFyIHNvIGl0IGZvbGxvd3MgaGVhZFxuICAgICAgLy8gQWRkIHRvIHNjZW5lXG4gICAgICBzY2VuZS5hZGQoc3Rhcik7XG4gICAgICBzY2VuZS5hZGQodGFpbCk7XG4gICAgICBzaG9vdGluZ1N0YXJzLnB1c2goeyBtZXNoOiBzdGFyLCB0YWlsLCB2ZWxvY2l0eTogc3Rhci52ZWxvY2l0eSwgZGlyLCBhZ2U6IDAsIG5vcm1hbGl6ZWRMaWZldGltZTogc3Rhci5ub3JtYWxpemVkTGlmZXRpbWUsIHRyYWlsUG9pbnRzLCBjb2xvciwgYnJpZ2h0bmVzcywgaGFzRnJhZ21lbnRlZDogZmFsc2UgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgYW5pbWF0ZSA9ICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG4gICAgICAvLyBSZW5kZXIgbWFpbiBzY2VuZSB3aXRoIGJsb29tXG4gICAgICBjb21wb3Nlci5yZW5kZXIoKTtcbiAgICAgIC8vIE92ZXJsYXkgY2xvc2Ugc3RhcnMgd2l0aCBjaHJvbWF0aWMgYWJlcnJhdGlvbiAob25seSBjbG9zZSBzdGFycyBnZXQgQ0EpXG4gICAgICBpZiAoY2xvc2VTdGFycykge1xuICAgICAgICBjYUNvbXBvc2VyLnJlbmRlcigpO1xuICAgICAgfVxuXG4gICAgICBjYW1lcmEucm90YXRpb24ueSArPSAodGFyZ2V0WSAtIGNhbWVyYS5yb3RhdGlvbi55KSAqIGRhbXBpbmc7XG4gICAgICAvLyBNb3ZlIHRoZSB2aXJ0dWFsIGNhbWVyYSBwb3NpdGlvbiBpbiB0aGUgZGlyZWN0aW9uIHRoZSBjYW1lcmEgaXMgZmFjaW5nXG4gICAgICBjb25zdCBmb3J3YXJkID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgIGNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihmb3J3YXJkKTtcbiAgICAgIHZpcnR1YWxDYW1lcmFQb3MuYWRkKGZvcndhcmQubXVsdGlwbHlTY2FsYXIoc3RhclNwZWVkKSk7XG4gICAgICAvLyBPZmZzZXQgYWxsIHN0YXJzIGJ5IC12aXJ0dWFsQ2FtZXJhUG9zIChmbG9hdGluZyBvcmlnaW4pXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc2l0aW9ucy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5W2ldID0gcG9zaXRpb25zW2ldIC0gdmlydHVhbENhbWVyYVBvcy54O1xuICAgICAgICBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5W2krMV0gPSBwb3NpdGlvbnNbaSsxXSAtIHZpcnR1YWxDYW1lcmFQb3MueTtcbiAgICAgICAgZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheVtpKzJdID0gcG9zaXRpb25zW2krMl0gLSB2aXJ0dWFsQ2FtZXJhUG9zLno7XG4gICAgICAgIC8vIEFuaW1hdGUgZ2xvdyBzcHJpdGUgZm9yIGRpc3RhbnQvY2xvc2UgZWZmZWN0XG4gICAgICAgIGNvbnN0IGdsb3cgPSBnbG93U3ByaXRlc1tpLzNdO1xuICAgICAgICBjb25zdCBzdGFyUG9zID0gbmV3IFRIUkVFLlZlY3RvcjMocG9zaXRpb25zW2ldIC0gdmlydHVhbENhbWVyYVBvcy54LCBwb3NpdGlvbnNbaSsxXSAtIHZpcnR1YWxDYW1lcmFQb3MueSwgcG9zaXRpb25zW2krMl0gLSB2aXJ0dWFsQ2FtZXJhUG9zLnopO1xuICAgICAgICBjb25zdCBkaXN0ID0gc3RhclBvcy5sZW5ndGgoKTtcbiAgICAgICAgLy8gSWYgY2xvc2UsIHJlZHVjZS9oaWRlIGdsb3csIGlmIGZhciwgbWFrZSBnbG93IGJpZyBhbmQgYnJpZ2h0XG4gICAgICAgIGlmIChkaXN0IDwgNDAwKSB7XG4gICAgICAgICAgZ2xvdy5tYXRlcmlhbC5vcGFjaXR5ID0gMC4wNiArIDAuMDggKiBNYXRoLnJhbmRvbSgpOyAvLyBzdWJ0bGUgZmxpY2tlclxuICAgICAgICAgIGdsb3cuc2NhbGUuc2V0KDcsIDcsIDEpO1xuICAgICAgICB9IGVsc2UgaWYgKGRpc3QgPiAxMjAwKSB7XG4gICAgICAgICAgZ2xvdy5tYXRlcmlhbC5vcGFjaXR5ID0gMC4zOCArIDAuMTggKiBNYXRoLnJhbmRvbSgpOyAvLyBpbnRlbnNlXG4gICAgICAgICAgZ2xvdy5zY2FsZS5zZXQoMzIsIDMyLCAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpbnRlcnBvbGF0ZVxuICAgICAgICAgIGNvbnN0IHQgPSAoZGlzdC00MDApLygxMjAwLTQwMCk7XG4gICAgICAgICAgZ2xvdy5tYXRlcmlhbC5vcGFjaXR5ID0gMC4wOCArIDAuMyp0ICsgMC4wOCAqIE1hdGgucmFuZG9tKCk7XG4gICAgICAgICAgY29uc3QgcyA9IDcgKyAoMzItNykqdDtcbiAgICAgICAgICBnbG93LnNjYWxlLnNldChzLCBzLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBnbG93LnBvc2l0aW9uLmNvcHkoc3RhclBvcyk7XG4gICAgICB9XG4gICAgICBpZiAoY2xvc2VTdGFycyAmJiBjbG9zZUdlb21ldHJ5ICYmIGNsb3NlUG9zaXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbG9zZVBvc2l0aW9ucy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgIGNsb3NlR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheVtpXSA9IGNsb3NlUG9zaXRpb25zW2ldIC0gdmlydHVhbENhbWVyYVBvcy54O1xuICAgICAgICAgIGNsb3NlR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheVtpKzFdID0gY2xvc2VQb3NpdGlvbnNbaSsxXSAtIHZpcnR1YWxDYW1lcmFQb3MueTtcbiAgICAgICAgICBjbG9zZUdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXlbaSsyXSA9IGNsb3NlUG9zaXRpb25zW2krMl0gLSB2aXJ0dWFsQ2FtZXJhUG9zLno7XG4gICAgICAgIH1cbiAgICAgICAgY2xvc2VHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICAvLyAtLS0gU2hvb3Rpbmcgc3RhciBzcGF3bmluZyAtLS1cbiAgICAgIGlmIChzaG9vdGluZ1N0YXJDb29sZG93biA8PSAwICYmIE1hdGgucmFuZG9tKCkgPCAwLjEpIHtcbiAgICAgICAgc3Bhd25TaG9vdGluZ1N0YXIoKTtcbiAgICAgICAgaWYgKGNhbWVyYSkge1xuICAgICAgICAgIGNvbnN0IHNoYWtlU3RyZW5ndGggPSAwLjA2ICsgTWF0aC5yYW5kb20oKSowLjA0O1xuICAgICAgICAgIGNhbWVyYS5wb3NpdGlvbi54ICs9IChNYXRoLnJhbmRvbSgpLTAuNSkqc2hha2VTdHJlbmd0aDtcbiAgICAgICAgICBjYW1lcmEucG9zaXRpb24ueSArPSAoTWF0aC5yYW5kb20oKS0wLjUpKnNoYWtlU3RyZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgc2hvb3RpbmdTdGFyQ29vbGRvd24gPSAxMCArIE1hdGgucmFuZG9tKCkgKiAxMDtcbiAgICAgIH0gZWxzZSBpZiAoc2hvb3RpbmdTdGFyQ29vbGRvd24gPiAwKSB7XG4gICAgICAgIHNob290aW5nU3RhckNvb2xkb3duLS07XG4gICAgICB9XG4gICAgICAvLyBBbmltYXRlIGFuZCBjbGVhbiB1cCBzaG9vdGluZyBzdGFyc1xuICAgICAgZm9yIChsZXQgaSA9IHNob290aW5nU3RhcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3Qgb2JqID0gc2hvb3RpbmdTdGFyc1tpXTtcbiAgICAgICAgLy8gQW5pbWF0ZSBzcGFyayBidXJzdCAoZmFkZSBhbmQgZXhwYW5kKVxuICAgICAgICBpZiAob2JqLm1lc2guY2hpbGRyZW4pIHtcbiAgICAgICAgICBjb25zdCBzcGFya3MgPSBvYmoubWVzaC5jaGlsZHJlbi5maW5kKGNoaWxkID0+IGNoaWxkLm5hbWUgPT09ICdzcGFya0J1cnN0Jyk7XG4gICAgICAgICAgaWYgKHNwYXJrcykge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzcGFya3MuY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgY29uc3Qgc3BhcmsgPSBzcGFya3MuY2hpbGRyZW5bal07XG4gICAgICAgICAgICAgIHNwYXJrLm1hdGVyaWFsLm9wYWNpdHkgKj0gMC45NjsgLy8gRmFkZVxuICAgICAgICAgICAgICBzcGFyay5zY2FsZS5tdWx0aXBseVNjYWxhcigxLjAzKTsgLy8gRXhwYW5kXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFuaW1hdGUgdGFpbCBzaGltbWVyIGFuZCBjb2xvciBjeWNsaW5nXG4gICAgICAgIGlmIChvYmoudGFpbCAmJiBvYmoudHJhaWxQb2ludHMpIHtcbiAgICAgICAgICBjb25zdCB0aW1lID0gcGVyZm9ybWFuY2Uubm93KCkgKiAwLjAwMTtcbiAgICAgICAgICBjb25zdCB0YWlsR2VvID0gb2JqLnRhaWwuZ2VvbWV0cnk7XG4gICAgICAgICAgY29uc3QgdGFpbENvbG9ycyA9IHRhaWxHZW8uZ2V0QXR0cmlidXRlKCdjb2xvcicpO1xuICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgdGFpbENvbG9ycy5jb3VudDsgaysrKSB7XG4gICAgICAgICAgICAvLyBDeWNsZSBodWVcbiAgICAgICAgICAgIGxldCByID0gdGFpbENvbG9ycy5nZXRYKGspLCBnID0gdGFpbENvbG9ycy5nZXRZKGspLCBiID0gdGFpbENvbG9ycy5nZXRaKGspO1xuICAgICAgICAgICAgLy8gQ29udmVydCB0byBIU0xcbiAgICAgICAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KHIsZyxiKSwgbWluID0gTWF0aC5taW4ocixnLGIpO1xuICAgICAgICAgICAgbGV0IGgscyxsO1xuICAgICAgICAgICAgbCA9IChtYXgrbWluKS8yO1xuICAgICAgICAgICAgaWYgKG1heCA9PT0gbWluKSB7aCA9IHMgPSAwO30gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnN0IGQgPSBtYXgtbWluO1xuICAgICAgICAgICAgICBzID0gbCA+IDAuNSA/IGQvKDItbWF4LW1pbikgOiBkLyhtYXgrbWluKTtcbiAgICAgICAgICAgICAgc3dpdGNoKG1heCl7XG4gICAgICAgICAgICAgICAgY2FzZSByOiBoID0gKGctYikvZCArIChnPGI/NjowKTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBnOiBoID0gKGItcikvZCArIDI7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgYjogaCA9IChyLWcpL2QgKyA0OyBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBoLz02O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaCA9IChoICsgMC4yNSpNYXRoLnNpbih0aW1lICsgayowLjIpKSAlIDEuMDsgLy8gQW5pbWF0ZSBodWVcbiAgICAgICAgICAgIC8vIENvbnZlcnQgYmFjayB0byBSR0JcbiAgICAgICAgICAgIGxldCBxID0gbCA8IDAuNSA/IGwqKDErcykgOiBsK3MtbCpzO1xuICAgICAgICAgICAgbGV0IHAgPSAyKmwtcTtcbiAgICAgICAgICAgIGxldCB0ciA9IGgrMS8zLCB0ZyA9IGgsIHRiID0gaC0xLzM7XG4gICAgICAgICAgICBjb25zdCBodWUycmdiID0gKHAscSx0KSA9PiB7XG4gICAgICAgICAgICAgIGlmICh0PDApIHQrPTE7IGlmICh0PjEpIHQtPTE7XG4gICAgICAgICAgICAgIGlmICh0PDEvNikgcmV0dXJuIHArKHEtcCkqNip0O1xuICAgICAgICAgICAgICBpZiAodDwxLzIpIHJldHVybiBxO1xuICAgICAgICAgICAgICBpZiAodDwyLzMpIHJldHVybiBwKyhxLXApKigyLzMtdCkqNjtcbiAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGFpbENvbG9ycy5zZXRYKGssIGh1ZTJyZ2IocCxxLHRyKSk7XG4gICAgICAgICAgICB0YWlsQ29sb3JzLnNldFkoaywgaHVlMnJnYihwLHEsdGcpKTtcbiAgICAgICAgICAgIHRhaWxDb2xvcnMuc2V0WihrLCBodWUycmdiKHAscSx0YikpO1xuICAgICAgICAgICAgLy8gU2hpbW1lcjogbW9kdWxhdGUgYWxwaGFcbiAgICAgICAgICAgIHRhaWxDb2xvcnMuc2V0VyhrLCB0YWlsQ29sb3JzLmdldFcoaykgKiAoMC45NyArIDAuMDMqTWF0aC5zaW4odGltZSo4ICsgaykpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGFpbENvbG9ycy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RyYWlnaHQtbGluZSB0cmFqZWN0b3J5XG4gICAgICAgIG9iai5tZXNoLnBvc2l0aW9uLmFkZChvYmoudmVsb2NpdHkpO1xuICAgICAgICBvYmoudGFpbC5wb3NpdGlvbi5jb3B5KG9iai5tZXNoLnBvc2l0aW9uKTtcbiAgICAgICAgLy8gQW5pbWF0ZSB0YWlsIChubyBsZXJwLCBqdXN0IGRyYWcpXG4gICAgICAgIG9iai5hZ2UrKztcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZExpZmUgPSBvYmouYWdlIC8gb2JqLm5vcm1hbGl6ZWRMaWZldGltZTtcbiAgICAgICAgb2JqLnRyYWlsUG9pbnRzLnVuc2hpZnQob2JqLm1lc2gucG9zaXRpb24uY2xvbmUoKSk7XG4gICAgICAgIGlmIChvYmoudHJhaWxQb2ludHMubGVuZ3RoID4gdGFpbExlbmd0aCAqIDMpIG9iai50cmFpbFBvaW50cy5wb3AoKTtcbiAgICAgICAgbGV0IHRhaWxHcm93ID0gTWF0aC5taW4oMSwgbm9ybWFsaXplZExpZmUgLyAwLjMpO1xuICAgICAgICBsZXQgYWN0aXZlU2VnbWVudHMgPSBNYXRoLmZsb29yKG9iai50cmFpbFBvaW50cy5sZW5ndGggKiB0YWlsR3Jvdyk7XG4gICAgICAgIGlmIChhY3RpdmVTZWdtZW50cyA8IDIpIGFjdGl2ZVNlZ21lbnRzID0gMjtcbiAgICAgICAgY29uc3QgdmlzaWJsZVRyYWlsID0gb2JqLnRyYWlsUG9pbnRzLnNsaWNlKDAsIGFjdGl2ZVNlZ21lbnRzKTtcbiAgICAgICAgb2JqLnRhaWwuZ2VvbWV0cnkuc2V0RnJvbVBvaW50cyh2aXNpYmxlVHJhaWwpO1xuICAgICAgICBjb25zdCB0YWlsQ29sb3JzID0gb2JqLnRhaWwuZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCdjb2xvcicpO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZpc2libGVUcmFpbC5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGxldCBhbHBoYSA9ICgxIC0gaiAvICh2aXNpYmxlVHJhaWwubGVuZ3RoIC0gMSkpICogMC45NTtcbiAgICAgICAgICBhbHBoYSAqPSAwLjkyICsgMC4wOCAqIE1hdGguc2luKERhdGUubm93KCkqMC4wMTUgKyBqKjAuNSk7XG4gICAgICAgICAgbGV0IHJhaW5ib3cgPSBbMHhmZmMwODAsIDB4ZmZlMDgwLCAweGZmZmY4MCwgMHg4MGZmZTYsIDB4ODBjMGZmLCAweGMwODBmZl07XG4gICAgICAgICAgbGV0IGdyYWRDb2xvciA9IHJhaW5ib3dbaiAlIHJhaW5ib3cubGVuZ3RoXTtcbiAgICAgICAgICBpZiAobm9ybWFsaXplZExpZmUgPiAwLjcpIGFscGhhICo9IE1hdGgubWF4KDAsIDEgLSAobm9ybWFsaXplZExpZmUgLSAwLjcgLSAwLjIpIC8gMC4zKTtcbiAgICAgICAgICB0YWlsQ29sb3JzLnNldFhZWlcoaiwgKGdyYWRDb2xvciA+PiAxNiAmIDI1NSkgLyAyNTUsIChncmFkQ29sb3IgPj4gOCAmIDI1NSkgLyAyNTUsIChncmFkQ29sb3IgJiAyNTUpIC8gMjU1LCBhbHBoYSk7XG4gICAgICAgIH1cbiAgICAgICAgdGFpbENvbG9ycy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIC8vIEFuaW1hdGUgaGVhZFxuICAgICAgICBsZXQgaGVhZENvbG9yO1xuICAgICAgICBpZiAobm9ybWFsaXplZExpZmUgPCAwLjUpIHtcbiAgICAgICAgICBoZWFkQ29sb3IgPSBuZXcgVEhSRUUuQ29sb3Iob2JqLmNvbG9yKS5sZXJwKG5ldyBUSFJFRS5Db2xvcigweGZmYzA4MCksIG5vcm1hbGl6ZWRMaWZlKjIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhlYWRDb2xvciA9IG5ldyBUSFJFRS5Db2xvcigweGZmYzA4MCkubGVycChuZXcgVEhSRUUuQ29sb3IoMHhmZjQwMDApLCAobm9ybWFsaXplZExpZmUtMC41KSoyKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZmxpY2tlciA9IDAuOTUgKyAwLjEzICogTWF0aC5zaW4oRGF0ZS5ub3coKSowLjA3ICsgTWF0aC5yYW5kb20oKSoxMCk7XG4gICAgICAgIGhlYWRDb2xvci5tdWx0aXBseVNjYWxhcihmbGlja2VyKTtcbiAgICAgICAgb2JqLm1lc2gubWF0ZXJpYWwuY29sb3IuY29weShoZWFkQ29sb3IpO1xuICAgICAgICBsZXQgc2NhbGUgPSAxICsgMi4yICogTWF0aC5zaW4oTWF0aC5QSSAqIG5vcm1hbGl6ZWRMaWZlKTtcbiAgICAgICAgbGV0IGRpc3RUb0NhbSA9IG9iai5tZXNoLnBvc2l0aW9uLmxlbmd0aCgpO1xuICAgICAgICBsZXQgZG9mQmx1ciA9IGRpc3RUb0NhbSA8IHN0YXJNYXhEaXN0YW5jZSAqIDAuNyA/IDAuNyA6IDEuMDtcbiAgICAgICAgb2JqLm1lc2guc2NhbGUuc2V0KHNjYWxlICogZG9mQmx1ciwgc2NhbGUgKiBkb2ZCbHVyLCBzY2FsZSAqIGRvZkJsdXIpO1xuICAgICAgICAvLyBTcGFya2xlIGJ1cnN0XG4gICAgICAgIGlmIChub3JtYWxpemVkTGlmZSA+PSAxICYmICFvYmouaGFzRnJhZ21lbnRlZCkge1xuICAgICAgICAgIC8vIC0tLSBTUEVDVEFDVUxBUiBFWFBMT1NJT04gKHZlcnkgcmFyZSkgLS0tXG4gICAgICAgICAgY29uc3Qgc3BlY3RhY3VsYXIgPSBNYXRoLnJhbmRvbSgpIDwgMC4wMjsgLy8gMiUgY2hhbmNlXG4gICAgICAgICAgY29uc3QgYnVyc3RDb3VudCA9IHNwZWN0YWN1bGFyID8gMTIwICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKjYwKSA6IDE4ICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKjgpO1xuICAgICAgICAgIGNvbnN0IHBhbGV0dGUgPSBzcGVjdGFjdWxhclxuICAgICAgICAgICAgPyBbMHhmZmUwNjYsIDB4ZmY2NmNjLCAweDY2Y2NmZiwgMHhmZmZmZmYsIDB4ODBmZmVhLCAweGZmZjJjYywgMHhmZmMwODAsIDB4ODBjMGZmLCAweGZmODBiMywgMHhmZjAwMDAsIDB4MDBmZjAwLCAweDAwMDBmZiwgMHhmZmZmMDAsIDB4MDBmZmZmLCAweGZmMDBmZiwgMHhmZjg4MDAsIDB4MDBmZjg4LCAweDg4MDBmZl1cbiAgICAgICAgICAgIDogWzB4ZmZmZmZmLCAweGZmZjZjMCwgMHhmZmUwNjYsIDB4ZmZjMDgwLCAweDgwYzBmZl07XG4gICAgICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCBidXJzdENvdW50OyBzKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gcGFsZXR0ZVtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqcGFsZXR0ZS5sZW5ndGgpXTtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBzcGVjdGFjdWxhciA/ICgxLjIgKyBNYXRoLnJhbmRvbSgpKjIuMikgOiAoMC43ICsgTWF0aC5yYW5kb20oKSowLjgpO1xuICAgICAgICAgICAgY29uc3Qgc3BhcmtsZUdlbyA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeShzaXplLCA4LCA4KTtcbiAgICAgICAgICAgIGNvbnN0IHNwYXJrbGVNYXQgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoeyBjb2xvciwgdHJhbnNwYXJlbnQ6IHRydWUsIG9wYWNpdHk6IHNwZWN0YWN1bGFyID8gMC45MiA6IDAuNywgYmxlbmRpbmc6IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmcgfSk7XG4gICAgICAgICAgICBjb25zdCBzcGFya2xlID0gbmV3IFRIUkVFLk1lc2goc3BhcmtsZUdlbywgc3BhcmtsZU1hdCk7XG4gICAgICAgICAgICBzcGFya2xlLnBvc2l0aW9uLmNvcHkob2JqLm1lc2gucG9zaXRpb24pO1xuICAgICAgICAgICAgLy8gU3BlY3RhY3VsYXI6IGh1Z2UsIGZhc3QsIHJhbmRvbSBkaXJlY3Rpb25zOyBub3JtYWw6IG1vZGVyYXRlXG4gICAgICAgICAgICBjb25zdCBzcGQgPSBzcGVjdGFjdWxhciA/ICg0ICsgTWF0aC5yYW5kb20oKSo4KSA6ICgyICsgTWF0aC5yYW5kb20oKSoyKTtcbiAgICAgICAgICAgIGNvbnN0IHNwYXJrbGVWZWwgPSBuZXcgVEhSRUUuVmVjdG9yMyhNYXRoLnJhbmRvbSgpLTAuNSwgTWF0aC5yYW5kb20oKS0wLjUsIE1hdGgucmFuZG9tKCktMC41KS5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhcihzcGQpO1xuICAgICAgICAgICAgc3BhcmtsZS51c2VyRGF0YSA9IHsgdmVsb2NpdHk6IHNwYXJrbGVWZWwsIGFnZTogMCwgc3BlY3RhY3VsYXIsIG1heEFnZTogc3BlY3RhY3VsYXIgPyA4MCArIE1hdGgucmFuZG9tKCkqNDAgOiA0MCArIE1hdGgucmFuZG9tKCkqMjAgfTsgLy8gPC0tIExPTkdFUiBMSUZFXG4gICAgICAgICAgICBzY2VuZS5hZGQoc3BhcmtsZSk7XG4gICAgICAgICAgICBpZiAoIXdpbmRvdy5fc3BhcmtsZXMpIHdpbmRvdy5fc3BhcmtsZXMgPSBbXTtcbiAgICAgICAgICAgIHdpbmRvdy5fc3BhcmtsZXMucHVzaChzcGFya2xlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNwZWN0YWN1bGFyKSB7XG4gICAgICAgICAgICAvLyBBZGQgYSBiaWcgZmxhc2hcbiAgICAgICAgICAgIGNvbnN0IGZsYXNoR2VvID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KDYsIDI0LCAyNCk7XG4gICAgICAgICAgICBjb25zdCBmbGFzaE1hdCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7IGNvbG9yOiAweGZmZmZmZiwgdHJhbnNwYXJlbnQ6IHRydWUsIG9wYWNpdHk6IDAuOCwgYmxlbmRpbmc6IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmcgfSk7XG4gICAgICAgICAgICBjb25zdCBmbGFzaCA9IG5ldyBUSFJFRS5NZXNoKGZsYXNoR2VvLCBmbGFzaE1hdCk7XG4gICAgICAgICAgICBmbGFzaC5wb3NpdGlvbi5jb3B5KG9iai5tZXNoLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIHNjZW5lLmFkZChmbGFzaCk7XG4gICAgICAgICAgICBpZiAoIXdpbmRvdy5fc3RhckZsYXNoZXMpIHdpbmRvdy5fc3RhckZsYXNoZXMgPSBbXTtcbiAgICAgICAgICAgIHdpbmRvdy5fc3RhckZsYXNoZXMucHVzaCh7IG1lc2g6IGZsYXNoLCBhZ2U6IDAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEZyYWdtZW50ZWQgdHJhaWwgbG9naWMgKGtlZXAgYXMgYmVmb3JlKVxuICAgICAgICAgIGNvbnN0IGZyYWdWZWwgPSBvYmoudmVsb2NpdHkuY2xvbmUoKS5hcHBseUF4aXNBbmdsZShuZXcgVEhSRUUuVmVjdG9yMygwLDEsMCksIChNYXRoLnJhbmRvbSgpLTAuNSkqMC4zKTtcbiAgICAgICAgICBjb25zdCBmcmFnU3RhciA9IG9iai5tZXNoLmNsb25lKCk7XG4gICAgICAgICAgZnJhZ1N0YXIucG9zaXRpb24uY29weShvYmoubWVzaC5wb3NpdGlvbik7XG4gICAgICAgICAgZnJhZ1N0YXIudmVsb2NpdHkgPSBmcmFnVmVsO1xuICAgICAgICAgIGZyYWdTdGFyLm5vcm1hbGl6ZWRMaWZlID0gbm9ybWFsaXplZExpZmU7XG4gICAgICAgICAgZnJhZ1N0YXIubm9ybWFsaXplZExpZmV0aW1lID0gb2JqLm5vcm1hbGl6ZWRMaWZldGltZSAqICgwLjUgKyBNYXRoLnJhbmRvbSgpKjAuNSk7XG4gICAgICAgICAgZnJhZ1N0YXIuYWdlID0gb2JqLmFnZTtcbiAgICAgICAgICBmcmFnU3Rhci5tYXRlcmlhbCA9IG9iai5tZXNoLm1hdGVyaWFsLmNsb25lKCk7XG4gICAgICAgICAgY29uc3QgZnJhZ1RyYWlsUG9pbnRzID0gb2JqLnRyYWlsUG9pbnRzLnNsaWNlKCk7XG4gICAgICAgICAgY29uc3QgZnJhZ1RhaWxHZW8gPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKS5zZXRGcm9tUG9pbnRzKGZyYWdUcmFpbFBvaW50cyk7XG4gICAgICAgICAgZnJhZ1RhaWxHZW8uc2V0QXR0cmlidXRlKCdjb2xvcicsIG9iai50YWlsLmdlb21ldHJ5LmdldEF0dHJpYnV0ZSgnY29sb3InKS5jbG9uZSgpKTtcbiAgICAgICAgICBjb25zdCBmcmFnVGFpbE1hdCA9IG9iai50YWlsLm1hdGVyaWFsLmNsb25lKCk7XG4gICAgICAgICAgY29uc3QgZnJhZ1RhaWwgPSBuZXcgVEhSRUUuTGluZShmcmFnVGFpbEdlbywgZnJhZ1RhaWxNYXQpO1xuICAgICAgICAgIGZyYWdUYWlsLnBvc2l0aW9uLmNvcHkoZnJhZ1N0YXIucG9zaXRpb24pO1xuICAgICAgICAgIHNjZW5lLmFkZChmcmFnU3Rhcik7XG4gICAgICAgICAgc2NlbmUuYWRkKGZyYWdUYWlsKTtcbiAgICAgICAgICBzaG9vdGluZ1N0YXJzLnB1c2goeyBtZXNoOiBmcmFnU3RhciwgdGFpbDogZnJhZ1RhaWwsIHZlbG9jaXR5OiBmcmFnU3Rhci52ZWxvY2l0eSwgZGlyOiBvYmouZGlyLCBhZ2U6IGZyYWdTdGFyLmFnZSwgbm9ybWFsaXplZExpZmV0aW1lOiBmcmFnU3Rhci5ub3JtYWxpemVkTGlmZXRpbWUsIHRyYWlsUG9pbnRzOiBmcmFnVHJhaWxQb2ludHMsIGNvbG9yOiBvYmouY29sb3IsIGJyaWdodG5lc3M6IG9iai5icmlnaHRuZXNzLCBoYXNGcmFnbWVudGVkOiB0cnVlIH0pO1xuICAgICAgICAgIG9iai5oYXNGcmFnbWVudGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTcGFyayBidXJzdFxuICAgICAgICBpZiAoIW9iai5oYXNTcGFya2VkICYmIG5vcm1hbGl6ZWRMaWZlID4gMC45NSAmJiBNYXRoLnJhbmRvbSgpIDwgMC4xKSB7XG4gICAgICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCA4ICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKjgpOyBzKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNwYXJrR2VvID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KDAuNSArIE1hdGgucmFuZG9tKCkqMC41LCA4LCA4KTtcbiAgICAgICAgICAgIGNvbnN0IHNwYXJrTWF0ID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHsgY29sb3I6IDB4ZmZmNmMwLCB0cmFuc3BhcmVudDogdHJ1ZSwgb3BhY2l0eTogMSwgYmxlbmRpbmc6IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmcgfSk7XG4gICAgICAgICAgICBjb25zdCBzcGFyayA9IG5ldyBUSFJFRS5NZXNoKHNwYXJrR2VvLCBzcGFya01hdCk7XG4gICAgICAgICAgICBzcGFyay5wb3NpdGlvbi5jb3B5KG9iai5tZXNoLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIHNwYXJrLnNwYXJrVmVsID0gbmV3IFRIUkVFLlZlY3RvcjMoTWF0aC5yYW5kb20oKS0wLjUsIE1hdGgucmFuZG9tKCktMC41LCBNYXRoLnJhbmRvbSgpLTAuNSkubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoMC41ICsgTWF0aC5yYW5kb20oKSoxLjIpO1xuICAgICAgICAgICAgc3Bhcmsuc3BhcmtMaWZlID0gMTIgKyBNYXRoLnJhbmRvbSgpKjEwO1xuICAgICAgICAgICAgc3Bhcmsuc3BhcmtBZ2UgPSAwO1xuICAgICAgICAgICAgc2NlbmUuYWRkKHNwYXJrKTtcbiAgICAgICAgICAgIGlmICghd2luZG93Ll9zdGFyU3BhcmtzKSB3aW5kb3cuX3N0YXJTcGFya3MgPSBbXTtcbiAgICAgICAgICAgIHdpbmRvdy5fc3RhclNwYXJrcy5wdXNoKHNwYXJrKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2JqLmhhc1NwYXJrZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZsYXNoXG4gICAgICAgIGlmICghb2JqLmhhc0ZsYXNoZWQgJiYgbm9ybWFsaXplZExpZmUgPiAwLjk4ICYmIE1hdGgucmFuZG9tKCkgPCAwLjIpIHtcbiAgICAgICAgICBjb25zdCBmbGFzaEdlbyA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeSgxLCAxNiwgMTYpO1xuICAgICAgICAgIGNvbnN0IGZsYXNoTWF0ID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHsgY29sb3I6IDB4ZmZmZmVlLCB0cmFuc3BhcmVudDogdHJ1ZSwgb3BhY2l0eTogMC44LCBibGVuZGluZzogVEhSRUUuQWRkaXRpdmVCbGVuZGluZyB9KTtcbiAgICAgICAgICBjb25zdCBmbGFzaCA9IG5ldyBUSFJFRS5NZXNoKGZsYXNoR2VvLCBmbGFzaE1hdCk7XG4gICAgICAgICAgZmxhc2gucG9zaXRpb24uY29weShvYmoubWVzaC5wb3NpdGlvbik7XG4gICAgICAgICAgc2NlbmUuYWRkKGZsYXNoKTtcbiAgICAgICAgICBpZiAoIXdpbmRvdy5fc3RhckZsYXNoZXMpIHdpbmRvdy5fc3RhckZsYXNoZXMgPSBbXTtcbiAgICAgICAgICB3aW5kb3cuX3N0YXJGbGFzaGVzLnB1c2goeyBtZXNoOiBmbGFzaCwgYWdlOiAwIH0pO1xuICAgICAgICAgIG9iai5oYXNGbGFzaGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGYWRlIG91dCBhcyBpdCBnZXRzIGZhciBhd2F5XG4gICAgICAgIGNvbnN0IGRpc3QgPSBvYmoubWVzaC5wb3NpdGlvbi5kaXN0YW5jZVRvKGNhbWVyYS5wb3NpdGlvbik7XG4gICAgICAgIGNvbnN0IGZhZGVTdGFydCA9IHN0YXJNYXhEaXN0YW5jZSAqIDAuNTtcbiAgICAgICAgaWYgKGRpc3QgPiBmYWRlU3RhcnQpIHtcbiAgICAgICAgICBjb25zdCBmYWRlID0gMSAtIChkaXN0IC0gZmFkZVN0YXJ0KSAvIChzdGFyTWF4RGlzdGFuY2UgLSBmYWRlU3RhcnQpO1xuICAgICAgICAgIG9iai5tZXNoLm1hdGVyaWFsLm9wYWNpdHkgPSBNYXRoLm1heCgwLCBmYWRlKTtcbiAgICAgICAgICBvYmoubWVzaC5tYXRlcmlhbC50cmFuc3BhcmVudCA9IHRydWU7XG4gICAgICAgICAgb2JqLnRhaWwubWF0ZXJpYWwub3BhY2l0eSA9IE1hdGgubWF4KDAsIGZhZGUgKiAwLjgpO1xuICAgICAgICAgIG9iai50YWlsLm1hdGVyaWFsLnRyYW5zcGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgd2hlbiBvdXQgb2YgYm91bmRzIG9yIGZ1bGx5IGZhZGVkIG9yIGxpZmUgZW5kZWRcbiAgICAgICAgaWYgKG5vcm1hbGl6ZWRMaWZlID49IDEuMCB8fCBkaXN0ID4gc3Rhck1heERpc3RhbmNlIHx8IG9iai5tZXNoLm1hdGVyaWFsLm9wYWNpdHkgPD0gMC4wMSkge1xuICAgICAgICAgIHNjZW5lLnJlbW92ZShvYmoubWVzaCk7XG4gICAgICAgICAgc2NlbmUucmVtb3ZlKG9iai50YWlsKTtcbiAgICAgICAgICBzaG9vdGluZ1N0YXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQW5pbWF0ZSBzcGFya3NcbiAgICAgIGlmICh3aW5kb3cuX3N0YXJTcGFya3MpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHdpbmRvdy5fc3RhclNwYXJrcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGNvbnN0IHNwYXJrID0gd2luZG93Ll9zdGFyU3BhcmtzW2ldO1xuICAgICAgICAgIHNwYXJrLnBvc2l0aW9uLmFkZChzcGFyay5zcGFya1ZlbCk7XG4gICAgICAgICAgc3Bhcmsuc3BhcmtBZ2UrKztcbiAgICAgICAgICBzcGFyay5tYXRlcmlhbC5vcGFjaXR5ICo9IDAuOTI7XG4gICAgICAgICAgaWYgKHNwYXJrLnNwYXJrQWdlID4gc3Bhcmsuc3BhcmtMaWZlKSB7XG4gICAgICAgICAgICBzY2VuZS5yZW1vdmUoc3BhcmspO1xuICAgICAgICAgICAgd2luZG93Ll9zdGFyU3BhcmtzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEFuaW1hdGUgZXhwbG9zaW9uIHBhcnRpY2xlcyAoc3BhcmtsZXMpXG4gICAgICBpZiAod2luZG93Ll9zcGFya2xlcykge1xuICAgICAgICBmb3IgKGxldCBpID0gd2luZG93Ll9zcGFya2xlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGNvbnN0IHNwYXJrbGUgPSB3aW5kb3cuX3NwYXJrbGVzW2ldO1xuICAgICAgICAgIHNwYXJrbGUucG9zaXRpb24uYWRkKHNwYXJrbGUudXNlckRhdGEudmVsb2NpdHkpO1xuICAgICAgICAgIHNwYXJrbGUudXNlckRhdGEuYWdlKys7XG4gICAgICAgICAgc3BhcmtsZS5tYXRlcmlhbC5vcGFjaXR5ICo9IDAuOTc7XG4gICAgICAgICAgaWYgKHNwYXJrbGUudXNlckRhdGEuYWdlID4gKHNwYXJrbGUudXNlckRhdGEubWF4QWdlIHx8IDQwKSkge1xuICAgICAgICAgICAgc2NlbmUucmVtb3ZlKHNwYXJrbGUpO1xuICAgICAgICAgICAgd2luZG93Ll9zcGFya2xlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBBbmltYXRlIGZsYXNoZXNcbiAgICAgIGlmICh3aW5kb3cuX3N0YXJGbGFzaGVzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB3aW5kb3cuX3N0YXJGbGFzaGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgY29uc3QgZmxhc2ggPSB3aW5kb3cuX3N0YXJGbGFzaGVzW2ldO1xuICAgICAgICAgIGZsYXNoLm1lc2guc2NhbGUubXVsdGlwbHlTY2FsYXIoMS4xNSk7XG4gICAgICAgICAgZmxhc2gubWVzaC5tYXRlcmlhbC5vcGFjaXR5ICo9IDAuODU7XG4gICAgICAgICAgZmxhc2guYWdlKys7XG4gICAgICAgICAgaWYgKGZsYXNoLmFnZSA+IDEwKSB7XG4gICAgICAgICAgICBzY2VuZS5yZW1vdmUoZmxhc2gubWVzaCk7XG4gICAgICAgICAgICB3aW5kb3cuX3N0YXJGbGFzaGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gLS0tIFN0YXJmaWVsZCBsb2dpYyAtLS1cbiAgICAgIGNvbnN0IHNxRGlzdCA9IHN0YXJNYXhEaXN0YW5jZSAqIHN0YXJNYXhEaXN0YW5jZTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIGNvbnN0IGR4ID0gcG9zaXRpb25zW2ldIC0gdmlydHVhbENhbWVyYVBvcy54O1xuICAgICAgICBjb25zdCBkeSA9IHBvc2l0aW9uc1tpICsgMV0gLSB2aXJ0dWFsQ2FtZXJhUG9zLnk7XG4gICAgICAgIGNvbnN0IGR6ID0gcG9zaXRpb25zW2kgKyAyXSAtIHZpcnR1YWxDYW1lcmFQb3MuejtcbiAgICAgICAgaWYgKGR4KmR4ICsgZHkqZHkgKyBkeipkeiA+IHNxRGlzdCkge1xuICAgICAgICAgIC8vIFBsYWNlIGluIGEgdGhpY2sgc3BoZXJpY2FsIHNoZWxsIGFyb3VuZCB0aGUgdmlydHVhbCBjYW1lcmEsIG5ldmVyIHRvbyBjbG9zZVxuICAgICAgICAgIGNvbnN0IG1pblJhZGl1cyA9IHN0YXJNYXhEaXN0YW5jZSAqIDAuODtcbiAgICAgICAgICBjb25zdCBtYXhSYWRpdXMgPSBzdGFyTWF4RGlzdGFuY2U7XG4gICAgICAgICAgY29uc3QgciA9IG1pblJhZGl1cyArIE1hdGgucmFuZG9tKCkgKiAobWF4UmFkaXVzIC0gbWluUmFkaXVzKTtcbiAgICAgICAgICBjb25zdCB0aGV0YSA9IE1hdGgucmFuZG9tKCkgKiAyICogTWF0aC5QSTtcbiAgICAgICAgICBjb25zdCBwaGkgPSBNYXRoLmFjb3MoMiAqIE1hdGgucmFuZG9tKCkgLSAxKTtcbiAgICAgICAgICBwb3NpdGlvbnNbaV0gPSB2aXJ0dWFsQ2FtZXJhUG9zLnggKyByICogTWF0aC5zaW4ocGhpKSAqIE1hdGguY29zKHRoZXRhKTtcbiAgICAgICAgICBwb3NpdGlvbnNbaSsxXSA9IHZpcnR1YWxDYW1lcmFQb3MueSArIHIgKiBNYXRoLnNpbihwaGkpICogTWF0aC5zaW4odGhldGEpO1xuICAgICAgICAgIHBvc2l0aW9uc1tpKzJdID0gdmlydHVhbENhbWVyYVBvcy56ICsgciAqIE1hdGguY29zKHBoaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlOyAvLyBBbHJlYWR5IHNldCBhYm92ZVxuXG4gICAgICAvLyBSb2J1c3Qgc3RhcmZpZWxkIGNvbG9yIHVwZGF0ZSB0byBwcmV2ZW50IHN0dWNrIHdoaXRlIGRvdHNcbiAgICAgIGNvbnN0IGNvbEFyciA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3IuYXJyYXk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc2l0aW9ucy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICBjb25zdCBpZHggPSBpIC8gMztcbiAgICAgICAgY29uc3QgZHggPSBwb3NpdGlvbnNbaV0gLSB2aXJ0dWFsQ2FtZXJhUG9zLng7XG4gICAgICAgIGNvbnN0IGR5ID0gcG9zaXRpb25zW2kgKyAxXSAtIHZpcnR1YWxDYW1lcmFQb3MueTtcbiAgICAgICAgY29uc3QgZHogPSBwb3NpdGlvbnNbaSArIDJdIC0gdmlydHVhbENhbWVyYVBvcy56O1xuICAgICAgICBjb25zdCBkaXN0ID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkeik7XG4gICAgICAgIGlmICh0aW1lcnNbaWR4XSA+IDApIHtcbiAgICAgICAgICB0aW1lcnNbaWR4XS0tO1xuICAgICAgICAgIGlmICh0aW1lcnNbaWR4XSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gVGltZXIgZXhwaXJlZCwgcmVzdG9yZSBjb2xvclxuICAgICAgICAgICAgc3BhcmtDb2xvcnNbaV0gPSBvcmlnaW5hbENvbG9yc1tpXTtcbiAgICAgICAgICAgIHNwYXJrQ29sb3JzW2krMV0gPSBvcmlnaW5hbENvbG9yc1tpKzFdO1xuICAgICAgICAgICAgc3BhcmtDb2xvcnNbaSsyXSA9IG9yaWdpbmFsQ29sb3JzW2krMl07XG4gICAgICAgICAgICBjb2xBcnJbaV0gPSBvcmlnaW5hbENvbG9yc1tpXTtcbiAgICAgICAgICAgIGNvbEFycltpKzFdID0gb3JpZ2luYWxDb2xvcnNbaSsxXTtcbiAgICAgICAgICAgIGNvbEFycltpKzJdID0gb3JpZ2luYWxDb2xvcnNbaSsyXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29sQXJyW2ldID0gc3BhcmtDb2xvcnNbaV07XG4gICAgICAgICAgICBjb2xBcnJbaSsxXSA9IHNwYXJrQ29sb3JzW2krMV07XG4gICAgICAgICAgICBjb2xBcnJbaSsyXSA9IHNwYXJrQ29sb3JzW2krMl07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRpc3QgPiBzdGFyTWF4RGlzdGFuY2UgKiAwLjMgJiYgTWF0aC5yYW5kb20oKSA8IDAuMDUpIHtcbiAgICAgICAgICB0aW1lcnNbaWR4XSA9IHNwYXJrbGVEdXJhdGlvbjtcbiAgICAgICAgICBjb25zdCBjID0gcGFsZXR0ZVtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBwYWxldHRlLmxlbmd0aCldO1xuICAgICAgICAgIHNwYXJrQ29sb3JzW2ldID0gY1swXTtcbiAgICAgICAgICBzcGFya0NvbG9yc1tpKzFdID0gY1sxXTtcbiAgICAgICAgICBzcGFya0NvbG9yc1tpKzJdID0gY1syXTtcbiAgICAgICAgICBjb2xBcnJbaV0gPSBzcGFya0NvbG9yc1tpXTtcbiAgICAgICAgICBjb2xBcnJbaSsxXSA9IHNwYXJrQ29sb3JzW2krMV07XG4gICAgICAgICAgY29sQXJyW2krMl0gPSBzcGFya0NvbG9yc1tpKzJdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNwYXJrQ29sb3JzW2ldID0gb3JpZ2luYWxDb2xvcnNbaV07XG4gICAgICAgICAgc3BhcmtDb2xvcnNbaSsxXSA9IG9yaWdpbmFsQ29sb3JzW2krMV07XG4gICAgICAgICAgc3BhcmtDb2xvcnNbaSsyXSA9IG9yaWdpbmFsQ29sb3JzW2krMl07XG4gICAgICAgICAgY29sQXJyW2ldID0gb3JpZ2luYWxDb2xvcnNbaV07XG4gICAgICAgICAgY29sQXJyW2krMV0gPSBvcmlnaW5hbENvbG9yc1tpKzFdO1xuICAgICAgICAgIGNvbEFycltpKzJdID0gb3JpZ2luYWxDb2xvcnNbaSsyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvci5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIGNvbXBvc2VyLnJlbmRlcigpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIERlZmVuc2l2ZTogbG9nIGVycm9yIHdpdGggY29udGV4dFxuICAgICAgICBjb25zb2xlLmVycm9yKCdTdGFyZmllbGQgYW5pbWF0aW9uIGVycm9yOicsIGVycik7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGFuaW1hdGUoKTsgLy8gU3RhcnQgdGhlIHJlbmRlciBsb29wXG5cbiAgICBjb25zdCBvblJlc2l6ZSA9ICgpID0+IHtcbiAgICAgIGNhbWVyYS5hc3BlY3QgPSB3aW5kb3cuaW5uZXJXaWR0aCAvIHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgIGNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgfVxuICB9LCBbXSlcblxuICByZXR1cm4gPGRpdiByZWY9e21vdW50UmVmfSAvPlxufVxuZXhwb3J0IGRlZmF1bHQgU3RhcmZpZWxkXG5cbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUVmZmVjdCIsInVzZVJlZiIsIlRIUkVFIiwiRWZmZWN0Q29tcG9zZXIiLCJVbnJlYWxCbG9vbVBhc3MiLCJSZW5kZXJQYXNzIiwiQ2hyb21hdGljQWJlcnJhdGlvblBhc3MiLCJTdGFyZmllbGQiLCJtb3VudFJlZiIsImN1cnJlbnQiLCJtb3VudCIsInN0eWxlIiwicG9zaXRpb24iLCJ0b3AiLCJsZWZ0Iiwid2lkdGgiLCJoZWlnaHQiLCJ6SW5kZXgiLCJzY2VuZSIsIlNjZW5lIiwiY2FtZXJhIiwiUGVyc3BlY3RpdmVDYW1lcmEiLCJ3aW5kb3ciLCJpbm5lcldpZHRoIiwiaW5uZXJIZWlnaHQiLCJzZXQiLCJ2aXJ0dWFsQ2FtZXJhUG9zIiwiVmVjdG9yMyIsInJlbmRlcmVyIiwiV2ViR0xSZW5kZXJlciIsImFudGlhbGlhcyIsInNldFBpeGVsUmF0aW8iLCJkZXZpY2VQaXhlbFJhdGlvIiwic2V0U2l6ZSIsInNldENsZWFyQ29sb3IiLCJhcHBlbmRDaGlsZCIsImRvbUVsZW1lbnQiLCJjb21wb3NlciIsInJlbmRlclBhc3MiLCJhZGRQYXNzIiwiYmxvb21QYXNzIiwiVmVjdG9yMiIsImNsb3NlU3RhcnNTY2VuZSIsImNhUGFzcyIsImNhQ29tcG9zZXIiLCJjYVJlbmRlclBhc3MiLCJyZXNpemVBbGwiLCJhc3BlY3QiLCJ1cGRhdGVQcm9qZWN0aW9uTWF0cml4IiwiYWRkRXZlbnRMaXN0ZW5lciIsInN0YXJDb3VudCIsInN0YXJNYXhEaXN0YW5jZSIsInN0YXJTcGVlZCIsImdlb21ldHJ5IiwiQnVmZmVyR2VvbWV0cnkiLCJjbG9zZUdlb21ldHJ5IiwicG9zaXRpb25zIiwiY2xvc2VQb3NpdGlvbnMiLCJzdGFyc1BsYWNlZCIsIk1hdGgiLCJyYW5kb20iLCJjbHVzdGVyVGhldGEiLCJQSSIsImNsdXN0ZXJQaGkiLCJhY29zIiwiY2x1c3RlclIiLCJjbHVzdGVyQ2VudGVyIiwic2luIiwiY29zIiwiY2x1c3RlclNpemUiLCJmbG9vciIsImMiLCJvZmZzZXRUaGV0YSIsIm9mZnNldFBoaSIsIm9mZnNldFIiLCJwdXNoIiwidGhldGEiLCJwaGkiLCJyIiwieCIsInkiLCJ6Iiwic2V0QXR0cmlidXRlIiwiRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSIsImxlbmd0aCIsInBhbGV0dGUiLCJjb2xvcnMiLCJpIiwib3JpZ2luYWxDb2xvcnMiLCJhdHRyaWJ1dGVzIiwiY29sb3IiLCJhcnJheSIsInNsaWNlIiwidGltZXJzIiwiRmxvYXQzMkFycmF5Iiwic3BhcmtDb2xvcnMiLCJzcGFya2xlRHVyYXRpb24iLCJtYXRlcmlhbCIsIlBvaW50c01hdGVyaWFsIiwic2l6ZSIsInNpemVBdHRlbnVhdGlvbiIsInZlcnRleENvbG9ycyIsInN0YXJzIiwiUG9pbnRzIiwiYWRkIiwiZ2xvd01hcCIsIlRleHR1cmVMb2FkZXIiLCJsb2FkIiwiZ2xvd1Nwcml0ZXMiLCJnbG93TWF0ZXJpYWwiLCJTcHJpdGVNYXRlcmlhbCIsIm1hcCIsIm9wYWNpdHkiLCJibGVuZGluZyIsIkFkZGl0aXZlQmxlbmRpbmciLCJkZXB0aFdyaXRlIiwiZ2xvdyIsIlNwcml0ZSIsImNsb25lIiwic2NhbGUiLCJjbG9zZVN0YXJzIiwidGFyZ2V0WSIsImRhbXBpbmciLCJvblNjcm9sbCIsInBjdCIsInNjcm9sbFkiLCJkb2N1bWVudCIsImJvZHkiLCJzY3JvbGxIZWlnaHQiLCJ0YWlsTGVuZ3RoIiwic2hvb3RpbmdTdGFycyIsInNob290aW5nU3RhckNvb2xkb3duIiwic3Bhd25TaG9vdGluZ1N0YXIiLCJkaXIiLCJub3JtYWxpemUiLCJtaW5EaXN0IiwibWF4RGlzdCIsImRpc3QiLCJzcGF3blBvcyIsIm11bHRpcGx5U2NhbGFyIiwidGFuZ2VudCIsInN1YiIsInByb2plY3RPblZlY3RvciIsInRhbmdlbnRpYWxTcGVlZCIsInJhZGlhbFNwZWVkIiwidmVsb2NpdHkiLCJ2aWJyYW50Q29sb3JzIiwiYnJpZ2h0bmVzcyIsImdlbyIsIlNwaGVyZUdlb21ldHJ5IiwibWF0IiwiTWVzaFBoeXNpY2FsTWF0ZXJpYWwiLCJlbWlzc2l2ZSIsImVtaXNzaXZlSW50ZW5zaXR5IiwibWV0YWxuZXNzIiwicm91Z2huZXNzIiwidHJhbnNtaXNzaW9uIiwidHJhbnNwYXJlbnQiLCJjbGVhcmNvYXQiLCJjbGVhcmNvYXRSb3VnaG5lc3MiLCJzdGFyIiwiTWVzaCIsInNwcml0ZU1hcCIsInNwcml0ZU1hdGVyaWFsIiwic3ByaXRlIiwiY29weSIsInNwYXJrQ291bnQiLCJzcGFya0dyb3VwIiwiR3JvdXAiLCJzcGFya01hdCIsIk1lc2hCYXNpY01hdGVyaWFsIiwic3BhcmtHZW8iLCJzcGFyayIsImFuZ2xlIiwibmFtZSIsIm5vcm1hbGl6ZWRMaWZlIiwibm9ybWFsaXplZExpZmV0aW1lIiwiYWdlIiwidHJhaWxTZWdtZW50cyIsInRyYWlsUG9pbnRzIiwic3BpcmFsIiwiY3VydmUiLCJwdCIsInRhaWxHZW8iLCJzZXRGcm9tUG9pbnRzIiwidGFpbENvbG9ycyIsImFscGhhIiwicmFpbmJvdyIsImdyYWRDb2xvciIsInRhaWxNYXQiLCJMaW5lQmFzaWNNYXRlcmlhbCIsInRhaWwiLCJMaW5lIiwidGFpbEdsb3dNYXAiLCJ0YWlsR2xvd01hdCIsInRhaWxHbG93IiwibWVzaCIsImhhc0ZyYWdtZW50ZWQiLCJhbmltYXRlIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwicmVuZGVyIiwicm90YXRpb24iLCJmb3J3YXJkIiwiZ2V0V29ybGREaXJlY3Rpb24iLCJzdGFyUG9zIiwidCIsInMiLCJuZWVkc1VwZGF0ZSIsInNoYWtlU3RyZW5ndGgiLCJvYmoiLCJjaGlsZHJlbiIsInNwYXJrcyIsImZpbmQiLCJjaGlsZCIsImoiLCJ0aW1lIiwicGVyZm9ybWFuY2UiLCJub3ciLCJnZXRBdHRyaWJ1dGUiLCJrIiwiY291bnQiLCJnZXRYIiwiZyIsImdldFkiLCJiIiwiZ2V0WiIsIm1heCIsIm1pbiIsImgiLCJsIiwiZCIsInEiLCJwIiwidHIiLCJ0ZyIsInRiIiwiaHVlMnJnYiIsInNldFgiLCJzZXRZIiwic2V0WiIsInNldFciLCJnZXRXIiwidW5zaGlmdCIsInBvcCIsInRhaWxHcm93IiwiYWN0aXZlU2VnbWVudHMiLCJ2aXNpYmxlVHJhaWwiLCJEYXRlIiwic2V0WFlaVyIsImhlYWRDb2xvciIsIkNvbG9yIiwibGVycCIsImZsaWNrZXIiLCJkaXN0VG9DYW0iLCJkb2ZCbHVyIiwic3BlY3RhY3VsYXIiLCJidXJzdENvdW50Iiwic3BhcmtsZUdlbyIsInNwYXJrbGVNYXQiLCJzcGFya2xlIiwic3BkIiwic3BhcmtsZVZlbCIsInVzZXJEYXRhIiwibWF4QWdlIiwiX3NwYXJrbGVzIiwiZmxhc2hHZW8iLCJmbGFzaE1hdCIsImZsYXNoIiwiX3N0YXJGbGFzaGVzIiwiZnJhZ1ZlbCIsImFwcGx5QXhpc0FuZ2xlIiwiZnJhZ1N0YXIiLCJmcmFnVHJhaWxQb2ludHMiLCJmcmFnVGFpbEdlbyIsImZyYWdUYWlsTWF0IiwiZnJhZ1RhaWwiLCJoYXNTcGFya2VkIiwic3BhcmtWZWwiLCJzcGFya0xpZmUiLCJzcGFya0FnZSIsIl9zdGFyU3BhcmtzIiwiaGFzRmxhc2hlZCIsImRpc3RhbmNlVG8iLCJmYWRlU3RhcnQiLCJmYWRlIiwicmVtb3ZlIiwic3BsaWNlIiwic3FEaXN0IiwiZHgiLCJkeSIsImR6IiwibWluUmFkaXVzIiwibWF4UmFkaXVzIiwiY29sQXJyIiwiaWR4Iiwic3FydCIsImVyciIsImNvbnNvbGUiLCJlcnJvciIsIm9uUmVzaXplIiwiZGl2IiwicmVmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/Starfield.jsx\n"));

/***/ })

});