"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./components/Starfield.jsx":
/*!**********************************!*\
  !*** ./components/Starfield.jsx ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar _s = $RefreshSig$();\n\n\nconst Starfield = ()=>{\n    _s();\n    const mountRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const mount = mountRef.current;\n        mount.style.position = \"fixed\";\n        mount.style.top = \"0\";\n        mount.style.left = \"0\";\n        mount.style.width = \"100%\";\n        mount.style.height = \"100%\";\n        mount.style.zIndex = \"-1\";\n        // Scene & Renderer\n        const scene = new three__WEBPACK_IMPORTED_MODULE_2__.Scene();\n        const camera = new three__WEBPACK_IMPORTED_MODULE_2__.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);\n        const renderer = new three__WEBPACK_IMPORTED_MODULE_2__.WebGLRenderer({\n            antialias: true\n        });\n        renderer.setPixelRatio(window.devicePixelRatio);\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        mount.appendChild(renderer.domElement);\n        // Starfield\n        const starCount = 10000;\n        const starMaxDistance = 1000;\n        const starSpeed = 1;\n        const geometry = new three__WEBPACK_IMPORTED_MODULE_2__.BufferGeometry();\n        const positions = [];\n        for(let i = 0; i < starCount; i++){\n            const theta = Math.random() * 2 * Math.PI;\n            const phi = Math.acos(2 * Math.random() - 1);\n            const r = Math.random() * starMaxDistance;\n            positions.push(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));\n        }\n        geometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_2__.Float32BufferAttribute(positions, 3));\n        const palette = [\n            [\n                1.0,\n                0.5,\n                0.5\n            ],\n            [\n                1.0,\n                0.75,\n                0.4\n            ],\n            [\n                1.0,\n                1.0,\n                0.9\n            ],\n            [\n                1.0,\n                1.0,\n                1.0\n            ],\n            [\n                0.4,\n                0.5,\n                1.0\n            ]\n        ];\n        const colors = [];\n        for(let i = 0; i < starCount; i++){\n            const c = palette[Math.floor(Math.random() * palette.length)];\n            colors.push(...c);\n        }\n        geometry.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_2__.Float32BufferAttribute(colors, 3));\n        const originalColors = geometry.attributes.color.array.slice();\n        const timers = new Float32Array(starCount);\n        const sparkColors = new Float32Array(starCount * 3);\n        const sparkleDuration = 180;\n        const material = new three__WEBPACK_IMPORTED_MODULE_2__.PointsMaterial({\n            size: 1,\n            sizeAttenuation: true,\n            vertexColors: true\n        });\n        const stars = new three__WEBPACK_IMPORTED_MODULE_2__.Points(geometry, material);\n        scene.add(stars);\n        let targetY = 0;\n        const damping = 0.05;\n        const onScroll = ()=>{\n            const pct = window.scrollY / (document.body.scrollHeight - window.innerHeight);\n            targetY = pct * Math.PI * 2;\n        };\n        window.addEventListener(\"scroll\", onScroll);\n        const tailLength = 50;\n        const shootingStars = [];\n        let shootingStarCooldown = 0; // Prevent too many at once\n        // Enhanced shooting star effect\n        function spawnShootingStar() {\n            // Spawn farther away from camera, in the distance, and not directly in front\n            const minAngle = Math.PI / 10; // 18 degrees away from camera center\n            const maxAngle = Math.PI / 3; // up to 60 degrees from camera center\n            const minDistance = 400; // never closer than this\n            const cameraDir = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n            camera.getWorldDirection(cameraDir);\n            let spawnDir, angleFromCenter;\n            do {\n                // Random angle between minAngle and maxAngle from camera direction\n                angleFromCenter = minAngle + (maxAngle - minAngle) * Math.random();\n                // Random azimuth\n                const azimuth = Math.random() * 2 * Math.PI;\n                // Spherical coordinates\n                spawnDir = cameraDir.clone();\n                // Rotate spawnDir by angleFromCenter around a random perpendicular axis\n                const axis = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(Math.cos(azimuth), Math.sin(azimuth), 0).normalize();\n                spawnDir.applyAxisAngle(axis, angleFromCenter).normalize();\n            }while (spawnDir.dot(cameraDir) > Math.cos(minAngle));\n            const distance = minDistance + Math.random() * (starMaxDistance - minDistance);\n            const startPos = camera.position.clone().add(spawnDir.clone().multiplyScalar(distance));\n            // Ensure direction is always away from camera\n            const away = spawnDir;\n            // Add a small random perpendicular component for variety\n            let perp = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1);\n            perp = perp.sub(perp.clone().projectOnVector(away)).normalize();\n            const dir = away.clone().add(perp.multiplyScalar(Math.random() * 0.5)).normalize();\n            // Make the speed much slower\n            const speed = starSpeed * (10 + Math.random() * 10); // 10-20 units per frame\n            const geo = new three__WEBPACK_IMPORTED_MODULE_2__.SphereGeometry(1, 8, 8); // Smaller, more distant\n            const mat = new three__WEBPACK_IMPORTED_MODULE_2__.MeshBasicMaterial({\n                color: 0xffffee,\n                emissive: 0xffffee,\n                emissiveIntensity: 2\n            });\n            const star = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(geo, mat);\n            star.position.copy(startPos);\n            star.velocity = dir.clone().multiplyScalar(speed);\n            star.life = 1.0;\n            // Pretty, glowing tail using points (sprites) instead of a line\n            const tailLen = 200 + Math.random() * 100;\n            const tailSegments = 24;\n            const tailPoints = [];\n            const tailColors = [];\n            for(let i = 0; i < tailSegments; i++){\n                // Position along the tail\n                const t = i / (tailSegments - 1);\n                // Position fades away from the star\n                tailPoints.push(dir.clone().negate().multiplyScalar(tailLen * t));\n                // Color/alpha: bright at head, fades at tail\n                const alpha = (1 - t) * 0.7;\n                // Soft yellow-white gradient\n                tailColors.push(1.0, 1.0, 0.85, alpha);\n            }\n            const tailGeo = new three__WEBPACK_IMPORTED_MODULE_2__.BufferGeometry();\n            tailGeo.setFromPoints(tailPoints);\n            tailGeo.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_2__.Float32BufferAttribute(tailColors, 4));\n            // Use a round sprite for each point\n            const sprite = new three__WEBPACK_IMPORTED_MODULE_2__.TextureLoader().load(\"https://cdn.jsdelivr.net/gh/mrdoob/three.js@master/examples/textures/sprites/circle.png\");\n            const tailMat = new three__WEBPACK_IMPORTED_MODULE_2__.PointsMaterial({\n                size: 16,\n                map: sprite,\n                vertexColors: true,\n                transparent: true,\n                depthWrite: false,\n                blending: three__WEBPACK_IMPORTED_MODULE_2__.AdditiveBlending\n            });\n            const tail = new three__WEBPACK_IMPORTED_MODULE_2__.Points(tailGeo, tailMat);\n            tail.position.copy(star.position);\n            tail.life = 1.0;\n            scene.add(star);\n            scene.add(tail);\n            shootingStars.push({\n                mesh: star,\n                tail,\n                velocity: star.velocity,\n                dir,\n                fade: false,\n                tailPoints\n            });\n        }\n        const animate = ()=>{\n            requestAnimationFrame(animate);\n            camera.rotation.y += (targetY - camera.rotation.y) * damping;\n            camera.translateZ(-starSpeed);\n            // Spawn shooting star occasionally, but not too frequently\n            // Decrease shooting star frequency for a more subtle effect\n            if (shootingStarCooldown <= 0 && Math.random() < 0.05) {\n                spawnShootingStar();\n                shootingStarCooldown = 30 + Math.random() * 40; // 0.5-1.2 seconds\n            } else if (shootingStarCooldown > 0) {\n                shootingStarCooldown--;\n            }\n            const posArr = geometry.attributes.position.array;\n            const sqDist = starMaxDistance * starMaxDistance;\n            for(let i = 0; i < posArr.length; i += 3){\n                const dx = posArr[i] - camera.position.x;\n                const dy = posArr[i + 1] - camera.position.y;\n                const dz = posArr[i + 2] - camera.position.z;\n                if (dx * dx + dy * dy + dz * dz > sqDist) {\n                    const theta = Math.random() * 2 * Math.PI;\n                    const phi = Math.acos(2 * Math.random() - 1);\n                    posArr[i] = camera.position.x + starMaxDistance * Math.sin(phi) * Math.cos(theta);\n                    posArr[i + 1] = camera.position.y + starMaxDistance * Math.sin(phi) * Math.sin(theta);\n                    posArr[i + 2] = camera.position.z + starMaxDistance * Math.cos(phi);\n                }\n            }\n            geometry.attributes.position.needsUpdate = true;\n            const colArr = geometry.attributes.color.array;\n            for(let i = 0; i < posArr.length; i += 3){\n                const idx = i / 3;\n                const dist = Math.sqrt(posArr[i] * posArr[i] + posArr[i + 1] * posArr[i + 1] + posArr[i + 2] * posArr[i + 2]);\n                if (timers[idx] > 0) timers[idx]--;\n                else if (dist > starMaxDistance * 0.3 && Math.random() < 0.05) {\n                    timers[idx] = sparkleDuration;\n                    const c = palette[Math.floor(Math.random() * palette.length)];\n                    sparkColors[i] = c[0];\n                    sparkColors[i + 1] = c[1];\n                    sparkColors[i + 2] = c[2];\n                }\n                if (timers[idx] > 0) {\n                    colArr[i] = sparkColors[i];\n                    colArr[i + 1] = sparkColors[i + 1];\n                    colArr[i + 2] = sparkColors[i + 2];\n                } else {\n                    colArr[i] = originalColors[i];\n                    colArr[i + 1] = originalColors[i + 1];\n                    colArr[i + 2] = originalColors[i + 2];\n                }\n            }\n            geometry.attributes.color.needsUpdate = true;\n            stars.rotation.x += 0.0001;\n            stars.rotation.y += 0.00015;\n            // Remove extra random spawn for shooting stars\n            // (no additional random spawns, only above logic)\n            for(let i = shootingStars.length - 1; i >= 0; i--){\n                const obj = shootingStars[i];\n                // Move shooting star in world space, independent of camera\n                obj.mesh.position.add(obj.velocity);\n                // Update tail points to follow star's path in world space\n                for(let j = obj.tailPoints.length - 1; j > 0; j--){\n                    obj.tailPoints[j].copy(obj.tailPoints[j - 1]);\n                }\n                obj.tailPoints[0] = obj.mesh.position.clone();\n                obj.tail.geometry.setFromPoints(obj.tailPoints);\n                // Update tail alpha gradient\n                const colors = obj.tail.geometry.attributes.color.array;\n                for(let j = 0; j < obj.tailPoints.length; j++){\n                    // Alpha fades out with both tail position and star life\n                    colors[j * 4 + 3] = (1 - j / (obj.tailPoints.length - 1)) * 0.7 * Math.max(0, obj.mesh.life);\n                }\n                obj.tail.geometry.attributes.color.needsUpdate = true;\n                obj.tail.position.set(0, 0, 0); // tail points are absolute\n                obj.tail.life -= 0.01;\n                obj.mesh.life -= 0.01;\n                // Fade the tail smoothly based on life\n                obj.tail.material.opacity = 1.0;\n                if (obj.mesh.life <= 0) {\n                    scene.remove(obj.mesh);\n                    scene.remove(obj.tail);\n                    shootingStars.splice(i, 1);\n                }\n            }\n            const cam = camera.position.clone();\n            for(let i = 0; i < posArr.length; i += 3){\n                posArr[i] -= cam.x;\n                posArr[i + 1] -= cam.y;\n                posArr[i + 2] -= cam.z;\n            }\n            geometry.attributes.position.needsUpdate = true;\n            shootingStars.forEach((obj)=>{\n                obj.mesh.position.sub(cam);\n                obj.tail.position.sub(cam);\n            });\n            camera.position.set(0, 0, 0);\n            renderer.render(scene, camera);\n        };\n        animate();\n        const onResize = ()=>{\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        };\n        window.addEventListener(\"resize\", onResize);\n        return ()=>{\n            window.removeEventListener(\"scroll\", onScroll);\n            window.removeEventListener(\"resize\", onResize);\n            mount.removeChild(renderer.domElement);\n        };\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: mountRef\n    }, void 0, false, {\n        fileName: \"/home/kayosdev/Websites/Portfolio/components/Starfield.jsx\",\n        lineNumber: 259,\n        columnNumber: 10\n    }, undefined);\n};\n_s(Starfield, \"V9/qkEdV8GfsDZk7lMTA1T8g5Ps=\");\n_c = Starfield;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Starfield);\nvar _c;\n$RefreshReg$(_c, \"Starfield\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUdELE9BQU9FLFdBQVc7WUFDdERKLE9BQU91SixzQkFBc0I7WUFDN0JsSixTQUFTSyxPQUFPLENBQUNSLE9BQU9DLFVBQVUsRUFBRUQsT0FBT0UsV0FBVztRQUN4RDtRQUNBRixPQUFPNEQsZ0JBQWdCLENBQUMsVUFBVXVGO1FBRWxDLE9BQU87WUFDTG5KLE9BQU9zSixtQkFBbUIsQ0FBQyxVQUFVaEc7WUFDckN0RCxPQUFPc0osbUJBQW1CLENBQUMsVUFBVUg7WUFDckNoSyxNQUFNb0ssV0FBVyxDQUFDcEosU0FBU08sVUFBVTtRQUN2QztJQUNGLEdBQUcsRUFBRTtJQUVMLHFCQUFPLDhEQUFDOEk7UUFBSUMsS0FBS3ZLOzs7Ozs7QUFDbkI7R0FoUU1EO0tBQUFBO0FBa1FOLCtEQUFlQSxTQUFTQSxFQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvU3RhcmZpZWxkLmpzeD9mMWEyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnXG5cbmNvbnN0IFN0YXJmaWVsZCA9ICgpID0+IHtcbiAgY29uc3QgbW91bnRSZWYgPSB1c2VSZWYobnVsbClcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IG1vdW50ID0gbW91bnRSZWYuY3VycmVudFxuICAgIG1vdW50LnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJ1xuICAgIG1vdW50LnN0eWxlLnRvcCA9ICcwJ1xuICAgIG1vdW50LnN0eWxlLmxlZnQgPSAnMCdcbiAgICBtb3VudC5zdHlsZS53aWR0aCA9ICcxMDAlJ1xuICAgIG1vdW50LnN0eWxlLmhlaWdodCA9ICcxMDAlJ1xuICAgIG1vdW50LnN0eWxlLnpJbmRleCA9ICctMSdcblxuICAgIC8vIFNjZW5lICYgUmVuZGVyZXJcbiAgICBjb25zdCBzY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpXG4gICAgY29uc3QgY2FtZXJhID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKDc1LCB3aW5kb3cuaW5uZXJXaWR0aCAvIHdpbmRvdy5pbm5lckhlaWdodCwgMC4xLCA1MDAwKVxuICAgIGNvbnN0IHJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoeyBhbnRpYWxpYXM6IHRydWUgfSlcbiAgICByZW5kZXJlci5zZXRQaXhlbFJhdGlvKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKVxuICAgIHJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodClcbiAgICBtb3VudC5hcHBlbmRDaGlsZChyZW5kZXJlci5kb21FbGVtZW50KVxuXG4gICAgLy8gU3RhcmZpZWxkXG4gICAgY29uc3Qgc3RhckNvdW50ID0gMTAwMDBcbiAgICBjb25zdCBzdGFyTWF4RGlzdGFuY2UgPSAxMDAwXG4gICAgY29uc3Qgc3RhclNwZWVkID0gMVxuICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KClcbiAgICBjb25zdCBwb3NpdGlvbnMgPSBbXVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhckNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHRoZXRhID0gTWF0aC5yYW5kb20oKSAqIDIgKiBNYXRoLlBJXG4gICAgICBjb25zdCBwaGkgPSBNYXRoLmFjb3MoMiAqIE1hdGgucmFuZG9tKCkgLSAxKVxuICAgICAgY29uc3QgciA9IE1hdGgucmFuZG9tKCkgKiBzdGFyTWF4RGlzdGFuY2VcbiAgICAgIHBvc2l0aW9ucy5wdXNoKFxuICAgICAgICByICogTWF0aC5zaW4ocGhpKSAqIE1hdGguY29zKHRoZXRhKSxcbiAgICAgICAgciAqIE1hdGguc2luKHBoaSkgKiBNYXRoLnNpbih0aGV0YSksXG4gICAgICAgIHIgKiBNYXRoLmNvcyhwaGkpXG4gICAgICApXG4gICAgfVxuICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgVEhSRUUuRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbnMsIDMpKVxuXG4gICAgY29uc3QgcGFsZXR0ZSA9IFtcbiAgICAgIFsxLjAsIDAuNSwgMC41XSxcbiAgICAgIFsxLjAsIDAuNzUsIDAuNF0sXG4gICAgICBbMS4wLCAxLjAsIDAuOV0sXG4gICAgICBbMS4wLCAxLjAsIDEuMF0sXG4gICAgICBbMC40LCAwLjUsIDEuMF0sXG4gICAgXVxuICAgIGNvbnN0IGNvbG9ycyA9IFtdXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFyQ291bnQ7IGkrKykge1xuICAgICAgY29uc3QgYyA9IHBhbGV0dGVbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcGFsZXR0ZS5sZW5ndGgpXVxuICAgICAgY29sb3JzLnB1c2goLi4uYylcbiAgICB9XG4gICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdjb2xvcicsIG5ldyBUSFJFRS5GbG9hdDMyQnVmZmVyQXR0cmlidXRlKGNvbG9ycywgMykpXG5cbiAgICBjb25zdCBvcmlnaW5hbENvbG9ycyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3IuYXJyYXkuc2xpY2UoKVxuICAgIGNvbnN0IHRpbWVycyA9IG5ldyBGbG9hdDMyQXJyYXkoc3RhckNvdW50KVxuICAgIGNvbnN0IHNwYXJrQ29sb3JzID0gbmV3IEZsb2F0MzJBcnJheShzdGFyQ291bnQgKiAzKVxuICAgIGNvbnN0IHNwYXJrbGVEdXJhdGlvbiA9IDE4MFxuXG4gICAgY29uc3QgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuUG9pbnRzTWF0ZXJpYWwoeyBzaXplOiAxLCBzaXplQXR0ZW51YXRpb246IHRydWUsIHZlcnRleENvbG9yczogdHJ1ZSB9KVxuICAgIGNvbnN0IHN0YXJzID0gbmV3IFRIUkVFLlBvaW50cyhnZW9tZXRyeSwgbWF0ZXJpYWwpXG4gICAgc2NlbmUuYWRkKHN0YXJzKVxuXG4gICAgbGV0IHRhcmdldFkgPSAwXG4gICAgY29uc3QgZGFtcGluZyA9IDAuMDVcbiAgICBjb25zdCBvblNjcm9sbCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHBjdCA9IHdpbmRvdy5zY3JvbGxZIC8gKGRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0IC0gd2luZG93LmlubmVySGVpZ2h0KVxuICAgICAgdGFyZ2V0WSA9IHBjdCAqIE1hdGguUEkgKiAyXG4gICAgfVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBvblNjcm9sbClcblxuICAgIGNvbnN0IHRhaWxMZW5ndGggPSA1MFxuICAgIGNvbnN0IHNob290aW5nU3RhcnMgPSBbXVxuICAgIGxldCBzaG9vdGluZ1N0YXJDb29sZG93biA9IDA7IC8vIFByZXZlbnQgdG9vIG1hbnkgYXQgb25jZVxuICAgIC8vIEVuaGFuY2VkIHNob290aW5nIHN0YXIgZWZmZWN0XG4gICAgZnVuY3Rpb24gc3Bhd25TaG9vdGluZ1N0YXIoKSB7XG4gICAgICAvLyBTcGF3biBmYXJ0aGVyIGF3YXkgZnJvbSBjYW1lcmEsIGluIHRoZSBkaXN0YW5jZSwgYW5kIG5vdCBkaXJlY3RseSBpbiBmcm9udFxuICAgICAgY29uc3QgbWluQW5nbGUgPSBNYXRoLlBJIC8gMTA7IC8vIDE4IGRlZ3JlZXMgYXdheSBmcm9tIGNhbWVyYSBjZW50ZXJcbiAgICAgIGNvbnN0IG1heEFuZ2xlID0gTWF0aC5QSSAvIDM7ICAvLyB1cCB0byA2MCBkZWdyZWVzIGZyb20gY2FtZXJhIGNlbnRlclxuICAgICAgY29uc3QgbWluRGlzdGFuY2UgPSA0MDA7IC8vIG5ldmVyIGNsb3NlciB0aGFuIHRoaXNcbiAgICAgIGNvbnN0IGNhbWVyYURpciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICBjYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oY2FtZXJhRGlyKTtcbiAgICAgIGxldCBzcGF3bkRpciwgYW5nbGVGcm9tQ2VudGVyO1xuICAgICAgZG8ge1xuICAgICAgICAvLyBSYW5kb20gYW5nbGUgYmV0d2VlbiBtaW5BbmdsZSBhbmQgbWF4QW5nbGUgZnJvbSBjYW1lcmEgZGlyZWN0aW9uXG4gICAgICAgIGFuZ2xlRnJvbUNlbnRlciA9IG1pbkFuZ2xlICsgKG1heEFuZ2xlIC0gbWluQW5nbGUpICogTWF0aC5yYW5kb20oKTtcbiAgICAgICAgLy8gUmFuZG9tIGF6aW11dGhcbiAgICAgICAgY29uc3QgYXppbXV0aCA9IE1hdGgucmFuZG9tKCkgKiAyICogTWF0aC5QSTtcbiAgICAgICAgLy8gU3BoZXJpY2FsIGNvb3JkaW5hdGVzXG4gICAgICAgIHNwYXduRGlyID0gY2FtZXJhRGlyLmNsb25lKCk7XG4gICAgICAgIC8vIFJvdGF0ZSBzcGF3bkRpciBieSBhbmdsZUZyb21DZW50ZXIgYXJvdW5kIGEgcmFuZG9tIHBlcnBlbmRpY3VsYXIgYXhpc1xuICAgICAgICBjb25zdCBheGlzID0gbmV3IFRIUkVFLlZlY3RvcjMoTWF0aC5jb3MoYXppbXV0aCksIE1hdGguc2luKGF6aW11dGgpLCAwKS5ub3JtYWxpemUoKTtcbiAgICAgICAgc3Bhd25EaXIuYXBwbHlBeGlzQW5nbGUoYXhpcywgYW5nbGVGcm9tQ2VudGVyKS5ub3JtYWxpemUoKTtcbiAgICAgIH0gd2hpbGUgKHNwYXduRGlyLmRvdChjYW1lcmFEaXIpID4gTWF0aC5jb3MobWluQW5nbGUpKTtcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gbWluRGlzdGFuY2UgKyBNYXRoLnJhbmRvbSgpICogKHN0YXJNYXhEaXN0YW5jZSAtIG1pbkRpc3RhbmNlKTtcbiAgICAgIGNvbnN0IHN0YXJ0UG9zID0gY2FtZXJhLnBvc2l0aW9uLmNsb25lKCkuYWRkKHNwYXduRGlyLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoZGlzdGFuY2UpKTtcbiAgICAgIC8vIEVuc3VyZSBkaXJlY3Rpb24gaXMgYWx3YXlzIGF3YXkgZnJvbSBjYW1lcmFcbiAgICAgIGNvbnN0IGF3YXkgPSBzcGF3bkRpcjtcbiAgICAgIC8vIEFkZCBhIHNtYWxsIHJhbmRvbSBwZXJwZW5kaWN1bGFyIGNvbXBvbmVudCBmb3IgdmFyaWV0eVxuICAgICAgbGV0IHBlcnAgPSBuZXcgVEhSRUUuVmVjdG9yMyhNYXRoLnJhbmRvbSgpKjItMSwgTWF0aC5yYW5kb20oKSoyLTEsIE1hdGgucmFuZG9tKCkqMi0xKTtcbiAgICAgIHBlcnAgPSBwZXJwLnN1YihwZXJwLmNsb25lKCkucHJvamVjdE9uVmVjdG9yKGF3YXkpKS5ub3JtYWxpemUoKTtcbiAgICAgIGNvbnN0IGRpciA9IGF3YXkuY2xvbmUoKS5hZGQocGVycC5tdWx0aXBseVNjYWxhcihNYXRoLnJhbmRvbSgpICogMC41KSkubm9ybWFsaXplKCk7XG4gICAgICAvLyBNYWtlIHRoZSBzcGVlZCBtdWNoIHNsb3dlclxuICAgICAgY29uc3Qgc3BlZWQgPSBzdGFyU3BlZWQgKiAoMTAgKyBNYXRoLnJhbmRvbSgpICogMTApOyAvLyAxMC0yMCB1bml0cyBwZXIgZnJhbWVcbiAgICAgIGNvbnN0IGdlbyA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeSgxLCA4LCA4KTsgLy8gU21hbGxlciwgbW9yZSBkaXN0YW50XG4gICAgICBjb25zdCBtYXQgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoeyBjb2xvcjogMHhmZmZmZWUsIGVtaXNzaXZlOiAweGZmZmZlZSwgZW1pc3NpdmVJbnRlbnNpdHk6IDIgfSk7XG4gICAgICBjb25zdCBzdGFyID0gbmV3IFRIUkVFLk1lc2goZ2VvLCBtYXQpO1xuICAgICAgc3Rhci5wb3NpdGlvbi5jb3B5KHN0YXJ0UG9zKTtcbiAgICAgIHN0YXIudmVsb2NpdHkgPSBkaXIuY2xvbmUoKS5tdWx0aXBseVNjYWxhcihzcGVlZCk7XG4gICAgICBzdGFyLmxpZmUgPSAxLjA7XG5cbiAgICAgIC8vIFByZXR0eSwgZ2xvd2luZyB0YWlsIHVzaW5nIHBvaW50cyAoc3ByaXRlcykgaW5zdGVhZCBvZiBhIGxpbmVcbiAgICAgIGNvbnN0IHRhaWxMZW4gPSAyMDAgKyBNYXRoLnJhbmRvbSgpICogMTAwO1xuICAgICAgY29uc3QgdGFpbFNlZ21lbnRzID0gMjQ7XG4gICAgICBjb25zdCB0YWlsUG9pbnRzID0gW107XG4gICAgICBjb25zdCB0YWlsQ29sb3JzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhaWxTZWdtZW50czsgaSsrKSB7XG4gICAgICAgIC8vIFBvc2l0aW9uIGFsb25nIHRoZSB0YWlsXG4gICAgICAgIGNvbnN0IHQgPSBpIC8gKHRhaWxTZWdtZW50cyAtIDEpO1xuICAgICAgICAvLyBQb3NpdGlvbiBmYWRlcyBhd2F5IGZyb20gdGhlIHN0YXJcbiAgICAgICAgdGFpbFBvaW50cy5wdXNoKGRpci5jbG9uZSgpLm5lZ2F0ZSgpLm11bHRpcGx5U2NhbGFyKHRhaWxMZW4gKiB0KSk7XG4gICAgICAgIC8vIENvbG9yL2FscGhhOiBicmlnaHQgYXQgaGVhZCwgZmFkZXMgYXQgdGFpbFxuICAgICAgICBjb25zdCBhbHBoYSA9ICgxIC0gdCkgKiAwLjc7XG4gICAgICAgIC8vIFNvZnQgeWVsbG93LXdoaXRlIGdyYWRpZW50XG4gICAgICAgIHRhaWxDb2xvcnMucHVzaCgxLjAsIDEuMCwgMC44NSwgYWxwaGEpO1xuICAgICAgfVxuICAgICAgY29uc3QgdGFpbEdlbyA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xuICAgICAgdGFpbEdlby5zZXRGcm9tUG9pbnRzKHRhaWxQb2ludHMpO1xuICAgICAgdGFpbEdlby5zZXRBdHRyaWJ1dGUoJ2NvbG9yJywgbmV3IFRIUkVFLkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodGFpbENvbG9ycywgNCkpO1xuICAgICAgLy8gVXNlIGEgcm91bmQgc3ByaXRlIGZvciBlYWNoIHBvaW50XG4gICAgICBjb25zdCBzcHJpdGUgPSBuZXcgVEhSRUUuVGV4dHVyZUxvYWRlcigpLmxvYWQoJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9naC9tcmRvb2IvdGhyZWUuanNAbWFzdGVyL2V4YW1wbGVzL3RleHR1cmVzL3Nwcml0ZXMvY2lyY2xlLnBuZycpO1xuICAgICAgY29uc3QgdGFpbE1hdCA9IG5ldyBUSFJFRS5Qb2ludHNNYXRlcmlhbCh7XG4gICAgICAgIHNpemU6IDE2LFxuICAgICAgICBtYXA6IHNwcml0ZSxcbiAgICAgICAgdmVydGV4Q29sb3JzOiB0cnVlLFxuICAgICAgICB0cmFuc3BhcmVudDogdHJ1ZSxcbiAgICAgICAgZGVwdGhXcml0ZTogZmFsc2UsXG4gICAgICAgIGJsZW5kaW5nOiBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nLFxuICAgICAgfSk7XG4gICAgICBjb25zdCB0YWlsID0gbmV3IFRIUkVFLlBvaW50cyh0YWlsR2VvLCB0YWlsTWF0KTtcbiAgICAgIHRhaWwucG9zaXRpb24uY29weShzdGFyLnBvc2l0aW9uKTtcbiAgICAgIHRhaWwubGlmZSA9IDEuMDtcbiAgICAgIHNjZW5lLmFkZChzdGFyKTtcbiAgICAgIHNjZW5lLmFkZCh0YWlsKTtcbiAgICAgIHNob290aW5nU3RhcnMucHVzaCh7IG1lc2g6IHN0YXIsIHRhaWwsIHZlbG9jaXR5OiBzdGFyLnZlbG9jaXR5LCBkaXIsIGZhZGU6IGZhbHNlLCB0YWlsUG9pbnRzIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGFuaW1hdGUgPSAoKSA9PiB7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSlcbiAgICAgIGNhbWVyYS5yb3RhdGlvbi55ICs9ICh0YXJnZXRZIC0gY2FtZXJhLnJvdGF0aW9uLnkpICogZGFtcGluZ1xuICAgICAgY2FtZXJhLnRyYW5zbGF0ZVooLXN0YXJTcGVlZClcblxuICAgICAgLy8gU3Bhd24gc2hvb3Rpbmcgc3RhciBvY2Nhc2lvbmFsbHksIGJ1dCBub3QgdG9vIGZyZXF1ZW50bHlcbiAgICAgIC8vIERlY3JlYXNlIHNob290aW5nIHN0YXIgZnJlcXVlbmN5IGZvciBhIG1vcmUgc3VidGxlIGVmZmVjdFxuICAgICAgaWYgKHNob290aW5nU3RhckNvb2xkb3duIDw9IDAgJiYgTWF0aC5yYW5kb20oKSA8IDAuMDUpIHsgLy8gNSUgY2hhbmNlIHBlciBmcmFtZVxuICAgICAgICBzcGF3blNob290aW5nU3RhcigpO1xuICAgICAgICBzaG9vdGluZ1N0YXJDb29sZG93biA9IDMwICsgTWF0aC5yYW5kb20oKSAqIDQwOyAvLyAwLjUtMS4yIHNlY29uZHNcbiAgICAgIH0gZWxzZSBpZiAoc2hvb3RpbmdTdGFyQ29vbGRvd24gPiAwKSB7XG4gICAgICAgIHNob290aW5nU3RhckNvb2xkb3duLS07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBvc0FyciA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXlcbiAgICAgIGNvbnN0IHNxRGlzdCA9IHN0YXJNYXhEaXN0YW5jZSAqIHN0YXJNYXhEaXN0YW5jZVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3NBcnIubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgY29uc3QgZHggPSBwb3NBcnJbaV0gLSBjYW1lcmEucG9zaXRpb24ueFxuICAgICAgICBjb25zdCBkeSA9IHBvc0FycltpICsgMV0gLSBjYW1lcmEucG9zaXRpb24ueVxuICAgICAgICBjb25zdCBkeiA9IHBvc0FycltpICsgMl0gLSBjYW1lcmEucG9zaXRpb24uelxuICAgICAgICBpZiAoZHgqZHggKyBkeSpkeSArIGR6KmR6ID4gc3FEaXN0KSB7XG4gICAgICAgICAgY29uc3QgdGhldGEgPSBNYXRoLnJhbmRvbSgpICogMiAqIE1hdGguUElcbiAgICAgICAgICBjb25zdCBwaGkgPSBNYXRoLmFjb3MoMiAqIE1hdGgucmFuZG9tKCkgLSAxKVxuICAgICAgICAgIHBvc0FycltpXSA9IGNhbWVyYS5wb3NpdGlvbi54ICsgc3Rhck1heERpc3RhbmNlICogTWF0aC5zaW4ocGhpKSAqIE1hdGguY29zKHRoZXRhKVxuICAgICAgICAgIHBvc0FycltpKzFdID0gY2FtZXJhLnBvc2l0aW9uLnkgKyBzdGFyTWF4RGlzdGFuY2UgKiBNYXRoLnNpbihwaGkpICogTWF0aC5zaW4odGhldGEpXG4gICAgICAgICAgcG9zQXJyW2krMl0gPSBjYW1lcmEucG9zaXRpb24ueiArIHN0YXJNYXhEaXN0YW5jZSAqIE1hdGguY29zKHBoaSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWVcblxuICAgICAgY29uc3QgY29sQXJyID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvci5hcnJheVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3NBcnIubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gaS8zXG4gICAgICAgIGNvbnN0IGRpc3QgPSBNYXRoLnNxcnQocG9zQXJyW2ldKnBvc0FycltpXSArIHBvc0FycltpKzFdKnBvc0FycltpKzFdICsgcG9zQXJyW2krMl0qcG9zQXJyW2krMl0pXG4gICAgICAgIGlmICh0aW1lcnNbaWR4XSA+IDApIHRpbWVyc1tpZHhdLS1cbiAgICAgICAgZWxzZSBpZiAoZGlzdCA+IHN0YXJNYXhEaXN0YW5jZSowLjMgJiYgTWF0aC5yYW5kb20oKSA8IDAuMDUpIHtcbiAgICAgICAgICB0aW1lcnNbaWR4XSA9IHNwYXJrbGVEdXJhdGlvblxuICAgICAgICAgIGNvbnN0IGMgPSBwYWxldHRlW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSpwYWxldHRlLmxlbmd0aCldXG4gICAgICAgICAgc3BhcmtDb2xvcnNbaV0gPSBjWzBdOyBzcGFya0NvbG9yc1tpKzFdID0gY1sxXTsgc3BhcmtDb2xvcnNbaSsyXSA9IGNbMl1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZXJzW2lkeF0gPiAwKSB7XG4gICAgICAgICAgY29sQXJyW2ldID0gc3BhcmtDb2xvcnNbaV07IGNvbEFycltpKzFdID0gc3BhcmtDb2xvcnNbaSsxXTsgY29sQXJyW2krMl0gPSBzcGFya0NvbG9yc1tpKzJdXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29sQXJyW2ldID0gb3JpZ2luYWxDb2xvcnNbaV07IGNvbEFycltpKzFdID0gb3JpZ2luYWxDb2xvcnNbaSsxXTsgY29sQXJyW2krMl0gPSBvcmlnaW5hbENvbG9yc1tpKzJdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3IubmVlZHNVcGRhdGUgPSB0cnVlXG5cbiAgICAgIHN0YXJzLnJvdGF0aW9uLnggKz0gMC4wMDAxXG4gICAgICBzdGFycy5yb3RhdGlvbi55ICs9IDAuMDAwMTVcblxuICAgICAgLy8gUmVtb3ZlIGV4dHJhIHJhbmRvbSBzcGF3biBmb3Igc2hvb3Rpbmcgc3RhcnNcbiAgICAgIC8vIChubyBhZGRpdGlvbmFsIHJhbmRvbSBzcGF3bnMsIG9ubHkgYWJvdmUgbG9naWMpXG4gICAgICBmb3IgKGxldCBpID0gc2hvb3RpbmdTdGFycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBvYmogPSBzaG9vdGluZ1N0YXJzW2ldO1xuICAgICAgICAvLyBNb3ZlIHNob290aW5nIHN0YXIgaW4gd29ybGQgc3BhY2UsIGluZGVwZW5kZW50IG9mIGNhbWVyYVxuICAgICAgICBvYmoubWVzaC5wb3NpdGlvbi5hZGQob2JqLnZlbG9jaXR5KTtcbiAgICAgICAgLy8gVXBkYXRlIHRhaWwgcG9pbnRzIHRvIGZvbGxvdyBzdGFyJ3MgcGF0aCBpbiB3b3JsZCBzcGFjZVxuICAgICAgICBmb3IgKGxldCBqID0gb2JqLnRhaWxQb2ludHMubGVuZ3RoIC0gMTsgaiA+IDA7IGotLSkge1xuICAgICAgICAgIG9iai50YWlsUG9pbnRzW2pdLmNvcHkob2JqLnRhaWxQb2ludHNbaiAtIDFdKTtcbiAgICAgICAgfVxuICAgICAgICBvYmoudGFpbFBvaW50c1swXSA9IG9iai5tZXNoLnBvc2l0aW9uLmNsb25lKCk7XG4gICAgICAgIG9iai50YWlsLmdlb21ldHJ5LnNldEZyb21Qb2ludHMob2JqLnRhaWxQb2ludHMpO1xuICAgICAgICAvLyBVcGRhdGUgdGFpbCBhbHBoYSBncmFkaWVudFxuICAgICAgICBjb25zdCBjb2xvcnMgPSBvYmoudGFpbC5nZW9tZXRyeS5hdHRyaWJ1dGVzLmNvbG9yLmFycmF5O1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG9iai50YWlsUG9pbnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgLy8gQWxwaGEgZmFkZXMgb3V0IHdpdGggYm90aCB0YWlsIHBvc2l0aW9uIGFuZCBzdGFyIGxpZmVcbiAgICAgICAgICBjb2xvcnNbaiAqIDQgKyAzXSA9ICgxIC0gaiAvIChvYmoudGFpbFBvaW50cy5sZW5ndGggLSAxKSkgKiAwLjcgKiBNYXRoLm1heCgwLCBvYmoubWVzaC5saWZlKTtcbiAgICAgICAgfVxuICAgICAgICBvYmoudGFpbC5nZW9tZXRyeS5hdHRyaWJ1dGVzLmNvbG9yLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgb2JqLnRhaWwucG9zaXRpb24uc2V0KDAsIDAsIDApOyAvLyB0YWlsIHBvaW50cyBhcmUgYWJzb2x1dGVcbiAgICAgICAgb2JqLnRhaWwubGlmZSAtPSAwLjAxO1xuICAgICAgICBvYmoubWVzaC5saWZlIC09IDAuMDE7XG4gICAgICAgIC8vIEZhZGUgdGhlIHRhaWwgc21vb3RobHkgYmFzZWQgb24gbGlmZVxuICAgICAgICBvYmoudGFpbC5tYXRlcmlhbC5vcGFjaXR5ID0gMS4wO1xuICAgICAgICBpZiAob2JqLm1lc2gubGlmZSA8PSAwKSB7XG4gICAgICAgICAgc2NlbmUucmVtb3ZlKG9iai5tZXNoKTtcbiAgICAgICAgICBzY2VuZS5yZW1vdmUob2JqLnRhaWwpO1xuICAgICAgICAgIHNob290aW5nU3RhcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNhbSA9IGNhbWVyYS5wb3NpdGlvbi5jbG9uZSgpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc0Fyci5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICBwb3NBcnJbaV0gLT0gY2FtLng7IHBvc0FycltpKzFdIC09IGNhbS55OyBwb3NBcnJbaSsyXSAtPSBjYW0uelxuICAgICAgfVxuICAgICAgZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWVcbiAgICAgIHNob290aW5nU3RhcnMuZm9yRWFjaChvYmogPT4ge1xuICAgICAgICBvYmoubWVzaC5wb3NpdGlvbi5zdWIoY2FtKTtcbiAgICAgICAgb2JqLnRhaWwucG9zaXRpb24uc3ViKGNhbSk7XG4gICAgICB9KVxuICAgICAgY2FtZXJhLnBvc2l0aW9uLnNldCgwLCAwLCAwKVxuICAgICAgcmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmEpXG4gICAgfVxuICAgIGFuaW1hdGUoKVxuXG4gICAgY29uc3Qgb25SZXNpemUgPSAoKSA9PiB7XG4gICAgICBjYW1lcmEuYXNwZWN0ID0gd2luZG93LmlubmVyV2lkdGggLyB3aW5kb3cuaW5uZXJIZWlnaHRcbiAgICAgIGNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KClcbiAgICAgIHJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodClcbiAgICB9XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uUmVzaXplKVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBvblNjcm9sbClcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvblJlc2l6ZSlcbiAgICAgIG1vdW50LnJlbW92ZUNoaWxkKHJlbmRlcmVyLmRvbUVsZW1lbnQpXG4gICAgfVxuICB9LCBbXSlcblxuICByZXR1cm4gPGRpdiByZWY9e21vdW50UmVmfSAvPlxufVxuXG5leHBvcnQgZGVmYXVsdCBTdGFyZmllbGRcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUVmZmVjdCIsInVzZVJlZiIsIlRIUkVFIiwiU3RhcmZpZWxkIiwibW91bnRSZWYiLCJtb3VudCIsImN1cnJlbnQiLCJzdHlsZSIsInBvc2l0aW9uIiwidG9wIiwibGVmdCIsIndpZHRoIiwiaGVpZ2h0IiwiekluZGV4Iiwic2NlbmUiLCJTY2VuZSIsImNhbWVyYSIsIlBlcnNwZWN0aXZlQ2FtZXJhIiwid2luZG93IiwiaW5uZXJXaWR0aCIsImlubmVySGVpZ2h0IiwicmVuZGVyZXIiLCJXZWJHTFJlbmRlcmVyIiwiYW50aWFsaWFzIiwic2V0UGl4ZWxSYXRpbyIsImRldmljZVBpeGVsUmF0aW8iLCJzZXRTaXplIiwiYXBwZW5kQ2hpbGQiLCJkb21FbGVtZW50Iiwic3RhckNvdW50Iiwic3Rhck1heERpc3RhbmNlIiwic3RhclNwZWVkIiwiZ2VvbWV0cnkiLCJCdWZmZXJHZW9tZXRyeSIsInBvc2l0aW9ucyIsImkiLCJ0aGV0YSIsIk1hdGgiLCJyYW5kb20iLCJQSSIsInBoaSIsImFjb3MiLCJyIiwicHVzaCIsInNpbiIsImNvcyIsInNldEF0dHJpYnV0ZSIsIkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUiLCJwYWxldHRlIiwiY29sb3JzIiwiYyIsImZsb29yIiwibGVuZ3RoIiwib3JpZ2luYWxDb2xvcnMiLCJhdHRyaWJ1dGVzIiwiY29sb3IiLCJhcnJheSIsInNsaWNlIiwidGltZXJzIiwiRmxvYXQzMkFycmF5Iiwic3BhcmtDb2xvcnMiLCJzcGFya2xlRHVyYXRpb24iLCJtYXRlcmlhbCIsIlBvaW50c01hdGVyaWFsIiwic2l6ZSIsInNpemVBdHRlbnVhdGlvbiIsInZlcnRleENvbG9ycyIsInN0YXJzIiwiUG9pbnRzIiwiYWRkIiwidGFyZ2V0WSIsImRhbXBpbmciLCJvblNjcm9sbCIsInBjdCIsInNjcm9sbFkiLCJkb2N1bWVudCIsImJvZHkiLCJzY3JvbGxIZWlnaHQiLCJhZGRFdmVudExpc3RlbmVyIiwidGFpbExlbmd0aCIsInNob290aW5nU3RhcnMiLCJzaG9vdGluZ1N0YXJDb29sZG93biIsInNwYXduU2hvb3RpbmdTdGFyIiwibWluQW5nbGUiLCJtYXhBbmdsZSIsIm1pbkRpc3RhbmNlIiwiY2FtZXJhRGlyIiwiVmVjdG9yMyIsImdldFdvcmxkRGlyZWN0aW9uIiwic3Bhd25EaXIiLCJhbmdsZUZyb21DZW50ZXIiLCJhemltdXRoIiwiY2xvbmUiLCJheGlzIiwibm9ybWFsaXplIiwiYXBwbHlBeGlzQW5nbGUiLCJkb3QiLCJkaXN0YW5jZSIsInN0YXJ0UG9zIiwibXVsdGlwbHlTY2FsYXIiLCJhd2F5IiwicGVycCIsInN1YiIsInByb2plY3RPblZlY3RvciIsImRpciIsInNwZWVkIiwiZ2VvIiwiU3BoZXJlR2VvbWV0cnkiLCJtYXQiLCJNZXNoQmFzaWNNYXRlcmlhbCIsImVtaXNzaXZlIiwiZW1pc3NpdmVJbnRlbnNpdHkiLCJzdGFyIiwiTWVzaCIsImNvcHkiLCJ2ZWxvY2l0eSIsImxpZmUiLCJ0YWlsTGVuIiwidGFpbFNlZ21lbnRzIiwidGFpbFBvaW50cyIsInRhaWxDb2xvcnMiLCJ0IiwibmVnYXRlIiwiYWxwaGEiLCJ0YWlsR2VvIiwic2V0RnJvbVBvaW50cyIsInNwcml0ZSIsIlRleHR1cmVMb2FkZXIiLCJsb2FkIiwidGFpbE1hdCIsIm1hcCIsInRyYW5zcGFyZW50IiwiZGVwdGhXcml0ZSIsImJsZW5kaW5nIiwiQWRkaXRpdmVCbGVuZGluZyIsInRhaWwiLCJtZXNoIiwiZmFkZSIsImFuaW1hdGUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJyb3RhdGlvbiIsInkiLCJ0cmFuc2xhdGVaIiwicG9zQXJyIiwic3FEaXN0IiwiZHgiLCJ4IiwiZHkiLCJkeiIsInoiLCJuZWVkc1VwZGF0ZSIsImNvbEFyciIsImlkeCIsImRpc3QiLCJzcXJ0Iiwib2JqIiwiaiIsIm1heCIsInNldCIsIm9wYWNpdHkiLCJyZW1vdmUiLCJzcGxpY2UiLCJjYW0iLCJmb3JFYWNoIiwicmVuZGVyIiwib25SZXNpemUiLCJhc3BlY3QiLCJ1cGRhdGVQcm9qZWN0aW9uTWF0cml4IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJlbW92ZUNoaWxkIiwiZGl2IiwicmVmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/Starfield.jsx\n"));

/***/ })

});