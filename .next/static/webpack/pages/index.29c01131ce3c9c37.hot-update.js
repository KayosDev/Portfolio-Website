"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./components/Starfield.jsx":
/*!**********************************!*\
  !*** ./components/Starfield.jsx ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar _s = $RefreshSig$();\n\n\nconst Starfield = ()=>{\n    _s();\n    const mountRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const mount = mountRef.current;\n        mount.style.position = \"fixed\";\n        mount.style.top = \"0\";\n        mount.style.left = \"0\";\n        mount.style.width = \"100%\";\n        mount.style.height = \"100%\";\n        mount.style.zIndex = \"0\";\n        // Scene & Renderer\n        const scene = new three__WEBPACK_IMPORTED_MODULE_2__.Scene();\n        const camera = new three__WEBPACK_IMPORTED_MODULE_2__.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);\n        camera.position.set(0, 0, 0);\n        // Virtual position to simulate infinite travel\n        let virtualCameraPos = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0, 0);\n        const renderer = new three__WEBPACK_IMPORTED_MODULE_2__.WebGLRenderer({\n            antialias: true\n        });\n        renderer.setPixelRatio(window.devicePixelRatio);\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        renderer.setClearColor(0x000000, 1);\n        mount.appendChild(renderer.domElement);\n        // Starfield\n        const starCount = 5000;\n        const starMaxDistance = 1000;\n        const starSpeed = 1;\n        const geometry = new three__WEBPACK_IMPORTED_MODULE_2__.BufferGeometry();\n        const positions = [];\n        let starsPlaced = 0;\n        while(starsPlaced < starCount){\n            // With 1% chance, spawn a star cluster (10-30 stars)\n            if (Math.random() < 0.01 && starsPlaced < starCount - 10) {\n                const clusterTheta = Math.random() * 2 * Math.PI;\n                const clusterPhi = Math.acos(2 * Math.random() - 1);\n                const clusterR = Math.random() * starMaxDistance;\n                const clusterCenter = [\n                    clusterR * Math.sin(clusterPhi) * Math.cos(clusterTheta),\n                    clusterR * Math.sin(clusterPhi) * Math.sin(clusterTheta),\n                    clusterR * Math.cos(clusterPhi)\n                ];\n                const clusterSize = 10 + Math.floor(Math.random() * 20); // 10-30 stars\n                for(let c = 0; c < clusterSize && starsPlaced < starCount; c++){\n                    // Each star in cluster is within 30 units of center\n                    const offsetTheta = Math.random() * 2 * Math.PI;\n                    const offsetPhi = Math.acos(2 * Math.random() - 1);\n                    const offsetR = Math.random() * 30; // cluster radius\n                    positions.push(clusterCenter[0] + offsetR * Math.sin(offsetPhi) * Math.cos(offsetTheta), clusterCenter[1] + offsetR * Math.sin(offsetPhi) * Math.sin(offsetTheta), clusterCenter[2] + offsetR * Math.cos(offsetPhi));\n                    starsPlaced++;\n                }\n            } else {\n                // Normal single star\n                const theta = Math.random() * 2 * Math.PI;\n                const phi = Math.acos(2 * Math.random() - 1);\n                const r = Math.random() * starMaxDistance;\n                positions.push(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));\n                starsPlaced++;\n            }\n        }\n        geometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_2__.Float32BufferAttribute(positions, 3));\n        const palette = [\n            [\n                1.0,\n                0.5,\n                0.5\n            ],\n            [\n                1.0,\n                0.75,\n                0.4\n            ],\n            [\n                1.0,\n                1.0,\n                0.9\n            ],\n            [\n                1.0,\n                1.0,\n                1.0\n            ],\n            [\n                0.4,\n                0.5,\n                1.0\n            ]\n        ];\n        const colors = [];\n        for(let i = 0; i < starCount; i++){\n            const c = palette[Math.floor(Math.random() * palette.length)];\n            colors.push(...c);\n        }\n        geometry.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_2__.Float32BufferAttribute(colors, 3));\n        const originalColors = geometry.attributes.color.array.slice();\n        const timers = new Float32Array(starCount);\n        const sparkColors = new Float32Array(starCount * 3);\n        const sparkleDuration = 180;\n        const material = new three__WEBPACK_IMPORTED_MODULE_2__.PointsMaterial({\n            size: 3.5,\n            sizeAttenuation: true,\n            vertexColors: true\n        });\n        const stars = new three__WEBPACK_IMPORTED_MODULE_2__.Points(geometry, material);\n        scene.add(stars);\n        let targetY = 0;\n        const damping = 0.05;\n        const onScroll = ()=>{\n            const pct = window.scrollY / (document.body.scrollHeight - window.innerHeight);\n            targetY = pct * Math.PI * 2;\n        };\n        window.addEventListener(\"scroll\", onScroll);\n        // --- Shooting Stars ---\n        const tailLength = 32; // Increase for longer tails\n        const shootingStars = [];\n        let shootingStarCooldown = 0;\n        // Spawn a shooting star with a glowing tail\n        function spawnShootingStar() {\n            // Pick a random direction on the sphere for the spawn location\n            const dir = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();\n            const minDist = starMaxDistance * 0.8;\n            const maxDist = starMaxDistance * 1.0;\n            const dist = minDist + Math.random() * (maxDist - minDist);\n            // Place the star at the distant edge\n            const spawnPos = dir.clone().multiplyScalar(dist);\n            // Tangential velocity: perpendicular to dir\n            let tangent = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1);\n            tangent = tangent.sub(tangent.clone().projectOnVector(dir)).normalize();\n            // Mix in a small radial component (inward or outward)\n            const tangentialSpeed = starSpeed * (0.5 + Math.random() * 1.5);\n            const radialSpeed = starSpeed * (Math.random() - 0.5) * 0.2; // small inward/outward\n            const velocity = tangent.multiplyScalar(tangentialSpeed).add(dir.clone().multiplyScalar(radialSpeed));\n            // Star color: random white/yellow/blue\n            const colors = [\n                0xffffee,\n                0xfff2cc,\n                0xcce6ff,\n                0xffffff\n            ];\n            const color = colors[Math.floor(Math.random() * colors.length)];\n            // Star brightness\n            const brightness = 1.2 + Math.random() * 1.5;\n            const geo = new three__WEBPACK_IMPORTED_MODULE_2__.SphereGeometry(1.5 + Math.random(), 16, 16);\n            const mat = new three__WEBPACK_IMPORTED_MODULE_2__.MeshBasicMaterial({\n                color: color\n            });\n            mat.opacity = 0.7 + Math.random() * 0.3;\n            mat.baseOpacity = mat.opacity; // Save for fade logic\n            mat.transparent = true;\n            const star = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(geo, mat);\n            star.position.copy(spawnPos);\n            star.velocity = velocity;\n            star.normalizedLife = 0.0; // Start at 0, will increase to 1.0\n            star.normalizedLifetime = 60 + Math.random() * 30; // Shorter normalizedLifetime: 60-90 frames\n            star.age = 0; // Track age in frames\n            // --- Realistic Meteor Tail (multi-point, gradient, fading) ---\n            const trailSegments = tailLength;\n            const trailPoints = [];\n            for(let i = 0; i < trailSegments; i++){\n                trailPoints.push(star.position.clone());\n            }\n            const tailGeo = new three__WEBPACK_IMPORTED_MODULE_2__.BufferGeometry().setFromPoints(trailPoints);\n            // Per-vertex color (alpha gradient)\n            const tailColors = [];\n            for(let i = 0; i < trailSegments; i++){\n                // Alpha fades out along the tail\n                const alpha = (1 - i / (trailSegments - 1)) * 0.85; // More persistent\n                // Color shifts from head color to faint blue/white/orange\n                let gradientColor;\n                if (i < trailSegments * 0.2) gradientColor = color; // head\n                else if (i < trailSegments * 0.7) gradientColor = 0x80c0ff;\n                else gradientColor = 0xffc080;\n                tailColors.push((gradientColor >> 16 & 255) / 255, (gradientColor >> 8 & 255) / 255, (gradientColor & 255) / 255, alpha);\n            }\n            tailGeo.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_2__.Float32BufferAttribute(tailColors, 4));\n            // Additive blending for glow\n            const tailMat = new three__WEBPACK_IMPORTED_MODULE_2__.LineBasicMaterial({\n                vertexColors: true,\n                transparent: true,\n                opacity: 1.0,\n                blending: three__WEBPACK_IMPORTED_MODULE_2__.AdditiveBlending\n            });\n            const tail = new three__WEBPACK_IMPORTED_MODULE_2__.Line(tailGeo, tailMat);\n            tail.position.copy(star.position);\n            // Add to scene\n            scene.add(star);\n            scene.add(tail);\n            shootingStars.push({\n                mesh: star,\n                tail,\n                velocity: star.velocity,\n                dir,\n                age: 0,\n                normalizedLifetime: star.normalizedLifetime,\n                trailPoints,\n                color,\n                brightness,\n                hasFragmented: false\n            });\n        }\n        const animate = ()=>{\n            requestAnimationFrame(animate);\n            camera.rotation.y += (targetY - camera.rotation.y) * damping;\n            // Move the virtual camera position in the direction the camera is facing\n            const forward = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n            camera.getWorldDirection(forward);\n            virtualCameraPos.add(forward.multiplyScalar(starSpeed));\n            // Offset all stars by -virtualCameraPos (floating origin)\n            for(let i = 0; i < positions.length; i += 3){\n                geometry.attributes.position.array[i] = positions[i] - virtualCameraPos.x;\n                geometry.attributes.position.array[i + 1] = positions[i + 1] - virtualCameraPos.y;\n                geometry.attributes.position.array[i + 2] = positions[i + 2] - virtualCameraPos.z;\n            }\n            geometry.attributes.position.needsUpdate = true;\n            // --- Shooting star spawning ---\n            // DEV: Make shooting stars super common (spawn every frame if cooldown allows)\n            if (shootingStarCooldown <= 0 && Math.random() < 0.1) {\n                spawnShootingStar();\n                shootingStarCooldown = 10 + Math.random() * 10; // Longer cooldown for perf\n            } else if (shootingStarCooldown > 0) {\n                shootingStarCooldown--;\n            }\n            // Animate and clean up shooting stars\n            for(let i = shootingStars.length - 1; i >= 0; i--){\n                const obj = shootingStars[i];\n                // Curved trajectory\n                let perp = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5);\n                perp = perp.sub(perp.clone().projectOnVector(obj.velocity)).normalize().multiplyScalar(0.002 + Math.random() * 0.001);\n                obj.velocity.add(perp);\n                obj.velocity.normalize().multiplyScalar(obj.velocity.length());\n                obj.mesh.position.add(obj.velocity);\n                obj.tail.position.copy(obj.mesh.position);\n                // Animate tail\n                obj.age++;\n                const normalizedLife = obj.age / obj.normalizedLifetime;\n                for(let t = obj.trailPoints.length - 1; t > 0; t--){\n                    obj.trailPoints[t].lerp(obj.trailPoints[t - 1], 0.45);\n                }\n                obj.trailPoints[0].copy(obj.mesh.position);\n                let tailGrow = Math.min(1, normalizedLife / 0.3);\n                let activeSegments = Math.floor(obj.trailPoints.length * tailGrow);\n                if (activeSegments < 2) activeSegments = 2;\n                const visibleTrail = obj.trailPoints.slice(0, activeSegments);\n                obj.tail.geometry.setFromPoints(visibleTrail);\n                const tailColors = obj.tail.geometry.getAttribute(\"color\");\n                for(let j = 0; j < visibleTrail.length; j++){\n                    let alpha = (1 - j / (visibleTrail.length - 1)) * 0.95;\n                    alpha *= 0.92 + 0.08 * Math.sin(Date.now() * 0.015 + j * 0.5);\n                    let rainbow = [\n                        0xffc080,\n                        0xffe080,\n                        0xffff80,\n                        0x80ffe6,\n                        0x80c0ff,\n                        0xc080ff\n                    ];\n                    let gradColor = rainbow[j % rainbow.length];\n                    if (normalizedLife > 0.7) alpha *= Math.max(0, 1 - (normalizedLife - 0.7 - 0.2) / 0.3);\n                    tailColors.setXYZW(j, (gradColor >> 16 & 255) / 255, (gradColor >> 8 & 255) / 255, (gradColor & 255) / 255, alpha);\n                }\n                tailColors.needsUpdate = true;\n                // Animate head\n                let headColor;\n                if (normalizedLife < 0.5) {\n                    headColor = new three__WEBPACK_IMPORTED_MODULE_2__.Color(obj.color).lerp(new three__WEBPACK_IMPORTED_MODULE_2__.Color(0xffc080), normalizedLife * 2);\n                } else {\n                    headColor = new three__WEBPACK_IMPORTED_MODULE_2__.Color(0xffc080).lerp(new three__WEBPACK_IMPORTED_MODULE_2__.Color(0xff4000), (normalizedLife - 0.5) * 2);\n                }\n                let flicker = 0.95 + 0.13 * Math.sin(Date.now() * 0.07 + Math.random() * 10);\n                headColor.multiplyScalar(flicker);\n                obj.mesh.material.color.copy(headColor);\n                let scale = 1 + 2.2 * Math.sin(Math.PI * normalizedLife);\n                let distToCam = obj.mesh.position.length();\n                let dofBlur = distToCam < starMaxDistance * 0.7 ? 0.7 : 1.0;\n                obj.mesh.scale.set(scale * dofBlur, scale * dofBlur, scale * dofBlur);\n                // Sparkle burst\n                if (normalizedLife >= 1 && !obj.hasFragmented) {\n                    for(let s = 0; s < 9; s++){\n                        const sparkleGeo = new three__WEBPACK_IMPORTED_MODULE_2__.SphereGeometry(0.7 + Math.random() * 0.8, 8, 8);\n                        const sparkleMat = new three__WEBPACK_IMPORTED_MODULE_2__.MeshBasicMaterial({\n                            color: 0xffffff,\n                            transparent: true,\n                            opacity: 0.7,\n                            blending: three__WEBPACK_IMPORTED_MODULE_2__.AdditiveBlending\n                        });\n                        const sparkle = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(sparkleGeo, sparkleMat);\n                        sparkle.position.copy(obj.mesh.position);\n                        const sparkleVel = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize().multiplyScalar(2 + Math.random() * 2);\n                        sparkle.userData = {\n                            velocity: sparkleVel,\n                            age: 0\n                        };\n                        scene.add(sparkle);\n                        if (!window._sparkles) window._sparkles = [];\n                        window._sparkles.push(sparkle);\n                    }\n                    const fragVel = obj.velocity.clone().applyAxisAngle(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 1, 0), (Math.random() - 0.5) * 0.3);\n                    const fragStar = obj.mesh.clone();\n                    fragStar.position.copy(obj.mesh.position);\n                    fragStar.velocity = fragVel;\n                    fragStar.normalizedLife = normalizedLife;\n                    fragStar.normalizedLifetime = obj.normalizedLifetime * (0.5 + Math.random() * 0.5);\n                    fragStar.age = obj.age;\n                    fragStar.material = obj.mesh.material.clone();\n                    const fragTrailPoints = obj.trailPoints.slice();\n                    const fragTailGeo = new three__WEBPACK_IMPORTED_MODULE_2__.BufferGeometry().setFromPoints(fragTrailPoints);\n                    fragTailGeo.setAttribute(\"color\", obj.tail.geometry.getAttribute(\"color\").clone());\n                    const fragTailMat = obj.tail.material.clone();\n                    const fragTail = new three__WEBPACK_IMPORTED_MODULE_2__.Line(fragTailGeo, fragTailMat);\n                    fragTail.position.copy(fragStar.position);\n                    scene.add(fragStar);\n                    scene.add(fragTail);\n                    shootingStars.push({\n                        mesh: fragStar,\n                        tail: fragTail,\n                        velocity: fragStar.velocity,\n                        dir: obj.dir,\n                        age: fragStar.age,\n                        normalizedLifetime: fragStar.normalizedLifetime,\n                        trailPoints: fragTrailPoints,\n                        color: obj.color,\n                        brightness: obj.brightness,\n                        hasFragmented: true\n                    });\n                    obj.hasFragmented = true;\n                }\n                // Spark burst\n                if (!obj.hasSparked && normalizedLife > 0.95 && Math.random() < 0.1) {\n                    for(let s = 0; s < 8 + Math.floor(Math.random() * 8); s++){\n                        const sparkGeo = new three__WEBPACK_IMPORTED_MODULE_2__.SphereGeometry(0.5 + Math.random() * 0.5, 8, 8);\n                        const sparkMat = new three__WEBPACK_IMPORTED_MODULE_2__.MeshBasicMaterial({\n                            color: 0xfff6c0,\n                            transparent: true,\n                            opacity: 1,\n                            blending: three__WEBPACK_IMPORTED_MODULE_2__.AdditiveBlending\n                        });\n                        const spark = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(sparkGeo, sparkMat);\n                        spark.position.copy(obj.mesh.position);\n                        spark.sparkVel = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize().multiplyScalar(0.5 + Math.random() * 1.2);\n                        spark.sparkLife = 12 + Math.random() * 10;\n                        spark.sparkAge = 0;\n                        scene.add(spark);\n                        if (!window._starSparks) window._starSparks = [];\n                        window._starSparks.push(spark);\n                    }\n                    obj.hasSparked = true;\n                }\n                // Flash\n                if (!obj.hasFlashed && normalizedLife > 0.98 && Math.random() < 0.2) {\n                    const flashGeo = new three__WEBPACK_IMPORTED_MODULE_2__.SphereGeometry(1, 16, 16);\n                    const flashMat = new three__WEBPACK_IMPORTED_MODULE_2__.MeshBasicMaterial({\n                        color: 0xffffee,\n                        transparent: true,\n                        opacity: 0.8,\n                        blending: three__WEBPACK_IMPORTED_MODULE_2__.AdditiveBlending\n                    });\n                    const flash = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(flashGeo, flashMat);\n                    flash.position.copy(obj.mesh.position);\n                    scene.add(flash);\n                    if (!window._starFlashes) window._starFlashes = [];\n                    window._starFlashes.push({\n                        mesh: flash,\n                        age: 0\n                    });\n                    obj.hasFlashed = true;\n                }\n                // Fade out as it gets far away\n                const dist = obj.mesh.position.distanceTo(camera.position);\n                const fadeStart = starMaxDistance * 0.5;\n                if (dist > fadeStart) {\n                    const fade = 1 - (dist - fadeStart) / (starMaxDistance - fadeStart);\n                    obj.mesh.material.opacity = Math.max(0, fade);\n                    obj.mesh.material.transparent = true;\n                    obj.tail.material.opacity = Math.max(0, fade * 0.8);\n                    obj.tail.material.transparent = true;\n                }\n                // Remove when out of bounds or fully faded or life ended\n                if (normalizedLife >= 1.0 || dist > starMaxDistance || obj.mesh.material.opacity <= 0.01) {\n                    scene.remove(obj.mesh);\n                    scene.remove(obj.tail);\n                    shootingStars.splice(i, 1);\n                }\n            }\n            // Animate sparks\n            if (window._starSparks) {\n                for(let i = window._starSparks.length - 1; i >= 0; i--){\n                    const spark = window._starSparks[i];\n                    spark.position.add(spark.sparkVel);\n                    spark.sparkAge++;\n                    spark.material.opacity *= 0.85;\n                    if (spark.sparkAge > spark.sparkLife) {\n                        scene.remove(spark);\n                        window._starSparks.splice(i, 1);\n                    }\n                }\n            }\n            // Animate flashes\n            if (window._starFlashes) {\n                for(let i = window._starFlashes.length - 1; i >= 0; i--){\n                    const flash = window._starFlashes[i];\n                    flash.mesh.scale.multiplyScalar(1.15);\n                    flash.mesh.material.opacity *= 0.85;\n                    flash.age++;\n                    if (flash.age > 10) {\n                        scene.remove(flash.mesh);\n                        window._starFlashes.splice(i, 1);\n                    }\n                }\n            }\n            // --- Starfield logic ---\n            const sqDist = starMaxDistance * starMaxDistance;\n            for(let i = 0; i < positions.length; i += 3){\n                const dx = positions[i] - virtualCameraPos.x;\n                const dy = positions[i + 1] - virtualCameraPos.y;\n                const dz = positions[i + 2] - virtualCameraPos.z;\n                if (dx * dx + dy * dy + dz * dz > sqDist) {\n                    // Place in a thick spherical shell around the virtual camera, never too close\n                    const minRadius = starMaxDistance * 0.8;\n                    const maxRadius = starMaxDistance;\n                    const r = minRadius + Math.random() * (maxRadius - minRadius);\n                    const theta = Math.random() * 2 * Math.PI;\n                    const phi = Math.acos(2 * Math.random() - 1);\n                    positions[i] = virtualCameraPos.x + r * Math.sin(phi) * Math.cos(theta);\n                    positions[i + 1] = virtualCameraPos.y + r * Math.sin(phi) * Math.sin(theta);\n                    positions[i + 2] = virtualCameraPos.z + r * Math.cos(phi);\n                }\n            }\n            // geometry.attributes.position.needsUpdate = true; // Already set above\n            // Robust starfield color update to prevent stuck white dots\n            const colArr = geometry.attributes.color.array;\n            for(let i = 0; i < positions.length; i += 3){\n                const idx = i / 3;\n                const dx = positions[i] - virtualCameraPos.x;\n                const dy = positions[i + 1] - virtualCameraPos.y;\n                const dz = positions[i + 2] - virtualCameraPos.z;\n                const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);\n                if (timers[idx] > 0) {\n                    timers[idx]--;\n                    if (timers[idx] === 0) {\n                        // Timer expired, restore color\n                        sparkColors[i] = originalColors[i];\n                        sparkColors[i + 1] = originalColors[i + 1];\n                        sparkColors[i + 2] = originalColors[i + 2];\n                        colArr[i] = originalColors[i];\n                        colArr[i + 1] = originalColors[i + 1];\n                        colArr[i + 2] = originalColors[i + 2];\n                    } else {\n                        colArr[i] = sparkColors[i];\n                        colArr[i + 1] = sparkColors[i + 1];\n                        colArr[i + 2] = sparkColors[i + 2];\n                    }\n                } else if (dist > starMaxDistance * 0.3 && Math.random() < 0.05) {\n                    timers[idx] = sparkleDuration;\n                    const c = palette[Math.floor(Math.random() * palette.length)];\n                    sparkColors[i] = c[0];\n                    sparkColors[i + 1] = c[1];\n                    sparkColors[i + 2] = c[2];\n                    colArr[i] = sparkColors[i];\n                    colArr[i + 1] = sparkColors[i + 1];\n                    colArr[i + 2] = sparkColors[i + 2];\n                } else {\n                    sparkColors[i] = originalColors[i];\n                    sparkColors[i + 1] = originalColors[i + 1];\n                    sparkColors[i + 2] = originalColors[i + 2];\n                    colArr[i] = originalColors[i];\n                    colArr[i + 1] = originalColors[i + 1];\n                    colArr[i + 2] = originalColors[i + 2];\n                }\n            }\n            geometry.attributes.color.needsUpdate = true;\n            renderer.render(scene, camera);\n        };\n        animate(); // Start the render loop\n        const onResize = ()=>{\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        };\n        window.addEventListener(\"resize\", onResize);\n        return ()=>{\n            window.removeEventListener(\"scroll\", onScroll);\n            window.removeEventListener(\"resize\", onResize);\n            mount.removeChild(renderer.domElement);\n        };\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: mountRef\n    }, void 0, false, {\n        fileName: \"/home/kayosdev/Websites/Portfolio/components/Starfield.jsx\",\n        lineNumber: 424,\n        columnNumber: 10\n    }, undefined);\n};\n_s(Starfield, \"V9/qkEdV8GfsDZk7lMTA1T8g5Ps=\");\n_c = Starfield;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Starfield);\nvar _c;\n$RefreshReg$(_c, \"Starfield\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O1FBQ3ZDO0lBQ0YsR0FBRyxFQUFFO0lBRUwscUJBQU8sOERBQUN5TDtRQUFJQyxLQUFLdE47Ozs7OztBQUNuQjtHQXJhTUQ7S0FBQUE7QUF1YU4sK0RBQWVBLFNBQVNBLEVBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9TdGFyZmllbGQuanN4P2YxYTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuXG5jb25zdCBTdGFyZmllbGQgPSAoKSA9PiB7XG4gIGNvbnN0IG1vdW50UmVmID0gdXNlUmVmKG51bGwpXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBtb3VudCA9IG1vdW50UmVmLmN1cnJlbnRcbiAgICBtb3VudC5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCdcbiAgICBtb3VudC5zdHlsZS50b3AgPSAnMCdcbiAgICBtb3VudC5zdHlsZS5sZWZ0ID0gJzAnXG4gICAgbW91bnQuc3R5bGUud2lkdGggPSAnMTAwJSdcbiAgICBtb3VudC5zdHlsZS5oZWlnaHQgPSAnMTAwJSdcbiAgICBtb3VudC5zdHlsZS56SW5kZXggPSAnMCdcblxuICAgIC8vIFNjZW5lICYgUmVuZGVyZXJcbiAgICBjb25zdCBzY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpXG4gICAgY29uc3QgY2FtZXJhID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKDc1LCB3aW5kb3cuaW5uZXJXaWR0aCAvIHdpbmRvdy5pbm5lckhlaWdodCwgMC4xLCA1MDAwKVxuICAgIGNhbWVyYS5wb3NpdGlvbi5zZXQoMCwgMCwgMCk7XG4gICAgLy8gVmlydHVhbCBwb3NpdGlvbiB0byBzaW11bGF0ZSBpbmZpbml0ZSB0cmF2ZWxcbiAgICBsZXQgdmlydHVhbENhbWVyYVBvcyA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDApO1xuICAgIGNvbnN0IHJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoeyBhbnRpYWxpYXM6IHRydWUgfSlcbiAgICByZW5kZXJlci5zZXRQaXhlbFJhdGlvKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKVxuICAgIHJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodClcbiAgICByZW5kZXJlci5zZXRDbGVhckNvbG9yKDB4MDAwMDAwLCAxKTtcbiAgICBtb3VudC5hcHBlbmRDaGlsZChyZW5kZXJlci5kb21FbGVtZW50KVxuXG4gICAgLy8gU3RhcmZpZWxkXG4gICAgY29uc3Qgc3RhckNvdW50ID0gNTAwMFxuICAgIGNvbnN0IHN0YXJNYXhEaXN0YW5jZSA9IDEwMDBcbiAgICBjb25zdCBzdGFyU3BlZWQgPSAxXG4gICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKVxuICAgIGNvbnN0IHBvc2l0aW9ucyA9IFtdO1xuICAgIGxldCBzdGFyc1BsYWNlZCA9IDA7XG4gICAgd2hpbGUgKHN0YXJzUGxhY2VkIDwgc3RhckNvdW50KSB7XG4gICAgICAvLyBXaXRoIDElIGNoYW5jZSwgc3Bhd24gYSBzdGFyIGNsdXN0ZXIgKDEwLTMwIHN0YXJzKVxuICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPCAwLjAxICYmIHN0YXJzUGxhY2VkIDwgc3RhckNvdW50IC0gMTApIHtcbiAgICAgICAgY29uc3QgY2x1c3RlclRoZXRhID0gTWF0aC5yYW5kb20oKSAqIDIgKiBNYXRoLlBJO1xuICAgICAgICBjb25zdCBjbHVzdGVyUGhpID0gTWF0aC5hY29zKDIgKiBNYXRoLnJhbmRvbSgpIC0gMSk7XG4gICAgICAgIGNvbnN0IGNsdXN0ZXJSID0gTWF0aC5yYW5kb20oKSAqIHN0YXJNYXhEaXN0YW5jZTtcbiAgICAgICAgY29uc3QgY2x1c3RlckNlbnRlciA9IFtcbiAgICAgICAgICBjbHVzdGVyUiAqIE1hdGguc2luKGNsdXN0ZXJQaGkpICogTWF0aC5jb3MoY2x1c3RlclRoZXRhKSxcbiAgICAgICAgICBjbHVzdGVyUiAqIE1hdGguc2luKGNsdXN0ZXJQaGkpICogTWF0aC5zaW4oY2x1c3RlclRoZXRhKSxcbiAgICAgICAgICBjbHVzdGVyUiAqIE1hdGguY29zKGNsdXN0ZXJQaGkpXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGNsdXN0ZXJTaXplID0gMTAgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyMCk7IC8vIDEwLTMwIHN0YXJzXG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgY2x1c3RlclNpemUgJiYgc3RhcnNQbGFjZWQgPCBzdGFyQ291bnQ7IGMrKykge1xuICAgICAgICAgIC8vIEVhY2ggc3RhciBpbiBjbHVzdGVyIGlzIHdpdGhpbiAzMCB1bml0cyBvZiBjZW50ZXJcbiAgICAgICAgICBjb25zdCBvZmZzZXRUaGV0YSA9IE1hdGgucmFuZG9tKCkgKiAyICogTWF0aC5QSTtcbiAgICAgICAgICBjb25zdCBvZmZzZXRQaGkgPSBNYXRoLmFjb3MoMiAqIE1hdGgucmFuZG9tKCkgLSAxKTtcbiAgICAgICAgICBjb25zdCBvZmZzZXRSID0gTWF0aC5yYW5kb20oKSAqIDMwOyAvLyBjbHVzdGVyIHJhZGl1c1xuICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKFxuICAgICAgICAgICAgY2x1c3RlckNlbnRlclswXSArIG9mZnNldFIgKiBNYXRoLnNpbihvZmZzZXRQaGkpICogTWF0aC5jb3Mob2Zmc2V0VGhldGEpLFxuICAgICAgICAgICAgY2x1c3RlckNlbnRlclsxXSArIG9mZnNldFIgKiBNYXRoLnNpbihvZmZzZXRQaGkpICogTWF0aC5zaW4ob2Zmc2V0VGhldGEpLFxuICAgICAgICAgICAgY2x1c3RlckNlbnRlclsyXSArIG9mZnNldFIgKiBNYXRoLmNvcyhvZmZzZXRQaGkpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzdGFyc1BsYWNlZCsrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb3JtYWwgc2luZ2xlIHN0YXJcbiAgICAgICAgY29uc3QgdGhldGEgPSBNYXRoLnJhbmRvbSgpICogMiAqIE1hdGguUEk7XG4gICAgICAgIGNvbnN0IHBoaSA9IE1hdGguYWNvcygyICogTWF0aC5yYW5kb20oKSAtIDEpO1xuICAgICAgICBjb25zdCByID0gTWF0aC5yYW5kb20oKSAqIHN0YXJNYXhEaXN0YW5jZTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goXG4gICAgICAgICAgciAqIE1hdGguc2luKHBoaSkgKiBNYXRoLmNvcyh0aGV0YSksXG4gICAgICAgICAgciAqIE1hdGguc2luKHBoaSkgKiBNYXRoLnNpbih0aGV0YSksXG4gICAgICAgICAgciAqIE1hdGguY29zKHBoaSlcbiAgICAgICAgKTtcbiAgICAgICAgc3RhcnNQbGFjZWQrKztcbiAgICAgIH1cbiAgICB9XG4gICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBUSFJFRS5GbG9hdDMyQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9ucywgMykpXG5cbiAgICBjb25zdCBwYWxldHRlID0gW1xuICAgICAgWzEuMCwgMC41LCAwLjVdLFxuICAgICAgWzEuMCwgMC43NSwgMC40XSxcbiAgICAgIFsxLjAsIDEuMCwgMC45XSxcbiAgICAgIFsxLjAsIDEuMCwgMS4wXSxcbiAgICAgIFswLjQsIDAuNSwgMS4wXSxcbiAgICBdXG4gICAgY29uc3QgY29sb3JzID0gW11cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXJDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBjID0gcGFsZXR0ZVtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBwYWxldHRlLmxlbmd0aCldXG4gICAgICBjb2xvcnMucHVzaCguLi5jKVxuICAgIH1cbiAgICBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2NvbG9yJywgbmV3IFRIUkVFLkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoY29sb3JzLCAzKSlcblxuICAgIGNvbnN0IG9yaWdpbmFsQ29sb3JzID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvci5hcnJheS5zbGljZSgpXG4gICAgY29uc3QgdGltZXJzID0gbmV3IEZsb2F0MzJBcnJheShzdGFyQ291bnQpXG4gICAgY29uc3Qgc3BhcmtDb2xvcnMgPSBuZXcgRmxvYXQzMkFycmF5KHN0YXJDb3VudCAqIDMpXG4gICAgY29uc3Qgc3BhcmtsZUR1cmF0aW9uID0gMTgwXG5cbiAgICBjb25zdCBtYXRlcmlhbCA9IG5ldyBUSFJFRS5Qb2ludHNNYXRlcmlhbCh7IHNpemU6IDMuNSwgc2l6ZUF0dGVudWF0aW9uOiB0cnVlLCB2ZXJ0ZXhDb2xvcnM6IHRydWUgfSlcbiAgICBjb25zdCBzdGFycyA9IG5ldyBUSFJFRS5Qb2ludHMoZ2VvbWV0cnksIG1hdGVyaWFsKVxuICAgIHNjZW5lLmFkZChzdGFycylcblxuICAgIGxldCB0YXJnZXRZID0gMFxuICAgIGNvbnN0IGRhbXBpbmcgPSAwLjA1XG4gICAgY29uc3Qgb25TY3JvbGwgPSAoKSA9PiB7XG4gICAgICBjb25zdCBwY3QgPSB3aW5kb3cuc2Nyb2xsWSAvIChkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCAtIHdpbmRvdy5pbm5lckhlaWdodClcbiAgICAgIHRhcmdldFkgPSBwY3QgKiBNYXRoLlBJICogMlxuICAgIH1cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25TY3JvbGwpXG5cbiAgICAvLyAtLS0gU2hvb3RpbmcgU3RhcnMgLS0tXG4gICAgY29uc3QgdGFpbExlbmd0aCA9IDMyOyAvLyBJbmNyZWFzZSBmb3IgbG9uZ2VyIHRhaWxzXG4gICAgY29uc3Qgc2hvb3RpbmdTdGFycyA9IFtdO1xuICAgIGxldCBzaG9vdGluZ1N0YXJDb29sZG93biA9IDA7XG4gICAgLy8gU3Bhd24gYSBzaG9vdGluZyBzdGFyIHdpdGggYSBnbG93aW5nIHRhaWxcbiAgICBmdW5jdGlvbiBzcGF3blNob290aW5nU3RhcigpIHtcbiAgICAgIC8vIFBpY2sgYSByYW5kb20gZGlyZWN0aW9uIG9uIHRoZSBzcGhlcmUgZm9yIHRoZSBzcGF3biBsb2NhdGlvblxuICAgICAgY29uc3QgZGlyID0gbmV3IFRIUkVFLlZlY3RvcjMoTWF0aC5yYW5kb20oKSoyLTEsIE1hdGgucmFuZG9tKCkqMi0xLCBNYXRoLnJhbmRvbSgpKjItMSkubm9ybWFsaXplKCk7XG4gICAgICBjb25zdCBtaW5EaXN0ID0gc3Rhck1heERpc3RhbmNlICogMC44O1xuICAgICAgY29uc3QgbWF4RGlzdCA9IHN0YXJNYXhEaXN0YW5jZSAqIDEuMDtcbiAgICAgIGNvbnN0IGRpc3QgPSBtaW5EaXN0ICsgTWF0aC5yYW5kb20oKSAqIChtYXhEaXN0IC0gbWluRGlzdCk7XG4gICAgICAvLyBQbGFjZSB0aGUgc3RhciBhdCB0aGUgZGlzdGFudCBlZGdlXG4gICAgICBjb25zdCBzcGF3blBvcyA9IGRpci5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKGRpc3QpO1xuICAgICAgLy8gVGFuZ2VudGlhbCB2ZWxvY2l0eTogcGVycGVuZGljdWxhciB0byBkaXJcbiAgICAgIGxldCB0YW5nZW50ID0gbmV3IFRIUkVFLlZlY3RvcjMoTWF0aC5yYW5kb20oKSoyLTEsIE1hdGgucmFuZG9tKCkqMi0xLCBNYXRoLnJhbmRvbSgpKjItMSk7XG4gICAgICB0YW5nZW50ID0gdGFuZ2VudC5zdWIodGFuZ2VudC5jbG9uZSgpLnByb2plY3RPblZlY3RvcihkaXIpKS5ub3JtYWxpemUoKTtcbiAgICAgIC8vIE1peCBpbiBhIHNtYWxsIHJhZGlhbCBjb21wb25lbnQgKGlud2FyZCBvciBvdXR3YXJkKVxuICAgICAgY29uc3QgdGFuZ2VudGlhbFNwZWVkID0gc3RhclNwZWVkICogKDAuNSArIE1hdGgucmFuZG9tKCkgKiAxLjUpO1xuICAgICAgY29uc3QgcmFkaWFsU3BlZWQgPSBzdGFyU3BlZWQgKiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAwLjI7IC8vIHNtYWxsIGlud2FyZC9vdXR3YXJkXG4gICAgICBjb25zdCB2ZWxvY2l0eSA9IHRhbmdlbnQubXVsdGlwbHlTY2FsYXIodGFuZ2VudGlhbFNwZWVkKS5hZGQoZGlyLmNsb25lKCkubXVsdGlwbHlTY2FsYXIocmFkaWFsU3BlZWQpKTtcbiAgICAgIC8vIFN0YXIgY29sb3I6IHJhbmRvbSB3aGl0ZS95ZWxsb3cvYmx1ZVxuICAgICAgY29uc3QgY29sb3JzID0gWzB4ZmZmZmVlLCAweGZmZjJjYywgMHhjY2U2ZmYsIDB4ZmZmZmZmXTtcbiAgICAgIGNvbnN0IGNvbG9yID0gY29sb3JzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSpjb2xvcnMubGVuZ3RoKV07XG4gICAgICAvLyBTdGFyIGJyaWdodG5lc3NcbiAgICAgIGNvbnN0IGJyaWdodG5lc3MgPSAxLjIgKyBNYXRoLnJhbmRvbSgpKjEuNTtcbiAgICAgIGNvbnN0IGdlbyA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeSgxLjUgKyBNYXRoLnJhbmRvbSgpLCAxNiwgMTYpO1xuICAgICAgY29uc3QgbWF0ID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHsgY29sb3I6IGNvbG9yIH0pO1xuICAgICAgbWF0Lm9wYWNpdHkgPSAwLjcgKyBNYXRoLnJhbmRvbSgpKjAuMztcbiAgICAgIG1hdC5iYXNlT3BhY2l0eSA9IG1hdC5vcGFjaXR5OyAvLyBTYXZlIGZvciBmYWRlIGxvZ2ljXG4gICAgICBtYXQudHJhbnNwYXJlbnQgPSB0cnVlO1xuICAgICAgY29uc3Qgc3RhciA9IG5ldyBUSFJFRS5NZXNoKGdlbywgbWF0KTtcbiAgICAgIHN0YXIucG9zaXRpb24uY29weShzcGF3blBvcyk7XG4gICAgICBzdGFyLnZlbG9jaXR5ID0gdmVsb2NpdHk7XG4gICAgICBzdGFyLm5vcm1hbGl6ZWRMaWZlID0gMC4wOyAvLyBTdGFydCBhdCAwLCB3aWxsIGluY3JlYXNlIHRvIDEuMFxuICAgICAgc3Rhci5ub3JtYWxpemVkTGlmZXRpbWUgPSA2MCArIE1hdGgucmFuZG9tKCkgKiAzMDsgLy8gU2hvcnRlciBub3JtYWxpemVkTGlmZXRpbWU6IDYwLTkwIGZyYW1lc1xuICAgICAgc3Rhci5hZ2UgPSAwOyAvLyBUcmFjayBhZ2UgaW4gZnJhbWVzXG4gICAgICAvLyAtLS0gUmVhbGlzdGljIE1ldGVvciBUYWlsIChtdWx0aS1wb2ludCwgZ3JhZGllbnQsIGZhZGluZykgLS0tXG4gICAgICBjb25zdCB0cmFpbFNlZ21lbnRzID0gdGFpbExlbmd0aDtcbiAgICAgIGNvbnN0IHRyYWlsUG9pbnRzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYWlsU2VnbWVudHM7IGkrKykge1xuICAgICAgICB0cmFpbFBvaW50cy5wdXNoKHN0YXIucG9zaXRpb24uY2xvbmUoKSk7XG4gICAgICB9XG4gICAgICBjb25zdCB0YWlsR2VvID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCkuc2V0RnJvbVBvaW50cyh0cmFpbFBvaW50cyk7XG4gICAgICAvLyBQZXItdmVydGV4IGNvbG9yIChhbHBoYSBncmFkaWVudClcbiAgICAgIGNvbnN0IHRhaWxDb2xvcnMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhaWxTZWdtZW50czsgaSsrKSB7XG4gICAgICAgIC8vIEFscGhhIGZhZGVzIG91dCBhbG9uZyB0aGUgdGFpbFxuICAgICAgICBjb25zdCBhbHBoYSA9ICgxIC0gaSAvICh0cmFpbFNlZ21lbnRzIC0gMSkpICogMC44NTsgLy8gTW9yZSBwZXJzaXN0ZW50XG4gICAgICAgIC8vIENvbG9yIHNoaWZ0cyBmcm9tIGhlYWQgY29sb3IgdG8gZmFpbnQgYmx1ZS93aGl0ZS9vcmFuZ2VcbiAgICAgICAgbGV0IGdyYWRpZW50Q29sb3I7XG4gICAgICAgIGlmIChpIDwgdHJhaWxTZWdtZW50cyAqIDAuMikgZ3JhZGllbnRDb2xvciA9IGNvbG9yOyAvLyBoZWFkXG4gICAgICAgIGVsc2UgaWYgKGkgPCB0cmFpbFNlZ21lbnRzICogMC43KSBncmFkaWVudENvbG9yID0gMHg4MGMwZmY7XG4gICAgICAgIGVsc2UgZ3JhZGllbnRDb2xvciA9IDB4ZmZjMDgwO1xuICAgICAgICB0YWlsQ29sb3JzLnB1c2goKGdyYWRpZW50Q29sb3IgPj4gMTYgJiAyNTUpIC8gMjU1LCAoZ3JhZGllbnRDb2xvciA+PiA4ICYgMjU1KSAvIDI1NSwgKGdyYWRpZW50Q29sb3IgJiAyNTUpIC8gMjU1LCBhbHBoYSk7XG4gICAgICB9XG4gICAgICB0YWlsR2VvLnNldEF0dHJpYnV0ZSgnY29sb3InLCBuZXcgVEhSRUUuRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh0YWlsQ29sb3JzLCA0KSk7XG4gICAgICAvLyBBZGRpdGl2ZSBibGVuZGluZyBmb3IgZ2xvd1xuICAgICAgY29uc3QgdGFpbE1hdCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCh7IHZlcnRleENvbG9yczogdHJ1ZSwgdHJhbnNwYXJlbnQ6IHRydWUsIG9wYWNpdHk6IDEuMCwgYmxlbmRpbmc6IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmcgfSk7XG4gICAgICBjb25zdCB0YWlsID0gbmV3IFRIUkVFLkxpbmUodGFpbEdlbywgdGFpbE1hdCk7XG4gICAgICB0YWlsLnBvc2l0aW9uLmNvcHkoc3Rhci5wb3NpdGlvbik7XG4gICAgICAvLyBBZGQgdG8gc2NlbmVcbiAgICAgIHNjZW5lLmFkZChzdGFyKTtcbiAgICAgIHNjZW5lLmFkZCh0YWlsKTtcbiAgICAgIHNob290aW5nU3RhcnMucHVzaCh7IG1lc2g6IHN0YXIsIHRhaWwsIHZlbG9jaXR5OiBzdGFyLnZlbG9jaXR5LCBkaXIsIGFnZTogMCwgbm9ybWFsaXplZExpZmV0aW1lOiBzdGFyLm5vcm1hbGl6ZWRMaWZldGltZSwgdHJhaWxQb2ludHMsIGNvbG9yLCBicmlnaHRuZXNzLCBoYXNGcmFnbWVudGVkOiBmYWxzZSB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBhbmltYXRlID0gKCkgPT4ge1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuICAgICAgY2FtZXJhLnJvdGF0aW9uLnkgKz0gKHRhcmdldFkgLSBjYW1lcmEucm90YXRpb24ueSkgKiBkYW1waW5nO1xuICAgICAgLy8gTW92ZSB0aGUgdmlydHVhbCBjYW1lcmEgcG9zaXRpb24gaW4gdGhlIGRpcmVjdGlvbiB0aGUgY2FtZXJhIGlzIGZhY2luZ1xuICAgICAgY29uc3QgZm9yd2FyZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICBjYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oZm9yd2FyZCk7XG4gICAgICB2aXJ0dWFsQ2FtZXJhUG9zLmFkZChmb3J3YXJkLm11bHRpcGx5U2NhbGFyKHN0YXJTcGVlZCkpO1xuICAgICAgLy8gT2Zmc2V0IGFsbCBzdGFycyBieSAtdmlydHVhbENhbWVyYVBvcyAoZmxvYXRpbmcgb3JpZ2luKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3NpdGlvbnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheVtpXSA9IHBvc2l0aW9uc1tpXSAtIHZpcnR1YWxDYW1lcmFQb3MueDtcbiAgICAgICAgZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheVtpKzFdID0gcG9zaXRpb25zW2krMV0gLSB2aXJ0dWFsQ2FtZXJhUG9zLnk7XG4gICAgICAgIGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXlbaSsyXSA9IHBvc2l0aW9uc1tpKzJdIC0gdmlydHVhbENhbWVyYVBvcy56O1xuICAgICAgfVxuICAgICAgZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAgIC8vIC0tLSBTaG9vdGluZyBzdGFyIHNwYXduaW5nIC0tLVxuICAgICAgLy8gREVWOiBNYWtlIHNob290aW5nIHN0YXJzIHN1cGVyIGNvbW1vbiAoc3Bhd24gZXZlcnkgZnJhbWUgaWYgY29vbGRvd24gYWxsb3dzKVxuICAgICAgaWYgKHNob290aW5nU3RhckNvb2xkb3duIDw9IDAgJiYgTWF0aC5yYW5kb20oKSA8IDAuMSkgeyAvLyBTaG9vdGluZyBTdGFyIFNwYXduIFJhdGUgKHRocm90dGxlZClcbiAgICAgICAgc3Bhd25TaG9vdGluZ1N0YXIoKTtcbiAgICAgICAgc2hvb3RpbmdTdGFyQ29vbGRvd24gPSAxMCArIE1hdGgucmFuZG9tKCkgKiAxMDsgLy8gTG9uZ2VyIGNvb2xkb3duIGZvciBwZXJmXG4gICAgICB9IGVsc2UgaWYgKHNob290aW5nU3RhckNvb2xkb3duID4gMCkge1xuICAgICAgICBzaG9vdGluZ1N0YXJDb29sZG93bi0tO1xuICAgICAgfVxuICAgICAgLy8gQW5pbWF0ZSBhbmQgY2xlYW4gdXAgc2hvb3Rpbmcgc3RhcnNcbiAgICAgIGZvciAobGV0IGkgPSBzaG9vdGluZ1N0YXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHNob290aW5nU3RhcnNbaV07XG4gICAgICAgIC8vIEN1cnZlZCB0cmFqZWN0b3J5XG4gICAgICAgIGxldCBwZXJwID0gbmV3IFRIUkVFLlZlY3RvcjMoTWF0aC5yYW5kb20oKS0wLjUsIE1hdGgucmFuZG9tKCktMC41LCBNYXRoLnJhbmRvbSgpLTAuNSk7XG4gICAgICAgIHBlcnAgPSBwZXJwLnN1YihwZXJwLmNsb25lKCkucHJvamVjdE9uVmVjdG9yKG9iai52ZWxvY2l0eSkpLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKDAuMDAyICsgTWF0aC5yYW5kb20oKSowLjAwMSk7XG4gICAgICAgIG9iai52ZWxvY2l0eS5hZGQocGVycCk7XG4gICAgICAgIG9iai52ZWxvY2l0eS5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhcihvYmoudmVsb2NpdHkubGVuZ3RoKCkpO1xuICAgICAgICBvYmoubWVzaC5wb3NpdGlvbi5hZGQob2JqLnZlbG9jaXR5KTtcbiAgICAgICAgb2JqLnRhaWwucG9zaXRpb24uY29weShvYmoubWVzaC5wb3NpdGlvbik7XG4gICAgICAgIC8vIEFuaW1hdGUgdGFpbFxuICAgICAgICBvYmouYWdlKys7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRMaWZlID0gb2JqLmFnZSAvIG9iai5ub3JtYWxpemVkTGlmZXRpbWU7XG4gICAgICAgIGZvciAobGV0IHQgPSBvYmoudHJhaWxQb2ludHMubGVuZ3RoIC0gMTsgdCA+IDA7IHQtLSkge1xuICAgICAgICAgIG9iai50cmFpbFBvaW50c1t0XS5sZXJwKG9iai50cmFpbFBvaW50c1t0LTFdLCAwLjQ1KTtcbiAgICAgICAgfVxuICAgICAgICBvYmoudHJhaWxQb2ludHNbMF0uY29weShvYmoubWVzaC5wb3NpdGlvbik7XG4gICAgICAgIGxldCB0YWlsR3JvdyA9IE1hdGgubWluKDEsIG5vcm1hbGl6ZWRMaWZlIC8gMC4zKTtcbiAgICAgICAgbGV0IGFjdGl2ZVNlZ21lbnRzID0gTWF0aC5mbG9vcihvYmoudHJhaWxQb2ludHMubGVuZ3RoICogdGFpbEdyb3cpO1xuICAgICAgICBpZiAoYWN0aXZlU2VnbWVudHMgPCAyKSBhY3RpdmVTZWdtZW50cyA9IDI7XG4gICAgICAgIGNvbnN0IHZpc2libGVUcmFpbCA9IG9iai50cmFpbFBvaW50cy5zbGljZSgwLCBhY3RpdmVTZWdtZW50cyk7XG4gICAgICAgIG9iai50YWlsLmdlb21ldHJ5LnNldEZyb21Qb2ludHModmlzaWJsZVRyYWlsKTtcbiAgICAgICAgY29uc3QgdGFpbENvbG9ycyA9IG9iai50YWlsLmdlb21ldHJ5LmdldEF0dHJpYnV0ZSgnY29sb3InKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2aXNpYmxlVHJhaWwubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBsZXQgYWxwaGEgPSAoMSAtIGogLyAodmlzaWJsZVRyYWlsLmxlbmd0aCAtIDEpKSAqIDAuOTU7XG4gICAgICAgICAgYWxwaGEgKj0gMC45MiArIDAuMDggKiBNYXRoLnNpbihEYXRlLm5vdygpKjAuMDE1ICsgaiowLjUpO1xuICAgICAgICAgIGxldCByYWluYm93ID0gWzB4ZmZjMDgwLCAweGZmZTA4MCwgMHhmZmZmODAsIDB4ODBmZmU2LCAweDgwYzBmZiwgMHhjMDgwZmZdO1xuICAgICAgICAgIGxldCBncmFkQ29sb3IgPSByYWluYm93W2ogJSByYWluYm93Lmxlbmd0aF07XG4gICAgICAgICAgaWYgKG5vcm1hbGl6ZWRMaWZlID4gMC43KSBhbHBoYSAqPSBNYXRoLm1heCgwLCAxIC0gKG5vcm1hbGl6ZWRMaWZlIC0gMC43IC0gMC4yKSAvIDAuMyk7XG4gICAgICAgICAgdGFpbENvbG9ycy5zZXRYWVpXKGosIChncmFkQ29sb3IgPj4gMTYgJiAyNTUpIC8gMjU1LCAoZ3JhZENvbG9yID4+IDggJiAyNTUpIC8gMjU1LCAoZ3JhZENvbG9yICYgMjU1KSAvIDI1NSwgYWxwaGEpO1xuICAgICAgICB9XG4gICAgICAgIHRhaWxDb2xvcnMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAvLyBBbmltYXRlIGhlYWRcbiAgICAgICAgbGV0IGhlYWRDb2xvcjtcbiAgICAgICAgaWYgKG5vcm1hbGl6ZWRMaWZlIDwgMC41KSB7XG4gICAgICAgICAgaGVhZENvbG9yID0gbmV3IFRIUkVFLkNvbG9yKG9iai5jb2xvcikubGVycChuZXcgVEhSRUUuQ29sb3IoMHhmZmMwODApLCBub3JtYWxpemVkTGlmZSoyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoZWFkQ29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoMHhmZmMwODApLmxlcnAobmV3IFRIUkVFLkNvbG9yKDB4ZmY0MDAwKSwgKG5vcm1hbGl6ZWRMaWZlLTAuNSkqMik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZsaWNrZXIgPSAwLjk1ICsgMC4xMyAqIE1hdGguc2luKERhdGUubm93KCkqMC4wNyArIE1hdGgucmFuZG9tKCkqMTApO1xuICAgICAgICBoZWFkQ29sb3IubXVsdGlwbHlTY2FsYXIoZmxpY2tlcik7XG4gICAgICAgIG9iai5tZXNoLm1hdGVyaWFsLmNvbG9yLmNvcHkoaGVhZENvbG9yKTtcbiAgICAgICAgbGV0IHNjYWxlID0gMSArIDIuMiAqIE1hdGguc2luKE1hdGguUEkgKiBub3JtYWxpemVkTGlmZSk7XG4gICAgICAgIGxldCBkaXN0VG9DYW0gPSBvYmoubWVzaC5wb3NpdGlvbi5sZW5ndGgoKTtcbiAgICAgICAgbGV0IGRvZkJsdXIgPSBkaXN0VG9DYW0gPCBzdGFyTWF4RGlzdGFuY2UgKiAwLjcgPyAwLjcgOiAxLjA7XG4gICAgICAgIG9iai5tZXNoLnNjYWxlLnNldChzY2FsZSAqIGRvZkJsdXIsIHNjYWxlICogZG9mQmx1ciwgc2NhbGUgKiBkb2ZCbHVyKTtcbiAgICAgICAgLy8gU3BhcmtsZSBidXJzdFxuICAgICAgICBpZiAobm9ybWFsaXplZExpZmUgPj0gMSAmJiAhb2JqLmhhc0ZyYWdtZW50ZWQpIHtcbiAgICAgICAgICBmb3IgKGxldCBzID0gMDsgcyA8IDk7IHMrKykge1xuICAgICAgICAgICAgY29uc3Qgc3BhcmtsZUdlbyA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeSgwLjcgKyBNYXRoLnJhbmRvbSgpKjAuOCwgOCwgOCk7XG4gICAgICAgICAgICBjb25zdCBzcGFya2xlTWF0ID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHsgY29sb3I6IDB4ZmZmZmZmLCB0cmFuc3BhcmVudDogdHJ1ZSwgb3BhY2l0eTogMC43LCBibGVuZGluZzogVEhSRUUuQWRkaXRpdmVCbGVuZGluZyB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNwYXJrbGUgPSBuZXcgVEhSRUUuTWVzaChzcGFya2xlR2VvLCBzcGFya2xlTWF0KTtcbiAgICAgICAgICAgIHNwYXJrbGUucG9zaXRpb24uY29weShvYmoubWVzaC5wb3NpdGlvbik7XG4gICAgICAgICAgICBjb25zdCBzcGFya2xlVmVsID0gbmV3IFRIUkVFLlZlY3RvcjMoTWF0aC5yYW5kb20oKS0wLjUsIE1hdGgucmFuZG9tKCktMC41LCBNYXRoLnJhbmRvbSgpLTAuNSkubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoMitNYXRoLnJhbmRvbSgpKjIpO1xuICAgICAgICAgICAgc3BhcmtsZS51c2VyRGF0YSA9IHsgdmVsb2NpdHk6IHNwYXJrbGVWZWwsIGFnZTogMCB9O1xuICAgICAgICAgICAgc2NlbmUuYWRkKHNwYXJrbGUpO1xuICAgICAgICAgICAgaWYgKCF3aW5kb3cuX3NwYXJrbGVzKSB3aW5kb3cuX3NwYXJrbGVzID0gW107XG4gICAgICAgICAgICB3aW5kb3cuX3NwYXJrbGVzLnB1c2goc3BhcmtsZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGZyYWdWZWwgPSBvYmoudmVsb2NpdHkuY2xvbmUoKS5hcHBseUF4aXNBbmdsZShuZXcgVEhSRUUuVmVjdG9yMygwLDEsMCksIChNYXRoLnJhbmRvbSgpLTAuNSkqMC4zKTtcbiAgICAgICAgICBjb25zdCBmcmFnU3RhciA9IG9iai5tZXNoLmNsb25lKCk7XG4gICAgICAgICAgZnJhZ1N0YXIucG9zaXRpb24uY29weShvYmoubWVzaC5wb3NpdGlvbik7XG4gICAgICAgICAgZnJhZ1N0YXIudmVsb2NpdHkgPSBmcmFnVmVsO1xuICAgICAgICAgIGZyYWdTdGFyLm5vcm1hbGl6ZWRMaWZlID0gbm9ybWFsaXplZExpZmU7XG4gICAgICAgICAgZnJhZ1N0YXIubm9ybWFsaXplZExpZmV0aW1lID0gb2JqLm5vcm1hbGl6ZWRMaWZldGltZSAqICgwLjUgKyBNYXRoLnJhbmRvbSgpKjAuNSk7XG4gICAgICAgICAgZnJhZ1N0YXIuYWdlID0gb2JqLmFnZTtcbiAgICAgICAgICBmcmFnU3Rhci5tYXRlcmlhbCA9IG9iai5tZXNoLm1hdGVyaWFsLmNsb25lKCk7XG4gICAgICAgICAgY29uc3QgZnJhZ1RyYWlsUG9pbnRzID0gb2JqLnRyYWlsUG9pbnRzLnNsaWNlKCk7XG4gICAgICAgICAgY29uc3QgZnJhZ1RhaWxHZW8gPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKS5zZXRGcm9tUG9pbnRzKGZyYWdUcmFpbFBvaW50cyk7XG4gICAgICAgICAgZnJhZ1RhaWxHZW8uc2V0QXR0cmlidXRlKCdjb2xvcicsIG9iai50YWlsLmdlb21ldHJ5LmdldEF0dHJpYnV0ZSgnY29sb3InKS5jbG9uZSgpKTtcbiAgICAgICAgICBjb25zdCBmcmFnVGFpbE1hdCA9IG9iai50YWlsLm1hdGVyaWFsLmNsb25lKCk7XG4gICAgICAgICAgY29uc3QgZnJhZ1RhaWwgPSBuZXcgVEhSRUUuTGluZShmcmFnVGFpbEdlbywgZnJhZ1RhaWxNYXQpO1xuICAgICAgICAgIGZyYWdUYWlsLnBvc2l0aW9uLmNvcHkoZnJhZ1N0YXIucG9zaXRpb24pO1xuICAgICAgICAgIHNjZW5lLmFkZChmcmFnU3Rhcik7XG4gICAgICAgICAgc2NlbmUuYWRkKGZyYWdUYWlsKTtcbiAgICAgICAgICBzaG9vdGluZ1N0YXJzLnB1c2goeyBtZXNoOiBmcmFnU3RhciwgdGFpbDogZnJhZ1RhaWwsIHZlbG9jaXR5OiBmcmFnU3Rhci52ZWxvY2l0eSwgZGlyOiBvYmouZGlyLCBhZ2U6IGZyYWdTdGFyLmFnZSwgbm9ybWFsaXplZExpZmV0aW1lOiBmcmFnU3Rhci5ub3JtYWxpemVkTGlmZXRpbWUsIHRyYWlsUG9pbnRzOiBmcmFnVHJhaWxQb2ludHMsIGNvbG9yOiBvYmouY29sb3IsIGJyaWdodG5lc3M6IG9iai5icmlnaHRuZXNzLCBoYXNGcmFnbWVudGVkOiB0cnVlIH0pO1xuICAgICAgICAgIG9iai5oYXNGcmFnbWVudGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTcGFyayBidXJzdFxuICAgICAgICBpZiAoIW9iai5oYXNTcGFya2VkICYmIG5vcm1hbGl6ZWRMaWZlID4gMC45NSAmJiBNYXRoLnJhbmRvbSgpIDwgMC4xKSB7XG4gICAgICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCA4ICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKjgpOyBzKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNwYXJrR2VvID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KDAuNSArIE1hdGgucmFuZG9tKCkqMC41LCA4LCA4KTtcbiAgICAgICAgICAgIGNvbnN0IHNwYXJrTWF0ID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHsgY29sb3I6IDB4ZmZmNmMwLCB0cmFuc3BhcmVudDogdHJ1ZSwgb3BhY2l0eTogMSwgYmxlbmRpbmc6IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmcgfSk7XG4gICAgICAgICAgICBjb25zdCBzcGFyayA9IG5ldyBUSFJFRS5NZXNoKHNwYXJrR2VvLCBzcGFya01hdCk7XG4gICAgICAgICAgICBzcGFyay5wb3NpdGlvbi5jb3B5KG9iai5tZXNoLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIHNwYXJrLnNwYXJrVmVsID0gbmV3IFRIUkVFLlZlY3RvcjMoTWF0aC5yYW5kb20oKS0wLjUsIE1hdGgucmFuZG9tKCktMC41LCBNYXRoLnJhbmRvbSgpLTAuNSkubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoMC41ICsgTWF0aC5yYW5kb20oKSoxLjIpO1xuICAgICAgICAgICAgc3Bhcmsuc3BhcmtMaWZlID0gMTIgKyBNYXRoLnJhbmRvbSgpKjEwO1xuICAgICAgICAgICAgc3Bhcmsuc3BhcmtBZ2UgPSAwO1xuICAgICAgICAgICAgc2NlbmUuYWRkKHNwYXJrKTtcbiAgICAgICAgICAgIGlmICghd2luZG93Ll9zdGFyU3BhcmtzKSB3aW5kb3cuX3N0YXJTcGFya3MgPSBbXTtcbiAgICAgICAgICAgIHdpbmRvdy5fc3RhclNwYXJrcy5wdXNoKHNwYXJrKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2JqLmhhc1NwYXJrZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZsYXNoXG4gICAgICAgIGlmICghb2JqLmhhc0ZsYXNoZWQgJiYgbm9ybWFsaXplZExpZmUgPiAwLjk4ICYmIE1hdGgucmFuZG9tKCkgPCAwLjIpIHtcbiAgICAgICAgICBjb25zdCBmbGFzaEdlbyA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeSgxLCAxNiwgMTYpO1xuICAgICAgICAgIGNvbnN0IGZsYXNoTWF0ID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHsgY29sb3I6IDB4ZmZmZmVlLCB0cmFuc3BhcmVudDogdHJ1ZSwgb3BhY2l0eTogMC44LCBibGVuZGluZzogVEhSRUUuQWRkaXRpdmVCbGVuZGluZyB9KTtcbiAgICAgICAgICBjb25zdCBmbGFzaCA9IG5ldyBUSFJFRS5NZXNoKGZsYXNoR2VvLCBmbGFzaE1hdCk7XG4gICAgICAgICAgZmxhc2gucG9zaXRpb24uY29weShvYmoubWVzaC5wb3NpdGlvbik7XG4gICAgICAgICAgc2NlbmUuYWRkKGZsYXNoKTtcbiAgICAgICAgICBpZiAoIXdpbmRvdy5fc3RhckZsYXNoZXMpIHdpbmRvdy5fc3RhckZsYXNoZXMgPSBbXTtcbiAgICAgICAgICB3aW5kb3cuX3N0YXJGbGFzaGVzLnB1c2goeyBtZXNoOiBmbGFzaCwgYWdlOiAwIH0pO1xuICAgICAgICAgIG9iai5oYXNGbGFzaGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGYWRlIG91dCBhcyBpdCBnZXRzIGZhciBhd2F5XG4gICAgICAgIGNvbnN0IGRpc3QgPSBvYmoubWVzaC5wb3NpdGlvbi5kaXN0YW5jZVRvKGNhbWVyYS5wb3NpdGlvbik7XG4gICAgICAgIGNvbnN0IGZhZGVTdGFydCA9IHN0YXJNYXhEaXN0YW5jZSAqIDAuNTtcbiAgICAgICAgaWYgKGRpc3QgPiBmYWRlU3RhcnQpIHtcbiAgICAgICAgICBjb25zdCBmYWRlID0gMSAtIChkaXN0IC0gZmFkZVN0YXJ0KSAvIChzdGFyTWF4RGlzdGFuY2UgLSBmYWRlU3RhcnQpO1xuICAgICAgICAgIG9iai5tZXNoLm1hdGVyaWFsLm9wYWNpdHkgPSBNYXRoLm1heCgwLCBmYWRlKTtcbiAgICAgICAgICBvYmoubWVzaC5tYXRlcmlhbC50cmFuc3BhcmVudCA9IHRydWU7XG4gICAgICAgICAgb2JqLnRhaWwubWF0ZXJpYWwub3BhY2l0eSA9IE1hdGgubWF4KDAsIGZhZGUgKiAwLjgpO1xuICAgICAgICAgIG9iai50YWlsLm1hdGVyaWFsLnRyYW5zcGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgd2hlbiBvdXQgb2YgYm91bmRzIG9yIGZ1bGx5IGZhZGVkIG9yIGxpZmUgZW5kZWRcbiAgICAgICAgaWYgKG5vcm1hbGl6ZWRMaWZlID49IDEuMCB8fCBkaXN0ID4gc3Rhck1heERpc3RhbmNlIHx8IG9iai5tZXNoLm1hdGVyaWFsLm9wYWNpdHkgPD0gMC4wMSkge1xuICAgICAgICAgIHNjZW5lLnJlbW92ZShvYmoubWVzaCk7XG4gICAgICAgICAgc2NlbmUucmVtb3ZlKG9iai50YWlsKTtcbiAgICAgICAgICBzaG9vdGluZ1N0YXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQW5pbWF0ZSBzcGFya3NcbiAgICAgIGlmICh3aW5kb3cuX3N0YXJTcGFya3MpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHdpbmRvdy5fc3RhclNwYXJrcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGNvbnN0IHNwYXJrID0gd2luZG93Ll9zdGFyU3BhcmtzW2ldO1xuICAgICAgICAgIHNwYXJrLnBvc2l0aW9uLmFkZChzcGFyay5zcGFya1ZlbCk7XG4gICAgICAgICAgc3Bhcmsuc3BhcmtBZ2UrKztcbiAgICAgICAgICBzcGFyay5tYXRlcmlhbC5vcGFjaXR5ICo9IDAuODU7XG4gICAgICAgICAgaWYgKHNwYXJrLnNwYXJrQWdlID4gc3Bhcmsuc3BhcmtMaWZlKSB7XG4gICAgICAgICAgICBzY2VuZS5yZW1vdmUoc3BhcmspO1xuICAgICAgICAgICAgd2luZG93Ll9zdGFyU3BhcmtzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEFuaW1hdGUgZmxhc2hlc1xuICAgICAgaWYgKHdpbmRvdy5fc3RhckZsYXNoZXMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHdpbmRvdy5fc3RhckZsYXNoZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBjb25zdCBmbGFzaCA9IHdpbmRvdy5fc3RhckZsYXNoZXNbaV07XG4gICAgICAgICAgZmxhc2gubWVzaC5zY2FsZS5tdWx0aXBseVNjYWxhcigxLjE1KTtcbiAgICAgICAgICBmbGFzaC5tZXNoLm1hdGVyaWFsLm9wYWNpdHkgKj0gMC44NTtcbiAgICAgICAgICBmbGFzaC5hZ2UrKztcbiAgICAgICAgICBpZiAoZmxhc2guYWdlID4gMTApIHtcbiAgICAgICAgICAgIHNjZW5lLnJlbW92ZShmbGFzaC5tZXNoKTtcbiAgICAgICAgICAgIHdpbmRvdy5fc3RhckZsYXNoZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyAtLS0gU3RhcmZpZWxkIGxvZ2ljIC0tLVxuICAgICAgY29uc3Qgc3FEaXN0ID0gc3Rhck1heERpc3RhbmNlICogc3Rhck1heERpc3RhbmNlO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3NpdGlvbnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgY29uc3QgZHggPSBwb3NpdGlvbnNbaV0gLSB2aXJ0dWFsQ2FtZXJhUG9zLng7XG4gICAgICAgIGNvbnN0IGR5ID0gcG9zaXRpb25zW2kgKyAxXSAtIHZpcnR1YWxDYW1lcmFQb3MueTtcbiAgICAgICAgY29uc3QgZHogPSBwb3NpdGlvbnNbaSArIDJdIC0gdmlydHVhbENhbWVyYVBvcy56O1xuICAgICAgICBpZiAoZHgqZHggKyBkeSpkeSArIGR6KmR6ID4gc3FEaXN0KSB7XG4gICAgICAgICAgLy8gUGxhY2UgaW4gYSB0aGljayBzcGhlcmljYWwgc2hlbGwgYXJvdW5kIHRoZSB2aXJ0dWFsIGNhbWVyYSwgbmV2ZXIgdG9vIGNsb3NlXG4gICAgICAgICAgY29uc3QgbWluUmFkaXVzID0gc3Rhck1heERpc3RhbmNlICogMC44O1xuICAgICAgICAgIGNvbnN0IG1heFJhZGl1cyA9IHN0YXJNYXhEaXN0YW5jZTtcbiAgICAgICAgICBjb25zdCByID0gbWluUmFkaXVzICsgTWF0aC5yYW5kb20oKSAqIChtYXhSYWRpdXMgLSBtaW5SYWRpdXMpO1xuICAgICAgICAgIGNvbnN0IHRoZXRhID0gTWF0aC5yYW5kb20oKSAqIDIgKiBNYXRoLlBJO1xuICAgICAgICAgIGNvbnN0IHBoaSA9IE1hdGguYWNvcygyICogTWF0aC5yYW5kb20oKSAtIDEpO1xuICAgICAgICAgIHBvc2l0aW9uc1tpXSA9IHZpcnR1YWxDYW1lcmFQb3MueCArIHIgKiBNYXRoLnNpbihwaGkpICogTWF0aC5jb3ModGhldGEpO1xuICAgICAgICAgIHBvc2l0aW9uc1tpKzFdID0gdmlydHVhbENhbWVyYVBvcy55ICsgciAqIE1hdGguc2luKHBoaSkgKiBNYXRoLnNpbih0aGV0YSk7XG4gICAgICAgICAgcG9zaXRpb25zW2krMl0gPSB2aXJ0dWFsQ2FtZXJhUG9zLnogKyByICogTWF0aC5jb3MocGhpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7IC8vIEFscmVhZHkgc2V0IGFib3ZlXG5cbiAgICAgIC8vIFJvYnVzdCBzdGFyZmllbGQgY29sb3IgdXBkYXRlIHRvIHByZXZlbnQgc3R1Y2sgd2hpdGUgZG90c1xuICAgICAgY29uc3QgY29sQXJyID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvci5hcnJheTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IGkgLyAzO1xuICAgICAgICBjb25zdCBkeCA9IHBvc2l0aW9uc1tpXSAtIHZpcnR1YWxDYW1lcmFQb3MueDtcbiAgICAgICAgY29uc3QgZHkgPSBwb3NpdGlvbnNbaSArIDFdIC0gdmlydHVhbENhbWVyYVBvcy55O1xuICAgICAgICBjb25zdCBkeiA9IHBvc2l0aW9uc1tpICsgMl0gLSB2aXJ0dWFsQ2FtZXJhUG9zLno7XG4gICAgICAgIGNvbnN0IGRpc3QgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkgKyBkeiAqIGR6KTtcbiAgICAgICAgaWYgKHRpbWVyc1tpZHhdID4gMCkge1xuICAgICAgICAgIHRpbWVyc1tpZHhdLS07XG4gICAgICAgICAgaWYgKHRpbWVyc1tpZHhdID09PSAwKSB7XG4gICAgICAgICAgICAvLyBUaW1lciBleHBpcmVkLCByZXN0b3JlIGNvbG9yXG4gICAgICAgICAgICBzcGFya0NvbG9yc1tpXSA9IG9yaWdpbmFsQ29sb3JzW2ldO1xuICAgICAgICAgICAgc3BhcmtDb2xvcnNbaSsxXSA9IG9yaWdpbmFsQ29sb3JzW2krMV07XG4gICAgICAgICAgICBzcGFya0NvbG9yc1tpKzJdID0gb3JpZ2luYWxDb2xvcnNbaSsyXTtcbiAgICAgICAgICAgIGNvbEFycltpXSA9IG9yaWdpbmFsQ29sb3JzW2ldO1xuICAgICAgICAgICAgY29sQXJyW2krMV0gPSBvcmlnaW5hbENvbG9yc1tpKzFdO1xuICAgICAgICAgICAgY29sQXJyW2krMl0gPSBvcmlnaW5hbENvbG9yc1tpKzJdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2xBcnJbaV0gPSBzcGFya0NvbG9yc1tpXTtcbiAgICAgICAgICAgIGNvbEFycltpKzFdID0gc3BhcmtDb2xvcnNbaSsxXTtcbiAgICAgICAgICAgIGNvbEFycltpKzJdID0gc3BhcmtDb2xvcnNbaSsyXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZGlzdCA+IHN0YXJNYXhEaXN0YW5jZSAqIDAuMyAmJiBNYXRoLnJhbmRvbSgpIDwgMC4wNSkge1xuICAgICAgICAgIHRpbWVyc1tpZHhdID0gc3BhcmtsZUR1cmF0aW9uO1xuICAgICAgICAgIGNvbnN0IGMgPSBwYWxldHRlW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHBhbGV0dGUubGVuZ3RoKV07XG4gICAgICAgICAgc3BhcmtDb2xvcnNbaV0gPSBjWzBdO1xuICAgICAgICAgIHNwYXJrQ29sb3JzW2krMV0gPSBjWzFdO1xuICAgICAgICAgIHNwYXJrQ29sb3JzW2krMl0gPSBjWzJdO1xuICAgICAgICAgIGNvbEFycltpXSA9IHNwYXJrQ29sb3JzW2ldO1xuICAgICAgICAgIGNvbEFycltpKzFdID0gc3BhcmtDb2xvcnNbaSsxXTtcbiAgICAgICAgICBjb2xBcnJbaSsyXSA9IHNwYXJrQ29sb3JzW2krMl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3BhcmtDb2xvcnNbaV0gPSBvcmlnaW5hbENvbG9yc1tpXTtcbiAgICAgICAgICBzcGFya0NvbG9yc1tpKzFdID0gb3JpZ2luYWxDb2xvcnNbaSsxXTtcbiAgICAgICAgICBzcGFya0NvbG9yc1tpKzJdID0gb3JpZ2luYWxDb2xvcnNbaSsyXTtcbiAgICAgICAgICBjb2xBcnJbaV0gPSBvcmlnaW5hbENvbG9yc1tpXTtcbiAgICAgICAgICBjb2xBcnJbaSsxXSA9IG9yaWdpbmFsQ29sb3JzW2krMV07XG4gICAgICAgICAgY29sQXJyW2krMl0gPSBvcmlnaW5hbENvbG9yc1tpKzJdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBnZW9tZXRyeS5hdHRyaWJ1dGVzLmNvbG9yLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgcmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmEpO1xuICAgIH1cbiAgICBcbiAgICBhbmltYXRlKCk7IC8vIFN0YXJ0IHRoZSByZW5kZXIgbG9vcFxuXG4gICAgY29uc3Qgb25SZXNpemUgPSAoKSA9PiB7XG4gICAgICBjYW1lcmEuYXNwZWN0ID0gd2luZG93LmlubmVyV2lkdGggLyB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICBjYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgICAgcmVuZGVyZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvblJlc2l6ZSlcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25TY3JvbGwpXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25SZXNpemUpXG4gICAgICBtb3VudC5yZW1vdmVDaGlsZChyZW5kZXJlci5kb21FbGVtZW50KVxuICAgIH1cbiAgfSwgW10pXG5cbiAgcmV0dXJuIDxkaXYgcmVmPXttb3VudFJlZn0gLz5cbn1cblxuZXhwb3J0IGRlZmF1bHQgU3RhcmZpZWxkXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJUSFJFRSIsIlN0YXJmaWVsZCIsIm1vdW50UmVmIiwibW91bnQiLCJjdXJyZW50Iiwic3R5bGUiLCJwb3NpdGlvbiIsInRvcCIsImxlZnQiLCJ3aWR0aCIsImhlaWdodCIsInpJbmRleCIsInNjZW5lIiwiU2NlbmUiLCJjYW1lcmEiLCJQZXJzcGVjdGl2ZUNhbWVyYSIsIndpbmRvdyIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsInNldCIsInZpcnR1YWxDYW1lcmFQb3MiLCJWZWN0b3IzIiwicmVuZGVyZXIiLCJXZWJHTFJlbmRlcmVyIiwiYW50aWFsaWFzIiwic2V0UGl4ZWxSYXRpbyIsImRldmljZVBpeGVsUmF0aW8iLCJzZXRTaXplIiwic2V0Q2xlYXJDb2xvciIsImFwcGVuZENoaWxkIiwiZG9tRWxlbWVudCIsInN0YXJDb3VudCIsInN0YXJNYXhEaXN0YW5jZSIsInN0YXJTcGVlZCIsImdlb21ldHJ5IiwiQnVmZmVyR2VvbWV0cnkiLCJwb3NpdGlvbnMiLCJzdGFyc1BsYWNlZCIsIk1hdGgiLCJyYW5kb20iLCJjbHVzdGVyVGhldGEiLCJQSSIsImNsdXN0ZXJQaGkiLCJhY29zIiwiY2x1c3RlclIiLCJjbHVzdGVyQ2VudGVyIiwic2luIiwiY29zIiwiY2x1c3RlclNpemUiLCJmbG9vciIsImMiLCJvZmZzZXRUaGV0YSIsIm9mZnNldFBoaSIsIm9mZnNldFIiLCJwdXNoIiwidGhldGEiLCJwaGkiLCJyIiwic2V0QXR0cmlidXRlIiwiRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSIsInBhbGV0dGUiLCJjb2xvcnMiLCJpIiwibGVuZ3RoIiwib3JpZ2luYWxDb2xvcnMiLCJhdHRyaWJ1dGVzIiwiY29sb3IiLCJhcnJheSIsInNsaWNlIiwidGltZXJzIiwiRmxvYXQzMkFycmF5Iiwic3BhcmtDb2xvcnMiLCJzcGFya2xlRHVyYXRpb24iLCJtYXRlcmlhbCIsIlBvaW50c01hdGVyaWFsIiwic2l6ZSIsInNpemVBdHRlbnVhdGlvbiIsInZlcnRleENvbG9ycyIsInN0YXJzIiwiUG9pbnRzIiwiYWRkIiwidGFyZ2V0WSIsImRhbXBpbmciLCJvblNjcm9sbCIsInBjdCIsInNjcm9sbFkiLCJkb2N1bWVudCIsImJvZHkiLCJzY3JvbGxIZWlnaHQiLCJhZGRFdmVudExpc3RlbmVyIiwidGFpbExlbmd0aCIsInNob290aW5nU3RhcnMiLCJzaG9vdGluZ1N0YXJDb29sZG93biIsInNwYXduU2hvb3RpbmdTdGFyIiwiZGlyIiwibm9ybWFsaXplIiwibWluRGlzdCIsIm1heERpc3QiLCJkaXN0Iiwic3Bhd25Qb3MiLCJjbG9uZSIsIm11bHRpcGx5U2NhbGFyIiwidGFuZ2VudCIsInN1YiIsInByb2plY3RPblZlY3RvciIsInRhbmdlbnRpYWxTcGVlZCIsInJhZGlhbFNwZWVkIiwidmVsb2NpdHkiLCJicmlnaHRuZXNzIiwiZ2VvIiwiU3BoZXJlR2VvbWV0cnkiLCJtYXQiLCJNZXNoQmFzaWNNYXRlcmlhbCIsIm9wYWNpdHkiLCJiYXNlT3BhY2l0eSIsInRyYW5zcGFyZW50Iiwic3RhciIsIk1lc2giLCJjb3B5Iiwibm9ybWFsaXplZExpZmUiLCJub3JtYWxpemVkTGlmZXRpbWUiLCJhZ2UiLCJ0cmFpbFNlZ21lbnRzIiwidHJhaWxQb2ludHMiLCJ0YWlsR2VvIiwic2V0RnJvbVBvaW50cyIsInRhaWxDb2xvcnMiLCJhbHBoYSIsImdyYWRpZW50Q29sb3IiLCJ0YWlsTWF0IiwiTGluZUJhc2ljTWF0ZXJpYWwiLCJibGVuZGluZyIsIkFkZGl0aXZlQmxlbmRpbmciLCJ0YWlsIiwiTGluZSIsIm1lc2giLCJoYXNGcmFnbWVudGVkIiwiYW5pbWF0ZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInJvdGF0aW9uIiwieSIsImZvcndhcmQiLCJnZXRXb3JsZERpcmVjdGlvbiIsIngiLCJ6IiwibmVlZHNVcGRhdGUiLCJvYmoiLCJwZXJwIiwidCIsImxlcnAiLCJ0YWlsR3JvdyIsIm1pbiIsImFjdGl2ZVNlZ21lbnRzIiwidmlzaWJsZVRyYWlsIiwiZ2V0QXR0cmlidXRlIiwiaiIsIkRhdGUiLCJub3ciLCJyYWluYm93IiwiZ3JhZENvbG9yIiwibWF4Iiwic2V0WFlaVyIsImhlYWRDb2xvciIsIkNvbG9yIiwiZmxpY2tlciIsInNjYWxlIiwiZGlzdFRvQ2FtIiwiZG9mQmx1ciIsInMiLCJzcGFya2xlR2VvIiwic3BhcmtsZU1hdCIsInNwYXJrbGUiLCJzcGFya2xlVmVsIiwidXNlckRhdGEiLCJfc3BhcmtsZXMiLCJmcmFnVmVsIiwiYXBwbHlBeGlzQW5nbGUiLCJmcmFnU3RhciIsImZyYWdUcmFpbFBvaW50cyIsImZyYWdUYWlsR2VvIiwiZnJhZ1RhaWxNYXQiLCJmcmFnVGFpbCIsImhhc1NwYXJrZWQiLCJzcGFya0dlbyIsInNwYXJrTWF0Iiwic3BhcmsiLCJzcGFya1ZlbCIsInNwYXJrTGlmZSIsInNwYXJrQWdlIiwiX3N0YXJTcGFya3MiLCJoYXNGbGFzaGVkIiwiZmxhc2hHZW8iLCJmbGFzaE1hdCIsImZsYXNoIiwiX3N0YXJGbGFzaGVzIiwiZGlzdGFuY2VUbyIsImZhZGVTdGFydCIsImZhZGUiLCJyZW1vdmUiLCJzcGxpY2UiLCJzcURpc3QiLCJkeCIsImR5IiwiZHoiLCJtaW5SYWRpdXMiLCJtYXhSYWRpdXMiLCJjb2xBcnIiLCJpZHgiLCJzcXJ0IiwicmVuZGVyIiwib25SZXNpemUiLCJhc3BlY3QiLCJ1cGRhdGVQcm9qZWN0aW9uTWF0cml4IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJlbW92ZUNoaWxkIiwiZGl2IiwicmVmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/Starfield.jsx\n"));

/***/ })

});