"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./components/Starfield.jsx":
/*!**********************************!*\
  !*** ./components/Starfield.jsx ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar _s = $RefreshSig$();\n\n\nconst Starfield = ()=>{\n    _s();\n    const mountRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const mount = mountRef.current;\n        mount.style.position = \"fixed\";\n        mount.style.top = \"0\";\n        mount.style.left = \"0\";\n        mount.style.width = \"100%\";\n        mount.style.height = \"100%\";\n        mount.style.zIndex = \"0\";\n        // Scene & Renderer\n        const scene = new three__WEBPACK_IMPORTED_MODULE_2__.Scene();\n        const camera = new three__WEBPACK_IMPORTED_MODULE_2__.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);\n        camera.position.set(-1, 0, 0);\n        // Virtual position to simulate infinite travel\n        let virtualCameraPos = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0, 0);\n        const renderer = new three__WEBPACK_IMPORTED_MODULE_2__.WebGLRenderer({\n            antialias: true\n        });\n        renderer.setPixelRatio(window.devicePixelRatio);\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        renderer.setClearColor(0x000000, 1);\n        mount.appendChild(renderer.domElement);\n        // Starfield\n        const starCount = 10000;\n        const starMaxDistance = 1000;\n        const starSpeed = 0.5;\n        const geometry = new three__WEBPACK_IMPORTED_MODULE_2__.BufferGeometry();\n        const positions = [];\n        for(let i = 0; i < starCount; i++){\n            const theta = Math.random() * 2 * Math.PI;\n            const phi = Math.acos(2 * Math.random() - 1);\n            const r = Math.random() * starMaxDistance;\n            positions.push(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));\n        }\n        geometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_2__.Float32BufferAttribute(positions, 3));\n        const palette = [\n            [\n                1.0,\n                0.5,\n                0.5\n            ],\n            [\n                1.0,\n                0.75,\n                0.4\n            ],\n            [\n                1.0,\n                1.0,\n                0.9\n            ],\n            [\n                1.0,\n                1.0,\n                1.0\n            ],\n            [\n                0.4,\n                0.5,\n                1.0\n            ]\n        ];\n        const colors = [];\n        for(let i = 0; i < starCount; i++){\n            const c = palette[Math.floor(Math.random() * palette.length)];\n            colors.push(...c);\n        }\n        geometry.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_2__.Float32BufferAttribute(colors, 3));\n        const originalColors = geometry.attributes.color.array.slice();\n        const timers = new Float32Array(starCount);\n        const sparkColors = new Float32Array(starCount * 3);\n        const sparkleDuration = 180;\n        const material = new three__WEBPACK_IMPORTED_MODULE_2__.PointsMaterial({\n            size: 2.5,\n            sizeAttenuation: true,\n            vertexColors: true\n        });\n        const stars = new three__WEBPACK_IMPORTED_MODULE_2__.Points(geometry, material);\n        scene.add(stars);\n        let targetY = 0;\n        const damping = 0.05;\n        const onScroll = ()=>{\n            const pct = window.scrollY / (document.body.scrollHeight - window.innerHeight);\n            targetY = pct * Math.PI * 2;\n        };\n        window.addEventListener(\"scroll\", onScroll);\n        // --- Shooting Stars ---\n        const tailLength = 32; // Increase for longer tails\n        const shootingStars = [];\n        let shootingStarCooldown = 0;\n        // Spawn a shooting star with a glowing tail\n        function spawnShootingStar() {\n            // Pick a random direction on the sphere for the spawn location\n            const dir = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();\n            const minDist = starMaxDistance * 0.8;\n            const maxDist = starMaxDistance * 1.0;\n            const dist = minDist + Math.random() * (maxDist - minDist);\n            // Place the star at the distant edge\n            const spawnPos = dir.clone().multiplyScalar(dist);\n            // Tangential velocity: perpendicular to dir\n            let tangent = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1);\n            tangent = tangent.sub(tangent.clone().projectOnVector(dir)).normalize();\n            // Mix in a small radial component (inward or outward)\n            const tangentialSpeed = starSpeed * (0.5 + Math.random() * 1.5);\n            const radialSpeed = starSpeed * (Math.random() - 0.5) * 0.2; // small inward/outward\n            const velocity = tangent.multiplyScalar(tangentialSpeed).add(dir.clone().multiplyScalar(radialSpeed));\n            // Star color: random white/yellow/blue\n            const colors = [\n                0xffffee,\n                0xfff2cc,\n                0xcce6ff,\n                0xffffff\n            ];\n            const color = colors[Math.floor(Math.random() * colors.length)];\n            // Star brightness\n            const brightness = 1.2 + Math.random() * 1.5;\n            const geo = new three__WEBPACK_IMPORTED_MODULE_2__.SphereGeometry(1.5 + Math.random(), 16, 16);\n            const mat = new three__WEBPACK_IMPORTED_MODULE_2__.MeshBasicMaterial({\n                color: color\n            });\n            mat.opacity = 0.7 + Math.random() * 0.3;\n            mat.baseOpacity = mat.opacity; // Save for fade logic\n            mat.transparent = true;\n            const star = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(geo, mat);\n            star.position.copy(spawnPos);\n            star.velocity = velocity;\n            star.normalizedLife = 0.0; // Start at 0, will increase to 1.0\n            star.normalizedLifetime = 60 + Math.random() * 30; // Shorter normalizedLifetime: 60-90 frames\n            star.age = 0; // Track age in frames\n            // --- Realistic Meteor Tail (multi-point, gradient, fading) ---\n            const trailSegments = tailLength;\n            const trailPoints = [];\n            for(let i = 0; i < trailSegments; i++){\n                trailPoints.push(star.position.clone());\n            }\n            const tailGeo = new three__WEBPACK_IMPORTED_MODULE_2__.BufferGeometry().setFromPoints(trailPoints);\n            // Per-vertex color (alpha gradient)\n            const tailColors = [];\n            for(let i = 0; i < trailSegments; i++){\n                // Alpha fades out along the tail\n                const alpha = (1 - i / (trailSegments - 1)) * 0.85; // More persistent\n                // Color shifts from head color to faint blue/white/orange\n                let gradientColor;\n                if (i < trailSegments * 0.2) gradientColor = color; // head\n                else if (i < trailSegments * 0.7) gradientColor = 0x80c0ff;\n                else gradientColor = 0xffc080;\n                tailColors.push((gradientColor >> 16 & 255) / 255, (gradientColor >> 8 & 255) / 255, (gradientColor & 255) / 255, alpha);\n            }\n            tailGeo.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_2__.Float32BufferAttribute(tailColors, 4));\n            // Additive blending for glow\n            const tailMat = new three__WEBPACK_IMPORTED_MODULE_2__.LineBasicMaterial({\n                vertexColors: true,\n                transparent: true,\n                opacity: 1.0,\n                blending: three__WEBPACK_IMPORTED_MODULE_2__.AdditiveBlending\n            });\n            const tail = new three__WEBPACK_IMPORTED_MODULE_2__.Line(tailGeo, tailMat);\n            tail.position.copy(star.position);\n            // Add to scene\n            scene.add(star);\n            scene.add(tail);\n            shootingStars.push({\n                mesh: star,\n                tail,\n                velocity: star.velocity,\n                dir,\n                age: 0,\n                normalizedLifetime: star.normalizedLifetime,\n                trailPoints,\n                color,\n                brightness,\n                hasFragmented: false\n            });\n        }\n        const animate = ()=>{\n            requestAnimationFrame(animate);\n            camera.rotation.y += (targetY - camera.rotation.y) * damping;\n            // Move the virtual camera position in the direction the camera is facing\n            const forward = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n            camera.getWorldDirection(forward);\n            virtualCameraPos.add(forward.multiplyScalar(starSpeed));\n            // Offset all stars by -virtualCameraPos (floating origin)\n            for(let i = 0; i < positions.length; i += 3){\n                geometry.attributes.position.array[i] = positions[i] - virtualCameraPos.x;\n                geometry.attributes.position.array[i + 1] = positions[i + 1] - virtualCameraPos.y;\n                geometry.attributes.position.array[i + 2] = positions[i + 2] - virtualCameraPos.z;\n            }\n            geometry.attributes.position.needsUpdate = true;\n            // --- Shooting star spawning ---\n            // DEV: Make shooting stars super common (spawn every frame if cooldown allows)\n            if (shootingStarCooldown <= 0 && Math.random() < 1.0) {\n                spawnShootingStar();\n                shootingStarCooldown = 2 + Math.random() * 2; // Very short cooldown\n            } else if (shootingStarCooldown > 0) {\n                shootingStarCooldown--;\n            }\n            // Animate and clean up shooting stars\n            for(let i = shootingStars.length - 1; i >= 0; i--){\n                const obj = shootingStars[i];\n                // Curved trajectory\n                let perp = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5);\n                perp = perp.sub(perp.clone().projectOnVector(obj.velocity)).normalize().multiplyScalar(0.002 + Math.random() * 0.001);\n                obj.velocity.add(perp);\n                obj.velocity.normalize().multiplyScalar(obj.velocity.length());\n                obj.mesh.position.add(obj.velocity);\n                obj.tail.position.copy(obj.mesh.position);\n                // Animate tail\n                obj.age++;\n                const normalizedLife = obj.age / obj.normalizedLifetime;\n                for(let t = obj.trailPoints.length - 1; t > 0; t--){\n                    obj.trailPoints[t].lerp(obj.trailPoints[t - 1], 0.45);\n                }\n                obj.trailPoints[0].copy(obj.mesh.position);\n                let tailGrow = Math.min(1, normalizedLife / 0.3);\n                let activeSegments = Math.floor(obj.trailPoints.length * tailGrow);\n                if (activeSegments < 2) activeSegments = 2;\n                const visibleTrail = obj.trailPoints.slice(0, activeSegments);\n                obj.tail.geometry.setFromPoints(visibleTrail);\n                const tailColors = obj.tail.geometry.getAttribute(\"color\");\n                for(let j = 0; j < visibleTrail.length; j++){\n                    let alpha = (1 - j / (visibleTrail.length - 1)) * 0.95;\n                    alpha *= 0.92 + 0.08 * Math.sin(Date.now() * 0.015 + j * 0.5);\n                    let rainbow = [\n                        0xffc080,\n                        0xffe080,\n                        0xffff80,\n                        0x80ffe6,\n                        0x80c0ff,\n                        0xc080ff\n                    ];\n                    let gradColor = rainbow[j % rainbow.length];\n                    if (normalizedLife > 0.7) alpha *= Math.max(0, 1 - (normalizedLife - 0.7 - 0.2) / 0.3);\n                    tailColors.setXYZW(j, (gradColor >> 16 & 255) / 255, (gradColor >> 8 & 255) / 255, (gradColor & 255) / 255, alpha);\n                }\n                tailColors.needsUpdate = true;\n                // Animate head\n                let headColor;\n                if (normalizedLife < 0.5) {\n                    headColor = new three__WEBPACK_IMPORTED_MODULE_2__.Color(obj.color).lerp(new three__WEBPACK_IMPORTED_MODULE_2__.Color(0xffc080), normalizedLife * 2);\n                } else {\n                    headColor = new three__WEBPACK_IMPORTED_MODULE_2__.Color(0xffc080).lerp(new three__WEBPACK_IMPORTED_MODULE_2__.Color(0xff4000), (normalizedLife - 0.5) * 2);\n                }\n                let flicker = 0.95 + 0.13 * Math.sin(Date.now() * 0.07 + Math.random() * 10);\n                headColor.multiplyScalar(flicker);\n                obj.mesh.material.color.copy(headColor);\n                let scale = 1 + 2.2 * Math.sin(Math.PI * normalizedLife);\n                let distToCam = obj.mesh.position.length();\n                let dofBlur = distToCam < starMaxDistance * 0.7 ? 0.7 : 1.0;\n                obj.mesh.scale.set(scale * dofBlur, scale * dofBlur, scale * dofBlur);\n                // Sparkle burst\n                if (normalizedLife >= 1 && !obj.hasFragmented) {\n                    for(let s = 0; s < 9; s++){\n                        const sparkleGeo = new three__WEBPACK_IMPORTED_MODULE_2__.SphereGeometry(0.7 + Math.random() * 0.8, 8, 8);\n                        const sparkleMat = new three__WEBPACK_IMPORTED_MODULE_2__.MeshBasicMaterial({\n                            color: 0xffffff,\n                            transparent: true,\n                            opacity: 0.7,\n                            blending: three__WEBPACK_IMPORTED_MODULE_2__.AdditiveBlending\n                        });\n                        const sparkle = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(sparkleGeo, sparkleMat);\n                        sparkle.position.copy(obj.mesh.position);\n                        const sparkleVel = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize().multiplyScalar(2 + Math.random() * 2);\n                        sparkle.userData = {\n                            velocity: sparkleVel,\n                            age: 0\n                        };\n                        scene.add(sparkle);\n                        if (!window._sparkles) window._sparkles = [];\n                        window._sparkles.push(sparkle);\n                    }\n                    const fragVel = obj.velocity.clone().applyAxisAngle(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 1, 0), (Math.random() - 0.5) * 0.3);\n                    const fragStar = obj.mesh.clone();\n                    fragStar.position.copy(obj.mesh.position);\n                    fragStar.velocity = fragVel;\n                    fragStar.normalizedLife = normalizedLife;\n                    fragStar.normalizedLifetime = obj.normalizedLifetime * (0.5 + Math.random() * 0.5);\n                    fragStar.age = obj.age;\n                    fragStar.material = obj.mesh.material.clone();\n                    const fragTrailPoints = obj.trailPoints.slice();\n                    const fragTailGeo = new three__WEBPACK_IMPORTED_MODULE_2__.BufferGeometry().setFromPoints(fragTrailPoints);\n                    fragTailGeo.setAttribute(\"color\", obj.tail.geometry.getAttribute(\"color\").clone());\n                    const fragTailMat = obj.tail.material.clone();\n                    const fragTail = new three__WEBPACK_IMPORTED_MODULE_2__.Line(fragTailGeo, fragTailMat);\n                    fragTail.position.copy(fragStar.position);\n                    scene.add(fragStar);\n                    scene.add(fragTail);\n                    shootingStars.push({\n                        mesh: fragStar,\n                        tail: fragTail,\n                        velocity: fragStar.velocity,\n                        dir: obj.dir,\n                        age: fragStar.age,\n                        normalizedLifetime: fragStar.normalizedLifetime,\n                        trailPoints: fragTrailPoints,\n                        color: obj.color,\n                        brightness: obj.brightness,\n                        hasFragmented: true\n                    });\n                    obj.hasFragmented = true;\n                }\n                // Spark burst\n                if (!obj.hasSparked && normalizedLife > 0.95 && Math.random() < 0.1) {\n                    for(let s = 0; s < 8 + Math.floor(Math.random() * 8); s++){\n                        const sparkGeo = new three__WEBPACK_IMPORTED_MODULE_2__.SphereGeometry(0.5 + Math.random() * 0.5, 8, 8);\n                        const sparkMat = new three__WEBPACK_IMPORTED_MODULE_2__.MeshBasicMaterial({\n                            color: 0xfff6c0,\n                            transparent: true,\n                            opacity: 1,\n                            blending: three__WEBPACK_IMPORTED_MODULE_2__.AdditiveBlending\n                        });\n                        const spark = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(sparkGeo, sparkMat);\n                        spark.position.copy(obj.mesh.position);\n                        spark.sparkVel = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize().multiplyScalar(0.5 + Math.random() * 1.2);\n                        spark.sparkLife = 12 + Math.random() * 10;\n                        spark.sparkAge = 0;\n                        scene.add(spark);\n                        if (!window._starSparks) window._starSparks = [];\n                        window._starSparks.push(spark);\n                    }\n                    obj.hasSparked = true;\n                }\n                // Flash\n                if (!obj.hasFlashed && normalizedLife > 0.98 && Math.random() < 0.2) {\n                    const flashGeo = new three__WEBPACK_IMPORTED_MODULE_2__.SphereGeometry(1, 16, 16);\n                    const flashMat = new three__WEBPACK_IMPORTED_MODULE_2__.MeshBasicMaterial({\n                        color: 0xffffee,\n                        transparent: true,\n                        opacity: 0.8,\n                        blending: three__WEBPACK_IMPORTED_MODULE_2__.AdditiveBlending\n                    });\n                    const flash = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(flashGeo, flashMat);\n                    flash.position.copy(obj.mesh.position);\n                    scene.add(flash);\n                    if (!window._starFlashes) window._starFlashes = [];\n                    window._starFlashes.push({\n                        mesh: flash,\n                        age: 0\n                    });\n                    obj.hasFlashed = true;\n                }\n                // Fade out as it gets far away\n                const dist = obj.mesh.position.distanceTo(camera.position);\n                const fadeStart = starMaxDistance * 0.5;\n                if (dist > fadeStart) {\n                    const fade = 1 - (dist - fadeStart) / (starMaxDistance - fadeStart);\n                    obj.mesh.material.opacity = Math.max(0, fade);\n                    obj.mesh.material.transparent = true;\n                    obj.tail.material.opacity = Math.max(0, fade * 0.8);\n                    obj.tail.material.transparent = true;\n                }\n                // Remove when out of bounds or fully faded or life ended\n                if (normalizedLife >= 1.0 || dist > starMaxDistance || obj.mesh.material.opacity <= 0.01) {\n                    scene.remove(obj.mesh);\n                    scene.remove(obj.tail);\n                    shootingStars.splice(i, 1);\n                }\n            }\n            // Animate sparks\n            if (window._starSparks) {\n                for(let i = window._starSparks.length - 1; i >= 0; i--){\n                    const spark = window._starSparks[i];\n                    spark.position.add(spark.sparkVel);\n                    spark.sparkAge++;\n                    spark.material.opacity *= 0.85;\n                    if (spark.sparkAge > spark.sparkLife) {\n                        scene.remove(spark);\n                        window._starSparks.splice(i, 1);\n                    }\n                }\n            }\n            // Animate flashes\n            if (window._starFlashes) {\n                for(let i = window._starFlashes.length - 1; i >= 0; i--){\n                    const flash = window._starFlashes[i];\n                    flash.mesh.scale.multiplyScalar(1.15);\n                    flash.mesh.material.opacity *= 0.85;\n                    flash.age++;\n                    if (flash.age > 10) {\n                        scene.remove(flash.mesh);\n                        window._starFlashes.splice(i, 1);\n                    }\n                }\n            }\n            // --- Starfield logic ---\n            const sqDist = starMaxDistance * starMaxDistance;\n            for(let i = 0; i < positions.length; i += 3){\n                const dx = positions[i] - virtualCameraPos.x;\n                const dy = positions[i + 1] - virtualCameraPos.y;\n                const dz = positions[i + 2] - virtualCameraPos.z;\n                if (dx * dx + dy * dy + dz * dz > sqDist) {\n                    // Place in a thick spherical shell around the virtual camera, never too close\n                    const minRadius = starMaxDistance * 0.8;\n                    const maxRadius = starMaxDistance;\n                    const r = minRadius + Math.random() * (maxRadius - minRadius);\n                    const theta = Math.random() * 2 * Math.PI;\n                    const phi = Math.acos(2 * Math.random() - 1);\n                    positions[i] = virtualCameraPos.x + r * Math.sin(phi) * Math.cos(theta);\n                    positions[i + 1] = virtualCameraPos.y + r * Math.sin(phi) * Math.sin(theta);\n                    positions[i + 2] = virtualCameraPos.z + r * Math.cos(phi);\n                }\n            }\n            // geometry.attributes.position.needsUpdate = true; // Already set above\n            // Robust starfield color update to prevent stuck white dots\n            const colArr = geometry.attributes.color.array;\n            for(let i = 0; i < positions.length; i += 3){\n                const idx = i / 3;\n                const dx = positions[i] - virtualCameraPos.x;\n                const dy = positions[i + 1] - virtualCameraPos.y;\n                const dz = positions[i + 2] - virtualCameraPos.z;\n                const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);\n                if (timers[idx] > 0) {\n                    timers[idx]--;\n                    if (timers[idx] === 0) {\n                        // Timer expired, restore color\n                        sparkColors[i] = originalColors[i];\n                        sparkColors[i + 1] = originalColors[i + 1];\n                        sparkColors[i + 2] = originalColors[i + 2];\n                        colArr[i] = originalColors[i];\n                        colArr[i + 1] = originalColors[i + 1];\n                        colArr[i + 2] = originalColors[i + 2];\n                    } else {\n                        colArr[i] = sparkColors[i];\n                        colArr[i + 1] = sparkColors[i + 1];\n                        colArr[i + 2] = sparkColors[i + 2];\n                    }\n                } else if (dist > starMaxDistance * 0.3 && Math.random() < 0.05) {\n                    timers[idx] = sparkleDuration;\n                    const c = palette[Math.floor(Math.random() * palette.length)];\n                    sparkColors[i] = c[0];\n                    sparkColors[i + 1] = c[1];\n                    sparkColors[i + 2] = c[2];\n                    colArr[i] = sparkColors[i];\n                    colArr[i + 1] = sparkColors[i + 1];\n                    colArr[i + 2] = sparkColors[i + 2];\n                } else {\n                    sparkColors[i] = originalColors[i];\n                    sparkColors[i + 1] = originalColors[i + 1];\n                    sparkColors[i + 2] = originalColors[i + 2];\n                    colArr[i] = originalColors[i];\n                    colArr[i + 1] = originalColors[i + 1];\n                    colArr[i + 2] = originalColors[i + 2];\n                }\n            }\n            geometry.attributes.color.needsUpdate = true;\n            renderer.render(scene, camera);\n        };\n        animate(); // Start the render loop\n        const onResize = ()=>{\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        };\n        window.addEventListener(\"resize\", onResize);\n        return ()=>{\n            window.removeEventListener(\"scroll\", onScroll);\n            window.removeEventListener(\"resize\", onResize);\n            mount.removeChild(renderer.domElement);\n        };\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: mountRef\n    }, void 0, false, {\n        fileName: \"/home/kayosdev/Websites/Portfolio/components/Starfield.jsx\",\n        lineNumber: 396,\n        columnNumber: 10\n    }, undefined);\n};\n_s(Starfield, \"V9/qkEdV8GfsDZk7lMTA1T8g5Ps=\");\n_c = Starfield;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Starfield);\nvar _c;\n$RefreshReg$(_c, \"Starfield\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LHFCQUFPLDhEQUFDZ0w7UUFBSUMsS0FBSzdNOzs7Ozs7QUFDbkI7R0F6WU1EO0tBQUFBO0FBMllOLCtEQUFlQSxTQUFTQSxFQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvU3RhcmZpZWxkLmpzeD9mMWEyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcblxuY29uc3QgU3RhcmZpZWxkID0gKCkgPT4ge1xuICBjb25zdCBtb3VudFJlZiA9IHVzZVJlZihudWxsKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgbW91bnQgPSBtb3VudFJlZi5jdXJyZW50XG4gICAgbW91bnQuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnXG4gICAgbW91bnQuc3R5bGUudG9wID0gJzAnXG4gICAgbW91bnQuc3R5bGUubGVmdCA9ICcwJ1xuICAgIG1vdW50LnN0eWxlLndpZHRoID0gJzEwMCUnXG4gICAgbW91bnQuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnXG4gICAgbW91bnQuc3R5bGUuekluZGV4ID0gJzAnXG5cbiAgICAvLyBTY2VuZSAmIFJlbmRlcmVyXG4gICAgY29uc3Qgc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKVxuICAgIGNvbnN0IGNhbWVyYSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSg3NSwgd2luZG93LmlubmVyV2lkdGggLyB3aW5kb3cuaW5uZXJIZWlnaHQsIDAuMSwgNTAwMClcbiAgICBjYW1lcmEucG9zaXRpb24uc2V0KC0xLCAwLCAwKTtcbiAgICAvLyBWaXJ0dWFsIHBvc2l0aW9uIHRvIHNpbXVsYXRlIGluZmluaXRlIHRyYXZlbFxuICAgIGxldCB2aXJ0dWFsQ2FtZXJhUG9zID0gbmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMCk7XG4gICAgY29uc3QgcmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcih7IGFudGlhbGlhczogdHJ1ZSB9KVxuICAgIHJlbmRlcmVyLnNldFBpeGVsUmF0aW8od2luZG93LmRldmljZVBpeGVsUmF0aW8pXG4gICAgcmVuZGVyZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KVxuICAgIHJlbmRlcmVyLnNldENsZWFyQ29sb3IoMHgwMDAwMDAsIDEpO1xuICAgIG1vdW50LmFwcGVuZENoaWxkKHJlbmRlcmVyLmRvbUVsZW1lbnQpXG5cbiAgICAvLyBTdGFyZmllbGRcbiAgICBjb25zdCBzdGFyQ291bnQgPSAxMDAwMFxuICAgIGNvbnN0IHN0YXJNYXhEaXN0YW5jZSA9IDEwMDBcbiAgICBjb25zdCBzdGFyU3BlZWQgPSAwLjVcbiAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpXG4gICAgY29uc3QgcG9zaXRpb25zID0gW11cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXJDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCB0aGV0YSA9IE1hdGgucmFuZG9tKCkgKiAyICogTWF0aC5QSVxuICAgICAgY29uc3QgcGhpID0gTWF0aC5hY29zKDIgKiBNYXRoLnJhbmRvbSgpIC0gMSlcbiAgICAgIGNvbnN0IHIgPSBNYXRoLnJhbmRvbSgpICogc3Rhck1heERpc3RhbmNlXG4gICAgICBwb3NpdGlvbnMucHVzaChcbiAgICAgICAgciAqIE1hdGguc2luKHBoaSkgKiBNYXRoLmNvcyh0aGV0YSksXG4gICAgICAgIHIgKiBNYXRoLnNpbihwaGkpICogTWF0aC5zaW4odGhldGEpLFxuICAgICAgICByICogTWF0aC5jb3MocGhpKVxuICAgICAgKVxuICAgIH1cbiAgICBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUocG9zaXRpb25zLCAzKSlcblxuICAgIGNvbnN0IHBhbGV0dGUgPSBbXG4gICAgICBbMS4wLCAwLjUsIDAuNV0sXG4gICAgICBbMS4wLCAwLjc1LCAwLjRdLFxuICAgICAgWzEuMCwgMS4wLCAwLjldLFxuICAgICAgWzEuMCwgMS4wLCAxLjBdLFxuICAgICAgWzAuNCwgMC41LCAxLjBdLFxuICAgIF1cbiAgICBjb25zdCBjb2xvcnMgPSBbXVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhckNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IGMgPSBwYWxldHRlW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHBhbGV0dGUubGVuZ3RoKV1cbiAgICAgIGNvbG9ycy5wdXNoKC4uLmMpXG4gICAgfVxuICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnY29sb3InLCBuZXcgVEhSRUUuRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShjb2xvcnMsIDMpKVxuXG4gICAgY29uc3Qgb3JpZ2luYWxDb2xvcnMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLmNvbG9yLmFycmF5LnNsaWNlKClcbiAgICBjb25zdCB0aW1lcnMgPSBuZXcgRmxvYXQzMkFycmF5KHN0YXJDb3VudClcbiAgICBjb25zdCBzcGFya0NvbG9ycyA9IG5ldyBGbG9hdDMyQXJyYXkoc3RhckNvdW50ICogMylcbiAgICBjb25zdCBzcGFya2xlRHVyYXRpb24gPSAxODBcblxuICAgIGNvbnN0IG1hdGVyaWFsID0gbmV3IFRIUkVFLlBvaW50c01hdGVyaWFsKHsgc2l6ZTogMi41LCBzaXplQXR0ZW51YXRpb246IHRydWUsIHZlcnRleENvbG9yczogdHJ1ZSB9KVxuICAgIGNvbnN0IHN0YXJzID0gbmV3IFRIUkVFLlBvaW50cyhnZW9tZXRyeSwgbWF0ZXJpYWwpXG4gICAgc2NlbmUuYWRkKHN0YXJzKVxuXG4gICAgbGV0IHRhcmdldFkgPSAwXG4gICAgY29uc3QgZGFtcGluZyA9IDAuMDVcbiAgICBjb25zdCBvblNjcm9sbCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHBjdCA9IHdpbmRvdy5zY3JvbGxZIC8gKGRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0IC0gd2luZG93LmlubmVySGVpZ2h0KVxuICAgICAgdGFyZ2V0WSA9IHBjdCAqIE1hdGguUEkgKiAyXG4gICAgfVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBvblNjcm9sbClcblxuICAgIC8vIC0tLSBTaG9vdGluZyBTdGFycyAtLS1cbiAgICBjb25zdCB0YWlsTGVuZ3RoID0gMzI7IC8vIEluY3JlYXNlIGZvciBsb25nZXIgdGFpbHNcbiAgICBjb25zdCBzaG9vdGluZ1N0YXJzID0gW107XG4gICAgbGV0IHNob290aW5nU3RhckNvb2xkb3duID0gMDtcbiAgICAvLyBTcGF3biBhIHNob290aW5nIHN0YXIgd2l0aCBhIGdsb3dpbmcgdGFpbFxuICAgIGZ1bmN0aW9uIHNwYXduU2hvb3RpbmdTdGFyKCkge1xuICAgICAgLy8gUGljayBhIHJhbmRvbSBkaXJlY3Rpb24gb24gdGhlIHNwaGVyZSBmb3IgdGhlIHNwYXduIGxvY2F0aW9uXG4gICAgICBjb25zdCBkaXIgPSBuZXcgVEhSRUUuVmVjdG9yMyhNYXRoLnJhbmRvbSgpKjItMSwgTWF0aC5yYW5kb20oKSoyLTEsIE1hdGgucmFuZG9tKCkqMi0xKS5ub3JtYWxpemUoKTtcbiAgICAgIGNvbnN0IG1pbkRpc3QgPSBzdGFyTWF4RGlzdGFuY2UgKiAwLjg7XG4gICAgICBjb25zdCBtYXhEaXN0ID0gc3Rhck1heERpc3RhbmNlICogMS4wO1xuICAgICAgY29uc3QgZGlzdCA9IG1pbkRpc3QgKyBNYXRoLnJhbmRvbSgpICogKG1heERpc3QgLSBtaW5EaXN0KTtcbiAgICAgIC8vIFBsYWNlIHRoZSBzdGFyIGF0IHRoZSBkaXN0YW50IGVkZ2VcbiAgICAgIGNvbnN0IHNwYXduUG9zID0gZGlyLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoZGlzdCk7XG4gICAgICAvLyBUYW5nZW50aWFsIHZlbG9jaXR5OiBwZXJwZW5kaWN1bGFyIHRvIGRpclxuICAgICAgbGV0IHRhbmdlbnQgPSBuZXcgVEhSRUUuVmVjdG9yMyhNYXRoLnJhbmRvbSgpKjItMSwgTWF0aC5yYW5kb20oKSoyLTEsIE1hdGgucmFuZG9tKCkqMi0xKTtcbiAgICAgIHRhbmdlbnQgPSB0YW5nZW50LnN1Yih0YW5nZW50LmNsb25lKCkucHJvamVjdE9uVmVjdG9yKGRpcikpLm5vcm1hbGl6ZSgpO1xuICAgICAgLy8gTWl4IGluIGEgc21hbGwgcmFkaWFsIGNvbXBvbmVudCAoaW53YXJkIG9yIG91dHdhcmQpXG4gICAgICBjb25zdCB0YW5nZW50aWFsU3BlZWQgPSBzdGFyU3BlZWQgKiAoMC41ICsgTWF0aC5yYW5kb20oKSAqIDEuNSk7XG4gICAgICBjb25zdCByYWRpYWxTcGVlZCA9IHN0YXJTcGVlZCAqIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDAuMjsgLy8gc21hbGwgaW53YXJkL291dHdhcmRcbiAgICAgIGNvbnN0IHZlbG9jaXR5ID0gdGFuZ2VudC5tdWx0aXBseVNjYWxhcih0YW5nZW50aWFsU3BlZWQpLmFkZChkaXIuY2xvbmUoKS5tdWx0aXBseVNjYWxhcihyYWRpYWxTcGVlZCkpO1xuICAgICAgLy8gU3RhciBjb2xvcjogcmFuZG9tIHdoaXRlL3llbGxvdy9ibHVlXG4gICAgICBjb25zdCBjb2xvcnMgPSBbMHhmZmZmZWUsIDB4ZmZmMmNjLCAweGNjZTZmZiwgMHhmZmZmZmZdO1xuICAgICAgY29uc3QgY29sb3IgPSBjb2xvcnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKmNvbG9ycy5sZW5ndGgpXTtcbiAgICAgIC8vIFN0YXIgYnJpZ2h0bmVzc1xuICAgICAgY29uc3QgYnJpZ2h0bmVzcyA9IDEuMiArIE1hdGgucmFuZG9tKCkqMS41O1xuICAgICAgY29uc3QgZ2VvID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KDEuNSArIE1hdGgucmFuZG9tKCksIDE2LCAxNik7XG4gICAgICBjb25zdCBtYXQgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoeyBjb2xvcjogY29sb3IgfSk7XG4gICAgICBtYXQub3BhY2l0eSA9IDAuNyArIE1hdGgucmFuZG9tKCkqMC4zO1xuICAgICAgbWF0LmJhc2VPcGFjaXR5ID0gbWF0Lm9wYWNpdHk7IC8vIFNhdmUgZm9yIGZhZGUgbG9naWNcbiAgICAgIG1hdC50cmFuc3BhcmVudCA9IHRydWU7XG4gICAgICBjb25zdCBzdGFyID0gbmV3IFRIUkVFLk1lc2goZ2VvLCBtYXQpO1xuICAgICAgc3Rhci5wb3NpdGlvbi5jb3B5KHNwYXduUG9zKTtcbiAgICAgIHN0YXIudmVsb2NpdHkgPSB2ZWxvY2l0eTtcbiAgICAgIHN0YXIubm9ybWFsaXplZExpZmUgPSAwLjA7IC8vIFN0YXJ0IGF0IDAsIHdpbGwgaW5jcmVhc2UgdG8gMS4wXG4gICAgICBzdGFyLm5vcm1hbGl6ZWRMaWZldGltZSA9IDYwICsgTWF0aC5yYW5kb20oKSAqIDMwOyAvLyBTaG9ydGVyIG5vcm1hbGl6ZWRMaWZldGltZTogNjAtOTAgZnJhbWVzXG4gICAgICBzdGFyLmFnZSA9IDA7IC8vIFRyYWNrIGFnZSBpbiBmcmFtZXNcbiAgICAgIC8vIC0tLSBSZWFsaXN0aWMgTWV0ZW9yIFRhaWwgKG11bHRpLXBvaW50LCBncmFkaWVudCwgZmFkaW5nKSAtLS1cbiAgICAgIGNvbnN0IHRyYWlsU2VnbWVudHMgPSB0YWlsTGVuZ3RoO1xuICAgICAgY29uc3QgdHJhaWxQb2ludHMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhaWxTZWdtZW50czsgaSsrKSB7XG4gICAgICAgIHRyYWlsUG9pbnRzLnB1c2goc3Rhci5wb3NpdGlvbi5jbG9uZSgpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhaWxHZW8gPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKS5zZXRGcm9tUG9pbnRzKHRyYWlsUG9pbnRzKTtcbiAgICAgIC8vIFBlci12ZXJ0ZXggY29sb3IgKGFscGhhIGdyYWRpZW50KVxuICAgICAgY29uc3QgdGFpbENvbG9ycyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFpbFNlZ21lbnRzOyBpKyspIHtcbiAgICAgICAgLy8gQWxwaGEgZmFkZXMgb3V0IGFsb25nIHRoZSB0YWlsXG4gICAgICAgIGNvbnN0IGFscGhhID0gKDEgLSBpIC8gKHRyYWlsU2VnbWVudHMgLSAxKSkgKiAwLjg1OyAvLyBNb3JlIHBlcnNpc3RlbnRcbiAgICAgICAgLy8gQ29sb3Igc2hpZnRzIGZyb20gaGVhZCBjb2xvciB0byBmYWludCBibHVlL3doaXRlL29yYW5nZVxuICAgICAgICBsZXQgZ3JhZGllbnRDb2xvcjtcbiAgICAgICAgaWYgKGkgPCB0cmFpbFNlZ21lbnRzICogMC4yKSBncmFkaWVudENvbG9yID0gY29sb3I7IC8vIGhlYWRcbiAgICAgICAgZWxzZSBpZiAoaSA8IHRyYWlsU2VnbWVudHMgKiAwLjcpIGdyYWRpZW50Q29sb3IgPSAweDgwYzBmZjtcbiAgICAgICAgZWxzZSBncmFkaWVudENvbG9yID0gMHhmZmMwODA7XG4gICAgICAgIHRhaWxDb2xvcnMucHVzaCgoZ3JhZGllbnRDb2xvciA+PiAxNiAmIDI1NSkgLyAyNTUsIChncmFkaWVudENvbG9yID4+IDggJiAyNTUpIC8gMjU1LCAoZ3JhZGllbnRDb2xvciAmIDI1NSkgLyAyNTUsIGFscGhhKTtcbiAgICAgIH1cbiAgICAgIHRhaWxHZW8uc2V0QXR0cmlidXRlKCdjb2xvcicsIG5ldyBUSFJFRS5GbG9hdDMyQnVmZmVyQXR0cmlidXRlKHRhaWxDb2xvcnMsIDQpKTtcbiAgICAgIC8vIEFkZGl0aXZlIGJsZW5kaW5nIGZvciBnbG93XG4gICAgICBjb25zdCB0YWlsTWF0ID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKHsgdmVydGV4Q29sb3JzOiB0cnVlLCB0cmFuc3BhcmVudDogdHJ1ZSwgb3BhY2l0eTogMS4wLCBibGVuZGluZzogVEhSRUUuQWRkaXRpdmVCbGVuZGluZyB9KTtcbiAgICAgIGNvbnN0IHRhaWwgPSBuZXcgVEhSRUUuTGluZSh0YWlsR2VvLCB0YWlsTWF0KTtcbiAgICAgIHRhaWwucG9zaXRpb24uY29weShzdGFyLnBvc2l0aW9uKTtcbiAgICAgIC8vIEFkZCB0byBzY2VuZVxuICAgICAgc2NlbmUuYWRkKHN0YXIpO1xuICAgICAgc2NlbmUuYWRkKHRhaWwpO1xuICAgICAgc2hvb3RpbmdTdGFycy5wdXNoKHsgbWVzaDogc3RhciwgdGFpbCwgdmVsb2NpdHk6IHN0YXIudmVsb2NpdHksIGRpciwgYWdlOiAwLCBub3JtYWxpemVkTGlmZXRpbWU6IHN0YXIubm9ybWFsaXplZExpZmV0aW1lLCB0cmFpbFBvaW50cywgY29sb3IsIGJyaWdodG5lc3MsIGhhc0ZyYWdtZW50ZWQ6IGZhbHNlIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGFuaW1hdGUgPSAoKSA9PiB7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG4gICAgICBjYW1lcmEucm90YXRpb24ueSArPSAodGFyZ2V0WSAtIGNhbWVyYS5yb3RhdGlvbi55KSAqIGRhbXBpbmc7XG4gICAgICAvLyBNb3ZlIHRoZSB2aXJ0dWFsIGNhbWVyYSBwb3NpdGlvbiBpbiB0aGUgZGlyZWN0aW9uIHRoZSBjYW1lcmEgaXMgZmFjaW5nXG4gICAgICBjb25zdCBmb3J3YXJkID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgIGNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihmb3J3YXJkKTtcbiAgICAgIHZpcnR1YWxDYW1lcmFQb3MuYWRkKGZvcndhcmQubXVsdGlwbHlTY2FsYXIoc3RhclNwZWVkKSk7XG4gICAgICAvLyBPZmZzZXQgYWxsIHN0YXJzIGJ5IC12aXJ0dWFsQ2FtZXJhUG9zIChmbG9hdGluZyBvcmlnaW4pXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc2l0aW9ucy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5W2ldID0gcG9zaXRpb25zW2ldIC0gdmlydHVhbENhbWVyYVBvcy54O1xuICAgICAgICBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5W2krMV0gPSBwb3NpdGlvbnNbaSsxXSAtIHZpcnR1YWxDYW1lcmFQb3MueTtcbiAgICAgICAgZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheVtpKzJdID0gcG9zaXRpb25zW2krMl0gLSB2aXJ0dWFsQ2FtZXJhUG9zLno7XG4gICAgICB9XG4gICAgICBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgLy8gLS0tIFNob290aW5nIHN0YXIgc3Bhd25pbmcgLS0tXG4gICAgICAvLyBERVY6IE1ha2Ugc2hvb3Rpbmcgc3RhcnMgc3VwZXIgY29tbW9uIChzcGF3biBldmVyeSBmcmFtZSBpZiBjb29sZG93biBhbGxvd3MpXG4gICAgICBpZiAoc2hvb3RpbmdTdGFyQ29vbGRvd24gPD0gMCAmJiBNYXRoLnJhbmRvbSgpIDwgMS4wKSB7IC8vIFNob290aW5nIFN0YXIgU3Bhd24gUmF0ZVxuICAgICAgICBzcGF3blNob290aW5nU3RhcigpO1xuICAgICAgICBzaG9vdGluZ1N0YXJDb29sZG93biA9IDIgKyBNYXRoLnJhbmRvbSgpICogMjsgLy8gVmVyeSBzaG9ydCBjb29sZG93blxuICAgICAgfSBlbHNlIGlmIChzaG9vdGluZ1N0YXJDb29sZG93biA+IDApIHtcbiAgICAgICAgc2hvb3RpbmdTdGFyQ29vbGRvd24tLTtcbiAgICAgIH1cbiAgICAgIC8vIEFuaW1hdGUgYW5kIGNsZWFuIHVwIHNob290aW5nIHN0YXJzXG4gICAgICBmb3IgKGxldCBpID0gc2hvb3RpbmdTdGFycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBvYmogPSBzaG9vdGluZ1N0YXJzW2ldO1xuICAgICAgICAvLyBDdXJ2ZWQgdHJhamVjdG9yeVxuICAgICAgICBsZXQgcGVycCA9IG5ldyBUSFJFRS5WZWN0b3IzKE1hdGgucmFuZG9tKCktMC41LCBNYXRoLnJhbmRvbSgpLTAuNSwgTWF0aC5yYW5kb20oKS0wLjUpO1xuICAgICAgICBwZXJwID0gcGVycC5zdWIocGVycC5jbG9uZSgpLnByb2plY3RPblZlY3RvcihvYmoudmVsb2NpdHkpKS5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhcigwLjAwMiArIE1hdGgucmFuZG9tKCkqMC4wMDEpO1xuICAgICAgICBvYmoudmVsb2NpdHkuYWRkKHBlcnApO1xuICAgICAgICBvYmoudmVsb2NpdHkubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIob2JqLnZlbG9jaXR5Lmxlbmd0aCgpKTtcbiAgICAgICAgb2JqLm1lc2gucG9zaXRpb24uYWRkKG9iai52ZWxvY2l0eSk7XG4gICAgICAgIG9iai50YWlsLnBvc2l0aW9uLmNvcHkob2JqLm1lc2gucG9zaXRpb24pO1xuICAgICAgICAvLyBBbmltYXRlIHRhaWxcbiAgICAgICAgb2JqLmFnZSsrO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkTGlmZSA9IG9iai5hZ2UgLyBvYmoubm9ybWFsaXplZExpZmV0aW1lO1xuICAgICAgICBmb3IgKGxldCB0ID0gb2JqLnRyYWlsUG9pbnRzLmxlbmd0aCAtIDE7IHQgPiAwOyB0LS0pIHtcbiAgICAgICAgICBvYmoudHJhaWxQb2ludHNbdF0ubGVycChvYmoudHJhaWxQb2ludHNbdC0xXSwgMC40NSk7XG4gICAgICAgIH1cbiAgICAgICAgb2JqLnRyYWlsUG9pbnRzWzBdLmNvcHkob2JqLm1lc2gucG9zaXRpb24pO1xuICAgICAgICBsZXQgdGFpbEdyb3cgPSBNYXRoLm1pbigxLCBub3JtYWxpemVkTGlmZSAvIDAuMyk7XG4gICAgICAgIGxldCBhY3RpdmVTZWdtZW50cyA9IE1hdGguZmxvb3Iob2JqLnRyYWlsUG9pbnRzLmxlbmd0aCAqIHRhaWxHcm93KTtcbiAgICAgICAgaWYgKGFjdGl2ZVNlZ21lbnRzIDwgMikgYWN0aXZlU2VnbWVudHMgPSAyO1xuICAgICAgICBjb25zdCB2aXNpYmxlVHJhaWwgPSBvYmoudHJhaWxQb2ludHMuc2xpY2UoMCwgYWN0aXZlU2VnbWVudHMpO1xuICAgICAgICBvYmoudGFpbC5nZW9tZXRyeS5zZXRGcm9tUG9pbnRzKHZpc2libGVUcmFpbCk7XG4gICAgICAgIGNvbnN0IHRhaWxDb2xvcnMgPSBvYmoudGFpbC5nZW9tZXRyeS5nZXRBdHRyaWJ1dGUoJ2NvbG9yJyk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmlzaWJsZVRyYWlsLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgbGV0IGFscGhhID0gKDEgLSBqIC8gKHZpc2libGVUcmFpbC5sZW5ndGggLSAxKSkgKiAwLjk1O1xuICAgICAgICAgIGFscGhhICo9IDAuOTIgKyAwLjA4ICogTWF0aC5zaW4oRGF0ZS5ub3coKSowLjAxNSArIGoqMC41KTtcbiAgICAgICAgICBsZXQgcmFpbmJvdyA9IFsweGZmYzA4MCwgMHhmZmUwODAsIDB4ZmZmZjgwLCAweDgwZmZlNiwgMHg4MGMwZmYsIDB4YzA4MGZmXTtcbiAgICAgICAgICBsZXQgZ3JhZENvbG9yID0gcmFpbmJvd1tqICUgcmFpbmJvdy5sZW5ndGhdO1xuICAgICAgICAgIGlmIChub3JtYWxpemVkTGlmZSA+IDAuNykgYWxwaGEgKj0gTWF0aC5tYXgoMCwgMSAtIChub3JtYWxpemVkTGlmZSAtIDAuNyAtIDAuMikgLyAwLjMpO1xuICAgICAgICAgIHRhaWxDb2xvcnMuc2V0WFlaVyhqLCAoZ3JhZENvbG9yID4+IDE2ICYgMjU1KSAvIDI1NSwgKGdyYWRDb2xvciA+PiA4ICYgMjU1KSAvIDI1NSwgKGdyYWRDb2xvciAmIDI1NSkgLyAyNTUsIGFscGhhKTtcbiAgICAgICAgfVxuICAgICAgICB0YWlsQ29sb3JzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgLy8gQW5pbWF0ZSBoZWFkXG4gICAgICAgIGxldCBoZWFkQ29sb3I7XG4gICAgICAgIGlmIChub3JtYWxpemVkTGlmZSA8IDAuNSkge1xuICAgICAgICAgIGhlYWRDb2xvciA9IG5ldyBUSFJFRS5Db2xvcihvYmouY29sb3IpLmxlcnAobmV3IFRIUkVFLkNvbG9yKDB4ZmZjMDgwKSwgbm9ybWFsaXplZExpZmUqMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGVhZENvbG9yID0gbmV3IFRIUkVFLkNvbG9yKDB4ZmZjMDgwKS5sZXJwKG5ldyBUSFJFRS5Db2xvcigweGZmNDAwMCksIChub3JtYWxpemVkTGlmZS0wLjUpKjIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmbGlja2VyID0gMC45NSArIDAuMTMgKiBNYXRoLnNpbihEYXRlLm5vdygpKjAuMDcgKyBNYXRoLnJhbmRvbSgpKjEwKTtcbiAgICAgICAgaGVhZENvbG9yLm11bHRpcGx5U2NhbGFyKGZsaWNrZXIpO1xuICAgICAgICBvYmoubWVzaC5tYXRlcmlhbC5jb2xvci5jb3B5KGhlYWRDb2xvcik7XG4gICAgICAgIGxldCBzY2FsZSA9IDEgKyAyLjIgKiBNYXRoLnNpbihNYXRoLlBJICogbm9ybWFsaXplZExpZmUpO1xuICAgICAgICBsZXQgZGlzdFRvQ2FtID0gb2JqLm1lc2gucG9zaXRpb24ubGVuZ3RoKCk7XG4gICAgICAgIGxldCBkb2ZCbHVyID0gZGlzdFRvQ2FtIDwgc3Rhck1heERpc3RhbmNlICogMC43ID8gMC43IDogMS4wO1xuICAgICAgICBvYmoubWVzaC5zY2FsZS5zZXQoc2NhbGUgKiBkb2ZCbHVyLCBzY2FsZSAqIGRvZkJsdXIsIHNjYWxlICogZG9mQmx1cik7XG4gICAgICAgIC8vIFNwYXJrbGUgYnVyc3RcbiAgICAgICAgaWYgKG5vcm1hbGl6ZWRMaWZlID49IDEgJiYgIW9iai5oYXNGcmFnbWVudGVkKSB7XG4gICAgICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCA5OyBzKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNwYXJrbGVHZW8gPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoMC43ICsgTWF0aC5yYW5kb20oKSowLjgsIDgsIDgpO1xuICAgICAgICAgICAgY29uc3Qgc3BhcmtsZU1hdCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7IGNvbG9yOiAweGZmZmZmZiwgdHJhbnNwYXJlbnQ6IHRydWUsIG9wYWNpdHk6IDAuNywgYmxlbmRpbmc6IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmcgfSk7XG4gICAgICAgICAgICBjb25zdCBzcGFya2xlID0gbmV3IFRIUkVFLk1lc2goc3BhcmtsZUdlbywgc3BhcmtsZU1hdCk7XG4gICAgICAgICAgICBzcGFya2xlLnBvc2l0aW9uLmNvcHkob2JqLm1lc2gucG9zaXRpb24pO1xuICAgICAgICAgICAgY29uc3Qgc3BhcmtsZVZlbCA9IG5ldyBUSFJFRS5WZWN0b3IzKE1hdGgucmFuZG9tKCktMC41LCBNYXRoLnJhbmRvbSgpLTAuNSwgTWF0aC5yYW5kb20oKS0wLjUpLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKDIrTWF0aC5yYW5kb20oKSoyKTtcbiAgICAgICAgICAgIHNwYXJrbGUudXNlckRhdGEgPSB7IHZlbG9jaXR5OiBzcGFya2xlVmVsLCBhZ2U6IDAgfTtcbiAgICAgICAgICAgIHNjZW5lLmFkZChzcGFya2xlKTtcbiAgICAgICAgICAgIGlmICghd2luZG93Ll9zcGFya2xlcykgd2luZG93Ll9zcGFya2xlcyA9IFtdO1xuICAgICAgICAgICAgd2luZG93Ll9zcGFya2xlcy5wdXNoKHNwYXJrbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBmcmFnVmVsID0gb2JqLnZlbG9jaXR5LmNsb25lKCkuYXBwbHlBeGlzQW5nbGUobmV3IFRIUkVFLlZlY3RvcjMoMCwxLDApLCAoTWF0aC5yYW5kb20oKS0wLjUpKjAuMyk7XG4gICAgICAgICAgY29uc3QgZnJhZ1N0YXIgPSBvYmoubWVzaC5jbG9uZSgpO1xuICAgICAgICAgIGZyYWdTdGFyLnBvc2l0aW9uLmNvcHkob2JqLm1lc2gucG9zaXRpb24pO1xuICAgICAgICAgIGZyYWdTdGFyLnZlbG9jaXR5ID0gZnJhZ1ZlbDtcbiAgICAgICAgICBmcmFnU3Rhci5ub3JtYWxpemVkTGlmZSA9IG5vcm1hbGl6ZWRMaWZlO1xuICAgICAgICAgIGZyYWdTdGFyLm5vcm1hbGl6ZWRMaWZldGltZSA9IG9iai5ub3JtYWxpemVkTGlmZXRpbWUgKiAoMC41ICsgTWF0aC5yYW5kb20oKSowLjUpO1xuICAgICAgICAgIGZyYWdTdGFyLmFnZSA9IG9iai5hZ2U7XG4gICAgICAgICAgZnJhZ1N0YXIubWF0ZXJpYWwgPSBvYmoubWVzaC5tYXRlcmlhbC5jbG9uZSgpO1xuICAgICAgICAgIGNvbnN0IGZyYWdUcmFpbFBvaW50cyA9IG9iai50cmFpbFBvaW50cy5zbGljZSgpO1xuICAgICAgICAgIGNvbnN0IGZyYWdUYWlsR2VvID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCkuc2V0RnJvbVBvaW50cyhmcmFnVHJhaWxQb2ludHMpO1xuICAgICAgICAgIGZyYWdUYWlsR2VvLnNldEF0dHJpYnV0ZSgnY29sb3InLCBvYmoudGFpbC5nZW9tZXRyeS5nZXRBdHRyaWJ1dGUoJ2NvbG9yJykuY2xvbmUoKSk7XG4gICAgICAgICAgY29uc3QgZnJhZ1RhaWxNYXQgPSBvYmoudGFpbC5tYXRlcmlhbC5jbG9uZSgpO1xuICAgICAgICAgIGNvbnN0IGZyYWdUYWlsID0gbmV3IFRIUkVFLkxpbmUoZnJhZ1RhaWxHZW8sIGZyYWdUYWlsTWF0KTtcbiAgICAgICAgICBmcmFnVGFpbC5wb3NpdGlvbi5jb3B5KGZyYWdTdGFyLnBvc2l0aW9uKTtcbiAgICAgICAgICBzY2VuZS5hZGQoZnJhZ1N0YXIpO1xuICAgICAgICAgIHNjZW5lLmFkZChmcmFnVGFpbCk7XG4gICAgICAgICAgc2hvb3RpbmdTdGFycy5wdXNoKHsgbWVzaDogZnJhZ1N0YXIsIHRhaWw6IGZyYWdUYWlsLCB2ZWxvY2l0eTogZnJhZ1N0YXIudmVsb2NpdHksIGRpcjogb2JqLmRpciwgYWdlOiBmcmFnU3Rhci5hZ2UsIG5vcm1hbGl6ZWRMaWZldGltZTogZnJhZ1N0YXIubm9ybWFsaXplZExpZmV0aW1lLCB0cmFpbFBvaW50czogZnJhZ1RyYWlsUG9pbnRzLCBjb2xvcjogb2JqLmNvbG9yLCBicmlnaHRuZXNzOiBvYmouYnJpZ2h0bmVzcywgaGFzRnJhZ21lbnRlZDogdHJ1ZSB9KTtcbiAgICAgICAgICBvYmouaGFzRnJhZ21lbnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3BhcmsgYnVyc3RcbiAgICAgICAgaWYgKCFvYmouaGFzU3BhcmtlZCAmJiBub3JtYWxpemVkTGlmZSA+IDAuOTUgJiYgTWF0aC5yYW5kb20oKSA8IDAuMSkge1xuICAgICAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgOCArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSo4KTsgcysrKSB7XG4gICAgICAgICAgICBjb25zdCBzcGFya0dlbyA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeSgwLjUgKyBNYXRoLnJhbmRvbSgpKjAuNSwgOCwgOCk7XG4gICAgICAgICAgICBjb25zdCBzcGFya01hdCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7IGNvbG9yOiAweGZmZjZjMCwgdHJhbnNwYXJlbnQ6IHRydWUsIG9wYWNpdHk6IDEsIGJsZW5kaW5nOiBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nIH0pO1xuICAgICAgICAgICAgY29uc3Qgc3BhcmsgPSBuZXcgVEhSRUUuTWVzaChzcGFya0dlbywgc3BhcmtNYXQpO1xuICAgICAgICAgICAgc3BhcmsucG9zaXRpb24uY29weShvYmoubWVzaC5wb3NpdGlvbik7XG4gICAgICAgICAgICBzcGFyay5zcGFya1ZlbCA9IG5ldyBUSFJFRS5WZWN0b3IzKE1hdGgucmFuZG9tKCktMC41LCBNYXRoLnJhbmRvbSgpLTAuNSwgTWF0aC5yYW5kb20oKS0wLjUpLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKDAuNSArIE1hdGgucmFuZG9tKCkqMS4yKTtcbiAgICAgICAgICAgIHNwYXJrLnNwYXJrTGlmZSA9IDEyICsgTWF0aC5yYW5kb20oKSoxMDtcbiAgICAgICAgICAgIHNwYXJrLnNwYXJrQWdlID0gMDtcbiAgICAgICAgICAgIHNjZW5lLmFkZChzcGFyayk7XG4gICAgICAgICAgICBpZiAoIXdpbmRvdy5fc3RhclNwYXJrcykgd2luZG93Ll9zdGFyU3BhcmtzID0gW107XG4gICAgICAgICAgICB3aW5kb3cuX3N0YXJTcGFya3MucHVzaChzcGFyayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9iai5oYXNTcGFya2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGbGFzaFxuICAgICAgICBpZiAoIW9iai5oYXNGbGFzaGVkICYmIG5vcm1hbGl6ZWRMaWZlID4gMC45OCAmJiBNYXRoLnJhbmRvbSgpIDwgMC4yKSB7XG4gICAgICAgICAgY29uc3QgZmxhc2hHZW8gPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoMSwgMTYsIDE2KTtcbiAgICAgICAgICBjb25zdCBmbGFzaE1hdCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7IGNvbG9yOiAweGZmZmZlZSwgdHJhbnNwYXJlbnQ6IHRydWUsIG9wYWNpdHk6IDAuOCwgYmxlbmRpbmc6IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmcgfSk7XG4gICAgICAgICAgY29uc3QgZmxhc2ggPSBuZXcgVEhSRUUuTWVzaChmbGFzaEdlbywgZmxhc2hNYXQpO1xuICAgICAgICAgIGZsYXNoLnBvc2l0aW9uLmNvcHkob2JqLm1lc2gucG9zaXRpb24pO1xuICAgICAgICAgIHNjZW5lLmFkZChmbGFzaCk7XG4gICAgICAgICAgaWYgKCF3aW5kb3cuX3N0YXJGbGFzaGVzKSB3aW5kb3cuX3N0YXJGbGFzaGVzID0gW107XG4gICAgICAgICAgd2luZG93Ll9zdGFyRmxhc2hlcy5wdXNoKHsgbWVzaDogZmxhc2gsIGFnZTogMCB9KTtcbiAgICAgICAgICBvYmouaGFzRmxhc2hlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmFkZSBvdXQgYXMgaXQgZ2V0cyBmYXIgYXdheVxuICAgICAgICBjb25zdCBkaXN0ID0gb2JqLm1lc2gucG9zaXRpb24uZGlzdGFuY2VUbyhjYW1lcmEucG9zaXRpb24pO1xuICAgICAgICBjb25zdCBmYWRlU3RhcnQgPSBzdGFyTWF4RGlzdGFuY2UgKiAwLjU7XG4gICAgICAgIGlmIChkaXN0ID4gZmFkZVN0YXJ0KSB7XG4gICAgICAgICAgY29uc3QgZmFkZSA9IDEgLSAoZGlzdCAtIGZhZGVTdGFydCkgLyAoc3Rhck1heERpc3RhbmNlIC0gZmFkZVN0YXJ0KTtcbiAgICAgICAgICBvYmoubWVzaC5tYXRlcmlhbC5vcGFjaXR5ID0gTWF0aC5tYXgoMCwgZmFkZSk7XG4gICAgICAgICAgb2JqLm1lc2gubWF0ZXJpYWwudHJhbnNwYXJlbnQgPSB0cnVlO1xuICAgICAgICAgIG9iai50YWlsLm1hdGVyaWFsLm9wYWNpdHkgPSBNYXRoLm1heCgwLCBmYWRlICogMC44KTtcbiAgICAgICAgICBvYmoudGFpbC5tYXRlcmlhbC50cmFuc3BhcmVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHdoZW4gb3V0IG9mIGJvdW5kcyBvciBmdWxseSBmYWRlZCBvciBsaWZlIGVuZGVkXG4gICAgICAgIGlmIChub3JtYWxpemVkTGlmZSA+PSAxLjAgfHwgZGlzdCA+IHN0YXJNYXhEaXN0YW5jZSB8fCBvYmoubWVzaC5tYXRlcmlhbC5vcGFjaXR5IDw9IDAuMDEpIHtcbiAgICAgICAgICBzY2VuZS5yZW1vdmUob2JqLm1lc2gpO1xuICAgICAgICAgIHNjZW5lLnJlbW92ZShvYmoudGFpbCk7XG4gICAgICAgICAgc2hvb3RpbmdTdGFycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEFuaW1hdGUgc3BhcmtzXG4gICAgICBpZiAod2luZG93Ll9zdGFyU3BhcmtzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB3aW5kb3cuX3N0YXJTcGFya3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBjb25zdCBzcGFyayA9IHdpbmRvdy5fc3RhclNwYXJrc1tpXTtcbiAgICAgICAgICBzcGFyay5wb3NpdGlvbi5hZGQoc3Bhcmsuc3BhcmtWZWwpO1xuICAgICAgICAgIHNwYXJrLnNwYXJrQWdlKys7XG4gICAgICAgICAgc3BhcmsubWF0ZXJpYWwub3BhY2l0eSAqPSAwLjg1O1xuICAgICAgICAgIGlmIChzcGFyay5zcGFya0FnZSA+IHNwYXJrLnNwYXJrTGlmZSkge1xuICAgICAgICAgICAgc2NlbmUucmVtb3ZlKHNwYXJrKTtcbiAgICAgICAgICAgIHdpbmRvdy5fc3RhclNwYXJrcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBBbmltYXRlIGZsYXNoZXNcbiAgICAgIGlmICh3aW5kb3cuX3N0YXJGbGFzaGVzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB3aW5kb3cuX3N0YXJGbGFzaGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgY29uc3QgZmxhc2ggPSB3aW5kb3cuX3N0YXJGbGFzaGVzW2ldO1xuICAgICAgICAgIGZsYXNoLm1lc2guc2NhbGUubXVsdGlwbHlTY2FsYXIoMS4xNSk7XG4gICAgICAgICAgZmxhc2gubWVzaC5tYXRlcmlhbC5vcGFjaXR5ICo9IDAuODU7XG4gICAgICAgICAgZmxhc2guYWdlKys7XG4gICAgICAgICAgaWYgKGZsYXNoLmFnZSA+IDEwKSB7XG4gICAgICAgICAgICBzY2VuZS5yZW1vdmUoZmxhc2gubWVzaCk7XG4gICAgICAgICAgICB3aW5kb3cuX3N0YXJGbGFzaGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gLS0tIFN0YXJmaWVsZCBsb2dpYyAtLS1cbiAgICAgIGNvbnN0IHNxRGlzdCA9IHN0YXJNYXhEaXN0YW5jZSAqIHN0YXJNYXhEaXN0YW5jZTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIGNvbnN0IGR4ID0gcG9zaXRpb25zW2ldIC0gdmlydHVhbENhbWVyYVBvcy54O1xuICAgICAgICBjb25zdCBkeSA9IHBvc2l0aW9uc1tpICsgMV0gLSB2aXJ0dWFsQ2FtZXJhUG9zLnk7XG4gICAgICAgIGNvbnN0IGR6ID0gcG9zaXRpb25zW2kgKyAyXSAtIHZpcnR1YWxDYW1lcmFQb3MuejtcbiAgICAgICAgaWYgKGR4KmR4ICsgZHkqZHkgKyBkeipkeiA+IHNxRGlzdCkge1xuICAgICAgICAgIC8vIFBsYWNlIGluIGEgdGhpY2sgc3BoZXJpY2FsIHNoZWxsIGFyb3VuZCB0aGUgdmlydHVhbCBjYW1lcmEsIG5ldmVyIHRvbyBjbG9zZVxuICAgICAgICAgIGNvbnN0IG1pblJhZGl1cyA9IHN0YXJNYXhEaXN0YW5jZSAqIDAuODtcbiAgICAgICAgICBjb25zdCBtYXhSYWRpdXMgPSBzdGFyTWF4RGlzdGFuY2U7XG4gICAgICAgICAgY29uc3QgciA9IG1pblJhZGl1cyArIE1hdGgucmFuZG9tKCkgKiAobWF4UmFkaXVzIC0gbWluUmFkaXVzKTtcbiAgICAgICAgICBjb25zdCB0aGV0YSA9IE1hdGgucmFuZG9tKCkgKiAyICogTWF0aC5QSTtcbiAgICAgICAgICBjb25zdCBwaGkgPSBNYXRoLmFjb3MoMiAqIE1hdGgucmFuZG9tKCkgLSAxKTtcbiAgICAgICAgICBwb3NpdGlvbnNbaV0gPSB2aXJ0dWFsQ2FtZXJhUG9zLnggKyByICogTWF0aC5zaW4ocGhpKSAqIE1hdGguY29zKHRoZXRhKTtcbiAgICAgICAgICBwb3NpdGlvbnNbaSsxXSA9IHZpcnR1YWxDYW1lcmFQb3MueSArIHIgKiBNYXRoLnNpbihwaGkpICogTWF0aC5zaW4odGhldGEpO1xuICAgICAgICAgIHBvc2l0aW9uc1tpKzJdID0gdmlydHVhbENhbWVyYVBvcy56ICsgciAqIE1hdGguY29zKHBoaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlOyAvLyBBbHJlYWR5IHNldCBhYm92ZVxuXG4gICAgICAvLyBSb2J1c3Qgc3RhcmZpZWxkIGNvbG9yIHVwZGF0ZSB0byBwcmV2ZW50IHN0dWNrIHdoaXRlIGRvdHNcbiAgICAgIGNvbnN0IGNvbEFyciA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3IuYXJyYXk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc2l0aW9ucy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICBjb25zdCBpZHggPSBpIC8gMztcbiAgICAgICAgY29uc3QgZHggPSBwb3NpdGlvbnNbaV0gLSB2aXJ0dWFsQ2FtZXJhUG9zLng7XG4gICAgICAgIGNvbnN0IGR5ID0gcG9zaXRpb25zW2kgKyAxXSAtIHZpcnR1YWxDYW1lcmFQb3MueTtcbiAgICAgICAgY29uc3QgZHogPSBwb3NpdGlvbnNbaSArIDJdIC0gdmlydHVhbENhbWVyYVBvcy56O1xuICAgICAgICBjb25zdCBkaXN0ID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkeik7XG4gICAgICAgIGlmICh0aW1lcnNbaWR4XSA+IDApIHtcbiAgICAgICAgICB0aW1lcnNbaWR4XS0tO1xuICAgICAgICAgIGlmICh0aW1lcnNbaWR4XSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gVGltZXIgZXhwaXJlZCwgcmVzdG9yZSBjb2xvclxuICAgICAgICAgICAgc3BhcmtDb2xvcnNbaV0gPSBvcmlnaW5hbENvbG9yc1tpXTtcbiAgICAgICAgICAgIHNwYXJrQ29sb3JzW2krMV0gPSBvcmlnaW5hbENvbG9yc1tpKzFdO1xuICAgICAgICAgICAgc3BhcmtDb2xvcnNbaSsyXSA9IG9yaWdpbmFsQ29sb3JzW2krMl07XG4gICAgICAgICAgICBjb2xBcnJbaV0gPSBvcmlnaW5hbENvbG9yc1tpXTtcbiAgICAgICAgICAgIGNvbEFycltpKzFdID0gb3JpZ2luYWxDb2xvcnNbaSsxXTtcbiAgICAgICAgICAgIGNvbEFycltpKzJdID0gb3JpZ2luYWxDb2xvcnNbaSsyXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29sQXJyW2ldID0gc3BhcmtDb2xvcnNbaV07XG4gICAgICAgICAgICBjb2xBcnJbaSsxXSA9IHNwYXJrQ29sb3JzW2krMV07XG4gICAgICAgICAgICBjb2xBcnJbaSsyXSA9IHNwYXJrQ29sb3JzW2krMl07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRpc3QgPiBzdGFyTWF4RGlzdGFuY2UgKiAwLjMgJiYgTWF0aC5yYW5kb20oKSA8IDAuMDUpIHtcbiAgICAgICAgICB0aW1lcnNbaWR4XSA9IHNwYXJrbGVEdXJhdGlvbjtcbiAgICAgICAgICBjb25zdCBjID0gcGFsZXR0ZVtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBwYWxldHRlLmxlbmd0aCldO1xuICAgICAgICAgIHNwYXJrQ29sb3JzW2ldID0gY1swXTtcbiAgICAgICAgICBzcGFya0NvbG9yc1tpKzFdID0gY1sxXTtcbiAgICAgICAgICBzcGFya0NvbG9yc1tpKzJdID0gY1syXTtcbiAgICAgICAgICBjb2xBcnJbaV0gPSBzcGFya0NvbG9yc1tpXTtcbiAgICAgICAgICBjb2xBcnJbaSsxXSA9IHNwYXJrQ29sb3JzW2krMV07XG4gICAgICAgICAgY29sQXJyW2krMl0gPSBzcGFya0NvbG9yc1tpKzJdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNwYXJrQ29sb3JzW2ldID0gb3JpZ2luYWxDb2xvcnNbaV07XG4gICAgICAgICAgc3BhcmtDb2xvcnNbaSsxXSA9IG9yaWdpbmFsQ29sb3JzW2krMV07XG4gICAgICAgICAgc3BhcmtDb2xvcnNbaSsyXSA9IG9yaWdpbmFsQ29sb3JzW2krMl07XG4gICAgICAgICAgY29sQXJyW2ldID0gb3JpZ2luYWxDb2xvcnNbaV07XG4gICAgICAgICAgY29sQXJyW2krMV0gPSBvcmlnaW5hbENvbG9yc1tpKzFdO1xuICAgICAgICAgIGNvbEFycltpKzJdID0gb3JpZ2luYWxDb2xvcnNbaSsyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvci5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhKTtcbiAgICB9XG4gICAgXG4gICAgYW5pbWF0ZSgpOyAvLyBTdGFydCB0aGUgcmVuZGVyIGxvb3BcblxuICAgIGNvbnN0IG9uUmVzaXplID0gKCkgPT4ge1xuICAgICAgY2FtZXJhLmFzcGVjdCA9IHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAgIHJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25SZXNpemUpXG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIG9uU2Nyb2xsKVxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uUmVzaXplKVxuICAgICAgbW91bnQucmVtb3ZlQ2hpbGQocmVuZGVyZXIuZG9tRWxlbWVudClcbiAgICB9XG4gIH0sIFtdKVxuXG4gIHJldHVybiA8ZGl2IHJlZj17bW91bnRSZWZ9IC8+XG59XG5cbmV4cG9ydCBkZWZhdWx0IFN0YXJmaWVsZFxuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlRWZmZWN0IiwidXNlUmVmIiwiVEhSRUUiLCJTdGFyZmllbGQiLCJtb3VudFJlZiIsIm1vdW50IiwiY3VycmVudCIsInN0eWxlIiwicG9zaXRpb24iLCJ0b3AiLCJsZWZ0Iiwid2lkdGgiLCJoZWlnaHQiLCJ6SW5kZXgiLCJzY2VuZSIsIlNjZW5lIiwiY2FtZXJhIiwiUGVyc3BlY3RpdmVDYW1lcmEiLCJ3aW5kb3ciLCJpbm5lcldpZHRoIiwiaW5uZXJIZWlnaHQiLCJzZXQiLCJ2aXJ0dWFsQ2FtZXJhUG9zIiwiVmVjdG9yMyIsInJlbmRlcmVyIiwiV2ViR0xSZW5kZXJlciIsImFudGlhbGlhcyIsInNldFBpeGVsUmF0aW8iLCJkZXZpY2VQaXhlbFJhdGlvIiwic2V0U2l6ZSIsInNldENsZWFyQ29sb3IiLCJhcHBlbmRDaGlsZCIsImRvbUVsZW1lbnQiLCJzdGFyQ291bnQiLCJzdGFyTWF4RGlzdGFuY2UiLCJzdGFyU3BlZWQiLCJnZW9tZXRyeSIsIkJ1ZmZlckdlb21ldHJ5IiwicG9zaXRpb25zIiwiaSIsInRoZXRhIiwiTWF0aCIsInJhbmRvbSIsIlBJIiwicGhpIiwiYWNvcyIsInIiLCJwdXNoIiwic2luIiwiY29zIiwic2V0QXR0cmlidXRlIiwiRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSIsInBhbGV0dGUiLCJjb2xvcnMiLCJjIiwiZmxvb3IiLCJsZW5ndGgiLCJvcmlnaW5hbENvbG9ycyIsImF0dHJpYnV0ZXMiLCJjb2xvciIsImFycmF5Iiwic2xpY2UiLCJ0aW1lcnMiLCJGbG9hdDMyQXJyYXkiLCJzcGFya0NvbG9ycyIsInNwYXJrbGVEdXJhdGlvbiIsIm1hdGVyaWFsIiwiUG9pbnRzTWF0ZXJpYWwiLCJzaXplIiwic2l6ZUF0dGVudWF0aW9uIiwidmVydGV4Q29sb3JzIiwic3RhcnMiLCJQb2ludHMiLCJhZGQiLCJ0YXJnZXRZIiwiZGFtcGluZyIsIm9uU2Nyb2xsIiwicGN0Iiwic2Nyb2xsWSIsImRvY3VtZW50IiwiYm9keSIsInNjcm9sbEhlaWdodCIsImFkZEV2ZW50TGlzdGVuZXIiLCJ0YWlsTGVuZ3RoIiwic2hvb3RpbmdTdGFycyIsInNob290aW5nU3RhckNvb2xkb3duIiwic3Bhd25TaG9vdGluZ1N0YXIiLCJkaXIiLCJub3JtYWxpemUiLCJtaW5EaXN0IiwibWF4RGlzdCIsImRpc3QiLCJzcGF3blBvcyIsImNsb25lIiwibXVsdGlwbHlTY2FsYXIiLCJ0YW5nZW50Iiwic3ViIiwicHJvamVjdE9uVmVjdG9yIiwidGFuZ2VudGlhbFNwZWVkIiwicmFkaWFsU3BlZWQiLCJ2ZWxvY2l0eSIsImJyaWdodG5lc3MiLCJnZW8iLCJTcGhlcmVHZW9tZXRyeSIsIm1hdCIsIk1lc2hCYXNpY01hdGVyaWFsIiwib3BhY2l0eSIsImJhc2VPcGFjaXR5IiwidHJhbnNwYXJlbnQiLCJzdGFyIiwiTWVzaCIsImNvcHkiLCJub3JtYWxpemVkTGlmZSIsIm5vcm1hbGl6ZWRMaWZldGltZSIsImFnZSIsInRyYWlsU2VnbWVudHMiLCJ0cmFpbFBvaW50cyIsInRhaWxHZW8iLCJzZXRGcm9tUG9pbnRzIiwidGFpbENvbG9ycyIsImFscGhhIiwiZ3JhZGllbnRDb2xvciIsInRhaWxNYXQiLCJMaW5lQmFzaWNNYXRlcmlhbCIsImJsZW5kaW5nIiwiQWRkaXRpdmVCbGVuZGluZyIsInRhaWwiLCJMaW5lIiwibWVzaCIsImhhc0ZyYWdtZW50ZWQiLCJhbmltYXRlIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwicm90YXRpb24iLCJ5IiwiZm9yd2FyZCIsImdldFdvcmxkRGlyZWN0aW9uIiwieCIsInoiLCJuZWVkc1VwZGF0ZSIsIm9iaiIsInBlcnAiLCJ0IiwibGVycCIsInRhaWxHcm93IiwibWluIiwiYWN0aXZlU2VnbWVudHMiLCJ2aXNpYmxlVHJhaWwiLCJnZXRBdHRyaWJ1dGUiLCJqIiwiRGF0ZSIsIm5vdyIsInJhaW5ib3ciLCJncmFkQ29sb3IiLCJtYXgiLCJzZXRYWVpXIiwiaGVhZENvbG9yIiwiQ29sb3IiLCJmbGlja2VyIiwic2NhbGUiLCJkaXN0VG9DYW0iLCJkb2ZCbHVyIiwicyIsInNwYXJrbGVHZW8iLCJzcGFya2xlTWF0Iiwic3BhcmtsZSIsInNwYXJrbGVWZWwiLCJ1c2VyRGF0YSIsIl9zcGFya2xlcyIsImZyYWdWZWwiLCJhcHBseUF4aXNBbmdsZSIsImZyYWdTdGFyIiwiZnJhZ1RyYWlsUG9pbnRzIiwiZnJhZ1RhaWxHZW8iLCJmcmFnVGFpbE1hdCIsImZyYWdUYWlsIiwiaGFzU3BhcmtlZCIsInNwYXJrR2VvIiwic3BhcmtNYXQiLCJzcGFyayIsInNwYXJrVmVsIiwic3BhcmtMaWZlIiwic3BhcmtBZ2UiLCJfc3RhclNwYXJrcyIsImhhc0ZsYXNoZWQiLCJmbGFzaEdlbyIsImZsYXNoTWF0IiwiZmxhc2giLCJfc3RhckZsYXNoZXMiLCJkaXN0YW5jZVRvIiwiZmFkZVN0YXJ0IiwiZmFkZSIsInJlbW92ZSIsInNwbGljZSIsInNxRGlzdCIsImR4IiwiZHkiLCJkeiIsIm1pblJhZGl1cyIsIm1heFJhZGl1cyIsImNvbEFyciIsImlkeCIsInNxcnQiLCJyZW5kZXIiLCJvblJlc2l6ZSIsImFzcGVjdCIsInVwZGF0ZVByb2plY3Rpb25NYXRyaXgiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVtb3ZlQ2hpbGQiLCJkaXYiLCJyZWYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/Starfield.jsx\n"));

/***/ })

});