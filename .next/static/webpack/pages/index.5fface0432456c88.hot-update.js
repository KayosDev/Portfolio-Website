"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./components/Starfield.jsx":
/*!**********************************!*\
  !*** ./components/Starfield.jsx ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var three_examples_jsm_postprocessing_EffectComposer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three/examples/jsm/postprocessing/EffectComposer */ \"./node_modules/three/examples/jsm/postprocessing/EffectComposer.js\");\n/* harmony import */ var three_examples_jsm_postprocessing_UnrealBloomPass__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three/examples/jsm/postprocessing/UnrealBloomPass */ \"./node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js\");\n/* harmony import */ var three_examples_jsm_postprocessing_RenderPass__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three/examples/jsm/postprocessing/RenderPass */ \"./node_modules/three/examples/jsm/postprocessing/RenderPass.js\");\n/* harmony import */ var _ChromaticAberrationPass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ChromaticAberrationPass */ \"./components/ChromaticAberrationPass.js\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\nconst Starfield = ()=>{\n    _s();\n    const mountRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // Defensive: always use .current for refs\n        if (!mountRef.current) return;\n        const mount = mountRef.current;\n        mount.style.position = \"fixed\";\n        mount.style.top = \"0\";\n        mount.style.left = \"0\";\n        mount.style.width = \"100%\";\n        mount.style.height = \"100%\";\n        mount.style.zIndex = \"0\";\n        // Scene & Renderer\n        const scene = new three__WEBPACK_IMPORTED_MODULE_3__.Scene();\n        const camera = new three__WEBPACK_IMPORTED_MODULE_3__.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);\n        camera.position.set(0, 0, 0);\n        // Virtual position to simulate infinite travel\n        let virtualCameraPos = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(0, 0, 0);\n        const renderer = new three__WEBPACK_IMPORTED_MODULE_3__.WebGLRenderer({\n            antialias: true\n        });\n        renderer.setPixelRatio(window.devicePixelRatio);\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        renderer.setClearColor(0x000000, 1);\n        mount.appendChild(renderer.domElement);\n        // --- POSTPROCESSING ---\n        // Composer\n        const composer = new three_examples_jsm_postprocessing_EffectComposer__WEBPACK_IMPORTED_MODULE_4__.EffectComposer(renderer);\n        composer.setSize(window.innerWidth, window.innerHeight);\n        // Render pass\n        const renderPass = new three_examples_jsm_postprocessing_RenderPass__WEBPACK_IMPORTED_MODULE_5__.RenderPass(scene, camera);\n        composer.addPass(renderPass);\n        // Unreal Bloom Pass\n        // --- BLOOM (MAX) ---\n        const bloomPass = new three_examples_jsm_postprocessing_UnrealBloomPass__WEBPACK_IMPORTED_MODULE_6__.UnrealBloomPass(new three__WEBPACK_IMPORTED_MODULE_3__.Vector2(window.innerWidth, window.innerHeight), 2.5, 1.2, 0.12 // threshold (lower = more)\n        );\n        composer.addPass(bloomPass);\n        // --- CLOSE STARS: Separate Scene for Chromatic Aberration ---\n        const closeStarsScene = new three__WEBPACK_IMPORTED_MODULE_3__.Scene();\n        const caPass = new _ChromaticAberrationPass__WEBPACK_IMPORTED_MODULE_2__.ChromaticAberrationPass(new three__WEBPACK_IMPORTED_MODULE_3__.Vector2(0.0002, 0.0002)); // barely visible\n        const caComposer = new three_examples_jsm_postprocessing_EffectComposer__WEBPACK_IMPORTED_MODULE_4__.EffectComposer(renderer);\n        caComposer.setSize(window.innerWidth, window.innerHeight);\n        const caRenderPass = new three_examples_jsm_postprocessing_RenderPass__WEBPACK_IMPORTED_MODULE_5__.RenderPass(closeStarsScene, camera);\n        caComposer.addPass(caRenderPass);\n        caComposer.addPass(caPass);\n        // --- HANDLE RESIZE AND FULLSCREEN ---\n        function resizeAll() {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n            composer.setSize(window.innerWidth, window.innerHeight);\n            caComposer.setSize(window.innerWidth, window.innerHeight);\n        }\n        window.addEventListener(\"resize\", resizeAll);\n        window.addEventListener(\"fullscreenchange\", resizeAll);\n        // Starfield\n        const starCount = 500;\n        const starMaxDistance = 2000;\n        const starSpeed = 1;\n        const geometry = new three__WEBPACK_IMPORTED_MODULE_3__.BufferGeometry();\n        const closeGeometry = new three__WEBPACK_IMPORTED_MODULE_3__.BufferGeometry();\n        const positions = [];\n        const closePositions = [];\n        let starsPlaced = 0;\n        while(starsPlaced < starCount){\n            // With 1% chance, spawn a star cluster (10-30 stars)\n            if (Math.random() < 0.01 && starsPlaced < starCount - 10) {\n                const clusterTheta = Math.random() * 2 * Math.PI;\n                const clusterPhi = Math.acos(2 * Math.random() - 1);\n                const clusterR = Math.random() * starMaxDistance;\n                const clusterCenter = [\n                    clusterR * Math.sin(clusterPhi) * Math.cos(clusterTheta),\n                    clusterR * Math.sin(clusterPhi) * Math.sin(clusterTheta),\n                    clusterR * Math.cos(clusterPhi)\n                ];\n                const clusterSize = 10 + Math.floor(Math.random() * 20); // 10-30 stars\n                for(let c = 0; c < clusterSize && starsPlaced < starCount; c++){\n                    // Each star in cluster is within 30 units of center\n                    const offsetTheta = Math.random() * 2 * Math.PI;\n                    const offsetPhi = Math.acos(2 * Math.random() - 1);\n                    const offsetR = Math.random() * 30; // cluster radius\n                    positions.push(clusterCenter[0] + offsetR * Math.sin(offsetPhi) * Math.cos(offsetTheta), clusterCenter[1] + offsetR * Math.sin(offsetPhi) * Math.sin(offsetTheta), clusterCenter[2] + offsetR * Math.cos(offsetPhi));\n                    starsPlaced++;\n                }\n            } else {\n                // Normal single star\n                const theta = Math.random() * 2 * Math.PI;\n                const phi = Math.acos(2 * Math.random() - 1);\n                const r = Math.random() * starMaxDistance;\n                const x = r * Math.sin(phi) * Math.cos(theta);\n                const y = r * Math.sin(phi) * Math.sin(theta);\n                const z = r * Math.cos(phi);\n                positions.push(x, y, z);\n                // If close, also add to closePositions\n                if (r < 400) {\n                    closePositions.push(x, y, z);\n                }\n                starsPlaced++;\n            }\n        }\n        geometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_3__.Float32BufferAttribute(positions, 3));\n        if (closePositions.length > 0) {\n            closeGeometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_3__.Float32BufferAttribute(closePositions, 3));\n        }\n        // CRAZY BLOOM: All stars are extremely bright (color intensity >1)\n        const palette = [\n            [\n                3.0,\n                1.5,\n                1.5\n            ],\n            [\n                3.0,\n                2.25,\n                1.2\n            ],\n            [\n                3.0,\n                3.0,\n                2.7\n            ],\n            [\n                3.0,\n                3.0,\n                3.0\n            ],\n            [\n                1.2,\n                1.5,\n                3.0\n            ]\n        ];\n        const colors = [];\n        for(let i = 0; i < starCount; i++){\n            const c = palette[Math.floor(Math.random() * palette.length)];\n            colors.push(...c);\n        }\n        geometry.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_3__.Float32BufferAttribute(colors, 3));\n        const originalColors = geometry.attributes.color.array.slice();\n        const timers = new Float32Array(starCount);\n        const sparkColors = new Float32Array(starCount * 3);\n        const sparkleDuration = 180;\n        // --- SQUARE STARS USING POINTS ---\n        const material = new three__WEBPACK_IMPORTED_MODULE_3__.PointsMaterial({\n            size: 3.5,\n            sizeAttenuation: true,\n            vertexColors: true\n        });\n        const stars = new three__WEBPACK_IMPORTED_MODULE_3__.Points(geometry, material);\n        scene.add(stars);\n        // Add glow sprites to each star and animate them based on distance\n        const glowMap = new three__WEBPACK_IMPORTED_MODULE_3__.TextureLoader().load(\"https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/sprites/glow.png\");\n        const glowSprites = [];\n        const glowMaterial = new three__WEBPACK_IMPORTED_MODULE_3__.SpriteMaterial({\n            map: glowMap,\n            color: 0xffffff,\n            opacity: 0.18,\n            blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending,\n            depthWrite: false\n        });\n        for(let i = 0; i < starCount; i++){\n            const glow = new three__WEBPACK_IMPORTED_MODULE_3__.Sprite(glowMaterial.clone());\n            glow.position.set(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2]);\n            glow.scale.set(10, 10, 1);\n            scene.add(glow);\n            glowSprites.push(glow);\n        }\n        // Add close stars to separate scene\n        let closeStars;\n        if (closePositions.length > 0) {\n            closeStars = new three__WEBPACK_IMPORTED_MODULE_3__.Points(closeGeometry, material.clone());\n            closeStarsScene.add(closeStars);\n        }\n        let targetY = 0;\n        const damping = 0.05;\n        const onScroll = ()=>{\n            const pct = window.scrollY / (document.body.scrollHeight - window.innerHeight);\n            targetY = pct * Math.PI * 2;\n        };\n        window.addEventListener(\"scroll\", onScroll);\n        // --- Shooting Stars ---\n        const tailLength = 32; // Increase for longer tails\n        const shootingStars = [];\n        let shootingStarCooldown = 0;\n        // Spawn a shooting star with a stunning glowing tail\n        function spawnShootingStar() {\n            // Pick a random direction on the sphere for the spawn location\n            const dir = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();\n            // Ensure shooting stars never spawn close to the camera (at least 70% of max distance)\n            const minDist = starMaxDistance * 0.7;\n            const maxDist = starMaxDistance * 1.0;\n            const dist = minDist + Math.random() * (maxDist - minDist);\n            const spawnPos = dir.clone().multiplyScalar(dist);\n            // Tangential velocity: perpendicular to dir\n            let tangent = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1);\n            tangent = tangent.sub(tangent.clone().projectOnVector(dir)).normalize();\n            // Mix in a small radial component (inward or outward)\n            const tangentialSpeed = starSpeed * (2.5 + Math.random() * 2.5); // much faster\n            const radialSpeed = starSpeed * (Math.random() - 0.5) * 0.3; // more dramatic\n            const velocity = tangent.multiplyScalar(tangentialSpeed).add(dir.clone().multiplyScalar(radialSpeed));\n            // Stunning color gradient for the head\n            const vibrantColors = [\n                0xffe066,\n                0xff66cc,\n                0x66ccff,\n                0xffffff,\n                0x80ffea,\n                0xfff2cc,\n                0xffc080,\n                0x80c0ff,\n                0xff80b3\n            ];\n            const color = vibrantColors[Math.floor(Math.random() * vibrantColors.length)];\n            // Star brightness and size (always small and subtle)\n            const brightness = 2.5 + Math.random() * 1.5;\n            const geo = new three__WEBPACK_IMPORTED_MODULE_3__.SphereGeometry(0.7 + Math.random() * 0.5, 16, 16); // Small sphere\n            const mat = new three__WEBPACK_IMPORTED_MODULE_3__.MeshPhysicalMaterial({\n                color: color,\n                emissive: color,\n                emissiveIntensity: 2.5,\n                metalness: 0.7,\n                roughness: 0.3,\n                transmission: 0.7,\n                opacity: 0.98,\n                transparent: true,\n                clearcoat: 0.8,\n                clearcoatRoughness: 0.2\n            });\n            const star = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(geo, mat);\n            // Add a glowing sprite for extra glow\n            const spriteMap = new three__WEBPACK_IMPORTED_MODULE_3__.TextureLoader().load(\"https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/sprites/glow.png\");\n            const spriteMaterial = new three__WEBPACK_IMPORTED_MODULE_3__.SpriteMaterial({\n                map: spriteMap,\n                color: color,\n                opacity: 0.8,\n                blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n            });\n            const sprite = new three__WEBPACK_IMPORTED_MODULE_3__.Sprite(spriteMaterial);\n            sprite.scale.set(30, 30, 1);\n            sprite.position.copy(star.position);\n            star.add(sprite);\n            // Add dynamic spark burst at the head\n            const sparkCount = 18 + Math.floor(Math.random() * 8);\n            const sparkGroup = new three__WEBPACK_IMPORTED_MODULE_3__.Group();\n            for(let i = 0; i < sparkCount; i++){\n                const sparkMat = new three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial({\n                    color: vibrantColors[Math.floor(Math.random() * vibrantColors.length)],\n                    transparent: true,\n                    opacity: 0.8\n                });\n                const sparkGeo = new three__WEBPACK_IMPORTED_MODULE_3__.SphereGeometry(0.07 + Math.random() * 0.06, 8, 8);\n                const spark = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(sparkGeo, sparkMat);\n                const angle = i / sparkCount * Math.PI * 2;\n                spark.position.set(Math.cos(angle) * 1.2, Math.sin(angle) * 1.2, Math.random() * 0.4 - 0.2);\n                sparkGroup.add(spark);\n            }\n            sparkGroup.name = \"sparkBurst\";\n            star.add(sparkGroup);\n            star.position.copy(spawnPos);\n            star.velocity = velocity;\n            star.normalizedLife = 0.0;\n            star.normalizedLifetime = 80 + Math.random() * 80; // Longer, more dramatic\n            star.age = 0;\n            // --- Stunning Meteor Tail (very long, multi-color, glowing, fading, and 3D curve) ---\n            const trailSegments = tailLength * 3; // Even longer tail\n            const trailPoints = [];\n            for(let i = 0; i < trailSegments; i++){\n                // Add a 3D spiral/curve for more depth\n                const spiral = Math.sin(i * 0.25) * 8;\n                const curve = Math.cos(i * 0.15) * 4;\n                const pt = star.position.clone().add(new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(spiral, curve, -i * 3));\n                trailPoints.push(pt);\n            }\n            const tailGeo = new three__WEBPACK_IMPORTED_MODULE_3__.BufferGeometry().setFromPoints(trailPoints);\n            // Per-vertex color (multi-color rainbow gradient)\n            const tailColors = [];\n            for(let i = 0; i < trailSegments; i++){\n                // Alpha fades out along the tail\n                const alpha = (1 - i / (trailSegments - 1)) * 0.99;\n                // Rainbow gradient\n                const rainbow = [\n                    0xffe066,\n                    0xff66cc,\n                    0x66ccff,\n                    0xffffff,\n                    0x80ffea,\n                    0xfff2cc,\n                    0xffc080,\n                    0x80c0ff,\n                    0xff80b3\n                ];\n                const gradColor = rainbow[Math.floor(i / trailSegments * rainbow.length)];\n                tailColors.push((gradColor >> 16 & 255) / 255, (gradColor >> 8 & 255) / 255, (gradColor & 255) / 255, alpha);\n            }\n            tailGeo.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_3__.Float32BufferAttribute(tailColors, 4));\n            // Additive blending for glow + BLOOMED TAIL\n            const tailMat = new three__WEBPACK_IMPORTED_MODULE_3__.LineBasicMaterial({\n                vertexColors: true,\n                transparent: true,\n                opacity: 1.0,\n                blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n            });\n            const tail = new three__WEBPACK_IMPORTED_MODULE_3__.Line(tailGeo, tailMat);\n            tail.position.copy(star.position);\n            // Add a bloom sprite to the tail's head for extra glow\n            const tailGlowMap = new three__WEBPACK_IMPORTED_MODULE_3__.TextureLoader().load(\"https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/sprites/glow.png\");\n            const tailGlowMat = new three__WEBPACK_IMPORTED_MODULE_3__.SpriteMaterial({\n                map: tailGlowMap,\n                color: color,\n                opacity: 0.85,\n                blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n            });\n            const tailGlow = new three__WEBPACK_IMPORTED_MODULE_3__.Sprite(tailGlowMat);\n            tailGlow.scale.set(22, 22, 1);\n            tailGlow.position.copy(star.position);\n            star.add(tailGlow); // Attach to star so it follows head\n            // Add to scene\n            scene.add(star);\n            scene.add(tail);\n            shootingStars.push({\n                mesh: star,\n                tail,\n                velocity: star.velocity,\n                dir,\n                age: 0,\n                normalizedLifetime: star.normalizedLifetime,\n                trailPoints,\n                color,\n                brightness,\n                hasFragmented: false\n            });\n        }\n        const animate = ()=>{\n            try {\n                requestAnimationFrame(animate);\n                // Render main scene with bloom\n                composer.render();\n                // Overlay close stars with chromatic aberration (only close stars get CA)\n                if (closeStars) {\n                    caComposer.render();\n                }\n                camera.rotation.y += (targetY - camera.rotation.y) * damping;\n                // Move the virtual camera position in the direction the camera is facing\n                const forward = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();\n                camera.getWorldDirection(forward);\n                virtualCameraPos.add(forward.multiplyScalar(starSpeed));\n                // Offset all stars by -virtualCameraPos (floating origin)\n                for(let i = 0; i < positions.length; i += 3){\n                    geometry.attributes.position.array[i] = positions[i] - virtualCameraPos.x;\n                    geometry.attributes.position.array[i + 1] = positions[i + 1] - virtualCameraPos.y;\n                    geometry.attributes.position.array[i + 2] = positions[i + 2] - virtualCameraPos.z;\n                    // Animate glow sprite for distant/close effect\n                    const glow = glowSprites[i / 3];\n                    const starPos = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(positions[i] - virtualCameraPos.x, positions[i + 1] - virtualCameraPos.y, positions[i + 2] - virtualCameraPos.z);\n                    const dist = starPos.length();\n                    // If close, reduce/hide glow, if far, make glow big and bright\n                    if (dist < 400) {\n                        glow.material.opacity = 0.06 + 0.08 * Math.random(); // subtle flicker\n                        glow.scale.set(7, 7, 1);\n                    } else if (dist > 1200) {\n                        glow.material.opacity = 0.38 + 0.18 * Math.random(); // intense\n                        glow.scale.set(32, 32, 1);\n                    } else {\n                        // interpolate\n                        const t = (dist - 400) / (1200 - 400);\n                        glow.material.opacity = 0.08 + 0.3 * t + 0.08 * Math.random();\n                        const s = 7 + (32 - 7) * t;\n                        glow.scale.set(s, s, 1);\n                    }\n                    glow.position.copy(starPos);\n                }\n                if (closeStars && closeGeometry && closePositions.length > 0) {\n                    for(let i = 0; i < closePositions.length; i += 3){\n                        closeGeometry.attributes.position.array[i] = closePositions[i] - virtualCameraPos.x;\n                        closeGeometry.attributes.position.array[i + 1] = closePositions[i + 1] - virtualCameraPos.y;\n                        closeGeometry.attributes.position.array[i + 2] = closePositions[i + 2] - virtualCameraPos.z;\n                    }\n                    closeGeometry.attributes.position.needsUpdate = true;\n                }\n                geometry.attributes.position.needsUpdate = true;\n                // --- Shooting star spawning ---\n                if (shootingStarCooldown <= 0 && Math.random() < 0.1) {\n                    spawnShootingStar();\n                    if (camera) {\n                        const shakeStrength = 0.06 + Math.random() * 0.04;\n                        camera.position.x += (Math.random() - 0.5) * shakeStrength;\n                        camera.position.y += (Math.random() - 0.5) * shakeStrength;\n                    }\n                    shootingStarCooldown = 10 + Math.random() * 10;\n                } else if (shootingStarCooldown > 0) {\n                    shootingStarCooldown--;\n                }\n                // Animate and clean up shooting stars\n                for(let i = shootingStars.length - 1; i >= 0; i--){\n                    const obj = shootingStars[i];\n                    // Animate spark burst (fade and expand)\n                    if (obj.mesh.children) {\n                        const sparks = obj.mesh.children.find((child)=>child.name === \"sparkBurst\");\n                        if (sparks) {\n                            for(let j = 0; j < sparks.children.length; j++){\n                                const spark = sparks.children[j];\n                                spark.material.opacity *= 0.96; // Fade\n                                spark.scale.multiplyScalar(1.03); // Expand\n                            }\n                        }\n                    }\n                    // Animate tail shimmer and color cycling\n                    if (obj.tail && obj.trailPoints) {\n                        const time = performance.now() * 0.001;\n                        const tailGeo = obj.tail.geometry;\n                        const tailColors = tailGeo.getAttribute(\"color\");\n                        for(let k = 0; k < tailColors.count; k++){\n                            // Cycle hue\n                            let r = tailColors.getX(k), g = tailColors.getY(k), b = tailColors.getZ(k);\n                            // Convert to HSL\n                            const max = Math.max(r, g, b), min = Math.min(r, g, b);\n                            let h, s, l;\n                            l = (max + min) / 2;\n                            if (max === min) {\n                                h = s = 0;\n                            } else {\n                                const d = max - min;\n                                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n                                switch(max){\n                                    case r:\n                                        h = (g - b) / d + (g < b ? 6 : 0);\n                                        break;\n                                    case g:\n                                        h = (b - r) / d + 2;\n                                        break;\n                                    case b:\n                                        h = (r - g) / d + 4;\n                                        break;\n                                }\n                                h /= 6;\n                            }\n                            h = (h + 0.25 * Math.sin(time + k * 0.2)) % 1.0; // Animate hue\n                            // Convert back to RGB\n                            let q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n                            let p = 2 * l - q;\n                            let tr = h + 1 / 3, tg = h, tb = h - 1 / 3;\n                            const hue2rgb = (p, q, t)=>{\n                                if (t < 0) t += 1;\n                                if (t > 1) t -= 1;\n                                if (t < 1 / 6) return p + (q - p) * 6 * t;\n                                if (t < 1 / 2) return q;\n                                if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n                                return p;\n                            };\n                            tailColors.setX(k, hue2rgb(p, q, tr));\n                            tailColors.setY(k, hue2rgb(p, q, tg));\n                            tailColors.setZ(k, hue2rgb(p, q, tb));\n                            // Shimmer: modulate alpha\n                            tailColors.setW(k, tailColors.getW(k) * (0.97 + 0.03 * Math.sin(time * 8 + k)));\n                        }\n                        tailColors.needsUpdate = true;\n                    }\n                    // Straight-line trajectory\n                    obj.mesh.position.add(obj.velocity);\n                    obj.tail.position.copy(obj.mesh.position);\n                    // Animate tail (no lerp, just drag)\n                    obj.age++;\n                    const normalizedLife = obj.age / obj.normalizedLifetime;\n                    obj.trailPoints.unshift(obj.mesh.position.clone());\n                    if (obj.trailPoints.length > tailLength * 3) obj.trailPoints.pop();\n                    let tailGrow = Math.min(1, normalizedLife / 0.3);\n                    let activeSegments = Math.floor(obj.trailPoints.length * tailGrow);\n                    if (activeSegments < 2) activeSegments = 2;\n                    const visibleTrail = obj.trailPoints.slice(0, activeSegments);\n                    obj.tail.geometry.setFromPoints(visibleTrail);\n                    const tailColors = obj.tail.geometry.getAttribute(\"color\");\n                    for(let j = 0; j < visibleTrail.length; j++){\n                        let alpha = (1 - j / (visibleTrail.length - 1)) * 0.95;\n                        alpha *= 0.92 + 0.08 * Math.sin(Date.now() * 0.015 + j * 0.5);\n                        let rainbow = [\n                            0xffc080,\n                            0xffe080,\n                            0xffff80,\n                            0x80ffe6,\n                            0x80c0ff,\n                            0xc080ff\n                        ];\n                        let gradColor = rainbow[j % rainbow.length];\n                        if (normalizedLife > 0.7) alpha *= Math.max(0, 1 - (normalizedLife - 0.7 - 0.2) / 0.3);\n                        tailColors.setXYZW(j, (gradColor >> 16 & 255) / 255, (gradColor >> 8 & 255) / 255, (gradColor & 255) / 255, alpha);\n                    }\n                    tailColors.needsUpdate = true;\n                    // Animate head\n                    let headColor;\n                    if (normalizedLife < 0.5) {\n                        headColor = new three__WEBPACK_IMPORTED_MODULE_3__.Color(obj.color).lerp(new three__WEBPACK_IMPORTED_MODULE_3__.Color(0xffc080), normalizedLife * 2);\n                    } else {\n                        headColor = new three__WEBPACK_IMPORTED_MODULE_3__.Color(0xffc080).lerp(new three__WEBPACK_IMPORTED_MODULE_3__.Color(0xff4000), (normalizedLife - 0.5) * 2);\n                    }\n                    let flicker = 0.95 + 0.13 * Math.sin(Date.now() * 0.07 + Math.random() * 10);\n                    headColor.multiplyScalar(flicker);\n                    obj.mesh.material.color.copy(headColor);\n                    let scale = 1 + 2.2 * Math.sin(Math.PI * normalizedLife);\n                    let distToCam = obj.mesh.position.length();\n                    let dofBlur = distToCam < starMaxDistance * 0.7 ? 0.7 : 1.0;\n                    obj.mesh.scale.set(scale * dofBlur, scale * dofBlur, scale * dofBlur);\n                    // Sparkle burst\n                    if (normalizedLife >= 1 && !obj.hasFragmented) {\n                        // --- SPECTACULAR EXPLOSION (very rare) ---\n                        const spectacular = Math.random() < 0.02; // 2% chance\n                        const burstCount = spectacular ? 120 + Math.floor(Math.random() * 60) : 18 + Math.floor(Math.random() * 8);\n                        const palette = spectacular ? [\n                            0xffe066,\n                            0xff66cc,\n                            0x66ccff,\n                            0xffffff,\n                            0x80ffea,\n                            0xfff2cc,\n                            0xffc080,\n                            0x80c0ff,\n                            0xff80b3,\n                            0xff0000,\n                            0x00ff00,\n                            0x0000ff,\n                            0xffff00,\n                            0x00ffff,\n                            0xff00ff,\n                            0xff8800,\n                            0x00ff88,\n                            0x8800ff\n                        ] : [\n                            0xffffff,\n                            0xfff6c0,\n                            0xffe066,\n                            0xffc080,\n                            0x80c0ff\n                        ];\n                        for(let s = 0; s < burstCount; s++){\n                            const color = palette[Math.floor(Math.random() * palette.length)];\n                            const size = spectacular ? 1.2 + Math.random() * 2.2 : 0.7 + Math.random() * 0.8;\n                            const sparkleGeo = new three__WEBPACK_IMPORTED_MODULE_3__.SphereGeometry(size, 8, 8);\n                            const sparkleMat = new three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial({\n                                color,\n                                transparent: true,\n                                opacity: spectacular ? 0.92 : 0.7,\n                                blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n                            });\n                            const sparkle = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(sparkleGeo, sparkleMat);\n                            sparkle.position.copy(obj.mesh.position);\n                            // Spectacular: huge, fast, random directions; normal: moderate\n                            const spd = spectacular ? 4 + Math.random() * 8 : 2 + Math.random() * 2;\n                            const sparkleVel = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize().multiplyScalar(spd);\n                            sparkle.userData = {\n                                velocity: sparkleVel,\n                                age: 0,\n                                spectacular,\n                                maxAge: spectacular ? 80 + Math.random() * 40 : 40 + Math.random() * 20\n                            }; // <-- LONGER LIFE\n                            scene.add(sparkle);\n                            if (!window._sparkles) window._sparkles = [];\n                            window._sparkles.push(sparkle);\n                        }\n                        if (spectacular) {\n                            // Add a big flash\n                            const flashGeo = new three__WEBPACK_IMPORTED_MODULE_3__.SphereGeometry(6, 24, 24);\n                            const flashMat = new three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial({\n                                color: 0xffffff,\n                                transparent: true,\n                                opacity: 0.8,\n                                blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n                            });\n                            const flash = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(flashGeo, flashMat);\n                            flash.position.copy(obj.mesh.position);\n                            scene.add(flash);\n                            if (!window._starFlashes) window._starFlashes = [];\n                            window._starFlashes.push({\n                                mesh: flash,\n                                age: 0\n                            });\n                        }\n                        // Fragmented trail logic (keep as before)\n                        const fragVel = obj.velocity.clone().applyAxisAngle(new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(0, 1, 0), (Math.random() - 0.5) * 0.3);\n                        const fragStar = obj.mesh.clone();\n                        fragStar.position.copy(obj.mesh.position);\n                        fragStar.velocity = fragVel;\n                        fragStar.normalizedLife = normalizedLife;\n                        fragStar.normalizedLifetime = obj.normalizedLifetime * (0.5 + Math.random() * 0.5);\n                        fragStar.age = obj.age;\n                        fragStar.material = obj.mesh.material.clone();\n                        const fragTrailPoints = obj.trailPoints.slice();\n                        const fragTailGeo = new three__WEBPACK_IMPORTED_MODULE_3__.BufferGeometry().setFromPoints(fragTrailPoints);\n                        fragTailGeo.setAttribute(\"color\", obj.tail.geometry.getAttribute(\"color\").clone());\n                        const fragTailMat = obj.tail.material.clone();\n                        const fragTail = new three__WEBPACK_IMPORTED_MODULE_3__.Line(fragTailGeo, fragTailMat);\n                        fragTail.position.copy(fragStar.position);\n                        scene.add(fragStar);\n                        scene.add(fragTail);\n                        shootingStars.push({\n                            mesh: fragStar,\n                            tail: fragTail,\n                            velocity: fragStar.velocity,\n                            dir: obj.dir,\n                            age: fragStar.age,\n                            normalizedLifetime: fragStar.normalizedLifetime,\n                            trailPoints: fragTrailPoints,\n                            color: obj.color,\n                            brightness: obj.brightness,\n                            hasFragmented: true\n                        });\n                        obj.hasFragmented = true;\n                    }\n                    // Spark burst\n                    if (!obj.hasSparked && normalizedLife > 0.95 && Math.random() < 0.1) {\n                        for(let s = 0; s < 8 + Math.floor(Math.random() * 8); s++){\n                            const sparkGeo = new three__WEBPACK_IMPORTED_MODULE_3__.SphereGeometry(0.5 + Math.random() * 0.5, 8, 8);\n                            const sparkMat = new three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial({\n                                color: 0xfff6c0,\n                                transparent: true,\n                                opacity: 1,\n                                blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n                            });\n                            const spark = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(sparkGeo, sparkMat);\n                            spark.position.copy(obj.mesh.position);\n                            spark.sparkVel = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize().multiplyScalar(0.5 + Math.random() * 1.2);\n                            spark.sparkLife = 12 + Math.random() * 10;\n                            spark.sparkAge = 0;\n                            scene.add(spark);\n                            if (!window._starSparks) window._starSparks = [];\n                            window._starSparks.push(spark);\n                        }\n                        obj.hasSparked = true;\n                    }\n                    // Flash\n                    if (!obj.hasFlashed && normalizedLife > 0.98 && Math.random() < 0.2) {\n                        const flashGeo = new three__WEBPACK_IMPORTED_MODULE_3__.SphereGeometry(1, 16, 16);\n                        const flashMat = new three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial({\n                            color: 0xffffee,\n                            transparent: true,\n                            opacity: 0.8,\n                            blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n                        });\n                        const flash = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(flashGeo, flashMat);\n                        flash.position.copy(obj.mesh.position);\n                        scene.add(flash);\n                        if (!window._starFlashes) window._starFlashes = [];\n                        window._starFlashes.push({\n                            mesh: flash,\n                            age: 0\n                        });\n                        obj.hasFlashed = true;\n                    }\n                    // Fade out as it gets far away\n                    const dist = obj.mesh.position.distanceTo(camera.position);\n                    const fadeStart = starMaxDistance * 0.5;\n                    if (dist > fadeStart) {\n                        const fade = 1 - (dist - fadeStart) / (starMaxDistance - fadeStart);\n                        obj.mesh.material.opacity = Math.max(0, fade);\n                        obj.mesh.material.transparent = true;\n                        obj.tail.material.opacity = Math.max(0, fade * 0.8);\n                        obj.tail.material.transparent = true;\n                    }\n                    // Remove when out of bounds or fully faded or life ended\n                    if (normalizedLife >= 1.0 || dist > starMaxDistance || obj.mesh.material.opacity <= 0.01) {\n                        scene.remove(obj.mesh);\n                        scene.remove(obj.tail);\n                        shootingStars.splice(i, 1);\n                    }\n                }\n                // Animate sparks\n                if (window._starSparks) {\n                    for(let i = window._starSparks.length - 1; i >= 0; i--){\n                        const spark = window._starSparks[i];\n                        spark.position.add(spark.sparkVel);\n                        spark.sparkAge++;\n                        spark.material.opacity *= 0.92;\n                        if (spark.sparkAge > spark.sparkLife) {\n                            scene.remove(spark);\n                            window._starSparks.splice(i, 1);\n                        }\n                    }\n                }\n                // Animate explosion particles (sparkles)\n                if (window._sparkles) {\n                    for(let i = window._sparkles.length - 1; i >= 0; i--){\n                        const sparkle = window._sparkles[i];\n                        sparkle.position.add(sparkle.userData.velocity);\n                        sparkle.userData.age++;\n                        sparkle.material.opacity *= 0.97;\n                        if (sparkle.userData.age > (sparkle.userData.maxAge || 40)) {\n                            scene.remove(sparkle);\n                            window._sparkles.splice(i, 1);\n                        }\n                    }\n                }\n                // Animate flashes\n                if (window._starFlashes) {\n                    for(let i = window._starFlashes.length - 1; i >= 0; i--){\n                        const flash = window._starFlashes[i];\n                        flash.mesh.scale.multiplyScalar(1.15);\n                        flash.mesh.material.opacity *= 0.85;\n                        flash.age++;\n                        if (flash.age > 10) {\n                            scene.remove(flash.mesh);\n                            window._starFlashes.splice(i, 1);\n                        }\n                    }\n                }\n                // --- Starfield logic ---\n                const sqDist = starMaxDistance * starMaxDistance;\n                for(let i = 0; i < positions.length; i += 3){\n                    const dx = positions[i] - virtualCameraPos.x;\n                    const dy = positions[i + 1] - virtualCameraPos.y;\n                    const dz = positions[i + 2] - virtualCameraPos.z;\n                    if (dx * dx + dy * dy + dz * dz > sqDist) {\n                        // Place in a thick spherical shell around the virtual camera, never too close\n                        const minRadius = starMaxDistance * 0.8;\n                        const maxRadius = starMaxDistance;\n                        const r = minRadius + Math.random() * (maxRadius - minRadius);\n                        const theta = Math.random() * 2 * Math.PI;\n                        const phi = Math.acos(2 * Math.random() - 1);\n                        positions[i] = virtualCameraPos.x + r * Math.sin(phi) * Math.cos(theta);\n                        positions[i + 1] = virtualCameraPos.y + r * Math.sin(phi) * Math.sin(theta);\n                        positions[i + 2] = virtualCameraPos.z + r * Math.cos(phi);\n                    }\n                }\n                // geometry.attributes.position.needsUpdate = true; // Already set above\n                // Robust starfield color update to prevent stuck white dots\n                const colArr = geometry.attributes.color.array;\n                for(let i = 0; i < positions.length; i += 3){\n                    const idx = i / 3;\n                    const dx = positions[i] - virtualCameraPos.x;\n                    const dy = positions[i + 1] - virtualCameraPos.y;\n                    const dz = positions[i + 2] - virtualCameraPos.z;\n                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);\n                    if (timers[idx] > 0) {\n                        timers[idx]--;\n                        if (timers[idx] === 0) {\n                            // Timer expired, restore color\n                            sparkColors[i] = originalColors[i];\n                            sparkColors[i + 1] = originalColors[i + 1];\n                            sparkColors[i + 2] = originalColors[i + 2];\n                            colArr[i] = originalColors[i];\n                            colArr[i + 1] = originalColors[i + 1];\n                            colArr[i + 2] = originalColors[i + 2];\n                        } else {\n                            colArr[i] = sparkColors[i];\n                            colArr[i + 1] = sparkColors[i + 1];\n                            colArr[i + 2] = sparkColors[i + 2];\n                        }\n                    } else if (dist > starMaxDistance * 0.3 && Math.random() < 0.05) {\n                        timers[idx] = sparkleDuration;\n                        const c = palette[Math.floor(Math.random() * palette.length)];\n                        sparkColors[i] = c[0];\n                        sparkColors[i + 1] = c[1];\n                        sparkColors[i + 2] = c[2];\n                        colArr[i] = sparkColors[i];\n                        colArr[i + 1] = sparkColors[i + 1];\n                        colArr[i + 2] = sparkColors[i + 2];\n                    } else {\n                        sparkColors[i] = originalColors[i];\n                        sparkColors[i + 1] = originalColors[i + 1];\n                        sparkColors[i + 2] = originalColors[i + 2];\n                        colArr[i] = originalColors[i];\n                        colArr[i + 1] = originalColors[i + 1];\n                        colArr[i + 2] = originalColors[i + 2];\n                    }\n                }\n                geometry.attributes.color.needsUpdate = true;\n                composer.render();\n            } catch (err) {\n                // Defensive: log error with context\n                console.error(\"Starfield animation error:\", err);\n            }\n        };\n        animate(); // Start the render loop\n        const onResize = ()=>{\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n        };\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: mountRef\n    }, void 0, false, {\n        fileName: \"/home/kayosdev/Websites/Portfolio/components/Starfield.jsx\",\n        lineNumber: 649,\n        columnNumber: 10\n    }, undefined);\n};\n_s(Starfield, \"V9/qkEdV8GfsDZk7lMTA1T8g5Ps=\");\n_c = Starfield;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Starfield);\nvar _c;\n$RefreshReg$(_c, \"Starfield\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFFO3dCQUN0Q1EsV0FBVyxDQUFDUixJQUFFLEVBQUUsR0FBR0MsY0FBYyxDQUFDRCxJQUFFLEVBQUU7d0JBQ3RDOE0sTUFBTSxDQUFDOU0sRUFBRSxHQUFHQyxjQUFjLENBQUNELEVBQUU7d0JBQzdCOE0sTUFBTSxDQUFDOU0sSUFBRSxFQUFFLEdBQUdDLGNBQWMsQ0FBQ0QsSUFBRSxFQUFFO3dCQUNqQzhNLE1BQU0sQ0FBQzlNLElBQUUsRUFBRSxHQUFHQyxjQUFjLENBQUNELElBQUUsRUFBRTtvQkFDbkM7Z0JBQ0Y7Z0JBQ0FsQyxTQUFTb0MsVUFBVSxDQUFDQyxLQUFLLENBQUNxSCxXQUFXLEdBQUc7Z0JBQ3RDMUssU0FBU21LLE1BQU07WUFDakIsRUFBRSxPQUFPZ0csS0FBSztnQkFDWixvQ0FBb0M7Z0JBQ3BDQyxRQUFRQyxLQUFLLENBQUMsOEJBQThCRjtZQUM5QztRQUNGO1FBRUFsRyxXQUFXLHdCQUF3QjtRQUVuQyxNQUFNcUcsV0FBVztZQUNmdlIsT0FBTzJCLE1BQU0sR0FBR3pCLE9BQU9DLFVBQVUsR0FBR0QsT0FBT0UsV0FBVztZQUN0REosT0FBTzRCLHNCQUFzQjtRQUMvQjtJQUNGLEdBQUcsRUFBRTtJQUVMLHFCQUFPLDhEQUFDNFA7UUFBSUMsS0FBS3JTOzs7Ozs7QUFDbkI7R0Fsb0JNRDtLQUFBQTtBQW1vQk4sK0RBQWVBLFNBQVNBLEVBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9TdGFyZmllbGQuanN4P2YxYTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgRWZmZWN0Q29tcG9zZXIgfSBmcm9tICd0aHJlZS9leGFtcGxlcy9qc20vcG9zdHByb2Nlc3NpbmcvRWZmZWN0Q29tcG9zZXInO1xuaW1wb3J0IHsgVW5yZWFsQmxvb21QYXNzIH0gZnJvbSAndGhyZWUvZXhhbXBsZXMvanNtL3Bvc3Rwcm9jZXNzaW5nL1VucmVhbEJsb29tUGFzcyc7XG5pbXBvcnQgeyBSZW5kZXJQYXNzIH0gZnJvbSAndGhyZWUvZXhhbXBsZXMvanNtL3Bvc3Rwcm9jZXNzaW5nL1JlbmRlclBhc3MnO1xuaW1wb3J0IHsgQ2hyb21hdGljQWJlcnJhdGlvblBhc3MgfSBmcm9tICcuL0Nocm9tYXRpY0FiZXJyYXRpb25QYXNzJztcblxuY29uc3QgU3RhcmZpZWxkID0gKCkgPT4ge1xuICBjb25zdCBtb3VudFJlZiA9IHVzZVJlZihudWxsKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gRGVmZW5zaXZlOiBhbHdheXMgdXNlIC5jdXJyZW50IGZvciByZWZzXG4gICAgaWYgKCFtb3VudFJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgY29uc3QgbW91bnQgPSBtb3VudFJlZi5jdXJyZW50XG4gICAgbW91bnQuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnXG4gICAgbW91bnQuc3R5bGUudG9wID0gJzAnXG4gICAgbW91bnQuc3R5bGUubGVmdCA9ICcwJ1xuICAgIG1vdW50LnN0eWxlLndpZHRoID0gJzEwMCUnXG4gICAgbW91bnQuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnXG4gICAgbW91bnQuc3R5bGUuekluZGV4ID0gJzAnXG5cbiAgICAvLyBTY2VuZSAmIFJlbmRlcmVyXG4gICAgY29uc3Qgc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKVxuICAgIGNvbnN0IGNhbWVyYSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSg3NSwgd2luZG93LmlubmVyV2lkdGggLyB3aW5kb3cuaW5uZXJIZWlnaHQsIDAuMSwgNTAwMClcbiAgICBjYW1lcmEucG9zaXRpb24uc2V0KDAsIDAsIDApO1xuICAgIC8vIFZpcnR1YWwgcG9zaXRpb24gdG8gc2ltdWxhdGUgaW5maW5pdGUgdHJhdmVsXG4gICAgbGV0IHZpcnR1YWxDYW1lcmFQb3MgPSBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAwKTtcbiAgICBjb25zdCByZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKHsgYW50aWFsaWFzOiB0cnVlIH0pXG4gICAgcmVuZGVyZXIuc2V0UGl4ZWxSYXRpbyh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbylcbiAgICByZW5kZXJlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpXG4gICAgcmVuZGVyZXIuc2V0Q2xlYXJDb2xvcigweDAwMDAwMCwgMSk7XG4gICAgbW91bnQuYXBwZW5kQ2hpbGQocmVuZGVyZXIuZG9tRWxlbWVudClcblxuICAgIC8vIC0tLSBQT1NUUFJPQ0VTU0lORyAtLS1cbiAgICAvLyBDb21wb3NlclxuICAgIGNvbnN0IGNvbXBvc2VyID0gbmV3IEVmZmVjdENvbXBvc2VyKHJlbmRlcmVyKTtcbiAgICBjb21wb3Nlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIC8vIFJlbmRlciBwYXNzXG4gICAgY29uc3QgcmVuZGVyUGFzcyA9IG5ldyBSZW5kZXJQYXNzKHNjZW5lLCBjYW1lcmEpO1xuICAgIGNvbXBvc2VyLmFkZFBhc3MocmVuZGVyUGFzcyk7XG4gICAgLy8gVW5yZWFsIEJsb29tIFBhc3NcbiAgICAvLyAtLS0gQkxPT00gKE1BWCkgLS0tXG4gICAgY29uc3QgYmxvb21QYXNzID0gbmV3IFVucmVhbEJsb29tUGFzcyhcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpLFxuICAgICAgMi41LCAvLyBzdHJlbmd0aCAobWF4KVxuICAgICAgMS4yLCAvLyByYWRpdXMgKG1heClcbiAgICAgIDAuMTIgLy8gdGhyZXNob2xkIChsb3dlciA9IG1vcmUpXG4gICAgKTtcbiAgICBjb21wb3Nlci5hZGRQYXNzKGJsb29tUGFzcyk7XG5cbiAgICAvLyAtLS0gQ0xPU0UgU1RBUlM6IFNlcGFyYXRlIFNjZW5lIGZvciBDaHJvbWF0aWMgQWJlcnJhdGlvbiAtLS1cbiAgICBjb25zdCBjbG9zZVN0YXJzU2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcbiAgICBjb25zdCBjYVBhc3MgPSBuZXcgQ2hyb21hdGljQWJlcnJhdGlvblBhc3MobmV3IFRIUkVFLlZlY3RvcjIoMC4wMDAyLCAwLjAwMDIpKTsgLy8gYmFyZWx5IHZpc2libGVcbiAgICBjb25zdCBjYUNvbXBvc2VyID0gbmV3IEVmZmVjdENvbXBvc2VyKHJlbmRlcmVyKTtcbiAgICBjYUNvbXBvc2VyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgY29uc3QgY2FSZW5kZXJQYXNzID0gbmV3IFJlbmRlclBhc3MoY2xvc2VTdGFyc1NjZW5lLCBjYW1lcmEpO1xuICAgIGNhQ29tcG9zZXIuYWRkUGFzcyhjYVJlbmRlclBhc3MpO1xuICAgIGNhQ29tcG9zZXIuYWRkUGFzcyhjYVBhc3MpO1xuXG4gICAgLy8gLS0tIEhBTkRMRSBSRVNJWkUgQU5EIEZVTExTQ1JFRU4gLS0tXG4gICAgZnVuY3Rpb24gcmVzaXplQWxsKCkge1xuICAgICAgY2FtZXJhLmFzcGVjdCA9IHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAgIHJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgICBjb21wb3Nlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgICAgY2FDb21wb3Nlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIH1cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplQWxsKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZnVsbHNjcmVlbmNoYW5nZScsIHJlc2l6ZUFsbCk7XG5cbiAgICAvLyBTdGFyZmllbGRcbiAgICBjb25zdCBzdGFyQ291bnQgPSA1MDBcbiAgICBjb25zdCBzdGFyTWF4RGlzdGFuY2UgPSAyMDAwXG4gICAgY29uc3Qgc3RhclNwZWVkID0gMVxuICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KClcbiAgICBjb25zdCBjbG9zZUdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XG4gICAgY29uc3QgcG9zaXRpb25zID0gW107XG4gICAgY29uc3QgY2xvc2VQb3NpdGlvbnMgPSBbXTtcbiAgICBsZXQgc3RhcnNQbGFjZWQgPSAwO1xuICAgIHdoaWxlIChzdGFyc1BsYWNlZCA8IHN0YXJDb3VudCkge1xuICAgICAgLy8gV2l0aCAxJSBjaGFuY2UsIHNwYXduIGEgc3RhciBjbHVzdGVyICgxMC0zMCBzdGFycylcbiAgICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgMC4wMSAmJiBzdGFyc1BsYWNlZCA8IHN0YXJDb3VudCAtIDEwKSB7XG4gICAgICAgIGNvbnN0IGNsdXN0ZXJUaGV0YSA9IE1hdGgucmFuZG9tKCkgKiAyICogTWF0aC5QSTtcbiAgICAgICAgY29uc3QgY2x1c3RlclBoaSA9IE1hdGguYWNvcygyICogTWF0aC5yYW5kb20oKSAtIDEpO1xuICAgICAgICBjb25zdCBjbHVzdGVyUiA9IE1hdGgucmFuZG9tKCkgKiBzdGFyTWF4RGlzdGFuY2U7XG4gICAgICAgIGNvbnN0IGNsdXN0ZXJDZW50ZXIgPSBbXG4gICAgICAgICAgY2x1c3RlclIgKiBNYXRoLnNpbihjbHVzdGVyUGhpKSAqIE1hdGguY29zKGNsdXN0ZXJUaGV0YSksXG4gICAgICAgICAgY2x1c3RlclIgKiBNYXRoLnNpbihjbHVzdGVyUGhpKSAqIE1hdGguc2luKGNsdXN0ZXJUaGV0YSksXG4gICAgICAgICAgY2x1c3RlclIgKiBNYXRoLmNvcyhjbHVzdGVyUGhpKVxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBjbHVzdGVyU2l6ZSA9IDEwICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjApOyAvLyAxMC0zMCBzdGFyc1xuICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGNsdXN0ZXJTaXplICYmIHN0YXJzUGxhY2VkIDwgc3RhckNvdW50OyBjKyspIHtcbiAgICAgICAgICAvLyBFYWNoIHN0YXIgaW4gY2x1c3RlciBpcyB3aXRoaW4gMzAgdW5pdHMgb2YgY2VudGVyXG4gICAgICAgICAgY29uc3Qgb2Zmc2V0VGhldGEgPSBNYXRoLnJhbmRvbSgpICogMiAqIE1hdGguUEk7XG4gICAgICAgICAgY29uc3Qgb2Zmc2V0UGhpID0gTWF0aC5hY29zKDIgKiBNYXRoLnJhbmRvbSgpIC0gMSk7XG4gICAgICAgICAgY29uc3Qgb2Zmc2V0UiA9IE1hdGgucmFuZG9tKCkgKiAzMDsgLy8gY2x1c3RlciByYWRpdXNcbiAgICAgICAgICBwb3NpdGlvbnMucHVzaChcbiAgICAgICAgICAgIGNsdXN0ZXJDZW50ZXJbMF0gKyBvZmZzZXRSICogTWF0aC5zaW4ob2Zmc2V0UGhpKSAqIE1hdGguY29zKG9mZnNldFRoZXRhKSxcbiAgICAgICAgICAgIGNsdXN0ZXJDZW50ZXJbMV0gKyBvZmZzZXRSICogTWF0aC5zaW4ob2Zmc2V0UGhpKSAqIE1hdGguc2luKG9mZnNldFRoZXRhKSxcbiAgICAgICAgICAgIGNsdXN0ZXJDZW50ZXJbMl0gKyBvZmZzZXRSICogTWF0aC5jb3Mob2Zmc2V0UGhpKVxuICAgICAgICAgICk7XG4gICAgICAgICAgc3RhcnNQbGFjZWQrKztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm9ybWFsIHNpbmdsZSBzdGFyXG4gICAgICAgIGNvbnN0IHRoZXRhID0gTWF0aC5yYW5kb20oKSAqIDIgKiBNYXRoLlBJO1xuICAgICAgICBjb25zdCBwaGkgPSBNYXRoLmFjb3MoMiAqIE1hdGgucmFuZG9tKCkgLSAxKTtcbiAgICAgICAgY29uc3QgciA9IE1hdGgucmFuZG9tKCkgKiBzdGFyTWF4RGlzdGFuY2U7XG4gICAgICAgIGNvbnN0IHggPSByICogTWF0aC5zaW4ocGhpKSAqIE1hdGguY29zKHRoZXRhKTtcbiAgICAgICAgY29uc3QgeSA9IHIgKiBNYXRoLnNpbihwaGkpICogTWF0aC5zaW4odGhldGEpO1xuICAgICAgICBjb25zdCB6ID0gciAqIE1hdGguY29zKHBoaSk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKHgsIHksIHopO1xuICAgICAgICAvLyBJZiBjbG9zZSwgYWxzbyBhZGQgdG8gY2xvc2VQb3NpdGlvbnNcbiAgICAgICAgaWYgKHIgPCA0MDApIHtcbiAgICAgICAgICBjbG9zZVBvc2l0aW9ucy5wdXNoKHgsIHksIHopO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJzUGxhY2VkKys7XG4gICAgICB9XG4gICAgfVxuICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgVEhSRUUuRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbnMsIDMpKVxuICAgIGlmIChjbG9zZVBvc2l0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICBjbG9zZUdlb21ldHJ5LnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgVEhSRUUuRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShjbG9zZVBvc2l0aW9ucywgMykpO1xuICAgIH1cblxuICAgIC8vIENSQVpZIEJMT09NOiBBbGwgc3RhcnMgYXJlIGV4dHJlbWVseSBicmlnaHQgKGNvbG9yIGludGVuc2l0eSA+MSlcbiAgICBjb25zdCBwYWxldHRlID0gW1xuICAgICAgWzMuMCwgMS41LCAxLjVdLFxuICAgICAgWzMuMCwgMi4yNSwgMS4yXSxcbiAgICAgIFszLjAsIDMuMCwgMi43XSxcbiAgICAgIFszLjAsIDMuMCwgMy4wXSxcbiAgICAgIFsxLjIsIDEuNSwgMy4wXSxcbiAgICBdO1xuICAgIGNvbnN0IGNvbG9ycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhckNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IGMgPSBwYWxldHRlW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHBhbGV0dGUubGVuZ3RoKV07XG4gICAgICBjb2xvcnMucHVzaCguLi5jKTtcbiAgICB9XG4gICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdjb2xvcicsIG5ldyBUSFJFRS5GbG9hdDMyQnVmZmVyQXR0cmlidXRlKGNvbG9ycywgMykpO1xuXG4gICAgY29uc3Qgb3JpZ2luYWxDb2xvcnMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLmNvbG9yLmFycmF5LnNsaWNlKClcbiAgICBjb25zdCB0aW1lcnMgPSBuZXcgRmxvYXQzMkFycmF5KHN0YXJDb3VudClcbiAgICBjb25zdCBzcGFya0NvbG9ycyA9IG5ldyBGbG9hdDMyQXJyYXkoc3RhckNvdW50ICogMylcbiAgICBjb25zdCBzcGFya2xlRHVyYXRpb24gPSAxODBcblxuICAgIC8vIC0tLSBTUVVBUkUgU1RBUlMgVVNJTkcgUE9JTlRTIC0tLVxuY29uc3QgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuUG9pbnRzTWF0ZXJpYWwoeyBzaXplOiAzLjUsIHNpemVBdHRlbnVhdGlvbjogdHJ1ZSwgdmVydGV4Q29sb3JzOiB0cnVlIH0pO1xuY29uc3Qgc3RhcnMgPSBuZXcgVEhSRUUuUG9pbnRzKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG5zY2VuZS5hZGQoc3RhcnMpO1xuLy8gQWRkIGdsb3cgc3ByaXRlcyB0byBlYWNoIHN0YXIgYW5kIGFuaW1hdGUgdGhlbSBiYXNlZCBvbiBkaXN0YW5jZVxuY29uc3QgZ2xvd01hcCA9IG5ldyBUSFJFRS5UZXh0dXJlTG9hZGVyKCkubG9hZCgnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL21yZG9vYi90aHJlZS5qcy9tYXN0ZXIvZXhhbXBsZXMvdGV4dHVyZXMvc3ByaXRlcy9nbG93LnBuZycpO1xuY29uc3QgZ2xvd1Nwcml0ZXMgPSBbXTtcbmNvbnN0IGdsb3dNYXRlcmlhbCA9IG5ldyBUSFJFRS5TcHJpdGVNYXRlcmlhbCh7IG1hcDogZ2xvd01hcCwgY29sb3I6IDB4ZmZmZmZmLCBvcGFjaXR5OiAwLjE4LCBibGVuZGluZzogVEhSRUUuQWRkaXRpdmVCbGVuZGluZywgZGVwdGhXcml0ZTogZmFsc2UgfSk7XG5mb3IgKGxldCBpID0gMDsgaSA8IHN0YXJDb3VudDsgaSsrKSB7XG4gIGNvbnN0IGdsb3cgPSBuZXcgVEhSRUUuU3ByaXRlKGdsb3dNYXRlcmlhbC5jbG9uZSgpKTtcbiAgZ2xvdy5wb3NpdGlvbi5zZXQocG9zaXRpb25zW2kqM10sIHBvc2l0aW9uc1tpKjMrMV0sIHBvc2l0aW9uc1tpKjMrMl0pO1xuICBnbG93LnNjYWxlLnNldCgxMCwgMTAsIDEpO1xuICBzY2VuZS5hZGQoZ2xvdyk7XG4gIGdsb3dTcHJpdGVzLnB1c2goZ2xvdyk7XG59XG4vLyBBZGQgY2xvc2Ugc3RhcnMgdG8gc2VwYXJhdGUgc2NlbmVcbmxldCBjbG9zZVN0YXJzO1xuaWYgKGNsb3NlUG9zaXRpb25zLmxlbmd0aCA+IDApIHtcbiAgY2xvc2VTdGFycyA9IG5ldyBUSFJFRS5Qb2ludHMoY2xvc2VHZW9tZXRyeSwgbWF0ZXJpYWwuY2xvbmUoKSk7XG4gIGNsb3NlU3RhcnNTY2VuZS5hZGQoY2xvc2VTdGFycyk7XG59XG5cbiAgICBsZXQgdGFyZ2V0WSA9IDBcbiAgICBjb25zdCBkYW1waW5nID0gMC4wNVxuICAgIGNvbnN0IG9uU2Nyb2xsID0gKCkgPT4ge1xuICAgICAgY29uc3QgcGN0ID0gd2luZG93LnNjcm9sbFkgLyAoZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQgLSB3aW5kb3cuaW5uZXJIZWlnaHQpXG4gICAgICB0YXJnZXRZID0gcGN0ICogTWF0aC5QSSAqIDJcbiAgICB9XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIG9uU2Nyb2xsKVxuXG5cbiAgICAvLyAtLS0gU2hvb3RpbmcgU3RhcnMgLS0tXG4gICAgY29uc3QgdGFpbExlbmd0aCA9IDMyOyAvLyBJbmNyZWFzZSBmb3IgbG9uZ2VyIHRhaWxzXG4gICAgY29uc3Qgc2hvb3RpbmdTdGFycyA9IFtdO1xuICAgIGxldCBzaG9vdGluZ1N0YXJDb29sZG93biA9IDA7XG4gICAgLy8gU3Bhd24gYSBzaG9vdGluZyBzdGFyIHdpdGggYSBzdHVubmluZyBnbG93aW5nIHRhaWxcbiAgICBmdW5jdGlvbiBzcGF3blNob290aW5nU3RhcigpIHtcbiAgICAgIC8vIFBpY2sgYSByYW5kb20gZGlyZWN0aW9uIG9uIHRoZSBzcGhlcmUgZm9yIHRoZSBzcGF3biBsb2NhdGlvblxuICAgICAgY29uc3QgZGlyID0gbmV3IFRIUkVFLlZlY3RvcjMoTWF0aC5yYW5kb20oKSoyLTEsIE1hdGgucmFuZG9tKCkqMi0xLCBNYXRoLnJhbmRvbSgpKjItMSkubm9ybWFsaXplKCk7XG4gICAgICAvLyBFbnN1cmUgc2hvb3Rpbmcgc3RhcnMgbmV2ZXIgc3Bhd24gY2xvc2UgdG8gdGhlIGNhbWVyYSAoYXQgbGVhc3QgNzAlIG9mIG1heCBkaXN0YW5jZSlcbiAgICAgIGNvbnN0IG1pbkRpc3QgPSBzdGFyTWF4RGlzdGFuY2UgKiAwLjc7XG4gICAgICBjb25zdCBtYXhEaXN0ID0gc3Rhck1heERpc3RhbmNlICogMS4wO1xuICAgICAgY29uc3QgZGlzdCA9IG1pbkRpc3QgKyBNYXRoLnJhbmRvbSgpICogKG1heERpc3QgLSBtaW5EaXN0KTtcbiAgICAgIGNvbnN0IHNwYXduUG9zID0gZGlyLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoZGlzdCk7XG4gICAgICAvLyBUYW5nZW50aWFsIHZlbG9jaXR5OiBwZXJwZW5kaWN1bGFyIHRvIGRpclxuICAgICAgbGV0IHRhbmdlbnQgPSBuZXcgVEhSRUUuVmVjdG9yMyhNYXRoLnJhbmRvbSgpKjItMSwgTWF0aC5yYW5kb20oKSoyLTEsIE1hdGgucmFuZG9tKCkqMi0xKTtcbiAgICAgIHRhbmdlbnQgPSB0YW5nZW50LnN1Yih0YW5nZW50LmNsb25lKCkucHJvamVjdE9uVmVjdG9yKGRpcikpLm5vcm1hbGl6ZSgpO1xuICAgICAgLy8gTWl4IGluIGEgc21hbGwgcmFkaWFsIGNvbXBvbmVudCAoaW53YXJkIG9yIG91dHdhcmQpXG4gICAgICBjb25zdCB0YW5nZW50aWFsU3BlZWQgPSBzdGFyU3BlZWQgKiAoMi41ICsgTWF0aC5yYW5kb20oKSAqIDIuNSk7IC8vIG11Y2ggZmFzdGVyXG4gICAgICBjb25zdCByYWRpYWxTcGVlZCA9IHN0YXJTcGVlZCAqIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDAuMzsgLy8gbW9yZSBkcmFtYXRpY1xuICAgICAgY29uc3QgdmVsb2NpdHkgPSB0YW5nZW50Lm11bHRpcGx5U2NhbGFyKHRhbmdlbnRpYWxTcGVlZCkuYWRkKGRpci5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKHJhZGlhbFNwZWVkKSk7XG5cbiAgICAgIC8vIFN0dW5uaW5nIGNvbG9yIGdyYWRpZW50IGZvciB0aGUgaGVhZFxuICAgICAgY29uc3QgdmlicmFudENvbG9ycyA9IFsweGZmZTA2NiwgMHhmZjY2Y2MsIDB4NjZjY2ZmLCAweGZmZmZmZiwgMHg4MGZmZWEsIDB4ZmZmMmNjLCAweGZmYzA4MCwgMHg4MGMwZmYsIDB4ZmY4MGIzXTtcbiAgICAgIGNvbnN0IGNvbG9yID0gdmlicmFudENvbG9yc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqdmlicmFudENvbG9ycy5sZW5ndGgpXTtcbiAgICAgIC8vIFN0YXIgYnJpZ2h0bmVzcyBhbmQgc2l6ZSAoYWx3YXlzIHNtYWxsIGFuZCBzdWJ0bGUpXG4gICAgICBjb25zdCBicmlnaHRuZXNzID0gMi41ICsgTWF0aC5yYW5kb20oKSoxLjU7XG4gICAgICBjb25zdCBnZW8gPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoMC43ICsgTWF0aC5yYW5kb20oKSowLjUsIDE2LCAxNik7IC8vIFNtYWxsIHNwaGVyZVxuICAgICAgY29uc3QgbWF0ID0gbmV3IFRIUkVFLk1lc2hQaHlzaWNhbE1hdGVyaWFsKHtcbiAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICBlbWlzc2l2ZTogY29sb3IsXG4gICAgICAgIGVtaXNzaXZlSW50ZW5zaXR5OiAyLjUsXG4gICAgICAgIG1ldGFsbmVzczogMC43LFxuICAgICAgICByb3VnaG5lc3M6IDAuMyxcbiAgICAgICAgdHJhbnNtaXNzaW9uOiAwLjcsXG4gICAgICAgIG9wYWNpdHk6IDAuOTgsXG4gICAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgICBjbGVhcmNvYXQ6IDAuOCxcbiAgICAgICAgY2xlYXJjb2F0Um91Z2huZXNzOiAwLjIsXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHN0YXIgPSBuZXcgVEhSRUUuTWVzaChnZW8sIG1hdCk7XG4gICAgICAvLyBBZGQgYSBnbG93aW5nIHNwcml0ZSBmb3IgZXh0cmEgZ2xvd1xuICAgICAgY29uc3Qgc3ByaXRlTWFwID0gbmV3IFRIUkVFLlRleHR1cmVMb2FkZXIoKS5sb2FkKCdodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vbXJkb29iL3RocmVlLmpzL21hc3Rlci9leGFtcGxlcy90ZXh0dXJlcy9zcHJpdGVzL2dsb3cucG5nJyk7XG4gICAgICBjb25zdCBzcHJpdGVNYXRlcmlhbCA9IG5ldyBUSFJFRS5TcHJpdGVNYXRlcmlhbCh7IG1hcDogc3ByaXRlTWFwLCBjb2xvcjogY29sb3IsIG9wYWNpdHk6IDAuOCwgYmxlbmRpbmc6IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmcgfSk7XG4gICAgICBjb25zdCBzcHJpdGUgPSBuZXcgVEhSRUUuU3ByaXRlKHNwcml0ZU1hdGVyaWFsKTtcbiAgICAgIHNwcml0ZS5zY2FsZS5zZXQoMzAsIDMwLCAxKTtcbiAgICAgIHNwcml0ZS5wb3NpdGlvbi5jb3B5KHN0YXIucG9zaXRpb24pO1xuICAgICAgc3Rhci5hZGQoc3ByaXRlKTtcbiAgICAgIC8vIEFkZCBkeW5hbWljIHNwYXJrIGJ1cnN0IGF0IHRoZSBoZWFkXG4gICAgICBjb25zdCBzcGFya0NvdW50ID0gMTggKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqOCk7XG4gICAgICBjb25zdCBzcGFya0dyb3VwID0gbmV3IFRIUkVFLkdyb3VwKCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwYXJrQ291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBzcGFya01hdCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7IGNvbG9yOiB2aWJyYW50Q29sb3JzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSp2aWJyYW50Q29sb3JzLmxlbmd0aCldLCB0cmFuc3BhcmVudDogdHJ1ZSwgb3BhY2l0eTogMC44IH0pO1xuICAgICAgICBjb25zdCBzcGFya0dlbyA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeSgwLjA3ICsgTWF0aC5yYW5kb20oKSowLjA2LCA4LCA4KTtcbiAgICAgICAgY29uc3Qgc3BhcmsgPSBuZXcgVEhSRUUuTWVzaChzcGFya0dlbywgc3BhcmtNYXQpO1xuICAgICAgICBjb25zdCBhbmdsZSA9IChpIC8gc3BhcmtDb3VudCkgKiBNYXRoLlBJICogMjtcbiAgICAgICAgc3BhcmsucG9zaXRpb24uc2V0KE1hdGguY29zKGFuZ2xlKSoxLjIsIE1hdGguc2luKGFuZ2xlKSoxLjIsIE1hdGgucmFuZG9tKCkqMC40LTAuMik7XG4gICAgICAgIHNwYXJrR3JvdXAuYWRkKHNwYXJrKTtcbiAgICAgIH1cbiAgICAgIHNwYXJrR3JvdXAubmFtZSA9ICdzcGFya0J1cnN0JztcbiAgICAgIHN0YXIuYWRkKHNwYXJrR3JvdXApO1xuICAgICAgc3Rhci5wb3NpdGlvbi5jb3B5KHNwYXduUG9zKTtcbiAgICAgIHN0YXIudmVsb2NpdHkgPSB2ZWxvY2l0eTtcbiAgICAgIHN0YXIubm9ybWFsaXplZExpZmUgPSAwLjA7XG4gICAgICBzdGFyLm5vcm1hbGl6ZWRMaWZldGltZSA9IDgwICsgTWF0aC5yYW5kb20oKSAqIDgwOyAvLyBMb25nZXIsIG1vcmUgZHJhbWF0aWNcbiAgICAgIHN0YXIuYWdlID0gMDtcbiAgICAgIC8vIC0tLSBTdHVubmluZyBNZXRlb3IgVGFpbCAodmVyeSBsb25nLCBtdWx0aS1jb2xvciwgZ2xvd2luZywgZmFkaW5nLCBhbmQgM0QgY3VydmUpIC0tLVxuICAgICAgY29uc3QgdHJhaWxTZWdtZW50cyA9IHRhaWxMZW5ndGggKiAzOyAvLyBFdmVuIGxvbmdlciB0YWlsXG4gICAgICBjb25zdCB0cmFpbFBvaW50cyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFpbFNlZ21lbnRzOyBpKyspIHtcbiAgICAgICAgLy8gQWRkIGEgM0Qgc3BpcmFsL2N1cnZlIGZvciBtb3JlIGRlcHRoXG4gICAgICAgIGNvbnN0IHNwaXJhbCA9IE1hdGguc2luKGkgKiAwLjI1KSAqIDg7XG4gICAgICAgIGNvbnN0IGN1cnZlID0gTWF0aC5jb3MoaSAqIDAuMTUpICogNDtcbiAgICAgICAgY29uc3QgcHQgPSBzdGFyLnBvc2l0aW9uLmNsb25lKCkuYWRkKG5ldyBUSFJFRS5WZWN0b3IzKHNwaXJhbCwgY3VydmUsIC1pICogMykpO1xuICAgICAgICB0cmFpbFBvaW50cy5wdXNoKHB0KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhaWxHZW8gPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKS5zZXRGcm9tUG9pbnRzKHRyYWlsUG9pbnRzKTtcbiAgICAgIC8vIFBlci12ZXJ0ZXggY29sb3IgKG11bHRpLWNvbG9yIHJhaW5ib3cgZ3JhZGllbnQpXG4gICAgICBjb25zdCB0YWlsQ29sb3JzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYWlsU2VnbWVudHM7IGkrKykge1xuICAgICAgICAvLyBBbHBoYSBmYWRlcyBvdXQgYWxvbmcgdGhlIHRhaWxcbiAgICAgICAgY29uc3QgYWxwaGEgPSAoMSAtIGkgLyAodHJhaWxTZWdtZW50cyAtIDEpKSAqIDAuOTk7XG4gICAgICAgIC8vIFJhaW5ib3cgZ3JhZGllbnRcbiAgICAgICAgY29uc3QgcmFpbmJvdyA9IFsweGZmZTA2NiwgMHhmZjY2Y2MsIDB4NjZjY2ZmLCAweGZmZmZmZiwgMHg4MGZmZWEsIDB4ZmZmMmNjLCAweGZmYzA4MCwgMHg4MGMwZmYsIDB4ZmY4MGIzXTtcbiAgICAgICAgY29uc3QgZ3JhZENvbG9yID0gcmFpbmJvd1tNYXRoLmZsb29yKChpIC8gdHJhaWxTZWdtZW50cykgKiByYWluYm93Lmxlbmd0aCldO1xuICAgICAgICB0YWlsQ29sb3JzLnB1c2goKGdyYWRDb2xvciA+PiAxNiAmIDI1NSkgLyAyNTUsIChncmFkQ29sb3IgPj4gOCAmIDI1NSkgLyAyNTUsIChncmFkQ29sb3IgJiAyNTUpIC8gMjU1LCBhbHBoYSk7XG4gICAgICB9XG4gICAgICB0YWlsR2VvLnNldEF0dHJpYnV0ZSgnY29sb3InLCBuZXcgVEhSRUUuRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh0YWlsQ29sb3JzLCA0KSk7XG4gICAgICAvLyBBZGRpdGl2ZSBibGVuZGluZyBmb3IgZ2xvdyArIEJMT09NRUQgVEFJTFxuICAgICAgY29uc3QgdGFpbE1hdCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCh7IHZlcnRleENvbG9yczogdHJ1ZSwgdHJhbnNwYXJlbnQ6IHRydWUsIG9wYWNpdHk6IDEuMCwgYmxlbmRpbmc6IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmcgfSk7XG4gICAgICBjb25zdCB0YWlsID0gbmV3IFRIUkVFLkxpbmUodGFpbEdlbywgdGFpbE1hdCk7XG4gICAgICB0YWlsLnBvc2l0aW9uLmNvcHkoc3Rhci5wb3NpdGlvbik7XG4gICAgICAvLyBBZGQgYSBibG9vbSBzcHJpdGUgdG8gdGhlIHRhaWwncyBoZWFkIGZvciBleHRyYSBnbG93XG4gICAgICBjb25zdCB0YWlsR2xvd01hcCA9IG5ldyBUSFJFRS5UZXh0dXJlTG9hZGVyKCkubG9hZCgnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL21yZG9vYi90aHJlZS5qcy9tYXN0ZXIvZXhhbXBsZXMvdGV4dHVyZXMvc3ByaXRlcy9nbG93LnBuZycpO1xuICAgICAgY29uc3QgdGFpbEdsb3dNYXQgPSBuZXcgVEhSRUUuU3ByaXRlTWF0ZXJpYWwoeyBtYXA6IHRhaWxHbG93TWFwLCBjb2xvcjogY29sb3IsIG9wYWNpdHk6IDAuODUsIGJsZW5kaW5nOiBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nIH0pO1xuICAgICAgY29uc3QgdGFpbEdsb3cgPSBuZXcgVEhSRUUuU3ByaXRlKHRhaWxHbG93TWF0KTtcbiAgICAgIHRhaWxHbG93LnNjYWxlLnNldCgyMiwgMjIsIDEpO1xuICAgICAgdGFpbEdsb3cucG9zaXRpb24uY29weShzdGFyLnBvc2l0aW9uKTtcbiAgICAgIHN0YXIuYWRkKHRhaWxHbG93KTsgLy8gQXR0YWNoIHRvIHN0YXIgc28gaXQgZm9sbG93cyBoZWFkXG4gICAgICAvLyBBZGQgdG8gc2NlbmVcbiAgICAgIHNjZW5lLmFkZChzdGFyKTtcbiAgICAgIHNjZW5lLmFkZCh0YWlsKTtcbiAgICAgIHNob290aW5nU3RhcnMucHVzaCh7IG1lc2g6IHN0YXIsIHRhaWwsIHZlbG9jaXR5OiBzdGFyLnZlbG9jaXR5LCBkaXIsIGFnZTogMCwgbm9ybWFsaXplZExpZmV0aW1lOiBzdGFyLm5vcm1hbGl6ZWRMaWZldGltZSwgdHJhaWxQb2ludHMsIGNvbG9yLCBicmlnaHRuZXNzLCBoYXNGcmFnbWVudGVkOiBmYWxzZSB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBhbmltYXRlID0gKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcbiAgICAgIC8vIFJlbmRlciBtYWluIHNjZW5lIHdpdGggYmxvb21cbiAgICAgIGNvbXBvc2VyLnJlbmRlcigpO1xuICAgICAgLy8gT3ZlcmxheSBjbG9zZSBzdGFycyB3aXRoIGNocm9tYXRpYyBhYmVycmF0aW9uIChvbmx5IGNsb3NlIHN0YXJzIGdldCBDQSlcbiAgICAgIGlmIChjbG9zZVN0YXJzKSB7XG4gICAgICAgIGNhQ29tcG9zZXIucmVuZGVyKCk7XG4gICAgICB9XG5cbiAgICAgIGNhbWVyYS5yb3RhdGlvbi55ICs9ICh0YXJnZXRZIC0gY2FtZXJhLnJvdGF0aW9uLnkpICogZGFtcGluZztcbiAgICAgIC8vIE1vdmUgdGhlIHZpcnR1YWwgY2FtZXJhIHBvc2l0aW9uIGluIHRoZSBkaXJlY3Rpb24gdGhlIGNhbWVyYSBpcyBmYWNpbmdcbiAgICAgIGNvbnN0IGZvcndhcmQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKGZvcndhcmQpO1xuICAgICAgdmlydHVhbENhbWVyYVBvcy5hZGQoZm9yd2FyZC5tdWx0aXBseVNjYWxhcihzdGFyU3BlZWQpKTtcbiAgICAgIC8vIE9mZnNldCBhbGwgc3RhcnMgYnkgLXZpcnR1YWxDYW1lcmFQb3MgKGZsb2F0aW5nIG9yaWdpbilcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXlbaV0gPSBwb3NpdGlvbnNbaV0gLSB2aXJ0dWFsQ2FtZXJhUG9zLng7XG4gICAgICAgIGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXlbaSsxXSA9IHBvc2l0aW9uc1tpKzFdIC0gdmlydHVhbENhbWVyYVBvcy55O1xuICAgICAgICBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5W2krMl0gPSBwb3NpdGlvbnNbaSsyXSAtIHZpcnR1YWxDYW1lcmFQb3MuejtcbiAgICAgICAgLy8gQW5pbWF0ZSBnbG93IHNwcml0ZSBmb3IgZGlzdGFudC9jbG9zZSBlZmZlY3RcbiAgICAgICAgY29uc3QgZ2xvdyA9IGdsb3dTcHJpdGVzW2kvM107XG4gICAgICAgIGNvbnN0IHN0YXJQb3MgPSBuZXcgVEhSRUUuVmVjdG9yMyhwb3NpdGlvbnNbaV0gLSB2aXJ0dWFsQ2FtZXJhUG9zLngsIHBvc2l0aW9uc1tpKzFdIC0gdmlydHVhbENhbWVyYVBvcy55LCBwb3NpdGlvbnNbaSsyXSAtIHZpcnR1YWxDYW1lcmFQb3Mueik7XG4gICAgICAgIGNvbnN0IGRpc3QgPSBzdGFyUG9zLmxlbmd0aCgpO1xuICAgICAgICAvLyBJZiBjbG9zZSwgcmVkdWNlL2hpZGUgZ2xvdywgaWYgZmFyLCBtYWtlIGdsb3cgYmlnIGFuZCBicmlnaHRcbiAgICAgICAgaWYgKGRpc3QgPCA0MDApIHtcbiAgICAgICAgICBnbG93Lm1hdGVyaWFsLm9wYWNpdHkgPSAwLjA2ICsgMC4wOCAqIE1hdGgucmFuZG9tKCk7IC8vIHN1YnRsZSBmbGlja2VyXG4gICAgICAgICAgZ2xvdy5zY2FsZS5zZXQoNywgNywgMSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGlzdCA+IDEyMDApIHtcbiAgICAgICAgICBnbG93Lm1hdGVyaWFsLm9wYWNpdHkgPSAwLjM4ICsgMC4xOCAqIE1hdGgucmFuZG9tKCk7IC8vIGludGVuc2VcbiAgICAgICAgICBnbG93LnNjYWxlLnNldCgzMiwgMzIsIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGludGVycG9sYXRlXG4gICAgICAgICAgY29uc3QgdCA9IChkaXN0LTQwMCkvKDEyMDAtNDAwKTtcbiAgICAgICAgICBnbG93Lm1hdGVyaWFsLm9wYWNpdHkgPSAwLjA4ICsgMC4zKnQgKyAwLjA4ICogTWF0aC5yYW5kb20oKTtcbiAgICAgICAgICBjb25zdCBzID0gNyArICgzMi03KSp0O1xuICAgICAgICAgIGdsb3cuc2NhbGUuc2V0KHMsIHMsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGdsb3cucG9zaXRpb24uY29weShzdGFyUG9zKTtcbiAgICAgIH1cbiAgICAgIGlmIChjbG9zZVN0YXJzICYmIGNsb3NlR2VvbWV0cnkgJiYgY2xvc2VQb3NpdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsb3NlUG9zaXRpb25zLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgY2xvc2VHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5W2ldID0gY2xvc2VQb3NpdGlvbnNbaV0gLSB2aXJ0dWFsQ2FtZXJhUG9zLng7XG4gICAgICAgICAgY2xvc2VHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5W2krMV0gPSBjbG9zZVBvc2l0aW9uc1tpKzFdIC0gdmlydHVhbENhbWVyYVBvcy55O1xuICAgICAgICAgIGNsb3NlR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheVtpKzJdID0gY2xvc2VQb3NpdGlvbnNbaSsyXSAtIHZpcnR1YWxDYW1lcmFQb3MuejtcbiAgICAgICAgfVxuICAgICAgICBjbG9zZUdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAgIC8vIC0tLSBTaG9vdGluZyBzdGFyIHNwYXduaW5nIC0tLVxuICAgICAgaWYgKHNob290aW5nU3RhckNvb2xkb3duIDw9IDAgJiYgTWF0aC5yYW5kb20oKSA8IDAuMSkge1xuICAgICAgICBzcGF3blNob290aW5nU3RhcigpO1xuICAgICAgICBpZiAoY2FtZXJhKSB7XG4gICAgICAgICAgY29uc3Qgc2hha2VTdHJlbmd0aCA9IDAuMDYgKyBNYXRoLnJhbmRvbSgpKjAuMDQ7XG4gICAgICAgICAgY2FtZXJhLnBvc2l0aW9uLnggKz0gKE1hdGgucmFuZG9tKCktMC41KSpzaGFrZVN0cmVuZ3RoO1xuICAgICAgICAgIGNhbWVyYS5wb3NpdGlvbi55ICs9IChNYXRoLnJhbmRvbSgpLTAuNSkqc2hha2VTdHJlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBzaG9vdGluZ1N0YXJDb29sZG93biA9IDEwICsgTWF0aC5yYW5kb20oKSAqIDEwO1xuICAgICAgfSBlbHNlIGlmIChzaG9vdGluZ1N0YXJDb29sZG93biA+IDApIHtcbiAgICAgICAgc2hvb3RpbmdTdGFyQ29vbGRvd24tLTtcbiAgICAgIH1cbiAgICAgIC8vIEFuaW1hdGUgYW5kIGNsZWFuIHVwIHNob290aW5nIHN0YXJzXG4gICAgICBmb3IgKGxldCBpID0gc2hvb3RpbmdTdGFycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBvYmogPSBzaG9vdGluZ1N0YXJzW2ldO1xuICAgICAgICAvLyBBbmltYXRlIHNwYXJrIGJ1cnN0IChmYWRlIGFuZCBleHBhbmQpXG4gICAgICAgIGlmIChvYmoubWVzaC5jaGlsZHJlbikge1xuICAgICAgICAgIGNvbnN0IHNwYXJrcyA9IG9iai5tZXNoLmNoaWxkcmVuLmZpbmQoY2hpbGQgPT4gY2hpbGQubmFtZSA9PT0gJ3NwYXJrQnVyc3QnKTtcbiAgICAgICAgICBpZiAoc3BhcmtzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNwYXJrcy5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICBjb25zdCBzcGFyayA9IHNwYXJrcy5jaGlsZHJlbltqXTtcbiAgICAgICAgICAgICAgc3BhcmsubWF0ZXJpYWwub3BhY2l0eSAqPSAwLjk2OyAvLyBGYWRlXG4gICAgICAgICAgICAgIHNwYXJrLnNjYWxlLm11bHRpcGx5U2NhbGFyKDEuMDMpOyAvLyBFeHBhbmRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQW5pbWF0ZSB0YWlsIHNoaW1tZXIgYW5kIGNvbG9yIGN5Y2xpbmdcbiAgICAgICAgaWYgKG9iai50YWlsICYmIG9iai50cmFpbFBvaW50cykge1xuICAgICAgICAgIGNvbnN0IHRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAqIDAuMDAxO1xuICAgICAgICAgIGNvbnN0IHRhaWxHZW8gPSBvYmoudGFpbC5nZW9tZXRyeTtcbiAgICAgICAgICBjb25zdCB0YWlsQ29sb3JzID0gdGFpbEdlby5nZXRBdHRyaWJ1dGUoJ2NvbG9yJyk7XG4gICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCB0YWlsQ29sb3JzLmNvdW50OyBrKyspIHtcbiAgICAgICAgICAgIC8vIEN5Y2xlIGh1ZVxuICAgICAgICAgICAgbGV0IHIgPSB0YWlsQ29sb3JzLmdldFgoayksIGcgPSB0YWlsQ29sb3JzLmdldFkoayksIGIgPSB0YWlsQ29sb3JzLmdldFooayk7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRvIEhTTFxuICAgICAgICAgICAgY29uc3QgbWF4ID0gTWF0aC5tYXgocixnLGIpLCBtaW4gPSBNYXRoLm1pbihyLGcsYik7XG4gICAgICAgICAgICBsZXQgaCxzLGw7XG4gICAgICAgICAgICBsID0gKG1heCttaW4pLzI7XG4gICAgICAgICAgICBpZiAobWF4ID09PSBtaW4pIHtoID0gcyA9IDA7fSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3QgZCA9IG1heC1taW47XG4gICAgICAgICAgICAgIHMgPSBsID4gMC41ID8gZC8oMi1tYXgtbWluKSA6IGQvKG1heCttaW4pO1xuICAgICAgICAgICAgICBzd2l0Y2gobWF4KXtcbiAgICAgICAgICAgICAgICBjYXNlIHI6IGggPSAoZy1iKS9kICsgKGc8Yj82OjApOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIGc6IGggPSAoYi1yKS9kICsgMjsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBiOiBoID0gKHItZykvZCArIDQ7IGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGgvPTY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoID0gKGggKyAwLjI1Kk1hdGguc2luKHRpbWUgKyBrKjAuMikpICUgMS4wOyAvLyBBbmltYXRlIGh1ZVxuICAgICAgICAgICAgLy8gQ29udmVydCBiYWNrIHRvIFJHQlxuICAgICAgICAgICAgbGV0IHEgPSBsIDwgMC41ID8gbCooMStzKSA6IGwrcy1sKnM7XG4gICAgICAgICAgICBsZXQgcCA9IDIqbC1xO1xuICAgICAgICAgICAgbGV0IHRyID0gaCsxLzMsIHRnID0gaCwgdGIgPSBoLTEvMztcbiAgICAgICAgICAgIGNvbnN0IGh1ZTJyZ2IgPSAocCxxLHQpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHQ8MCkgdCs9MTsgaWYgKHQ+MSkgdC09MTtcbiAgICAgICAgICAgICAgaWYgKHQ8MS82KSByZXR1cm4gcCsocS1wKSo2KnQ7XG4gICAgICAgICAgICAgIGlmICh0PDEvMikgcmV0dXJuIHE7XG4gICAgICAgICAgICAgIGlmICh0PDIvMykgcmV0dXJuIHArKHEtcCkqKDIvMy10KSo2O1xuICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0YWlsQ29sb3JzLnNldFgoaywgaHVlMnJnYihwLHEsdHIpKTtcbiAgICAgICAgICAgIHRhaWxDb2xvcnMuc2V0WShrLCBodWUycmdiKHAscSx0ZykpO1xuICAgICAgICAgICAgdGFpbENvbG9ycy5zZXRaKGssIGh1ZTJyZ2IocCxxLHRiKSk7XG4gICAgICAgICAgICAvLyBTaGltbWVyOiBtb2R1bGF0ZSBhbHBoYVxuICAgICAgICAgICAgdGFpbENvbG9ycy5zZXRXKGssIHRhaWxDb2xvcnMuZ2V0VyhrKSAqICgwLjk3ICsgMC4wMypNYXRoLnNpbih0aW1lKjggKyBrKSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0YWlsQ29sb3JzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdHJhaWdodC1saW5lIHRyYWplY3RvcnlcbiAgICAgICAgb2JqLm1lc2gucG9zaXRpb24uYWRkKG9iai52ZWxvY2l0eSk7XG4gICAgICAgIG9iai50YWlsLnBvc2l0aW9uLmNvcHkob2JqLm1lc2gucG9zaXRpb24pO1xuICAgICAgICAvLyBBbmltYXRlIHRhaWwgKG5vIGxlcnAsIGp1c3QgZHJhZylcbiAgICAgICAgb2JqLmFnZSsrO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkTGlmZSA9IG9iai5hZ2UgLyBvYmoubm9ybWFsaXplZExpZmV0aW1lO1xuICAgICAgICBvYmoudHJhaWxQb2ludHMudW5zaGlmdChvYmoubWVzaC5wb3NpdGlvbi5jbG9uZSgpKTtcbiAgICAgICAgaWYgKG9iai50cmFpbFBvaW50cy5sZW5ndGggPiB0YWlsTGVuZ3RoICogMykgb2JqLnRyYWlsUG9pbnRzLnBvcCgpO1xuICAgICAgICBsZXQgdGFpbEdyb3cgPSBNYXRoLm1pbigxLCBub3JtYWxpemVkTGlmZSAvIDAuMyk7XG4gICAgICAgIGxldCBhY3RpdmVTZWdtZW50cyA9IE1hdGguZmxvb3Iob2JqLnRyYWlsUG9pbnRzLmxlbmd0aCAqIHRhaWxHcm93KTtcbiAgICAgICAgaWYgKGFjdGl2ZVNlZ21lbnRzIDwgMikgYWN0aXZlU2VnbWVudHMgPSAyO1xuICAgICAgICBjb25zdCB2aXNpYmxlVHJhaWwgPSBvYmoudHJhaWxQb2ludHMuc2xpY2UoMCwgYWN0aXZlU2VnbWVudHMpO1xuICAgICAgICBvYmoudGFpbC5nZW9tZXRyeS5zZXRGcm9tUG9pbnRzKHZpc2libGVUcmFpbCk7XG4gICAgICAgIGNvbnN0IHRhaWxDb2xvcnMgPSBvYmoudGFpbC5nZW9tZXRyeS5nZXRBdHRyaWJ1dGUoJ2NvbG9yJyk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmlzaWJsZVRyYWlsLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgbGV0IGFscGhhID0gKDEgLSBqIC8gKHZpc2libGVUcmFpbC5sZW5ndGggLSAxKSkgKiAwLjk1O1xuICAgICAgICAgIGFscGhhICo9IDAuOTIgKyAwLjA4ICogTWF0aC5zaW4oRGF0ZS5ub3coKSowLjAxNSArIGoqMC41KTtcbiAgICAgICAgICBsZXQgcmFpbmJvdyA9IFsweGZmYzA4MCwgMHhmZmUwODAsIDB4ZmZmZjgwLCAweDgwZmZlNiwgMHg4MGMwZmYsIDB4YzA4MGZmXTtcbiAgICAgICAgICBsZXQgZ3JhZENvbG9yID0gcmFpbmJvd1tqICUgcmFpbmJvdy5sZW5ndGhdO1xuICAgICAgICAgIGlmIChub3JtYWxpemVkTGlmZSA+IDAuNykgYWxwaGEgKj0gTWF0aC5tYXgoMCwgMSAtIChub3JtYWxpemVkTGlmZSAtIDAuNyAtIDAuMikgLyAwLjMpO1xuICAgICAgICAgIHRhaWxDb2xvcnMuc2V0WFlaVyhqLCAoZ3JhZENvbG9yID4+IDE2ICYgMjU1KSAvIDI1NSwgKGdyYWRDb2xvciA+PiA4ICYgMjU1KSAvIDI1NSwgKGdyYWRDb2xvciAmIDI1NSkgLyAyNTUsIGFscGhhKTtcbiAgICAgICAgfVxuICAgICAgICB0YWlsQ29sb3JzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgLy8gQW5pbWF0ZSBoZWFkXG4gICAgICAgIGxldCBoZWFkQ29sb3I7XG4gICAgICAgIGlmIChub3JtYWxpemVkTGlmZSA8IDAuNSkge1xuICAgICAgICAgIGhlYWRDb2xvciA9IG5ldyBUSFJFRS5Db2xvcihvYmouY29sb3IpLmxlcnAobmV3IFRIUkVFLkNvbG9yKDB4ZmZjMDgwKSwgbm9ybWFsaXplZExpZmUqMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGVhZENvbG9yID0gbmV3IFRIUkVFLkNvbG9yKDB4ZmZjMDgwKS5sZXJwKG5ldyBUSFJFRS5Db2xvcigweGZmNDAwMCksIChub3JtYWxpemVkTGlmZS0wLjUpKjIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmbGlja2VyID0gMC45NSArIDAuMTMgKiBNYXRoLnNpbihEYXRlLm5vdygpKjAuMDcgKyBNYXRoLnJhbmRvbSgpKjEwKTtcbiAgICAgICAgaGVhZENvbG9yLm11bHRpcGx5U2NhbGFyKGZsaWNrZXIpO1xuICAgICAgICBvYmoubWVzaC5tYXRlcmlhbC5jb2xvci5jb3B5KGhlYWRDb2xvcik7XG4gICAgICAgIGxldCBzY2FsZSA9IDEgKyAyLjIgKiBNYXRoLnNpbihNYXRoLlBJICogbm9ybWFsaXplZExpZmUpO1xuICAgICAgICBsZXQgZGlzdFRvQ2FtID0gb2JqLm1lc2gucG9zaXRpb24ubGVuZ3RoKCk7XG4gICAgICAgIGxldCBkb2ZCbHVyID0gZGlzdFRvQ2FtIDwgc3Rhck1heERpc3RhbmNlICogMC43ID8gMC43IDogMS4wO1xuICAgICAgICBvYmoubWVzaC5zY2FsZS5zZXQoc2NhbGUgKiBkb2ZCbHVyLCBzY2FsZSAqIGRvZkJsdXIsIHNjYWxlICogZG9mQmx1cik7XG4gICAgICAgIC8vIFNwYXJrbGUgYnVyc3RcbiAgICAgICAgaWYgKG5vcm1hbGl6ZWRMaWZlID49IDEgJiYgIW9iai5oYXNGcmFnbWVudGVkKSB7XG4gICAgICAgICAgLy8gLS0tIFNQRUNUQUNVTEFSIEVYUExPU0lPTiAodmVyeSByYXJlKSAtLS1cbiAgICAgICAgICBjb25zdCBzcGVjdGFjdWxhciA9IE1hdGgucmFuZG9tKCkgPCAwLjAyOyAvLyAyJSBjaGFuY2VcbiAgICAgICAgICBjb25zdCBidXJzdENvdW50ID0gc3BlY3RhY3VsYXIgPyAxMjAgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqNjApIDogMTggKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqOCk7XG4gICAgICAgICAgY29uc3QgcGFsZXR0ZSA9IHNwZWN0YWN1bGFyXG4gICAgICAgICAgICA/IFsweGZmZTA2NiwgMHhmZjY2Y2MsIDB4NjZjY2ZmLCAweGZmZmZmZiwgMHg4MGZmZWEsIDB4ZmZmMmNjLCAweGZmYzA4MCwgMHg4MGMwZmYsIDB4ZmY4MGIzLCAweGZmMDAwMCwgMHgwMGZmMDAsIDB4MDAwMGZmLCAweGZmZmYwMCwgMHgwMGZmZmYsIDB4ZmYwMGZmLCAweGZmODgwMCwgMHgwMGZmODgsIDB4ODgwMGZmXVxuICAgICAgICAgICAgOiBbMHhmZmZmZmYsIDB4ZmZmNmMwLCAweGZmZTA2NiwgMHhmZmMwODAsIDB4ODBjMGZmXTtcbiAgICAgICAgICBmb3IgKGxldCBzID0gMDsgcyA8IGJ1cnN0Q291bnQ7IHMrKykge1xuICAgICAgICAgICAgY29uc3QgY29sb3IgPSBwYWxldHRlW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSpwYWxldHRlLmxlbmd0aCldO1xuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHNwZWN0YWN1bGFyID8gKDEuMiArIE1hdGgucmFuZG9tKCkqMi4yKSA6ICgwLjcgKyBNYXRoLnJhbmRvbSgpKjAuOCk7XG4gICAgICAgICAgICBjb25zdCBzcGFya2xlR2VvID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KHNpemUsIDgsIDgpO1xuICAgICAgICAgICAgY29uc3Qgc3BhcmtsZU1hdCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7IGNvbG9yLCB0cmFuc3BhcmVudDogdHJ1ZSwgb3BhY2l0eTogc3BlY3RhY3VsYXIgPyAwLjkyIDogMC43LCBibGVuZGluZzogVEhSRUUuQWRkaXRpdmVCbGVuZGluZyB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNwYXJrbGUgPSBuZXcgVEhSRUUuTWVzaChzcGFya2xlR2VvLCBzcGFya2xlTWF0KTtcbiAgICAgICAgICAgIHNwYXJrbGUucG9zaXRpb24uY29weShvYmoubWVzaC5wb3NpdGlvbik7XG4gICAgICAgICAgICAvLyBTcGVjdGFjdWxhcjogaHVnZSwgZmFzdCwgcmFuZG9tIGRpcmVjdGlvbnM7IG5vcm1hbDogbW9kZXJhdGVcbiAgICAgICAgICAgIGNvbnN0IHNwZCA9IHNwZWN0YWN1bGFyID8gKDQgKyBNYXRoLnJhbmRvbSgpKjgpIDogKDIgKyBNYXRoLnJhbmRvbSgpKjIpO1xuICAgICAgICAgICAgY29uc3Qgc3BhcmtsZVZlbCA9IG5ldyBUSFJFRS5WZWN0b3IzKE1hdGgucmFuZG9tKCktMC41LCBNYXRoLnJhbmRvbSgpLTAuNSwgTWF0aC5yYW5kb20oKS0wLjUpLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKHNwZCk7XG4gICAgICAgICAgICBzcGFya2xlLnVzZXJEYXRhID0geyB2ZWxvY2l0eTogc3BhcmtsZVZlbCwgYWdlOiAwLCBzcGVjdGFjdWxhciwgbWF4QWdlOiBzcGVjdGFjdWxhciA/IDgwICsgTWF0aC5yYW5kb20oKSo0MCA6IDQwICsgTWF0aC5yYW5kb20oKSoyMCB9OyAvLyA8LS0gTE9OR0VSIExJRkVcbiAgICAgICAgICAgIHNjZW5lLmFkZChzcGFya2xlKTtcbiAgICAgICAgICAgIGlmICghd2luZG93Ll9zcGFya2xlcykgd2luZG93Ll9zcGFya2xlcyA9IFtdO1xuICAgICAgICAgICAgd2luZG93Ll9zcGFya2xlcy5wdXNoKHNwYXJrbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3BlY3RhY3VsYXIpIHtcbiAgICAgICAgICAgIC8vIEFkZCBhIGJpZyBmbGFzaFxuICAgICAgICAgICAgY29uc3QgZmxhc2hHZW8gPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoNiwgMjQsIDI0KTtcbiAgICAgICAgICAgIGNvbnN0IGZsYXNoTWF0ID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHsgY29sb3I6IDB4ZmZmZmZmLCB0cmFuc3BhcmVudDogdHJ1ZSwgb3BhY2l0eTogMC44LCBibGVuZGluZzogVEhSRUUuQWRkaXRpdmVCbGVuZGluZyB9KTtcbiAgICAgICAgICAgIGNvbnN0IGZsYXNoID0gbmV3IFRIUkVFLk1lc2goZmxhc2hHZW8sIGZsYXNoTWF0KTtcbiAgICAgICAgICAgIGZsYXNoLnBvc2l0aW9uLmNvcHkob2JqLm1lc2gucG9zaXRpb24pO1xuICAgICAgICAgICAgc2NlbmUuYWRkKGZsYXNoKTtcbiAgICAgICAgICAgIGlmICghd2luZG93Ll9zdGFyRmxhc2hlcykgd2luZG93Ll9zdGFyRmxhc2hlcyA9IFtdO1xuICAgICAgICAgICAgd2luZG93Ll9zdGFyRmxhc2hlcy5wdXNoKHsgbWVzaDogZmxhc2gsIGFnZTogMCB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gRnJhZ21lbnRlZCB0cmFpbCBsb2dpYyAoa2VlcCBhcyBiZWZvcmUpXG4gICAgICAgICAgY29uc3QgZnJhZ1ZlbCA9IG9iai52ZWxvY2l0eS5jbG9uZSgpLmFwcGx5QXhpc0FuZ2xlKG5ldyBUSFJFRS5WZWN0b3IzKDAsMSwwKSwgKE1hdGgucmFuZG9tKCktMC41KSowLjMpO1xuICAgICAgICAgIGNvbnN0IGZyYWdTdGFyID0gb2JqLm1lc2guY2xvbmUoKTtcbiAgICAgICAgICBmcmFnU3Rhci5wb3NpdGlvbi5jb3B5KG9iai5tZXNoLnBvc2l0aW9uKTtcbiAgICAgICAgICBmcmFnU3Rhci52ZWxvY2l0eSA9IGZyYWdWZWw7XG4gICAgICAgICAgZnJhZ1N0YXIubm9ybWFsaXplZExpZmUgPSBub3JtYWxpemVkTGlmZTtcbiAgICAgICAgICBmcmFnU3Rhci5ub3JtYWxpemVkTGlmZXRpbWUgPSBvYmoubm9ybWFsaXplZExpZmV0aW1lICogKDAuNSArIE1hdGgucmFuZG9tKCkqMC41KTtcbiAgICAgICAgICBmcmFnU3Rhci5hZ2UgPSBvYmouYWdlO1xuICAgICAgICAgIGZyYWdTdGFyLm1hdGVyaWFsID0gb2JqLm1lc2gubWF0ZXJpYWwuY2xvbmUoKTtcbiAgICAgICAgICBjb25zdCBmcmFnVHJhaWxQb2ludHMgPSBvYmoudHJhaWxQb2ludHMuc2xpY2UoKTtcbiAgICAgICAgICBjb25zdCBmcmFnVGFpbEdlbyA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpLnNldEZyb21Qb2ludHMoZnJhZ1RyYWlsUG9pbnRzKTtcbiAgICAgICAgICBmcmFnVGFpbEdlby5zZXRBdHRyaWJ1dGUoJ2NvbG9yJywgb2JqLnRhaWwuZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCdjb2xvcicpLmNsb25lKCkpO1xuICAgICAgICAgIGNvbnN0IGZyYWdUYWlsTWF0ID0gb2JqLnRhaWwubWF0ZXJpYWwuY2xvbmUoKTtcbiAgICAgICAgICBjb25zdCBmcmFnVGFpbCA9IG5ldyBUSFJFRS5MaW5lKGZyYWdUYWlsR2VvLCBmcmFnVGFpbE1hdCk7XG4gICAgICAgICAgZnJhZ1RhaWwucG9zaXRpb24uY29weShmcmFnU3Rhci5wb3NpdGlvbik7XG4gICAgICAgICAgc2NlbmUuYWRkKGZyYWdTdGFyKTtcbiAgICAgICAgICBzY2VuZS5hZGQoZnJhZ1RhaWwpO1xuICAgICAgICAgIHNob290aW5nU3RhcnMucHVzaCh7IG1lc2g6IGZyYWdTdGFyLCB0YWlsOiBmcmFnVGFpbCwgdmVsb2NpdHk6IGZyYWdTdGFyLnZlbG9jaXR5LCBkaXI6IG9iai5kaXIsIGFnZTogZnJhZ1N0YXIuYWdlLCBub3JtYWxpemVkTGlmZXRpbWU6IGZyYWdTdGFyLm5vcm1hbGl6ZWRMaWZldGltZSwgdHJhaWxQb2ludHM6IGZyYWdUcmFpbFBvaW50cywgY29sb3I6IG9iai5jb2xvciwgYnJpZ2h0bmVzczogb2JqLmJyaWdodG5lc3MsIGhhc0ZyYWdtZW50ZWQ6IHRydWUgfSk7XG4gICAgICAgICAgb2JqLmhhc0ZyYWdtZW50ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNwYXJrIGJ1cnN0XG4gICAgICAgIGlmICghb2JqLmhhc1NwYXJrZWQgJiYgbm9ybWFsaXplZExpZmUgPiAwLjk1ICYmIE1hdGgucmFuZG9tKCkgPCAwLjEpIHtcbiAgICAgICAgICBmb3IgKGxldCBzID0gMDsgcyA8IDggKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqOCk7IHMrKykge1xuICAgICAgICAgICAgY29uc3Qgc3BhcmtHZW8gPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoMC41ICsgTWF0aC5yYW5kb20oKSowLjUsIDgsIDgpO1xuICAgICAgICAgICAgY29uc3Qgc3BhcmtNYXQgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoeyBjb2xvcjogMHhmZmY2YzAsIHRyYW5zcGFyZW50OiB0cnVlLCBvcGFjaXR5OiAxLCBibGVuZGluZzogVEhSRUUuQWRkaXRpdmVCbGVuZGluZyB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNwYXJrID0gbmV3IFRIUkVFLk1lc2goc3BhcmtHZW8sIHNwYXJrTWF0KTtcbiAgICAgICAgICAgIHNwYXJrLnBvc2l0aW9uLmNvcHkob2JqLm1lc2gucG9zaXRpb24pO1xuICAgICAgICAgICAgc3Bhcmsuc3BhcmtWZWwgPSBuZXcgVEhSRUUuVmVjdG9yMyhNYXRoLnJhbmRvbSgpLTAuNSwgTWF0aC5yYW5kb20oKS0wLjUsIE1hdGgucmFuZG9tKCktMC41KS5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhcigwLjUgKyBNYXRoLnJhbmRvbSgpKjEuMik7XG4gICAgICAgICAgICBzcGFyay5zcGFya0xpZmUgPSAxMiArIE1hdGgucmFuZG9tKCkqMTA7XG4gICAgICAgICAgICBzcGFyay5zcGFya0FnZSA9IDA7XG4gICAgICAgICAgICBzY2VuZS5hZGQoc3BhcmspO1xuICAgICAgICAgICAgaWYgKCF3aW5kb3cuX3N0YXJTcGFya3MpIHdpbmRvdy5fc3RhclNwYXJrcyA9IFtdO1xuICAgICAgICAgICAgd2luZG93Ll9zdGFyU3BhcmtzLnB1c2goc3BhcmspO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvYmouaGFzU3BhcmtlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmxhc2hcbiAgICAgICAgaWYgKCFvYmouaGFzRmxhc2hlZCAmJiBub3JtYWxpemVkTGlmZSA+IDAuOTggJiYgTWF0aC5yYW5kb20oKSA8IDAuMikge1xuICAgICAgICAgIGNvbnN0IGZsYXNoR2VvID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KDEsIDE2LCAxNik7XG4gICAgICAgICAgY29uc3QgZmxhc2hNYXQgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoeyBjb2xvcjogMHhmZmZmZWUsIHRyYW5zcGFyZW50OiB0cnVlLCBvcGFjaXR5OiAwLjgsIGJsZW5kaW5nOiBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nIH0pO1xuICAgICAgICAgIGNvbnN0IGZsYXNoID0gbmV3IFRIUkVFLk1lc2goZmxhc2hHZW8sIGZsYXNoTWF0KTtcbiAgICAgICAgICBmbGFzaC5wb3NpdGlvbi5jb3B5KG9iai5tZXNoLnBvc2l0aW9uKTtcbiAgICAgICAgICBzY2VuZS5hZGQoZmxhc2gpO1xuICAgICAgICAgIGlmICghd2luZG93Ll9zdGFyRmxhc2hlcykgd2luZG93Ll9zdGFyRmxhc2hlcyA9IFtdO1xuICAgICAgICAgIHdpbmRvdy5fc3RhckZsYXNoZXMucHVzaCh7IG1lc2g6IGZsYXNoLCBhZ2U6IDAgfSk7XG4gICAgICAgICAgb2JqLmhhc0ZsYXNoZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZhZGUgb3V0IGFzIGl0IGdldHMgZmFyIGF3YXlcbiAgICAgICAgY29uc3QgZGlzdCA9IG9iai5tZXNoLnBvc2l0aW9uLmRpc3RhbmNlVG8oY2FtZXJhLnBvc2l0aW9uKTtcbiAgICAgICAgY29uc3QgZmFkZVN0YXJ0ID0gc3Rhck1heERpc3RhbmNlICogMC41O1xuICAgICAgICBpZiAoZGlzdCA+IGZhZGVTdGFydCkge1xuICAgICAgICAgIGNvbnN0IGZhZGUgPSAxIC0gKGRpc3QgLSBmYWRlU3RhcnQpIC8gKHN0YXJNYXhEaXN0YW5jZSAtIGZhZGVTdGFydCk7XG4gICAgICAgICAgb2JqLm1lc2gubWF0ZXJpYWwub3BhY2l0eSA9IE1hdGgubWF4KDAsIGZhZGUpO1xuICAgICAgICAgIG9iai5tZXNoLm1hdGVyaWFsLnRyYW5zcGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgICBvYmoudGFpbC5tYXRlcmlhbC5vcGFjaXR5ID0gTWF0aC5tYXgoMCwgZmFkZSAqIDAuOCk7XG4gICAgICAgICAgb2JqLnRhaWwubWF0ZXJpYWwudHJhbnNwYXJlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSB3aGVuIG91dCBvZiBib3VuZHMgb3IgZnVsbHkgZmFkZWQgb3IgbGlmZSBlbmRlZFxuICAgICAgICBpZiAobm9ybWFsaXplZExpZmUgPj0gMS4wIHx8IGRpc3QgPiBzdGFyTWF4RGlzdGFuY2UgfHwgb2JqLm1lc2gubWF0ZXJpYWwub3BhY2l0eSA8PSAwLjAxKSB7XG4gICAgICAgICAgc2NlbmUucmVtb3ZlKG9iai5tZXNoKTtcbiAgICAgICAgICBzY2VuZS5yZW1vdmUob2JqLnRhaWwpO1xuICAgICAgICAgIHNob290aW5nU3RhcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBBbmltYXRlIHNwYXJrc1xuICAgICAgaWYgKHdpbmRvdy5fc3RhclNwYXJrcykge1xuICAgICAgICBmb3IgKGxldCBpID0gd2luZG93Ll9zdGFyU3BhcmtzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgY29uc3Qgc3BhcmsgPSB3aW5kb3cuX3N0YXJTcGFya3NbaV07XG4gICAgICAgICAgc3BhcmsucG9zaXRpb24uYWRkKHNwYXJrLnNwYXJrVmVsKTtcbiAgICAgICAgICBzcGFyay5zcGFya0FnZSsrO1xuICAgICAgICAgIHNwYXJrLm1hdGVyaWFsLm9wYWNpdHkgKj0gMC45MjtcbiAgICAgICAgICBpZiAoc3Bhcmsuc3BhcmtBZ2UgPiBzcGFyay5zcGFya0xpZmUpIHtcbiAgICAgICAgICAgIHNjZW5lLnJlbW92ZShzcGFyayk7XG4gICAgICAgICAgICB3aW5kb3cuX3N0YXJTcGFya3Muc3BsaWNlKGksIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQW5pbWF0ZSBleHBsb3Npb24gcGFydGljbGVzIChzcGFya2xlcylcbiAgICAgIGlmICh3aW5kb3cuX3NwYXJrbGVzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB3aW5kb3cuX3NwYXJrbGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgY29uc3Qgc3BhcmtsZSA9IHdpbmRvdy5fc3BhcmtsZXNbaV07XG4gICAgICAgICAgc3BhcmtsZS5wb3NpdGlvbi5hZGQoc3BhcmtsZS51c2VyRGF0YS52ZWxvY2l0eSk7XG4gICAgICAgICAgc3BhcmtsZS51c2VyRGF0YS5hZ2UrKztcbiAgICAgICAgICBzcGFya2xlLm1hdGVyaWFsLm9wYWNpdHkgKj0gMC45NztcbiAgICAgICAgICBpZiAoc3BhcmtsZS51c2VyRGF0YS5hZ2UgPiAoc3BhcmtsZS51c2VyRGF0YS5tYXhBZ2UgfHwgNDApKSB7XG4gICAgICAgICAgICBzY2VuZS5yZW1vdmUoc3BhcmtsZSk7XG4gICAgICAgICAgICB3aW5kb3cuX3NwYXJrbGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEFuaW1hdGUgZmxhc2hlc1xuICAgICAgaWYgKHdpbmRvdy5fc3RhckZsYXNoZXMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHdpbmRvdy5fc3RhckZsYXNoZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBjb25zdCBmbGFzaCA9IHdpbmRvdy5fc3RhckZsYXNoZXNbaV07XG4gICAgICAgICAgZmxhc2gubWVzaC5zY2FsZS5tdWx0aXBseVNjYWxhcigxLjE1KTtcbiAgICAgICAgICBmbGFzaC5tZXNoLm1hdGVyaWFsLm9wYWNpdHkgKj0gMC44NTtcbiAgICAgICAgICBmbGFzaC5hZ2UrKztcbiAgICAgICAgICBpZiAoZmxhc2guYWdlID4gMTApIHtcbiAgICAgICAgICAgIHNjZW5lLnJlbW92ZShmbGFzaC5tZXNoKTtcbiAgICAgICAgICAgIHdpbmRvdy5fc3RhckZsYXNoZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyAtLS0gU3RhcmZpZWxkIGxvZ2ljIC0tLVxuICAgICAgY29uc3Qgc3FEaXN0ID0gc3Rhck1heERpc3RhbmNlICogc3Rhck1heERpc3RhbmNlO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3NpdGlvbnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgY29uc3QgZHggPSBwb3NpdGlvbnNbaV0gLSB2aXJ0dWFsQ2FtZXJhUG9zLng7XG4gICAgICAgIGNvbnN0IGR5ID0gcG9zaXRpb25zW2kgKyAxXSAtIHZpcnR1YWxDYW1lcmFQb3MueTtcbiAgICAgICAgY29uc3QgZHogPSBwb3NpdGlvbnNbaSArIDJdIC0gdmlydHVhbENhbWVyYVBvcy56O1xuICAgICAgICBpZiAoZHgqZHggKyBkeSpkeSArIGR6KmR6ID4gc3FEaXN0KSB7XG4gICAgICAgICAgLy8gUGxhY2UgaW4gYSB0aGljayBzcGhlcmljYWwgc2hlbGwgYXJvdW5kIHRoZSB2aXJ0dWFsIGNhbWVyYSwgbmV2ZXIgdG9vIGNsb3NlXG4gICAgICAgICAgY29uc3QgbWluUmFkaXVzID0gc3Rhck1heERpc3RhbmNlICogMC44O1xuICAgICAgICAgIGNvbnN0IG1heFJhZGl1cyA9IHN0YXJNYXhEaXN0YW5jZTtcbiAgICAgICAgICBjb25zdCByID0gbWluUmFkaXVzICsgTWF0aC5yYW5kb20oKSAqIChtYXhSYWRpdXMgLSBtaW5SYWRpdXMpO1xuICAgICAgICAgIGNvbnN0IHRoZXRhID0gTWF0aC5yYW5kb20oKSAqIDIgKiBNYXRoLlBJO1xuICAgICAgICAgIGNvbnN0IHBoaSA9IE1hdGguYWNvcygyICogTWF0aC5yYW5kb20oKSAtIDEpO1xuICAgICAgICAgIHBvc2l0aW9uc1tpXSA9IHZpcnR1YWxDYW1lcmFQb3MueCArIHIgKiBNYXRoLnNpbihwaGkpICogTWF0aC5jb3ModGhldGEpO1xuICAgICAgICAgIHBvc2l0aW9uc1tpKzFdID0gdmlydHVhbENhbWVyYVBvcy55ICsgciAqIE1hdGguc2luKHBoaSkgKiBNYXRoLnNpbih0aGV0YSk7XG4gICAgICAgICAgcG9zaXRpb25zW2krMl0gPSB2aXJ0dWFsQ2FtZXJhUG9zLnogKyByICogTWF0aC5jb3MocGhpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7IC8vIEFscmVhZHkgc2V0IGFib3ZlXG5cbiAgICAgIC8vIFJvYnVzdCBzdGFyZmllbGQgY29sb3IgdXBkYXRlIHRvIHByZXZlbnQgc3R1Y2sgd2hpdGUgZG90c1xuICAgICAgY29uc3QgY29sQXJyID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvci5hcnJheTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IGkgLyAzO1xuICAgICAgICBjb25zdCBkeCA9IHBvc2l0aW9uc1tpXSAtIHZpcnR1YWxDYW1lcmFQb3MueDtcbiAgICAgICAgY29uc3QgZHkgPSBwb3NpdGlvbnNbaSArIDFdIC0gdmlydHVhbENhbWVyYVBvcy55O1xuICAgICAgICBjb25zdCBkeiA9IHBvc2l0aW9uc1tpICsgMl0gLSB2aXJ0dWFsQ2FtZXJhUG9zLno7XG4gICAgICAgIGNvbnN0IGRpc3QgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkgKyBkeiAqIGR6KTtcbiAgICAgICAgaWYgKHRpbWVyc1tpZHhdID4gMCkge1xuICAgICAgICAgIHRpbWVyc1tpZHhdLS07XG4gICAgICAgICAgaWYgKHRpbWVyc1tpZHhdID09PSAwKSB7XG4gICAgICAgICAgICAvLyBUaW1lciBleHBpcmVkLCByZXN0b3JlIGNvbG9yXG4gICAgICAgICAgICBzcGFya0NvbG9yc1tpXSA9IG9yaWdpbmFsQ29sb3JzW2ldO1xuICAgICAgICAgICAgc3BhcmtDb2xvcnNbaSsxXSA9IG9yaWdpbmFsQ29sb3JzW2krMV07XG4gICAgICAgICAgICBzcGFya0NvbG9yc1tpKzJdID0gb3JpZ2luYWxDb2xvcnNbaSsyXTtcbiAgICAgICAgICAgIGNvbEFycltpXSA9IG9yaWdpbmFsQ29sb3JzW2ldO1xuICAgICAgICAgICAgY29sQXJyW2krMV0gPSBvcmlnaW5hbENvbG9yc1tpKzFdO1xuICAgICAgICAgICAgY29sQXJyW2krMl0gPSBvcmlnaW5hbENvbG9yc1tpKzJdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2xBcnJbaV0gPSBzcGFya0NvbG9yc1tpXTtcbiAgICAgICAgICAgIGNvbEFycltpKzFdID0gc3BhcmtDb2xvcnNbaSsxXTtcbiAgICAgICAgICAgIGNvbEFycltpKzJdID0gc3BhcmtDb2xvcnNbaSsyXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZGlzdCA+IHN0YXJNYXhEaXN0YW5jZSAqIDAuMyAmJiBNYXRoLnJhbmRvbSgpIDwgMC4wNSkge1xuICAgICAgICAgIHRpbWVyc1tpZHhdID0gc3BhcmtsZUR1cmF0aW9uO1xuICAgICAgICAgIGNvbnN0IGMgPSBwYWxldHRlW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHBhbGV0dGUubGVuZ3RoKV07XG4gICAgICAgICAgc3BhcmtDb2xvcnNbaV0gPSBjWzBdO1xuICAgICAgICAgIHNwYXJrQ29sb3JzW2krMV0gPSBjWzFdO1xuICAgICAgICAgIHNwYXJrQ29sb3JzW2krMl0gPSBjWzJdO1xuICAgICAgICAgIGNvbEFycltpXSA9IHNwYXJrQ29sb3JzW2ldO1xuICAgICAgICAgIGNvbEFycltpKzFdID0gc3BhcmtDb2xvcnNbaSsxXTtcbiAgICAgICAgICBjb2xBcnJbaSsyXSA9IHNwYXJrQ29sb3JzW2krMl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3BhcmtDb2xvcnNbaV0gPSBvcmlnaW5hbENvbG9yc1tpXTtcbiAgICAgICAgICBzcGFya0NvbG9yc1tpKzFdID0gb3JpZ2luYWxDb2xvcnNbaSsxXTtcbiAgICAgICAgICBzcGFya0NvbG9yc1tpKzJdID0gb3JpZ2luYWxDb2xvcnNbaSsyXTtcbiAgICAgICAgICBjb2xBcnJbaV0gPSBvcmlnaW5hbENvbG9yc1tpXTtcbiAgICAgICAgICBjb2xBcnJbaSsxXSA9IG9yaWdpbmFsQ29sb3JzW2krMV07XG4gICAgICAgICAgY29sQXJyW2krMl0gPSBvcmlnaW5hbENvbG9yc1tpKzJdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBnZW9tZXRyeS5hdHRyaWJ1dGVzLmNvbG9yLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgY29tcG9zZXIucmVuZGVyKCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gRGVmZW5zaXZlOiBsb2cgZXJyb3Igd2l0aCBjb250ZXh0XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1N0YXJmaWVsZCBhbmltYXRpb24gZXJyb3I6JywgZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgYW5pbWF0ZSgpOyAvLyBTdGFydCB0aGUgcmVuZGVyIGxvb3BcblxuICAgIGNvbnN0IG9uUmVzaXplID0gKCkgPT4ge1xuICAgICAgY2FtZXJhLmFzcGVjdCA9IHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICB9XG4gIH0sIFtdKVxuXG4gIHJldHVybiA8ZGl2IHJlZj17bW91bnRSZWZ9IC8+XG59XG5leHBvcnQgZGVmYXVsdCBTdGFyZmllbGRcblxuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlRWZmZWN0IiwidXNlUmVmIiwiVEhSRUUiLCJFZmZlY3RDb21wb3NlciIsIlVucmVhbEJsb29tUGFzcyIsIlJlbmRlclBhc3MiLCJDaHJvbWF0aWNBYmVycmF0aW9uUGFzcyIsIlN0YXJmaWVsZCIsIm1vdW50UmVmIiwiY3VycmVudCIsIm1vdW50Iiwic3R5bGUiLCJwb3NpdGlvbiIsInRvcCIsImxlZnQiLCJ3aWR0aCIsImhlaWdodCIsInpJbmRleCIsInNjZW5lIiwiU2NlbmUiLCJjYW1lcmEiLCJQZXJzcGVjdGl2ZUNhbWVyYSIsIndpbmRvdyIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsInNldCIsInZpcnR1YWxDYW1lcmFQb3MiLCJWZWN0b3IzIiwicmVuZGVyZXIiLCJXZWJHTFJlbmRlcmVyIiwiYW50aWFsaWFzIiwic2V0UGl4ZWxSYXRpbyIsImRldmljZVBpeGVsUmF0aW8iLCJzZXRTaXplIiwic2V0Q2xlYXJDb2xvciIsImFwcGVuZENoaWxkIiwiZG9tRWxlbWVudCIsImNvbXBvc2VyIiwicmVuZGVyUGFzcyIsImFkZFBhc3MiLCJibG9vbVBhc3MiLCJWZWN0b3IyIiwiY2xvc2VTdGFyc1NjZW5lIiwiY2FQYXNzIiwiY2FDb21wb3NlciIsImNhUmVuZGVyUGFzcyIsInJlc2l6ZUFsbCIsImFzcGVjdCIsInVwZGF0ZVByb2plY3Rpb25NYXRyaXgiLCJhZGRFdmVudExpc3RlbmVyIiwic3RhckNvdW50Iiwic3Rhck1heERpc3RhbmNlIiwic3RhclNwZWVkIiwiZ2VvbWV0cnkiLCJCdWZmZXJHZW9tZXRyeSIsImNsb3NlR2VvbWV0cnkiLCJwb3NpdGlvbnMiLCJjbG9zZVBvc2l0aW9ucyIsInN0YXJzUGxhY2VkIiwiTWF0aCIsInJhbmRvbSIsImNsdXN0ZXJUaGV0YSIsIlBJIiwiY2x1c3RlclBoaSIsImFjb3MiLCJjbHVzdGVyUiIsImNsdXN0ZXJDZW50ZXIiLCJzaW4iLCJjb3MiLCJjbHVzdGVyU2l6ZSIsImZsb29yIiwiYyIsIm9mZnNldFRoZXRhIiwib2Zmc2V0UGhpIiwib2Zmc2V0UiIsInB1c2giLCJ0aGV0YSIsInBoaSIsInIiLCJ4IiwieSIsInoiLCJzZXRBdHRyaWJ1dGUiLCJGbG9hdDMyQnVmZmVyQXR0cmlidXRlIiwibGVuZ3RoIiwicGFsZXR0ZSIsImNvbG9ycyIsImkiLCJvcmlnaW5hbENvbG9ycyIsImF0dHJpYnV0ZXMiLCJjb2xvciIsImFycmF5Iiwic2xpY2UiLCJ0aW1lcnMiLCJGbG9hdDMyQXJyYXkiLCJzcGFya0NvbG9ycyIsInNwYXJrbGVEdXJhdGlvbiIsIm1hdGVyaWFsIiwiUG9pbnRzTWF0ZXJpYWwiLCJzaXplIiwic2l6ZUF0dGVudWF0aW9uIiwidmVydGV4Q29sb3JzIiwic3RhcnMiLCJQb2ludHMiLCJhZGQiLCJnbG93TWFwIiwiVGV4dHVyZUxvYWRlciIsImxvYWQiLCJnbG93U3ByaXRlcyIsImdsb3dNYXRlcmlhbCIsIlNwcml0ZU1hdGVyaWFsIiwibWFwIiwib3BhY2l0eSIsImJsZW5kaW5nIiwiQWRkaXRpdmVCbGVuZGluZyIsImRlcHRoV3JpdGUiLCJnbG93IiwiU3ByaXRlIiwiY2xvbmUiLCJzY2FsZSIsImNsb3NlU3RhcnMiLCJ0YXJnZXRZIiwiZGFtcGluZyIsIm9uU2Nyb2xsIiwicGN0Iiwic2Nyb2xsWSIsImRvY3VtZW50IiwiYm9keSIsInNjcm9sbEhlaWdodCIsInRhaWxMZW5ndGgiLCJzaG9vdGluZ1N0YXJzIiwic2hvb3RpbmdTdGFyQ29vbGRvd24iLCJzcGF3blNob290aW5nU3RhciIsImRpciIsIm5vcm1hbGl6ZSIsIm1pbkRpc3QiLCJtYXhEaXN0IiwiZGlzdCIsInNwYXduUG9zIiwibXVsdGlwbHlTY2FsYXIiLCJ0YW5nZW50Iiwic3ViIiwicHJvamVjdE9uVmVjdG9yIiwidGFuZ2VudGlhbFNwZWVkIiwicmFkaWFsU3BlZWQiLCJ2ZWxvY2l0eSIsInZpYnJhbnRDb2xvcnMiLCJicmlnaHRuZXNzIiwiZ2VvIiwiU3BoZXJlR2VvbWV0cnkiLCJtYXQiLCJNZXNoUGh5c2ljYWxNYXRlcmlhbCIsImVtaXNzaXZlIiwiZW1pc3NpdmVJbnRlbnNpdHkiLCJtZXRhbG5lc3MiLCJyb3VnaG5lc3MiLCJ0cmFuc21pc3Npb24iLCJ0cmFuc3BhcmVudCIsImNsZWFyY29hdCIsImNsZWFyY29hdFJvdWdobmVzcyIsInN0YXIiLCJNZXNoIiwic3ByaXRlTWFwIiwic3ByaXRlTWF0ZXJpYWwiLCJzcHJpdGUiLCJjb3B5Iiwic3BhcmtDb3VudCIsInNwYXJrR3JvdXAiLCJHcm91cCIsInNwYXJrTWF0IiwiTWVzaEJhc2ljTWF0ZXJpYWwiLCJzcGFya0dlbyIsInNwYXJrIiwiYW5nbGUiLCJuYW1lIiwibm9ybWFsaXplZExpZmUiLCJub3JtYWxpemVkTGlmZXRpbWUiLCJhZ2UiLCJ0cmFpbFNlZ21lbnRzIiwidHJhaWxQb2ludHMiLCJzcGlyYWwiLCJjdXJ2ZSIsInB0IiwidGFpbEdlbyIsInNldEZyb21Qb2ludHMiLCJ0YWlsQ29sb3JzIiwiYWxwaGEiLCJyYWluYm93IiwiZ3JhZENvbG9yIiwidGFpbE1hdCIsIkxpbmVCYXNpY01hdGVyaWFsIiwidGFpbCIsIkxpbmUiLCJ0YWlsR2xvd01hcCIsInRhaWxHbG93TWF0IiwidGFpbEdsb3ciLCJtZXNoIiwiaGFzRnJhZ21lbnRlZCIsImFuaW1hdGUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJyZW5kZXIiLCJyb3RhdGlvbiIsImZvcndhcmQiLCJnZXRXb3JsZERpcmVjdGlvbiIsInN0YXJQb3MiLCJ0IiwicyIsIm5lZWRzVXBkYXRlIiwic2hha2VTdHJlbmd0aCIsIm9iaiIsImNoaWxkcmVuIiwic3BhcmtzIiwiZmluZCIsImNoaWxkIiwiaiIsInRpbWUiLCJwZXJmb3JtYW5jZSIsIm5vdyIsImdldEF0dHJpYnV0ZSIsImsiLCJjb3VudCIsImdldFgiLCJnIiwiZ2V0WSIsImIiLCJnZXRaIiwibWF4IiwibWluIiwiaCIsImwiLCJkIiwicSIsInAiLCJ0ciIsInRnIiwidGIiLCJodWUycmdiIiwic2V0WCIsInNldFkiLCJzZXRaIiwic2V0VyIsImdldFciLCJ1bnNoaWZ0IiwicG9wIiwidGFpbEdyb3ciLCJhY3RpdmVTZWdtZW50cyIsInZpc2libGVUcmFpbCIsIkRhdGUiLCJzZXRYWVpXIiwiaGVhZENvbG9yIiwiQ29sb3IiLCJsZXJwIiwiZmxpY2tlciIsImRpc3RUb0NhbSIsImRvZkJsdXIiLCJzcGVjdGFjdWxhciIsImJ1cnN0Q291bnQiLCJzcGFya2xlR2VvIiwic3BhcmtsZU1hdCIsInNwYXJrbGUiLCJzcGQiLCJzcGFya2xlVmVsIiwidXNlckRhdGEiLCJtYXhBZ2UiLCJfc3BhcmtsZXMiLCJmbGFzaEdlbyIsImZsYXNoTWF0IiwiZmxhc2giLCJfc3RhckZsYXNoZXMiLCJmcmFnVmVsIiwiYXBwbHlBeGlzQW5nbGUiLCJmcmFnU3RhciIsImZyYWdUcmFpbFBvaW50cyIsImZyYWdUYWlsR2VvIiwiZnJhZ1RhaWxNYXQiLCJmcmFnVGFpbCIsImhhc1NwYXJrZWQiLCJzcGFya1ZlbCIsInNwYXJrTGlmZSIsInNwYXJrQWdlIiwiX3N0YXJTcGFya3MiLCJoYXNGbGFzaGVkIiwiZGlzdGFuY2VUbyIsImZhZGVTdGFydCIsImZhZGUiLCJyZW1vdmUiLCJzcGxpY2UiLCJzcURpc3QiLCJkeCIsImR5IiwiZHoiLCJtaW5SYWRpdXMiLCJtYXhSYWRpdXMiLCJjb2xBcnIiLCJpZHgiLCJzcXJ0IiwiZXJyIiwiY29uc29sZSIsImVycm9yIiwib25SZXNpemUiLCJkaXYiLCJyZWYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/Starfield.jsx\n"));

/***/ })

});