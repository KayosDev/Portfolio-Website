"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./components/Starfield.jsx":
/*!**********************************!*\
  !*** ./components/Starfield.jsx ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var three_examples_jsm_postprocessing_EffectComposer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three/examples/jsm/postprocessing/EffectComposer */ \"./node_modules/three/examples/jsm/postprocessing/EffectComposer.js\");\n/* harmony import */ var three_examples_jsm_postprocessing_UnrealBloomPass__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three/examples/jsm/postprocessing/UnrealBloomPass */ \"./node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js\");\n/* harmony import */ var three_examples_jsm_postprocessing_RenderPass__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three/examples/jsm/postprocessing/RenderPass */ \"./node_modules/three/examples/jsm/postprocessing/RenderPass.js\");\n/* harmony import */ var three_examples_jsm_postprocessing_ShaderPass__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! three/examples/jsm/postprocessing/ShaderPass */ \"./node_modules/three/examples/jsm/postprocessing/ShaderPass.js\");\n/* harmony import */ var three_examples_jsm_shaders_FXAAShader__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! three/examples/jsm/shaders/FXAAShader */ \"./node_modules/three/examples/jsm/shaders/FXAAShader.js\");\n/* harmony import */ var three_examples_jsm_postprocessing_FilmPass__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! three/examples/jsm/postprocessing/FilmPass */ \"./node_modules/three/examples/jsm/postprocessing/FilmPass.js\");\n/* harmony import */ var _ChromaticAberrationPass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ChromaticAberrationPass */ \"./components/ChromaticAberrationPass.js\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\n\nconst Starfield = ()=>{\n    _s();\n    const mountRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // Defensive: always use .current for refs\n        if (!mountRef.current) return;\n        const mount = mountRef.current;\n        mount.style.position = \"fixed\";\n        mount.style.top = \"0\";\n        mount.style.left = \"0\";\n        mount.style.width = \"100%\";\n        mount.style.height = \"100%\";\n        mount.style.zIndex = \"0\";\n        // Scene & Renderer\n        const scene = new three__WEBPACK_IMPORTED_MODULE_3__.Scene();\n        const camera = new three__WEBPACK_IMPORTED_MODULE_3__.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);\n        camera.position.set(0, 0, 0);\n        // Virtual position to simulate infinite travel\n        let virtualCameraPos = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(0, 0, 0);\n        const renderer = new three__WEBPACK_IMPORTED_MODULE_3__.WebGLRenderer({\n            antialias: false\n        }) // We'll use FXAA instead\n        ;\n        renderer.setPixelRatio(window.devicePixelRatio);\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        renderer.setClearColor(0x000000, 1);\n        if (\"outputColorSpace\" in renderer) {\n            renderer.outputColorSpace = three__WEBPACK_IMPORTED_MODULE_3__.SRGBColorSpace;\n        }\n        renderer.toneMapping = three__WEBPACK_IMPORTED_MODULE_3__.NoToneMapping;\n        renderer.autoClear = true;\n        mount.appendChild(renderer.domElement);\n        // --- MAIN STARFIELD POST-PROCESSING ---\n        const composer = new three_examples_jsm_postprocessing_EffectComposer__WEBPACK_IMPORTED_MODULE_4__.EffectComposer(renderer);\n        composer.setSize(window.innerWidth, window.innerHeight);\n        const renderPass = new three_examples_jsm_postprocessing_RenderPass__WEBPACK_IMPORTED_MODULE_5__.RenderPass(scene, camera);\n        renderPass.clear = true;\n        composer.addPass(renderPass);\n        // UnrealBloomPass: \"crazy\" bloom\n        const bloomPass = new three_examples_jsm_postprocessing_UnrealBloomPass__WEBPACK_IMPORTED_MODULE_6__.UnrealBloomPass(new three__WEBPACK_IMPORTED_MODULE_3__.Vector2(window.innerWidth, window.innerHeight), 3.5, 1.6, 0.01 // threshold\n        );\n        composer.addPass(bloomPass);\n        // FXAA Pass\n        const fxaaPass = new three_examples_jsm_postprocessing_ShaderPass__WEBPACK_IMPORTED_MODULE_7__.ShaderPass(three_examples_jsm_shaders_FXAAShader__WEBPACK_IMPORTED_MODULE_8__.FXAAShader);\n        fxaaPass.material.uniforms[\"resolution\"].value.x = 1 / window.innerWidth;\n        fxaaPass.material.uniforms[\"resolution\"].value.y = 1 / window.innerHeight;\n        composer.addPass(fxaaPass);\n        // FilmPass\n        const filmPass = new three_examples_jsm_postprocessing_FilmPass__WEBPACK_IMPORTED_MODULE_9__.FilmPass(0.7, 0.08, 648, false // grayscale\n        );\n        composer.addPass(filmPass);\n        // --- SHOOTING STAR POST-PROCESSING ONLY ---\n        // Separate scene and composer for shooting stars\n        const shootingStarScene = new three__WEBPACK_IMPORTED_MODULE_3__.Scene();\n        const shootingStarComposer = new three_examples_jsm_postprocessing_EffectComposer__WEBPACK_IMPORTED_MODULE_4__.EffectComposer(renderer);\n        shootingStarComposer.setSize(window.innerWidth, window.innerHeight);\n        const shootingStarRenderPass = new three_examples_jsm_postprocessing_RenderPass__WEBPACK_IMPORTED_MODULE_5__.RenderPass(shootingStarScene, camera);\n        shootingStarComposer.addPass(shootingStarRenderPass);\n        // Intense bloom for shooting stars\n        const shootingStarBloomPass = new three_examples_jsm_postprocessing_UnrealBloomPass__WEBPACK_IMPORTED_MODULE_6__.UnrealBloomPass(new three__WEBPACK_IMPORTED_MODULE_3__.Vector2(window.innerWidth, window.innerHeight), 4.0, 2.0, 0.0 // all bright\n        );\n        shootingStarComposer.addPass(shootingStarBloomPass);\n        // --- CLOSE STARS: Separate Scene for Chromatic Aberration ---\n        const closeStarsScene = new three__WEBPACK_IMPORTED_MODULE_3__.Scene();\n        const caPass = new _ChromaticAberrationPass__WEBPACK_IMPORTED_MODULE_2__.ChromaticAberrationPass(new three__WEBPACK_IMPORTED_MODULE_3__.Vector2(0.0002, 0.0002)); // barely visible\n        const caComposer = new three_examples_jsm_postprocessing_EffectComposer__WEBPACK_IMPORTED_MODULE_4__.EffectComposer(renderer);\n        caComposer.setSize(window.innerWidth, window.innerHeight);\n        const caRenderPass = new three_examples_jsm_postprocessing_RenderPass__WEBPACK_IMPORTED_MODULE_5__.RenderPass(closeStarsScene, camera);\n        caComposer.addPass(caRenderPass);\n        caComposer.addPass(caPass);\n        // --- HANDLE RESIZE AND FULLSCREEN ---\n        function resizeAll() {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n            // Main composer\n            composer.setSize(window.innerWidth, window.innerHeight);\n            // FXAA resolution\n            fxaaPass.material.uniforms[\"resolution\"].value.x = 1 / window.innerWidth;\n            fxaaPass.material.uniforms[\"resolution\"].value.y = 1 / window.innerHeight;\n            // Other composers\n            shootingStarComposer.setSize(window.innerWidth, window.innerHeight);\n            caComposer.setSize(window.innerWidth, window.innerHeight);\n        }\n        window.addEventListener(\"resize\", resizeAll);\n        window.addEventListener(\"fullscreenchange\", resizeAll);\n        // Starfield\n        const starCount = 5000;\n        const starMaxDistance = 2000;\n        const starSpeed = 1;\n        const geometry = new three__WEBPACK_IMPORTED_MODULE_3__.BufferGeometry();\n        const closeGeometry = new three__WEBPACK_IMPORTED_MODULE_3__.BufferGeometry();\n        const positions = [];\n        const closePositions = [];\n        let starsPlaced = 0;\n        while(starsPlaced < starCount){\n            // With 1% chance, spawn a star cluster (10-30 stars)\n            if (Math.random() < 0.01 && starsPlaced < starCount - 10) {\n                const clusterTheta = Math.random() * 2 * Math.PI;\n                const clusterPhi = Math.acos(2 * Math.random() - 1);\n                const clusterR = Math.random() * starMaxDistance;\n                const clusterCenter = [\n                    clusterR * Math.sin(clusterPhi) * Math.cos(clusterTheta),\n                    clusterR * Math.sin(clusterPhi) * Math.sin(clusterTheta),\n                    clusterR * Math.cos(clusterPhi)\n                ];\n                const clusterSize = 10 + Math.floor(Math.random() * 20); // 10-30 stars\n                for(let c = 0; c < clusterSize && starsPlaced < starCount; c++){\n                    // Each star in cluster is within 30 units of center\n                    const offsetTheta = Math.random() * 2 * Math.PI;\n                    const offsetPhi = Math.acos(2 * Math.random() - 1);\n                    const offsetR = Math.random() * 30; // cluster radius\n                    positions.push(clusterCenter[0] + offsetR * Math.sin(offsetPhi) * Math.cos(offsetTheta), clusterCenter[1] + offsetR * Math.sin(offsetPhi) * Math.sin(offsetTheta), clusterCenter[2] + offsetR * Math.cos(offsetPhi));\n                    starsPlaced++;\n                }\n            } else {\n                // Normal single star\n                const theta = Math.random() * 2 * Math.PI;\n                const phi = Math.acos(2 * Math.random() - 1);\n                const r = Math.random() * starMaxDistance;\n                const x = r * Math.sin(phi) * Math.cos(theta);\n                const y = r * Math.sin(phi) * Math.sin(theta);\n                const z = r * Math.cos(phi);\n                positions.push(x, y, z);\n                // If close, also add to closePositions\n                if (r < 400) {\n                    closePositions.push(x, y, z);\n                }\n                starsPlaced++;\n            }\n        }\n        geometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_3__.Float32BufferAttribute(positions, 3));\n        if (closePositions.length > 0) {\n            closeGeometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_3__.Float32BufferAttribute(closePositions, 3));\n        }\n        // CRAZY BLOOM: All stars are extremely bright (color intensity >1)\n        const palette = [\n            [\n                1.0,\n                0.5,\n                0.5\n            ],\n            [\n                1.0,\n                0.75,\n                0.4\n            ],\n            [\n                1.0,\n                1.0,\n                0.9\n            ],\n            [\n                1.0,\n                1.0,\n                1.0\n            ],\n            [\n                0.4,\n                0.5,\n                1.0\n            ]\n        ];\n        const colors = [];\n        for(let i = 0; i < starCount; i++){\n            const c = palette[Math.floor(Math.random() * palette.length)];\n            colors.push(...c);\n        }\n        geometry.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_3__.Float32BufferAttribute(colors, 3));\n        const originalColors = geometry.attributes.color.array.slice();\n        const timers = new Float32Array(starCount);\n        const sparkColors = new Float32Array(starCount * 3);\n        const sparkleDuration = 180;\n        // --- SQUARE STARS USING POINTS ---\n        const material = new three__WEBPACK_IMPORTED_MODULE_3__.PointsMaterial({\n            size: 10,\n            sizeAttenuation: false,\n            vertexColors: true\n        });\n        const stars = new three__WEBPACK_IMPORTED_MODULE_3__.Points(geometry, material);\n        scene.add(stars);\n        // Add glow sprites to each star and animate them based on distance\n        const glowMap = new three__WEBPACK_IMPORTED_MODULE_3__.TextureLoader().load(\"/glow.png\");\n        const glowSprites = [];\n        const glowMaterial = new three__WEBPACK_IMPORTED_MODULE_3__.SpriteMaterial({\n            map: glowMap,\n            color: 0xffffff,\n            opacity: 0.18,\n            blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending,\n            depthWrite: false\n        });\n        for(let i = 0; i < starCount; i++){\n            const glow = new three__WEBPACK_IMPORTED_MODULE_3__.Sprite(glowMaterial.clone());\n            glow.position.set(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2]);\n            glow.scale.set(10, 10, 1);\n            scene.add(glow);\n            glowSprites.push(glow);\n        }\n        // Add close stars to separate scene\n        let closeStars;\n        if (closePositions.length > 0) {\n            closeStars = new three__WEBPACK_IMPORTED_MODULE_3__.Points(closeGeometry, material.clone());\n            closeStarsScene.add(closeStars);\n        }\n        let targetY = 0;\n        const damping = 0.05;\n        const onScroll = ()=>{\n            const pct = window.scrollY / (document.body.scrollHeight - window.innerHeight);\n            targetY = pct * Math.PI * 2;\n        };\n        window.addEventListener(\"scroll\", onScroll);\n        // --- Shooting Stars ---\n        const tailLength = 32; // Increase for longer tails\n        const shootingStars = [];\n        let shootingStarCooldown = 0;\n        // Spawn a shooting star with a stunning glowing tail\n        function spawnShootingStar() {\n            // Pick a random direction on the sphere for the spawn location\n            const dir = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();\n            // Ensure shooting stars never spawn close to the camera (at least 70% of max distance)\n            const minDist = starMaxDistance * 0.7;\n            const maxDist = starMaxDistance * 1.0;\n            const dist = minDist + Math.random() * (maxDist - minDist);\n            const spawnPos = dir.clone().multiplyScalar(dist);\n            // Tangential velocity: perpendicular to dir\n            let tangent = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1);\n            tangent = tangent.sub(tangent.clone().projectOnVector(dir)).normalize();\n            // Mix in a small radial component (inward or outward)\n            const tangentialSpeed = starSpeed * (2.5 + Math.random() * 2.5); // much faster\n            const radialSpeed = starSpeed * (Math.random() - 0.5) * 0.3; // more dramatic\n            const velocity = tangent.multiplyScalar(tangentialSpeed).add(dir.clone().multiplyScalar(radialSpeed));\n            // Stunning color gradient for the head\n            const vibrantColors = [\n                0xffe066,\n                0xff66cc,\n                0x66ccff,\n                0xffffff,\n                0x80ffea,\n                0xfff2cc,\n                0xffc080,\n                0x80c0ff,\n                0xff80b3\n            ];\n            const color = vibrantColors[Math.floor(Math.random() * vibrantColors.length)];\n            // Star brightness and size (always small and subtle)\n            const brightness = 2.5 + Math.random() * 1.5;\n            const geo = new three__WEBPACK_IMPORTED_MODULE_3__.SphereGeometry(0.7 + Math.random() * 0.5, 16, 16); // Small sphere\n            const mat = new three__WEBPACK_IMPORTED_MODULE_3__.MeshPhysicalMaterial({\n                color: color,\n                emissive: color,\n                emissiveIntensity: 14.0,\n                metalness: 0.7,\n                roughness: 0.3,\n                transmission: 0.7,\n                opacity: 0.98,\n                transparent: true,\n                clearcoat: 0.8,\n                clearcoatRoughness: 0.2\n            });\n            const star = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(geo, mat);\n            // Add a large, intense bloom sprite for extra bloom\n            const spriteMap = new three__WEBPACK_IMPORTED_MODULE_3__.TextureLoader().load(\"/glow.png\");\n            const spriteMaterial = new three__WEBPACK_IMPORTED_MODULE_3__.SpriteMaterial({\n                map: spriteMap,\n                color: 0xffffff,\n                opacity: 1.0,\n                blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n            });\n            const sprite = new three__WEBPACK_IMPORTED_MODULE_3__.Sprite(spriteMaterial);\n            sprite.scale.set(70, 70, 1); // Large for bloom\n            sprite.position.copy(star.position);\n            star.add(sprite);\n            // Add a colored sprite for color pop\n            const colorSpriteMaterial = new three__WEBPACK_IMPORTED_MODULE_3__.SpriteMaterial({\n                map: spriteMap,\n                color: color,\n                opacity: 0.6,\n                blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n            });\n            const colorSprite = new three__WEBPACK_IMPORTED_MODULE_3__.Sprite(colorSpriteMaterial);\n            colorSprite.scale.set(34, 34, 1);\n            colorSprite.position.copy(star.position);\n            star.add(colorSprite);\n            // Add to both main scene and shootingStarScene\n            scene.add(star);\n            shootingStarScene.add(star);\n            // Add dynamic spark burst at the head\n            const sparkCount = 18 + Math.floor(Math.random() * 8);\n            const sparkGroup = new three__WEBPACK_IMPORTED_MODULE_3__.Group();\n            for(let i = 0; i < sparkCount; i++){\n                const sparkMat = new three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial({\n                    color: vibrantColors[Math.floor(Math.random() * vibrantColors.length)],\n                    transparent: true,\n                    opacity: 0.8\n                });\n                const sparkGeo = new three__WEBPACK_IMPORTED_MODULE_3__.SphereGeometry(0.07 + Math.random() * 0.06, 8, 8);\n                const spark = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(sparkGeo, sparkMat);\n                const angle = i / sparkCount * Math.PI * 2;\n                spark.position.set(Math.cos(angle) * 1.2, Math.sin(angle) * 1.2, Math.random() * 0.4 - 0.2);\n                sparkGroup.add(spark);\n            }\n            sparkGroup.name = \"sparkBurst\";\n            star.add(sparkGroup);\n            star.position.copy(spawnPos);\n            star.velocity = velocity;\n            star.normalizedLife = 0.0;\n            star.normalizedLifetime = 80 + Math.random() * 80; // Longer, more dramatic\n            star.age = 0;\n            // --- Stunning Meteor Tail (very long, multi-color, glowing, fading, and 3D curve) ---\n            const trailSegments = tailLength * 3;\n            const trailPoints = [];\n            for(let i = 0; i < trailSegments; i++){\n                // Add a 3D spiral/curve for more depth\n                const spiral = Math.sin(i * 0.25) * 8;\n                const curve = Math.cos(i * 0.15) * 4;\n                const pt = star.position.clone().add(new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(spiral, curve, -i * 3));\n                trailPoints.push(pt);\n            }\n            const tailGeo = new three__WEBPACK_IMPORTED_MODULE_3__.BufferGeometry().setFromPoints(trailPoints);\n            // Per-vertex color (multi-color rainbow gradient)\n            const tailColors = [];\n            for(let i = 0; i < trailSegments; i++){\n                // Alpha fades out along the tail\n                const alpha = (1 - i / (trailSegments - 1)) * 0.99;\n                // Rainbow gradient\n                const rainbow = [\n                    0xffe066,\n                    0xff66cc,\n                    0x66ccff,\n                    0xffffff,\n                    0x80ffea,\n                    0xfff2cc,\n                    0xffc080,\n                    0x80c0ff,\n                    0xff80b3\n                ];\n                const gradColor = rainbow[Math.floor(i / trailSegments * rainbow.length)];\n                tailColors.push((gradColor >> 16 & 255) / 255, (gradColor >> 8 & 255) / 255, (gradColor & 255) / 255, alpha);\n            }\n            tailGeo.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_3__.Float32BufferAttribute(tailColors, 4));\n            // Additive blending for glow + BLOOMED TAIL\n            const tailMat = new three__WEBPACK_IMPORTED_MODULE_3__.LineBasicMaterial({\n                vertexColors: true,\n                transparent: true,\n                opacity: 1.0,\n                blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n            });\n            // --- TAILS ---\n            // 1. Crisp tail for main scene\n            const tailMatMain = new three__WEBPACK_IMPORTED_MODULE_3__.LineBasicMaterial({\n                vertexColors: true,\n                transparent: true,\n                opacity: 1.0,\n                blending: three__WEBPACK_IMPORTED_MODULE_3__.NormalBlending\n            });\n            const tailMain = new three__WEBPACK_IMPORTED_MODULE_3__.Line(tailGeo.clone(), tailMatMain);\n            tailMain.position.copy(star.position);\n            scene.add(tailMain);\n            // 2. Intense bloom tail for shootingStarScene\n            const tailMatBloom = new three__WEBPACK_IMPORTED_MODULE_3__.LineBasicMaterial({\n                vertexColors: true,\n                transparent: true,\n                opacity: 1.0,\n                blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n            });\n            const tailBloom = new three__WEBPACK_IMPORTED_MODULE_3__.Line(tailGeo, tailMatBloom);\n            tailBloom.position.copy(star.position);\n            // Add a bloom sprite to the tail's head for extra glow\n            const tailGlowMap = new three__WEBPACK_IMPORTED_MODULE_3__.TextureLoader().load(\"/glow.png\");\n            const tailGlowMat = new three__WEBPACK_IMPORTED_MODULE_3__.SpriteMaterial({\n                map: tailGlowMap,\n                color: 0xffffff,\n                opacity: 0.88,\n                blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n            });\n            const tailGlow = new three__WEBPACK_IMPORTED_MODULE_3__.Sprite(tailGlowMat);\n            tailGlow.scale.set(50, 50, 1); // Larger for more bloom\n            tailGlow.position.copy(star.position);\n            tailBloom.add(tailGlow);\n            shootingStarScene.add(tailBloom);\n            // Add star to both scenes\n            scene.add(star);\n            shootingStarScene.add(star);\n            shootingStars.push({\n                mesh: star,\n                tail: tailMain,\n                tailBloom,\n                velocity: star.velocity,\n                dir,\n                age: 0,\n                normalizedLifetime: star.normalizedLifetime,\n                trailPoints,\n                color,\n                brightness,\n                hasFragmented: false\n            });\n        }\n        // Create an animation ID reference for cleanup\n        let animationId;\n        const animate = ()=>{\n            // Store the animation ID for cleanup\n            animationId = requestAnimationFrame(animate);\n            // Update star positions relative to virtual camera\n            for(let i = 0; i < positions.length; i += 3){\n                geometry.attributes.position.array[i] = positions[i] - virtualCameraPos.x;\n                geometry.attributes.position.array[i + 1] = positions[i + 1] - virtualCameraPos.y;\n                geometry.attributes.position.array[i + 2] = positions[i + 2] - virtualCameraPos.z;\n            }\n            geometry.attributes.position.needsUpdate = true;\n            // Update glow sprite positions\n            for(let i = 0; i < glowSprites.length; i++){\n                const idx = i * 3;\n                glowSprites[i].position.set(positions[idx] - virtualCameraPos.x, positions[idx + 1] - virtualCameraPos.y, positions[idx + 2] - virtualCameraPos.z);\n            }\n            // --- POST-PROCESSING PIPELINE ---\n            // --- POST-PROCESSING PIPELINE ---\n            composer.render(); // Only RenderPass enabled for debugging\n            // (bloom, FXAA, FilmPass are NOT added)\n            // shootingStarComposer, caComposer remain disabled for now\n            camera.rotation.y += (targetY - camera.rotation.y) * damping;\n            // Move the virtual camera position in the direction the camera is facing\n            const forward = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();\n            camera.getWorldDirection(forward);\n            virtualCameraPos.add(forward.multiplyScalar(starSpeed));\n            // Intense color (oversaturated, brightened) -- must be inside the for loop over stars\n            const colorAttr = geometry.attributes.color;\n            for(let i = 0; i < positions.length; i += 3){\n                const origR = colorAttr.array[i];\n                const origG = colorAttr.array[i + 1];\n                const origB = colorAttr.array[i + 2];\n                const dist = Math.sqrt(Math.pow(positions[i] - virtualCameraPos.x, 2) + Math.pow(positions[i + 1] - virtualCameraPos.y, 2) + Math.pow(positions[i + 2] - virtualCameraPos.z, 2));\n                const intenseR = Math.min(origR * 2.5, 1.0), intenseG = Math.min(origG * 2.5, 1.0), intenseB = Math.min(origB * 2.5, 1.0);\n                // Fade factor: 0 = close, 1 = far\n                let fadeT = (dist - 200) / (starMaxDistance * 0.9 - 200);\n                fadeT = Math.max(0, Math.min(1, fadeT));\n                // Ease for smoothness\n                fadeT = Math.pow(fadeT, 1.5);\n                // Lerp between original and intense color\n                colorAttr.array[i] = origR * (1 - fadeT) + intenseR * fadeT;\n                colorAttr.array[i + 1] = origG * (1 - fadeT) + intenseG * fadeT;\n                colorAttr.array[i + 2] = origB * (1 - fadeT) + intenseB * fadeT;\n            }\n            colorAttr.needsUpdate = true;\n            // If you have glow logic per-star, move that inside the loop as well, or handle after\n            if (closeStars && closeGeometry && closePositions.length > 0) {\n                for(let i = 0; i < closePositions.length; i += 3){\n                    closeGeometry.attributes.position.array[i] = closePositions[i] - virtualCameraPos.x;\n                    closeGeometry.attributes.position.array[i + 1] = closePositions[i + 1] - virtualCameraPos.y;\n                    closeGeometry.attributes.position.array[i + 2] = closePositions[i + 2] - virtualCameraPos.z;\n                }\n                closeGeometry.attributes.position.needsUpdate = true;\n            }\n            geometry.attributes.position.needsUpdate = true;\n            // Update shooting star cooldown\n            if (shootingStarCooldown <= 0 && Math.random() < 0.02) {\n                spawnShootingStar();\n                shootingStarCooldown = 30 + Math.random() * 60;\n            } else if (shootingStarCooldown > 0) {\n                shootingStarCooldown--;\n            }\n            // --- Shooting star spawning ---\n            if (shootingStarCooldown <= 0 && Math.random() < 0.1) {\n                spawnShootingStar();\n                if (camera) {\n                    const shakeStrength = 0.06 + Math.random() * 0.04;\n                    camera.position.x += (Math.random() - 0.5) * shakeStrength;\n                    camera.position.y += (Math.random() - 0.5) * shakeStrength;\n                }\n                shootingStarCooldown = 10 + Math.random() * 10;\n            } else if (shootingStarCooldown > 0) {\n                shootingStarCooldown--;\n            }\n            // Animate and clean up shooting stars\n            for(let i = shootingStars.length - 1; i >= 0; i--){\n                const obj = shootingStars[i];\n                // Animate spark burst (fade and expand)\n                if (obj.mesh.children) {\n                    const sparks = obj.mesh.children.find((child)=>child.name === \"sparkBurst\");\n                    if (sparks) {\n                        for(let j = 0; j < sparks.children.length; j++){\n                            const spark = sparks.children[j];\n                            spark.material.opacity *= 0.96; // Fade\n                            spark.scale.multiplyScalar(1.03); // Expand\n                        }\n                    }\n                }\n                // Animate tail shimmer and color cycling\n                if (obj.tail && obj.trailPoints) {\n                    const time = performance.now() * 0.001;\n                    const tailGeo = obj.tail.geometry;\n                    const tailColors = tailGeo.getAttribute(\"color\");\n                    for(let k = 0; k < tailColors.count; k++){\n                        // Cycle hue\n                        let r = tailColors.getX(k), g = tailColors.getY(k), b = tailColors.getZ(k);\n                        // Convert to HSL\n                        const max = Math.max(r, g, b), min = Math.min(r, g, b);\n                        let h, s, l;\n                        l = (max + min) / 2;\n                        if (max === min) {\n                            h = s = 0;\n                        } else {\n                            const d = max - min;\n                            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n                            switch(max){\n                                case r:\n                                    h = (g - b) / d + (g < b ? 6 : 0);\n                                    break;\n                                case g:\n                                    h = (b - r) / d + 2;\n                                    break;\n                                case b:\n                                    h = (r - g) / d + 4;\n                                    break;\n                            }\n                            h /= 6;\n                        }\n                        h = (h + 0.25 * Math.sin(time + k * 0.2)) % 1.0; // Animate hue\n                        // Convert back to RGB\n                        let q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n                        let p = 2 * l - q;\n                        let tr = h + 1 / 3, tg = h, tb = h - 1 / 3;\n                        const hue2rgb = (p, q, t)=>{\n                            if (t < 0) t += 1;\n                            if (t > 1) t -= 1;\n                            if (t < 1 / 6) return p + (q - p) * 6 * t;\n                            if (t < 1 / 2) return q;\n                            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n                            return p;\n                        };\n                        tailColors.setX(k, hue2rgb(p, q, tr));\n                        tailColors.setY(k, hue2rgb(p, q, tg));\n                        tailColors.setZ(k, hue2rgb(p, q, tb));\n                        // Shimmer: modulate alpha\n                        tailColors.setW(k, tailColors.getW(k) * (0.97 + 0.03 * Math.sin(time * 8 + k)));\n                    }\n                    tailColors.needsUpdate = true;\n                }\n                // Straight-line trajectory\n                obj.mesh.position.add(obj.velocity);\n                obj.tail.position.copy(obj.mesh.position);\n                if (obj.tailBloom) obj.tailBloom.position.copy(obj.mesh.position);\n                // Animate tail (no lerp, just drag)\n                // COMPLETE MESS VERY HACKY FIX LATER OR DONT?????\n                obj.age++;\n                const normalizedLife = obj.age / obj.normalizedLifetime;\n                obj.trailPoints.unshift(obj.mesh.position.clone());\n                if (obj.trailPoints.length > tailLength * 3) obj.trailPoints.pop();\n                let tailGrow = Math.min(1, normalizedLife / 0.3);\n                let activeSegments = Math.floor(obj.trailPoints.length * tailGrow);\n                if (activeSegments < 2) activeSegments = 2;\n                const visibleTrail = obj.trailPoints.slice(0, activeSegments);\n                obj.tail.geometry.setFromPoints(visibleTrail);\n                if (obj.tailBloom) obj.tailBloom.geometry.setFromPoints(visibleTrail);\n                const tailColors = obj.tail.geometry.getAttribute(\"color\");\n                let tailColorsBloom = obj.tailBloom ? obj.tailBloom.geometry.getAttribute(\"color\") : null;\n                for(let j = 0; j < visibleTrail.length; j++){\n                    let alpha = (1 - j / (visibleTrail.length - 1)) * 0.95;\n                    alpha *= 0.92 + 0.08 * Math.sin(Date.now() * 0.015 + j * 0.5);\n                    let rainbow = [\n                        0xffc080,\n                        0xffe080,\n                        0xffff80,\n                        0x80ffe6,\n                        0x80c0ff,\n                        0xc080ff\n                    ];\n                    let gradColor = rainbow[j % rainbow.length];\n                    if (normalizedLife > 0.7) alpha *= Math.max(0, 1 - (normalizedLife - 0.7 - 0.2) / 0.3);\n                    tailColors.setXYZW(j, (gradColor >> 16 & 255) / 255, (gradColor >> 8 & 255) / 255, (gradColor & 255) / 255, alpha);\n                    if (tailColorsBloom) tailColorsBloom.setXYZW(j, (gradColor >> 16 & 255) / 255, (gradColor >> 8 & 255) / 255, (gradColor & 255) / 255, alpha);\n                }\n                tailColors.needsUpdate = true;\n                // Animate head\n                let headColor;\n                if (normalizedLife < 0.5) {\n                    headColor = new three__WEBPACK_IMPORTED_MODULE_3__.Color(obj.color).lerp(new three__WEBPACK_IMPORTED_MODULE_3__.Color(0xffc080), normalizedLife * 2);\n                } else {\n                    headColor = new three__WEBPACK_IMPORTED_MODULE_3__.Color(0xffc080).lerp(new three__WEBPACK_IMPORTED_MODULE_3__.Color(0xff4000), (normalizedLife - 0.5) * 2);\n                }\n                let flicker = 0.95 + 0.13 * Math.sin(Date.now() * 0.07 + Math.random() * 10);\n                headColor.multiplyScalar(flicker);\n                obj.mesh.material.color.copy(headColor);\n                let scale = 1 + 2.2 * Math.sin(Math.PI * normalizedLife);\n                let distToCam = obj.mesh.position.length();\n                let dofBlur = distToCam < starMaxDistance * 0.7 ? 0.7 : 1.0;\n                obj.mesh.scale.set(scale * dofBlur, scale * dofBlur, scale * dofBlur);\n                // Sparkle burst\n                if (normalizedLife >= 1 && !obj.hasFragmented) {\n                    // --- SPECTACULAR EXPLOSION (very rare) ---\n                    const spectacular = Math.random() < 0.02; // 2% chance\n                    const burstCount = spectacular ? 120 + Math.floor(Math.random() * 60) : 18 + Math.floor(Math.random() * 8);\n                    const palette = spectacular ? [\n                        0xffe066,\n                        0xff66cc,\n                        0x66ccff,\n                        0xffffff,\n                        0x80ffea,\n                        0xfff2cc,\n                        0xffc080,\n                        0x80c0ff,\n                        0xff80b3,\n                        0xff0000,\n                        0x00ff00,\n                        0x0000ff,\n                        0xffff00,\n                        0x00ffff,\n                        0xff00ff,\n                        0xff8800,\n                        0x00ff88,\n                        0x8800ff\n                    ] : [\n                        0xffffff,\n                        0xfff6c0,\n                        0xffe066,\n                        0xffc080,\n                        0x80c0ff\n                    ];\n                    for(let s = 0; s < burstCount; s++){\n                        const color = palette[Math.floor(Math.random() * palette.length)];\n                        const size = spectacular ? 1.2 + Math.random() * 2.2 : 0.7 + Math.random() * 0.8;\n                        const sparkleGeo = new three__WEBPACK_IMPORTED_MODULE_3__.SphereGeometry(size, 8, 8);\n                        const sparkleMat = new three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial({\n                            color,\n                            transparent: true,\n                            opacity: spectacular ? 0.92 : 0.7,\n                            blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n                        });\n                        const sparkle = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(sparkleGeo, sparkleMat);\n                        sparkle.position.copy(obj.mesh.position);\n                        // Spectacular: huge, fast, random directions; normal: moderate\n                        const spd = spectacular ? 4 + Math.random() * 8 : 2 + Math.random() * 2;\n                        const sparkleVel = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize().multiplyScalar(spd);\n                        sparkle.userData = {\n                            velocity: sparkleVel,\n                            age: 0,\n                            spectacular,\n                            maxAge: spectacular ? 80 + Math.random() * 40 : 40 + Math.random() * 20\n                        }; // <-- LONGER LIFE\n                        scene.add(sparkle);\n                        if (!window._sparkles) window._sparkles = [];\n                        window._sparkles.push(sparkle);\n                    }\n                    if (spectacular) {\n                        // Add a big flash\n                        const flashGeo = new three__WEBPACK_IMPORTED_MODULE_3__.SphereGeometry(6, 24, 24);\n                        const flashMat = new three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial({\n                            color: 0xffffff,\n                            transparent: true,\n                            opacity: 0.8,\n                            blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n                        });\n                        const flash = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(flashGeo, flashMat);\n                        flash.position.copy(obj.mesh.position);\n                        scene.add(flash);\n                        if (!window._starFlashes) window._starFlashes = [];\n                        window._starFlashes.push({\n                            mesh: flash,\n                            age: 0\n                        });\n                    }\n                    // Fragmented trail logic (keep as before)\n                    const fragVel = obj.velocity.clone().applyAxisAngle(new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(0, 1, 0), (Math.random() - 0.5) * 0.3);\n                    const fragStar = obj.mesh.clone();\n                    fragStar.position.copy(obj.mesh.position);\n                    fragStar.velocity = fragVel;\n                    fragStar.normalizedLife = normalizedLife;\n                    fragStar.normalizedLifetime = obj.normalizedLifetime * (0.5 + Math.random() * 0.5);\n                    fragStar.age = obj.age;\n                    fragStar.material = obj.mesh.material.clone();\n                    const fragTrailPoints = obj.trailPoints.slice();\n                    const fragTailGeo = new three__WEBPACK_IMPORTED_MODULE_3__.BufferGeometry().setFromPoints(fragTrailPoints);\n                    fragTailGeo.setAttribute(\"color\", obj.tail.geometry.getAttribute(\"color\").clone());\n                    const fragTailMat = obj.tail.material.clone();\n                    const fragTail = new three__WEBPACK_IMPORTED_MODULE_3__.Line(fragTailGeo, fragTailMat);\n                    fragTail.position.copy(fragStar.position);\n                    scene.add(fragStar);\n                    scene.add(fragTail);\n                    shootingStars.push({\n                        mesh: fragStar,\n                        tail: fragTail,\n                        velocity: fragStar.velocity,\n                        dir: obj.dir,\n                        age: fragStar.age,\n                        normalizedLifetime: fragStar.normalizedLifetime,\n                        trailPoints: fragTrailPoints,\n                        color: obj.color,\n                        brightness: obj.brightness,\n                        hasFragmented: true\n                    });\n                    obj.hasFragmented = true;\n                }\n                // Spark burst\n                if (!obj.hasSparked && normalizedLife > 0.95 && Math.random() < 0.1) {\n                    for(let s = 0; s < 8 + Math.floor(Math.random() * 8); s++){\n                        const sparkGeo = new three__WEBPACK_IMPORTED_MODULE_3__.SphereGeometry(0.5 + Math.random() * 0.5, 8, 8);\n                        const sparkMat = new three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial({\n                            color: 0xfff6c0,\n                            transparent: true,\n                            opacity: 1,\n                            blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n                        });\n                        const spark = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(sparkGeo, sparkMat);\n                        spark.position.copy(obj.mesh.position);\n                        spark.sparkVel = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize().multiplyScalar(0.5 + Math.random() * 1.2);\n                        spark.sparkLife = 12 + Math.random() * 10;\n                        spark.sparkAge = 0;\n                        scene.add(spark);\n                        if (!window._starSparks) window._starSparks = [];\n                        window._starSparks.push(spark);\n                    }\n                    obj.hasSparked = true;\n                }\n                // Flash\n                if (!obj.hasFlashed && normalizedLife > 0.98 && Math.random() < 0.2) {\n                    const flashGeo = new three__WEBPACK_IMPORTED_MODULE_3__.SphereGeometry(1, 16, 16);\n                    const flashMat = new three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial({\n                        color: 0xffffee,\n                        transparent: true,\n                        opacity: 0.8,\n                        blending: three__WEBPACK_IMPORTED_MODULE_3__.AdditiveBlending\n                    });\n                    const flash = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(flashGeo, flashMat);\n                    flash.position.copy(obj.mesh.position);\n                    scene.add(flash);\n                    if (!window._starFlashes) window._starFlashes = [];\n                    window._starFlashes.push({\n                        mesh: flash,\n                        age: 0\n                    });\n                    obj.hasFlashed = true;\n                }\n                // Fade out as it gets far away\n                const dist = obj.mesh.position.distanceTo(camera.position);\n                const fadeStart = starMaxDistance * 0.5;\n                if (dist > fadeStart) {\n                    const fade = 1 - (dist - fadeStart) / (starMaxDistance - fadeStart);\n                    obj.mesh.material.opacity = Math.max(0, fade);\n                    obj.mesh.material.transparent = true;\n                    obj.tail.material.opacity = Math.max(0, fade * 0.8);\n                    obj.tail.material.transparent = true;\n                }\n                // Remove when out of bounds or fully faded or life ended\n                // Fade tail after explosion\n                if ((normalizedLife >= 1.0 || dist > starMaxDistance || obj.mesh.material.opacity <= 0.01) && !obj.tailFading) {\n                    scene.remove(obj.mesh);\n                    // Start tail fade-out ghost\n                    obj.tailFading = true;\n                    obj.tailFadeAge = 0;\n                    if (!window._fadingTails) window._fadingTails = [];\n                    window._fadingTails.push({\n                        tail: obj.tail,\n                        tailBloom: obj.tailBloom,\n                        age: 0\n                    });\n                    shootingStars.splice(i, 1);\n                }\n            }\n            // Animate sparks\n            if (window._starSparks) {\n                for(let i = window._starSparks.length - 1; i >= 0; i--){\n                    const spark = window._starSparks[i];\n                    spark.position.add(spark.sparkVel);\n                    spark.sparkAge++;\n                    spark.material.opacity *= 0.92;\n                    if (spark.sparkAge > spark.sparkLife) {\n                        scene.remove(spark);\n                        window._starSparks.splice(i, 1);\n                    }\n                }\n            }\n            // Animate explosion particles (sparkles)\n            if (window._sparkles) {\n                for(let i = window._sparkles.length - 1; i >= 0; i--){\n                    const sparkle = window._sparkles[i];\n                    sparkle.position.add(sparkle.userData.velocity);\n                    sparkle.userData.age++;\n                    sparkle.material.opacity *= 0.97;\n                    if (sparkle.userData.age > (sparkle.userData.maxAge || 40)) {\n                        scene.remove(sparkle);\n                        window._sparkles.splice(i, 1);\n                    }\n                }\n            }\n            // Animate fading tails (ghosts)\n            if (window._fadingTails) {\n                for(let i = window._fadingTails.length - 1; i >= 0; i--){\n                    const ghost = window._fadingTails[i];\n                    if (ghost.tail) {\n                        ghost.tail.material.opacity *= 0.92;\n                        if (ghost.tail.material.opacity < 0.01) {\n                            scene.remove(ghost.tail);\n                            window._fadingTails.splice(i, 1);\n                            continue;\n                        }\n                    }\n                    if (ghost.tailBloom) {\n                        ghost.tailBloom.material.opacity *= 0.92;\n                        if (ghost.tailBloom.material.opacity < 0.01) {\n                            shootingStarScene.remove(ghost.tailBloom);\n                            ghost.tailBloom = null;\n                        }\n                    }\n                    ghost.age++;\n                }\n            }\n            // Animate flashes\n            if (window._starFlashes) {\n                for(let i = window._starFlashes.length - 1; i >= 0; i--){\n                    const flash = window._starFlashes[i];\n                    flash.mesh.scale.multiplyScalar(1.15);\n                    flash.mesh.material.opacity *= 0.85;\n                    flash.age++;\n                    if (flash.age > 10) {\n                        scene.remove(flash.mesh);\n                        window._starFlashes.splice(i, 1);\n                    }\n                }\n            }\n            // --- Starfield logic ---\n            const sqDist = starMaxDistance * starMaxDistance;\n            for(let i = 0; i < positions.length; i += 3){\n                const dx = positions[i] - virtualCameraPos.x;\n                const dy = positions[i + 1] - virtualCameraPos.y;\n                const dz = positions[i + 2] - virtualCameraPos.z;\n                if (dx * dx + dy * dy + dz * dz > sqDist) {\n                    // Place in a thick spherical shell around the virtual camera, never too close\n                    const minRadius = starMaxDistance * 0.8;\n                    const maxRadius = starMaxDistance;\n                    const r = minRadius + Math.random() * (maxRadius - minRadius);\n                    const theta = Math.random() * 2 * Math.PI;\n                    const phi = Math.acos(2 * Math.random() - 1);\n                    positions[i] = virtualCameraPos.x + r * Math.sin(phi) * Math.cos(theta);\n                    positions[i + 1] = virtualCameraPos.y + r * Math.sin(phi) * Math.sin(theta);\n                    positions[i + 2] = virtualCameraPos.z + r * Math.cos(phi);\n                }\n            }\n            // geometry.attributes.position.needsUpdate = true; // Already set above\n            // Robust starfield color update to prevent stuck white dots\n            // This works NO TOUCHY\n            const colArr = geometry.attributes.color.array;\n            for(let i = 0; i < positions.length; i += 3){\n                const idx = i / 3;\n                const dx = positions[i] - virtualCameraPos.x;\n                const dy = positions[i + 1] - virtualCameraPos.y;\n                const dz = positions[i + 2] - virtualCameraPos.z;\n                const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);\n                if (timers[idx] > 0) {\n                    timers[idx]--;\n                    if (timers[idx] === 0) {\n                        // Timer expired, restore color\n                        sparkColors[i] = originalColors[i];\n                        sparkColors[i + 1] = originalColors[i + 1];\n                        sparkColors[i + 2] = originalColors[i + 2];\n                        colArr[i] = originalColors[i];\n                        colArr[i + 1] = originalColors[i + 1];\n                        colArr[i + 2] = originalColors[i + 2];\n                    } else {\n                        colArr[i] = sparkColors[i];\n                        colArr[i + 1] = sparkColors[i + 1];\n                        colArr[i + 2] = sparkColors[i + 2];\n                    }\n                } else if (dist > starMaxDistance * 0.3 && Math.random() < 0.05) {\n                    timers[idx] = sparkleDuration;\n                    const c = palette[Math.floor(Math.random() * palette.length)];\n                    sparkColors[i] = c[0];\n                    sparkColors[i + 1] = c[1];\n                    sparkColors[i + 2] = c[2];\n                    colArr[i] = sparkColors[i];\n                    colArr[i + 1] = sparkColors[i + 1];\n                    colArr[i + 2] = sparkColors[i + 2];\n                } else {\n                    sparkColors[i] = originalColors[i];\n                    sparkColors[i + 1] = originalColors[i + 1];\n                    sparkColors[i + 2] = originalColors[i + 2];\n                    colArr[i] = originalColors[i];\n                    colArr[i + 1] = originalColors[i + 1];\n                    colArr[i + 2] = originalColors[i + 2];\n                }\n            }\n            geometry.attributes.color.needsUpdate = true;\n        };\n        // Start the animation loop\n        animate();\n        // Handle window resize\n        const onResize = ()=>{\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n            shootingStarComposer.setSize(window.innerWidth, window.innerHeight);\n            caComposer.setSize(window.innerWidth, window.innerHeight);\n        };\n        // Add event listener for resize\n        window.addEventListener(\"resize\", onResize);\n        // Clean up function\n        return ()=>{\n            window.removeEventListener(\"resize\", onResize);\n            window.removeEventListener(\"resize\", resizeAll);\n            window.removeEventListener(\"fullscreenchange\", resizeAll);\n            window.removeEventListener(\"scroll\", onScroll);\n            // Cancel the animation frame using the stored ID\n            if (animationId) {\n                cancelAnimationFrame(animationId);\n            }\n            // Dispose composers\n            if (composer) composer.dispose();\n            if (shootingStarComposer) shootingStarComposer.dispose();\n            if (caComposer) caComposer.dispose();\n            // Clean up Three.js resources\n            if (renderer) {\n                renderer.dispose();\n                if (mount && mount.contains(renderer.domElement)) {\n                    mount.removeChild(renderer.domElement);\n                }\n            }\n        };\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: mountRef\n    }, void 0, false, {\n        fileName: \"/home/kayosdev/Websites/Portfolio/components/Starfield.jsx\",\n        lineNumber: 800,\n        columnNumber: 10\n    }, undefined);\n};\n_s(Starfield, \"V9/qkEdV8GfsDZk7lMTA1T8g5Ps=\");\n_c = Starfield;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Starfield);\nvar _c;\n$RefreshReg$(_c, \"Starfield\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LE9BQU9DLFVBQVUsRUFBRUQsT0FBT0UsV0FBVztZQUNsRXFDLFdBQVc1QixPQUFPLENBQUNYLE9BQU9DLFVBQVUsRUFBRUQsT0FBT0UsV0FBVztRQUMxRDtRQUVBLGdDQUFnQztRQUNoQ0YsT0FBTzRDLGdCQUFnQixDQUFDLFVBQVV5UTtRQUVsQyxvQkFBb0I7UUFDcEIsT0FBTztZQUNMclQsT0FBT3NULG1CQUFtQixDQUFDLFVBQVVEO1lBQ3JDclQsT0FBT3NULG1CQUFtQixDQUFDLFVBQVU3UTtZQUNyQ3pDLE9BQU9zVCxtQkFBbUIsQ0FBQyxvQkFBb0I3UTtZQUMvQ3pDLE9BQU9zVCxtQkFBbUIsQ0FBQyxVQUFVbk07WUFDckMsaURBQWlEO1lBQ2pELElBQUlrRixhQUFhO2dCQUNma0gscUJBQXFCbEg7WUFDdkI7WUFDQSxvQkFBb0I7WUFDcEIsSUFBSWpMLFVBQVVBLFNBQVNvUyxPQUFPO1lBQzlCLElBQUl0UixzQkFBc0JBLHFCQUFxQnNSLE9BQU87WUFDdEQsSUFBSWpSLFlBQVlBLFdBQVdpUixPQUFPO1lBQ2xDLDhCQUE4QjtZQUM5QixJQUFJbFQsVUFBVTtnQkFDWkEsU0FBU2tULE9BQU87Z0JBQ2hCLElBQUlwVSxTQUFTQSxNQUFNcVUsUUFBUSxDQUFDblQsU0FBU2EsVUFBVSxHQUFHO29CQUNoRC9CLE1BQU1zVSxXQUFXLENBQUNwVCxTQUFTYSxVQUFVO2dCQUN2QztZQUNGO1FBQ0Y7SUFDRixHQUFHLEVBQUU7SUFFTCxxQkFBTyw4REFBQ3dTO1FBQUlDLEtBQUsxVTs7Ozs7O0FBQ25CO0dBdHhCTUQ7S0FBQUE7QUF3eEJOLCtEQUFlQSxTQUFTQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvU3RhcmZpZWxkLmpzeD9mMWEyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCB7IEVmZmVjdENvbXBvc2VyIH0gZnJvbSAndGhyZWUvZXhhbXBsZXMvanNtL3Bvc3Rwcm9jZXNzaW5nL0VmZmVjdENvbXBvc2VyJztcbmltcG9ydCB7IFVucmVhbEJsb29tUGFzcyB9IGZyb20gJ3RocmVlL2V4YW1wbGVzL2pzbS9wb3N0cHJvY2Vzc2luZy9VbnJlYWxCbG9vbVBhc3MnO1xuaW1wb3J0IHsgUmVuZGVyUGFzcyB9IGZyb20gJ3RocmVlL2V4YW1wbGVzL2pzbS9wb3N0cHJvY2Vzc2luZy9SZW5kZXJQYXNzJztcbmltcG9ydCB7IFNoYWRlclBhc3MgfSBmcm9tICd0aHJlZS9leGFtcGxlcy9qc20vcG9zdHByb2Nlc3NpbmcvU2hhZGVyUGFzcyc7XG5pbXBvcnQgeyBGWEFBU2hhZGVyIH0gZnJvbSAndGhyZWUvZXhhbXBsZXMvanNtL3NoYWRlcnMvRlhBQVNoYWRlcic7XG5pbXBvcnQgeyBGaWxtUGFzcyB9IGZyb20gJ3RocmVlL2V4YW1wbGVzL2pzbS9wb3N0cHJvY2Vzc2luZy9GaWxtUGFzcyc7XG5pbXBvcnQgeyBDaHJvbWF0aWNBYmVycmF0aW9uUGFzcyB9IGZyb20gJy4vQ2hyb21hdGljQWJlcnJhdGlvblBhc3MnO1xuXG5jb25zdCBTdGFyZmllbGQgPSAoKSA9PiB7XG4gIGNvbnN0IG1vdW50UmVmID0gdXNlUmVmKG51bGwpXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBEZWZlbnNpdmU6IGFsd2F5cyB1c2UgLmN1cnJlbnQgZm9yIHJlZnNcbiAgICBpZiAoIW1vdW50UmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICBjb25zdCBtb3VudCA9IG1vdW50UmVmLmN1cnJlbnRcbiAgICBtb3VudC5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCdcbiAgICBtb3VudC5zdHlsZS50b3AgPSAnMCdcbiAgICBtb3VudC5zdHlsZS5sZWZ0ID0gJzAnXG4gICAgbW91bnQuc3R5bGUud2lkdGggPSAnMTAwJSdcbiAgICBtb3VudC5zdHlsZS5oZWlnaHQgPSAnMTAwJSdcbiAgICBtb3VudC5zdHlsZS56SW5kZXggPSAnMCdcblxuICAgIC8vIFNjZW5lICYgUmVuZGVyZXJcbiAgICBjb25zdCBzY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpXG4gICAgY29uc3QgY2FtZXJhID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKDc1LCB3aW5kb3cuaW5uZXJXaWR0aCAvIHdpbmRvdy5pbm5lckhlaWdodCwgMC4xLCA1MDAwKVxuICAgIGNhbWVyYS5wb3NpdGlvbi5zZXQoMCwgMCwgMCk7XG4gICAgLy8gVmlydHVhbCBwb3NpdGlvbiB0byBzaW11bGF0ZSBpbmZpbml0ZSB0cmF2ZWxcbiAgICBsZXQgdmlydHVhbENhbWVyYVBvcyA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDApO1xuICAgIGNvbnN0IHJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoeyBhbnRpYWxpYXM6IGZhbHNlIH0pIC8vIFdlJ2xsIHVzZSBGWEFBIGluc3RlYWRcbiAgICByZW5kZXJlci5zZXRQaXhlbFJhdGlvKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKVxuICAgIHJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodClcbiAgICByZW5kZXJlci5zZXRDbGVhckNvbG9yKDB4MDAwMDAwLCAxKTtcbiAgICBpZiAoJ291dHB1dENvbG9yU3BhY2UnIGluIHJlbmRlcmVyKSB7XG4gICAgICByZW5kZXJlci5vdXRwdXRDb2xvclNwYWNlID0gVEhSRUUuU1JHQkNvbG9yU3BhY2U7XG4gICAgfVxuICAgIHJlbmRlcmVyLnRvbmVNYXBwaW5nID0gVEhSRUUuTm9Ub25lTWFwcGluZztcbiAgICByZW5kZXJlci5hdXRvQ2xlYXIgPSB0cnVlO1xuICAgIG1vdW50LmFwcGVuZENoaWxkKHJlbmRlcmVyLmRvbUVsZW1lbnQpXG5cbiAgICAvLyAtLS0gTUFJTiBTVEFSRklFTEQgUE9TVC1QUk9DRVNTSU5HIC0tLVxuICAgIGNvbnN0IGNvbXBvc2VyID0gbmV3IEVmZmVjdENvbXBvc2VyKHJlbmRlcmVyKTtcbiAgICBjb21wb3Nlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgIGNvbnN0IHJlbmRlclBhc3MgPSBuZXcgUmVuZGVyUGFzcyhzY2VuZSwgY2FtZXJhKTtcbiAgICByZW5kZXJQYXNzLmNsZWFyID0gdHJ1ZTtcbiAgICBjb21wb3Nlci5hZGRQYXNzKHJlbmRlclBhc3MpO1xuICAgIC8vIFVucmVhbEJsb29tUGFzczogXCJjcmF6eVwiIGJsb29tXG4gICAgY29uc3QgYmxvb21QYXNzID0gbmV3IFVucmVhbEJsb29tUGFzcyhcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpLFxuICAgICAgMy41LCAvLyBpbnRlbnNpdHlcbiAgICAgIDEuNiwgLy8gcmFkaXVzXG4gICAgICAwLjAxIC8vIHRocmVzaG9sZFxuICAgICk7XG4gICAgY29tcG9zZXIuYWRkUGFzcyhibG9vbVBhc3MpO1xuICAgIC8vIEZYQUEgUGFzc1xuICAgIGNvbnN0IGZ4YWFQYXNzID0gbmV3IFNoYWRlclBhc3MoRlhBQVNoYWRlcik7XG4gICAgZnhhYVBhc3MubWF0ZXJpYWwudW5pZm9ybXNbJ3Jlc29sdXRpb24nXS52YWx1ZS54ID0gMSAvIHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIGZ4YWFQYXNzLm1hdGVyaWFsLnVuaWZvcm1zWydyZXNvbHV0aW9uJ10udmFsdWUueSA9IDEgLyB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgY29tcG9zZXIuYWRkUGFzcyhmeGFhUGFzcyk7XG4gICAgLy8gRmlsbVBhc3NcbiAgICBjb25zdCBmaWxtUGFzcyA9IG5ldyBGaWxtUGFzcyhcbiAgICAgIDAuNywgLy8gbm9pc2UgaW50ZW5zaXR5XG4gICAgICAwLjA4LCAvLyBzY2FubGluZSBpbnRlbnNpdHlcbiAgICAgIDY0OCwgLy8gc2NhbmxpbmUgY291bnRcbiAgICAgIGZhbHNlIC8vIGdyYXlzY2FsZVxuICAgICk7XG4gICAgY29tcG9zZXIuYWRkUGFzcyhmaWxtUGFzcyk7XG5cbiAgICBcbiAgICAvLyAtLS0gU0hPT1RJTkcgU1RBUiBQT1NULVBST0NFU1NJTkcgT05MWSAtLS1cbiAgICAvLyBTZXBhcmF0ZSBzY2VuZSBhbmQgY29tcG9zZXIgZm9yIHNob290aW5nIHN0YXJzXG4gICAgY29uc3Qgc2hvb3RpbmdTdGFyU2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcbiAgICBjb25zdCBzaG9vdGluZ1N0YXJDb21wb3NlciA9IG5ldyBFZmZlY3RDb21wb3NlcihyZW5kZXJlcik7XG4gICAgc2hvb3RpbmdTdGFyQ29tcG9zZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICBjb25zdCBzaG9vdGluZ1N0YXJSZW5kZXJQYXNzID0gbmV3IFJlbmRlclBhc3Moc2hvb3RpbmdTdGFyU2NlbmUsIGNhbWVyYSk7XG4gICAgc2hvb3RpbmdTdGFyQ29tcG9zZXIuYWRkUGFzcyhzaG9vdGluZ1N0YXJSZW5kZXJQYXNzKTtcbiAgICAvLyBJbnRlbnNlIGJsb29tIGZvciBzaG9vdGluZyBzdGFyc1xuICAgIGNvbnN0IHNob290aW5nU3RhckJsb29tUGFzcyA9IG5ldyBVbnJlYWxCbG9vbVBhc3MoXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMih3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KSxcbiAgICAgIDQuMCwgLy8gc3Ryb25nXG4gICAgICAyLjAsIC8vIHdpZGVcbiAgICAgIDAuMCAvLyBhbGwgYnJpZ2h0XG4gICAgKTtcbiAgICBzaG9vdGluZ1N0YXJDb21wb3Nlci5hZGRQYXNzKHNob290aW5nU3RhckJsb29tUGFzcyk7XG5cbiAgICAvLyAtLS0gQ0xPU0UgU1RBUlM6IFNlcGFyYXRlIFNjZW5lIGZvciBDaHJvbWF0aWMgQWJlcnJhdGlvbiAtLS1cbiAgICBjb25zdCBjbG9zZVN0YXJzU2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcbiAgICBjb25zdCBjYVBhc3MgPSBuZXcgQ2hyb21hdGljQWJlcnJhdGlvblBhc3MobmV3IFRIUkVFLlZlY3RvcjIoMC4wMDAyLCAwLjAwMDIpKTsgLy8gYmFyZWx5IHZpc2libGVcbiAgICBjb25zdCBjYUNvbXBvc2VyID0gbmV3IEVmZmVjdENvbXBvc2VyKHJlbmRlcmVyKTtcbiAgICBjYUNvbXBvc2VyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgY29uc3QgY2FSZW5kZXJQYXNzID0gbmV3IFJlbmRlclBhc3MoY2xvc2VTdGFyc1NjZW5lLCBjYW1lcmEpO1xuICAgIGNhQ29tcG9zZXIuYWRkUGFzcyhjYVJlbmRlclBhc3MpO1xuICAgIGNhQ29tcG9zZXIuYWRkUGFzcyhjYVBhc3MpO1xuXG4gICAgLy8gLS0tIEhBTkRMRSBSRVNJWkUgQU5EIEZVTExTQ1JFRU4gLS0tXG4gICAgZnVuY3Rpb24gcmVzaXplQWxsKCkge1xuICAgICAgY2FtZXJhLmFzcGVjdCA9IHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAgIHJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG5cbiAgICAgIC8vIE1haW4gY29tcG9zZXJcbiAgICAgIGNvbXBvc2VyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgICAvLyBGWEFBIHJlc29sdXRpb25cbiAgICAgIGZ4YWFQYXNzLm1hdGVyaWFsLnVuaWZvcm1zWydyZXNvbHV0aW9uJ10udmFsdWUueCA9IDEgLyB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgIGZ4YWFQYXNzLm1hdGVyaWFsLnVuaWZvcm1zWydyZXNvbHV0aW9uJ10udmFsdWUueSA9IDEgLyB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICAvLyBPdGhlciBjb21wb3NlcnNcbiAgICAgIHNob290aW5nU3RhckNvbXBvc2VyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgICBjYUNvbXBvc2VyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgfVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCByZXNpemVBbGwpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdmdWxsc2NyZWVuY2hhbmdlJywgcmVzaXplQWxsKTtcblxuICAgIC8vIFN0YXJmaWVsZFxuICAgIGNvbnN0IHN0YXJDb3VudCA9IDUwMDBcbiAgICBjb25zdCBzdGFyTWF4RGlzdGFuY2UgPSAyMDAwXG4gICAgY29uc3Qgc3RhclNwZWVkID0gMVxuICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KClcbiAgICBjb25zdCBjbG9zZUdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XG4gICAgY29uc3QgcG9zaXRpb25zID0gW107XG4gICAgY29uc3QgY2xvc2VQb3NpdGlvbnMgPSBbXTtcbiAgICBsZXQgc3RhcnNQbGFjZWQgPSAwO1xuICAgIHdoaWxlIChzdGFyc1BsYWNlZCA8IHN0YXJDb3VudCkge1xuICAgICAgLy8gV2l0aCAxJSBjaGFuY2UsIHNwYXduIGEgc3RhciBjbHVzdGVyICgxMC0zMCBzdGFycylcbiAgICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgMC4wMSAmJiBzdGFyc1BsYWNlZCA8IHN0YXJDb3VudCAtIDEwKSB7XG4gICAgICAgIGNvbnN0IGNsdXN0ZXJUaGV0YSA9IE1hdGgucmFuZG9tKCkgKiAyICogTWF0aC5QSTtcbiAgICAgICAgY29uc3QgY2x1c3RlclBoaSA9IE1hdGguYWNvcygyICogTWF0aC5yYW5kb20oKSAtIDEpO1xuICAgICAgICBjb25zdCBjbHVzdGVyUiA9IE1hdGgucmFuZG9tKCkgKiBzdGFyTWF4RGlzdGFuY2U7XG4gICAgICAgIGNvbnN0IGNsdXN0ZXJDZW50ZXIgPSBbXG4gICAgICAgICAgY2x1c3RlclIgKiBNYXRoLnNpbihjbHVzdGVyUGhpKSAqIE1hdGguY29zKGNsdXN0ZXJUaGV0YSksXG4gICAgICAgICAgY2x1c3RlclIgKiBNYXRoLnNpbihjbHVzdGVyUGhpKSAqIE1hdGguc2luKGNsdXN0ZXJUaGV0YSksXG4gICAgICAgICAgY2x1c3RlclIgKiBNYXRoLmNvcyhjbHVzdGVyUGhpKVxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBjbHVzdGVyU2l6ZSA9IDEwICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjApOyAvLyAxMC0zMCBzdGFyc1xuICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGNsdXN0ZXJTaXplICYmIHN0YXJzUGxhY2VkIDwgc3RhckNvdW50OyBjKyspIHtcbiAgICAgICAgICAvLyBFYWNoIHN0YXIgaW4gY2x1c3RlciBpcyB3aXRoaW4gMzAgdW5pdHMgb2YgY2VudGVyXG4gICAgICAgICAgY29uc3Qgb2Zmc2V0VGhldGEgPSBNYXRoLnJhbmRvbSgpICogMiAqIE1hdGguUEk7XG4gICAgICAgICAgY29uc3Qgb2Zmc2V0UGhpID0gTWF0aC5hY29zKDIgKiBNYXRoLnJhbmRvbSgpIC0gMSk7XG4gICAgICAgICAgY29uc3Qgb2Zmc2V0UiA9IE1hdGgucmFuZG9tKCkgKiAzMDsgLy8gY2x1c3RlciByYWRpdXNcbiAgICAgICAgICBwb3NpdGlvbnMucHVzaChcbiAgICAgICAgICAgIGNsdXN0ZXJDZW50ZXJbMF0gKyBvZmZzZXRSICogTWF0aC5zaW4ob2Zmc2V0UGhpKSAqIE1hdGguY29zKG9mZnNldFRoZXRhKSxcbiAgICAgICAgICAgIGNsdXN0ZXJDZW50ZXJbMV0gKyBvZmZzZXRSICogTWF0aC5zaW4ob2Zmc2V0UGhpKSAqIE1hdGguc2luKG9mZnNldFRoZXRhKSxcbiAgICAgICAgICAgIGNsdXN0ZXJDZW50ZXJbMl0gKyBvZmZzZXRSICogTWF0aC5jb3Mob2Zmc2V0UGhpKVxuICAgICAgICAgICk7XG4gICAgICAgICAgc3RhcnNQbGFjZWQrKztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm9ybWFsIHNpbmdsZSBzdGFyXG4gICAgICAgIGNvbnN0IHRoZXRhID0gTWF0aC5yYW5kb20oKSAqIDIgKiBNYXRoLlBJO1xuICAgICAgICBjb25zdCBwaGkgPSBNYXRoLmFjb3MoMiAqIE1hdGgucmFuZG9tKCkgLSAxKTtcbiAgICAgICAgY29uc3QgciA9IE1hdGgucmFuZG9tKCkgKiBzdGFyTWF4RGlzdGFuY2U7XG4gICAgICAgIGNvbnN0IHggPSByICogTWF0aC5zaW4ocGhpKSAqIE1hdGguY29zKHRoZXRhKTtcbiAgICAgICAgY29uc3QgeSA9IHIgKiBNYXRoLnNpbihwaGkpICogTWF0aC5zaW4odGhldGEpO1xuICAgICAgICBjb25zdCB6ID0gciAqIE1hdGguY29zKHBoaSk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKHgsIHksIHopO1xuICAgICAgICAvLyBJZiBjbG9zZSwgYWxzbyBhZGQgdG8gY2xvc2VQb3NpdGlvbnNcbiAgICAgICAgaWYgKHIgPCA0MDApIHtcbiAgICAgICAgICBjbG9zZVBvc2l0aW9ucy5wdXNoKHgsIHksIHopO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJzUGxhY2VkKys7XG4gICAgICB9XG4gICAgfVxuICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgVEhSRUUuRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbnMsIDMpKVxuICAgIGlmIChjbG9zZVBvc2l0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICBjbG9zZUdlb21ldHJ5LnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgVEhSRUUuRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShjbG9zZVBvc2l0aW9ucywgMykpO1xuICAgIH1cblxuICAgIC8vIENSQVpZIEJMT09NOiBBbGwgc3RhcnMgYXJlIGV4dHJlbWVseSBicmlnaHQgKGNvbG9yIGludGVuc2l0eSA+MSlcbiAgICBjb25zdCBwYWxldHRlID0gW1xuICAgICAgWzEuMCwgMC41LCAwLjVdLFxuICAgICAgWzEuMCwgMC43NSwgMC40XSxcbiAgICAgIFsxLjAsIDEuMCwgMC45XSxcbiAgICAgIFsxLjAsIDEuMCwgMS4wXSxcbiAgICAgIFswLjQsIDAuNSwgMS4wXSxcbiAgICBdO1xuICAgIGNvbnN0IGNvbG9ycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhckNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IGMgPSBwYWxldHRlW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHBhbGV0dGUubGVuZ3RoKV07XG4gICAgICBjb2xvcnMucHVzaCguLi5jKTtcbiAgICB9XG4gICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdjb2xvcicsIG5ldyBUSFJFRS5GbG9hdDMyQnVmZmVyQXR0cmlidXRlKGNvbG9ycywgMykpO1xuXG4gICAgY29uc3Qgb3JpZ2luYWxDb2xvcnMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLmNvbG9yLmFycmF5LnNsaWNlKClcbiAgICBjb25zdCB0aW1lcnMgPSBuZXcgRmxvYXQzMkFycmF5KHN0YXJDb3VudClcbiAgICBjb25zdCBzcGFya0NvbG9ycyA9IG5ldyBGbG9hdDMyQXJyYXkoc3RhckNvdW50ICogMylcbiAgICBjb25zdCBzcGFya2xlRHVyYXRpb24gPSAxODBcblxuICAgIC8vIC0tLSBTUVVBUkUgU1RBUlMgVVNJTkcgUE9JTlRTIC0tLVxuY29uc3QgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuUG9pbnRzTWF0ZXJpYWwoeyBzaXplOiAxMCwgc2l6ZUF0dGVudWF0aW9uOiBmYWxzZSwgdmVydGV4Q29sb3JzOiB0cnVlIH0pO1xuY29uc3Qgc3RhcnMgPSBuZXcgVEhSRUUuUG9pbnRzKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG5zY2VuZS5hZGQoc3RhcnMpO1xuLy8gQWRkIGdsb3cgc3ByaXRlcyB0byBlYWNoIHN0YXIgYW5kIGFuaW1hdGUgdGhlbSBiYXNlZCBvbiBkaXN0YW5jZVxuY29uc3QgZ2xvd01hcCA9IG5ldyBUSFJFRS5UZXh0dXJlTG9hZGVyKCkubG9hZCgnL2dsb3cucG5nJyk7XG5jb25zdCBnbG93U3ByaXRlcyA9IFtdO1xuY29uc3QgZ2xvd01hdGVyaWFsID0gbmV3IFRIUkVFLlNwcml0ZU1hdGVyaWFsKHsgbWFwOiBnbG93TWFwLCBjb2xvcjogMHhmZmZmZmYsIG9wYWNpdHk6IDAuMTgsIGJsZW5kaW5nOiBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nLCBkZXB0aFdyaXRlOiBmYWxzZSB9KTtcbmZvciAobGV0IGkgPSAwOyBpIDwgc3RhckNvdW50OyBpKyspIHtcbiAgY29uc3QgZ2xvdyA9IG5ldyBUSFJFRS5TcHJpdGUoZ2xvd01hdGVyaWFsLmNsb25lKCkpO1xuICBnbG93LnBvc2l0aW9uLnNldChwb3NpdGlvbnNbaSozXSwgcG9zaXRpb25zW2kqMysxXSwgcG9zaXRpb25zW2kqMysyXSk7XG4gIGdsb3cuc2NhbGUuc2V0KDEwLCAxMCwgMSk7XG4gIHNjZW5lLmFkZChnbG93KTtcbiAgZ2xvd1Nwcml0ZXMucHVzaChnbG93KTtcbn1cbi8vIEFkZCBjbG9zZSBzdGFycyB0byBzZXBhcmF0ZSBzY2VuZVxubGV0IGNsb3NlU3RhcnM7XG5pZiAoY2xvc2VQb3NpdGlvbnMubGVuZ3RoID4gMCkge1xuICBjbG9zZVN0YXJzID0gbmV3IFRIUkVFLlBvaW50cyhjbG9zZUdlb21ldHJ5LCBtYXRlcmlhbC5jbG9uZSgpKTtcbiAgY2xvc2VTdGFyc1NjZW5lLmFkZChjbG9zZVN0YXJzKTtcbn1cblxuICAgIGxldCB0YXJnZXRZID0gMFxuICAgIGNvbnN0IGRhbXBpbmcgPSAwLjA1XG4gICAgY29uc3Qgb25TY3JvbGwgPSAoKSA9PiB7XG4gICAgICBjb25zdCBwY3QgPSB3aW5kb3cuc2Nyb2xsWSAvIChkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCAtIHdpbmRvdy5pbm5lckhlaWdodClcbiAgICAgIHRhcmdldFkgPSBwY3QgKiBNYXRoLlBJICogMlxuICAgIH1cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25TY3JvbGwpXG5cblxuICAgIC8vIC0tLSBTaG9vdGluZyBTdGFycyAtLS1cbiAgICBjb25zdCB0YWlsTGVuZ3RoID0gMzI7IC8vIEluY3JlYXNlIGZvciBsb25nZXIgdGFpbHNcbiAgICBjb25zdCBzaG9vdGluZ1N0YXJzID0gW107XG4gICAgbGV0IHNob290aW5nU3RhckNvb2xkb3duID0gMDtcbiAgICAvLyBTcGF3biBhIHNob290aW5nIHN0YXIgd2l0aCBhIHN0dW5uaW5nIGdsb3dpbmcgdGFpbFxuICAgIGZ1bmN0aW9uIHNwYXduU2hvb3RpbmdTdGFyKCkge1xuICAgICAgLy8gUGljayBhIHJhbmRvbSBkaXJlY3Rpb24gb24gdGhlIHNwaGVyZSBmb3IgdGhlIHNwYXduIGxvY2F0aW9uXG4gICAgICBjb25zdCBkaXIgPSBuZXcgVEhSRUUuVmVjdG9yMyhNYXRoLnJhbmRvbSgpKjItMSwgTWF0aC5yYW5kb20oKSoyLTEsIE1hdGgucmFuZG9tKCkqMi0xKS5ub3JtYWxpemUoKTtcbiAgICAgIC8vIEVuc3VyZSBzaG9vdGluZyBzdGFycyBuZXZlciBzcGF3biBjbG9zZSB0byB0aGUgY2FtZXJhIChhdCBsZWFzdCA3MCUgb2YgbWF4IGRpc3RhbmNlKVxuICAgICAgY29uc3QgbWluRGlzdCA9IHN0YXJNYXhEaXN0YW5jZSAqIDAuNztcbiAgICAgIGNvbnN0IG1heERpc3QgPSBzdGFyTWF4RGlzdGFuY2UgKiAxLjA7XG4gICAgICBjb25zdCBkaXN0ID0gbWluRGlzdCArIE1hdGgucmFuZG9tKCkgKiAobWF4RGlzdCAtIG1pbkRpc3QpO1xuICAgICAgY29uc3Qgc3Bhd25Qb3MgPSBkaXIuY2xvbmUoKS5tdWx0aXBseVNjYWxhcihkaXN0KTtcbiAgICAgIC8vIFRhbmdlbnRpYWwgdmVsb2NpdHk6IHBlcnBlbmRpY3VsYXIgdG8gZGlyXG4gICAgICBsZXQgdGFuZ2VudCA9IG5ldyBUSFJFRS5WZWN0b3IzKE1hdGgucmFuZG9tKCkqMi0xLCBNYXRoLnJhbmRvbSgpKjItMSwgTWF0aC5yYW5kb20oKSoyLTEpO1xuICAgICAgdGFuZ2VudCA9IHRhbmdlbnQuc3ViKHRhbmdlbnQuY2xvbmUoKS5wcm9qZWN0T25WZWN0b3IoZGlyKSkubm9ybWFsaXplKCk7XG4gICAgICAvLyBNaXggaW4gYSBzbWFsbCByYWRpYWwgY29tcG9uZW50IChpbndhcmQgb3Igb3V0d2FyZClcbiAgICAgIGNvbnN0IHRhbmdlbnRpYWxTcGVlZCA9IHN0YXJTcGVlZCAqICgyLjUgKyBNYXRoLnJhbmRvbSgpICogMi41KTsgLy8gbXVjaCBmYXN0ZXJcbiAgICAgIGNvbnN0IHJhZGlhbFNwZWVkID0gc3RhclNwZWVkICogKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMC4zOyAvLyBtb3JlIGRyYW1hdGljXG4gICAgICBjb25zdCB2ZWxvY2l0eSA9IHRhbmdlbnQubXVsdGlwbHlTY2FsYXIodGFuZ2VudGlhbFNwZWVkKS5hZGQoZGlyLmNsb25lKCkubXVsdGlwbHlTY2FsYXIocmFkaWFsU3BlZWQpKTtcblxuICAgICAgLy8gU3R1bm5pbmcgY29sb3IgZ3JhZGllbnQgZm9yIHRoZSBoZWFkXG4gICAgICBjb25zdCB2aWJyYW50Q29sb3JzID0gWzB4ZmZlMDY2LCAweGZmNjZjYywgMHg2NmNjZmYsIDB4ZmZmZmZmLCAweDgwZmZlYSwgMHhmZmYyY2MsIDB4ZmZjMDgwLCAweDgwYzBmZiwgMHhmZjgwYjNdO1xuICAgICAgY29uc3QgY29sb3IgPSB2aWJyYW50Q29sb3JzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSp2aWJyYW50Q29sb3JzLmxlbmd0aCldO1xuICAgICAgLy8gU3RhciBicmlnaHRuZXNzIGFuZCBzaXplIChhbHdheXMgc21hbGwgYW5kIHN1YnRsZSlcbiAgICAgIGNvbnN0IGJyaWdodG5lc3MgPSAyLjUgKyBNYXRoLnJhbmRvbSgpKjEuNTtcbiAgICAgIGNvbnN0IGdlbyA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeSgwLjcgKyBNYXRoLnJhbmRvbSgpKjAuNSwgMTYsIDE2KTsgLy8gU21hbGwgc3BoZXJlXG4gICAgICBjb25zdCBtYXQgPSBuZXcgVEhSRUUuTWVzaFBoeXNpY2FsTWF0ZXJpYWwoe1xuICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgIGVtaXNzaXZlOiBjb2xvcixcbiAgICAgICAgZW1pc3NpdmVJbnRlbnNpdHk6IDE0LjAsIC8vIEludGVuc2UgYmxvb21cbiAgICAgICAgbWV0YWxuZXNzOiAwLjcsXG4gICAgICAgIHJvdWdobmVzczogMC4zLFxuICAgICAgICB0cmFuc21pc3Npb246IDAuNyxcbiAgICAgICAgb3BhY2l0eTogMC45OCxcbiAgICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXG4gICAgICAgIGNsZWFyY29hdDogMC44LFxuICAgICAgICBjbGVhcmNvYXRSb3VnaG5lc3M6IDAuMixcbiAgICAgIH0pO1xuICAgICAgY29uc3Qgc3RhciA9IG5ldyBUSFJFRS5NZXNoKGdlbywgbWF0KTtcbiAgICAgIC8vIEFkZCBhIGxhcmdlLCBpbnRlbnNlIGJsb29tIHNwcml0ZSBmb3IgZXh0cmEgYmxvb21cbiAgICAgIGNvbnN0IHNwcml0ZU1hcCA9IG5ldyBUSFJFRS5UZXh0dXJlTG9hZGVyKCkubG9hZCgnL2dsb3cucG5nJyk7XG4gICAgICBjb25zdCBzcHJpdGVNYXRlcmlhbCA9IG5ldyBUSFJFRS5TcHJpdGVNYXRlcmlhbCh7IG1hcDogc3ByaXRlTWFwLCBjb2xvcjogMHhmZmZmZmYsIG9wYWNpdHk6IDEuMCwgYmxlbmRpbmc6IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmcgfSk7XG4gICAgICBjb25zdCBzcHJpdGUgPSBuZXcgVEhSRUUuU3ByaXRlKHNwcml0ZU1hdGVyaWFsKTtcbiAgICAgIHNwcml0ZS5zY2FsZS5zZXQoNzAsIDcwLCAxKTsgLy8gTGFyZ2UgZm9yIGJsb29tXG4gICAgICBzcHJpdGUucG9zaXRpb24uY29weShzdGFyLnBvc2l0aW9uKTtcbiAgICAgIHN0YXIuYWRkKHNwcml0ZSk7XG4gICAgICAvLyBBZGQgYSBjb2xvcmVkIHNwcml0ZSBmb3IgY29sb3IgcG9wXG4gICAgICBjb25zdCBjb2xvclNwcml0ZU1hdGVyaWFsID0gbmV3IFRIUkVFLlNwcml0ZU1hdGVyaWFsKHsgbWFwOiBzcHJpdGVNYXAsIGNvbG9yOiBjb2xvciwgb3BhY2l0eTogMC42LCBibGVuZGluZzogVEhSRUUuQWRkaXRpdmVCbGVuZGluZyB9KTtcbiAgICAgIGNvbnN0IGNvbG9yU3ByaXRlID0gbmV3IFRIUkVFLlNwcml0ZShjb2xvclNwcml0ZU1hdGVyaWFsKTtcbiAgICAgIGNvbG9yU3ByaXRlLnNjYWxlLnNldCgzNCwgMzQsIDEpO1xuICAgICAgY29sb3JTcHJpdGUucG9zaXRpb24uY29weShzdGFyLnBvc2l0aW9uKTtcbiAgICAgIHN0YXIuYWRkKGNvbG9yU3ByaXRlKTtcbiAgICAgIC8vIEFkZCB0byBib3RoIG1haW4gc2NlbmUgYW5kIHNob290aW5nU3RhclNjZW5lXG4gICAgICBzY2VuZS5hZGQoc3Rhcik7XG4gICAgICBzaG9vdGluZ1N0YXJTY2VuZS5hZGQoc3Rhcik7XG4gICAgICAvLyBBZGQgZHluYW1pYyBzcGFyayBidXJzdCBhdCB0aGUgaGVhZFxuICAgICAgY29uc3Qgc3BhcmtDb3VudCA9IDE4ICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKjgpO1xuICAgICAgY29uc3Qgc3BhcmtHcm91cCA9IG5ldyBUSFJFRS5Hcm91cCgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGFya0NvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3Qgc3BhcmtNYXQgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoeyBjb2xvcjogdmlicmFudENvbG9yc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqdmlicmFudENvbG9ycy5sZW5ndGgpXSwgdHJhbnNwYXJlbnQ6IHRydWUsIG9wYWNpdHk6IDAuOCB9KTtcbiAgICAgICAgY29uc3Qgc3BhcmtHZW8gPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoMC4wNyArIE1hdGgucmFuZG9tKCkqMC4wNiwgOCwgOCk7XG4gICAgICAgIGNvbnN0IHNwYXJrID0gbmV3IFRIUkVFLk1lc2goc3BhcmtHZW8sIHNwYXJrTWF0KTtcbiAgICAgICAgY29uc3QgYW5nbGUgPSAoaSAvIHNwYXJrQ291bnQpICogTWF0aC5QSSAqIDI7XG4gICAgICAgIHNwYXJrLnBvc2l0aW9uLnNldChNYXRoLmNvcyhhbmdsZSkqMS4yLCBNYXRoLnNpbihhbmdsZSkqMS4yLCBNYXRoLnJhbmRvbSgpKjAuNC0wLjIpO1xuICAgICAgICBzcGFya0dyb3VwLmFkZChzcGFyayk7XG4gICAgICB9XG4gICAgICBzcGFya0dyb3VwLm5hbWUgPSAnc3BhcmtCdXJzdCc7XG4gICAgICBzdGFyLmFkZChzcGFya0dyb3VwKTtcbiAgICAgIHN0YXIucG9zaXRpb24uY29weShzcGF3blBvcyk7XG4gICAgICBzdGFyLnZlbG9jaXR5ID0gdmVsb2NpdHk7XG4gICAgICBzdGFyLm5vcm1hbGl6ZWRMaWZlID0gMC4wO1xuICAgICAgc3Rhci5ub3JtYWxpemVkTGlmZXRpbWUgPSA4MCArIE1hdGgucmFuZG9tKCkgKiA4MDsgLy8gTG9uZ2VyLCBtb3JlIGRyYW1hdGljXG4gICAgICBzdGFyLmFnZSA9IDA7XG4gICAgICAvLyAtLS0gU3R1bm5pbmcgTWV0ZW9yIFRhaWwgKHZlcnkgbG9uZywgbXVsdGktY29sb3IsIGdsb3dpbmcsIGZhZGluZywgYW5kIDNEIGN1cnZlKSAtLS1cbiAgICAgIGNvbnN0IHRyYWlsU2VnbWVudHMgPSB0YWlsTGVuZ3RoICogMzsgXG4gICAgICBjb25zdCB0cmFpbFBvaW50cyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFpbFNlZ21lbnRzOyBpKyspIHtcbiAgICAgICAgLy8gQWRkIGEgM0Qgc3BpcmFsL2N1cnZlIGZvciBtb3JlIGRlcHRoXG4gICAgICAgIGNvbnN0IHNwaXJhbCA9IE1hdGguc2luKGkgKiAwLjI1KSAqIDg7XG4gICAgICAgIGNvbnN0IGN1cnZlID0gTWF0aC5jb3MoaSAqIDAuMTUpICogNDtcbiAgICAgICAgY29uc3QgcHQgPSBzdGFyLnBvc2l0aW9uLmNsb25lKCkuYWRkKG5ldyBUSFJFRS5WZWN0b3IzKHNwaXJhbCwgY3VydmUsIC1pICogMykpO1xuICAgICAgICB0cmFpbFBvaW50cy5wdXNoKHB0KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhaWxHZW8gPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKS5zZXRGcm9tUG9pbnRzKHRyYWlsUG9pbnRzKTtcbiAgICAgIC8vIFBlci12ZXJ0ZXggY29sb3IgKG11bHRpLWNvbG9yIHJhaW5ib3cgZ3JhZGllbnQpXG4gICAgICBjb25zdCB0YWlsQ29sb3JzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYWlsU2VnbWVudHM7IGkrKykge1xuICAgICAgICAvLyBBbHBoYSBmYWRlcyBvdXQgYWxvbmcgdGhlIHRhaWxcbiAgICAgICAgY29uc3QgYWxwaGEgPSAoMSAtIGkgLyAodHJhaWxTZWdtZW50cyAtIDEpKSAqIDAuOTk7XG4gICAgICAgIC8vIFJhaW5ib3cgZ3JhZGllbnRcbiAgICAgICAgY29uc3QgcmFpbmJvdyA9IFsweGZmZTA2NiwgMHhmZjY2Y2MsIDB4NjZjY2ZmLCAweGZmZmZmZiwgMHg4MGZmZWEsIDB4ZmZmMmNjLCAweGZmYzA4MCwgMHg4MGMwZmYsIDB4ZmY4MGIzXTtcbiAgICAgICAgY29uc3QgZ3JhZENvbG9yID0gcmFpbmJvd1tNYXRoLmZsb29yKChpIC8gdHJhaWxTZWdtZW50cykgKiByYWluYm93Lmxlbmd0aCldO1xuICAgICAgICB0YWlsQ29sb3JzLnB1c2goKGdyYWRDb2xvciA+PiAxNiAmIDI1NSkgLyAyNTUsIChncmFkQ29sb3IgPj4gOCAmIDI1NSkgLyAyNTUsIChncmFkQ29sb3IgJiAyNTUpIC8gMjU1LCBhbHBoYSk7XG4gICAgICB9XG4gICAgICB0YWlsR2VvLnNldEF0dHJpYnV0ZSgnY29sb3InLCBuZXcgVEhSRUUuRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh0YWlsQ29sb3JzLCA0KSk7XG4gICAgICAvLyBBZGRpdGl2ZSBibGVuZGluZyBmb3IgZ2xvdyArIEJMT09NRUQgVEFJTFxuICAgICAgY29uc3QgdGFpbE1hdCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCh7IHZlcnRleENvbG9yczogdHJ1ZSwgdHJhbnNwYXJlbnQ6IHRydWUsIG9wYWNpdHk6IDEuMCwgYmxlbmRpbmc6IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmcgfSk7XG4gICAgICAvLyAtLS0gVEFJTFMgLS0tXG4gICAgICAvLyAxLiBDcmlzcCB0YWlsIGZvciBtYWluIHNjZW5lXG4gICAgICBjb25zdCB0YWlsTWF0TWFpbiA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCh7IHZlcnRleENvbG9yczogdHJ1ZSwgdHJhbnNwYXJlbnQ6IHRydWUsIG9wYWNpdHk6IDEuMCwgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nIH0pO1xuICAgICAgY29uc3QgdGFpbE1haW4gPSBuZXcgVEhSRUUuTGluZSh0YWlsR2VvLmNsb25lKCksIHRhaWxNYXRNYWluKTtcbiAgICAgIHRhaWxNYWluLnBvc2l0aW9uLmNvcHkoc3Rhci5wb3NpdGlvbik7XG4gICAgICBzY2VuZS5hZGQodGFpbE1haW4pO1xuICAgICAgLy8gMi4gSW50ZW5zZSBibG9vbSB0YWlsIGZvciBzaG9vdGluZ1N0YXJTY2VuZVxuICAgICAgY29uc3QgdGFpbE1hdEJsb29tID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKHsgdmVydGV4Q29sb3JzOiB0cnVlLCB0cmFuc3BhcmVudDogdHJ1ZSwgb3BhY2l0eTogMS4wLCBibGVuZGluZzogVEhSRUUuQWRkaXRpdmVCbGVuZGluZyB9KTtcbiAgICAgIGNvbnN0IHRhaWxCbG9vbSA9IG5ldyBUSFJFRS5MaW5lKHRhaWxHZW8sIHRhaWxNYXRCbG9vbSk7XG4gICAgICB0YWlsQmxvb20ucG9zaXRpb24uY29weShzdGFyLnBvc2l0aW9uKTtcbiAgICAgIC8vIEFkZCBhIGJsb29tIHNwcml0ZSB0byB0aGUgdGFpbCdzIGhlYWQgZm9yIGV4dHJhIGdsb3dcbiAgICAgIGNvbnN0IHRhaWxHbG93TWFwID0gbmV3IFRIUkVFLlRleHR1cmVMb2FkZXIoKS5sb2FkKCcvZ2xvdy5wbmcnKTtcbiAgICAgIGNvbnN0IHRhaWxHbG93TWF0ID0gbmV3IFRIUkVFLlNwcml0ZU1hdGVyaWFsKHsgbWFwOiB0YWlsR2xvd01hcCwgY29sb3I6IDB4ZmZmZmZmLCBvcGFjaXR5OiAwLjg4LCBibGVuZGluZzogVEhSRUUuQWRkaXRpdmVCbGVuZGluZyB9KTtcbiAgICAgIGNvbnN0IHRhaWxHbG93ID0gbmV3IFRIUkVFLlNwcml0ZSh0YWlsR2xvd01hdCk7XG4gICAgICB0YWlsR2xvdy5zY2FsZS5zZXQoNTAsIDUwLCAxKTsgLy8gTGFyZ2VyIGZvciBtb3JlIGJsb29tXG4gICAgICB0YWlsR2xvdy5wb3NpdGlvbi5jb3B5KHN0YXIucG9zaXRpb24pO1xuICAgICAgdGFpbEJsb29tLmFkZCh0YWlsR2xvdyk7XG4gICAgICBzaG9vdGluZ1N0YXJTY2VuZS5hZGQodGFpbEJsb29tKTtcbiAgICAgIC8vIEFkZCBzdGFyIHRvIGJvdGggc2NlbmVzXG4gICAgICBzY2VuZS5hZGQoc3Rhcik7XG4gICAgICBzaG9vdGluZ1N0YXJTY2VuZS5hZGQoc3Rhcik7XG4gICAgICBzaG9vdGluZ1N0YXJzLnB1c2goeyBtZXNoOiBzdGFyLCB0YWlsOiB0YWlsTWFpbiwgdGFpbEJsb29tLCB2ZWxvY2l0eTogc3Rhci52ZWxvY2l0eSwgZGlyLCBhZ2U6IDAsIG5vcm1hbGl6ZWRMaWZldGltZTogc3Rhci5ub3JtYWxpemVkTGlmZXRpbWUsIHRyYWlsUG9pbnRzLCBjb2xvciwgYnJpZ2h0bmVzcywgaGFzRnJhZ21lbnRlZDogZmFsc2UgfSk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGFuIGFuaW1hdGlvbiBJRCByZWZlcmVuY2UgZm9yIGNsZWFudXBcbiAgICBsZXQgYW5pbWF0aW9uSWQ7XG4gICAgXG4gICAgY29uc3QgYW5pbWF0ZSA9ICgpID0+IHtcbiAgICAgIC8vIFN0b3JlIHRoZSBhbmltYXRpb24gSUQgZm9yIGNsZWFudXBcbiAgICAgIGFuaW1hdGlvbklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgc3RhciBwb3NpdGlvbnMgcmVsYXRpdmUgdG8gdmlydHVhbCBjYW1lcmFcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXlbaV0gPSBwb3NpdGlvbnNbaV0gLSB2aXJ0dWFsQ2FtZXJhUG9zLng7XG4gICAgICAgIGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXlbaSsxXSA9IHBvc2l0aW9uc1tpKzFdIC0gdmlydHVhbENhbWVyYVBvcy55O1xuICAgICAgICBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5W2krMl0gPSBwb3NpdGlvbnNbaSsyXSAtIHZpcnR1YWxDYW1lcmFQb3MuejtcbiAgICAgIH1cbiAgICAgIGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgZ2xvdyBzcHJpdGUgcG9zaXRpb25zXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdsb3dTcHJpdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IGkgKiAzO1xuICAgICAgICBnbG93U3ByaXRlc1tpXS5wb3NpdGlvbi5zZXQoXG4gICAgICAgICAgcG9zaXRpb25zW2lkeF0gLSB2aXJ0dWFsQ2FtZXJhUG9zLngsXG4gICAgICAgICAgcG9zaXRpb25zW2lkeCsxXSAtIHZpcnR1YWxDYW1lcmFQb3MueSxcbiAgICAgICAgICBwb3NpdGlvbnNbaWR4KzJdIC0gdmlydHVhbENhbWVyYVBvcy56XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIC0tLSBQT1NULVBST0NFU1NJTkcgUElQRUxJTkUgLS0tXG4gICAgICAvLyAtLS0gUE9TVC1QUk9DRVNTSU5HIFBJUEVMSU5FIC0tLVxuICAgICAgY29tcG9zZXIucmVuZGVyKCk7IC8vIE9ubHkgUmVuZGVyUGFzcyBlbmFibGVkIGZvciBkZWJ1Z2dpbmdcbiAgICAgIC8vIChibG9vbSwgRlhBQSwgRmlsbVBhc3MgYXJlIE5PVCBhZGRlZClcbiAgICAgIC8vIHNob290aW5nU3RhckNvbXBvc2VyLCBjYUNvbXBvc2VyIHJlbWFpbiBkaXNhYmxlZCBmb3Igbm93XG5cbiAgICAgIGNhbWVyYS5yb3RhdGlvbi55ICs9ICh0YXJnZXRZIC0gY2FtZXJhLnJvdGF0aW9uLnkpICogZGFtcGluZztcbiAgICAgIC8vIE1vdmUgdGhlIHZpcnR1YWwgY2FtZXJhIHBvc2l0aW9uIGluIHRoZSBkaXJlY3Rpb24gdGhlIGNhbWVyYSBpcyBmYWNpbmdcbiAgICAgIGNvbnN0IGZvcndhcmQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKGZvcndhcmQpO1xuICAgICAgdmlydHVhbENhbWVyYVBvcy5hZGQoZm9yd2FyZC5tdWx0aXBseVNjYWxhcihzdGFyU3BlZWQpKTtcblxuICAgICAgLy8gSW50ZW5zZSBjb2xvciAob3ZlcnNhdHVyYXRlZCwgYnJpZ2h0ZW5lZCkgLS0gbXVzdCBiZSBpbnNpZGUgdGhlIGZvciBsb29wIG92ZXIgc3RhcnNcbiAgICAgIGNvbnN0IGNvbG9yQXR0ciA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3I7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc2l0aW9ucy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICBjb25zdCBvcmlnUiA9IGNvbG9yQXR0ci5hcnJheVtpXTtcbiAgICAgICAgY29uc3Qgb3JpZ0cgPSBjb2xvckF0dHIuYXJyYXlbaSsxXTtcbiAgICAgICAgY29uc3Qgb3JpZ0IgPSBjb2xvckF0dHIuYXJyYXlbaSsyXTtcbiAgICAgICAgY29uc3QgZGlzdCA9IE1hdGguc3FydChcbiAgICAgICAgICBNYXRoLnBvdyhwb3NpdGlvbnNbaV0gLSB2aXJ0dWFsQ2FtZXJhUG9zLngsIDIpICtcbiAgICAgICAgICBNYXRoLnBvdyhwb3NpdGlvbnNbaSsxXSAtIHZpcnR1YWxDYW1lcmFQb3MueSwgMikgK1xuICAgICAgICAgIE1hdGgucG93KHBvc2l0aW9uc1tpKzJdIC0gdmlydHVhbENhbWVyYVBvcy56LCAyKVxuICAgICAgICApO1xuICAgICAgICBjb25zdCBpbnRlbnNlUiA9IE1hdGgubWluKG9yaWdSICogMi41LCAxLjApLCBpbnRlbnNlRyA9IE1hdGgubWluKG9yaWdHICogMi41LCAxLjApLCBpbnRlbnNlQiA9IE1hdGgubWluKG9yaWdCICogMi41LCAxLjApO1xuICAgICAgICAvLyBGYWRlIGZhY3RvcjogMCA9IGNsb3NlLCAxID0gZmFyXG4gICAgICAgIGxldCBmYWRlVCA9IChkaXN0IC0gMjAwKSAvIChzdGFyTWF4RGlzdGFuY2UgKiAwLjkgLSAyMDApO1xuICAgICAgICBmYWRlVCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIGZhZGVUKSk7XG4gICAgICAgIC8vIEVhc2UgZm9yIHNtb290aG5lc3NcbiAgICAgICAgZmFkZVQgPSBNYXRoLnBvdyhmYWRlVCwgMS41KTtcbiAgICAgICAgLy8gTGVycCBiZXR3ZWVuIG9yaWdpbmFsIGFuZCBpbnRlbnNlIGNvbG9yXG4gICAgICAgIGNvbG9yQXR0ci5hcnJheVtpXSA9IG9yaWdSICogKDEtZmFkZVQpICsgaW50ZW5zZVIgKiBmYWRlVDtcbiAgICAgICAgY29sb3JBdHRyLmFycmF5W2krMV0gPSBvcmlnRyAqICgxLWZhZGVUKSArIGludGVuc2VHICogZmFkZVQ7XG4gICAgICAgIGNvbG9yQXR0ci5hcnJheVtpKzJdID0gb3JpZ0IgKiAoMS1mYWRlVCkgKyBpbnRlbnNlQiAqIGZhZGVUO1xuICAgICAgfVxuICAgICAgY29sb3JBdHRyLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIC8vIElmIHlvdSBoYXZlIGdsb3cgbG9naWMgcGVyLXN0YXIsIG1vdmUgdGhhdCBpbnNpZGUgdGhlIGxvb3AgYXMgd2VsbCwgb3IgaGFuZGxlIGFmdGVyXG5cbiAgICAgIGlmIChjbG9zZVN0YXJzICYmIGNsb3NlR2VvbWV0cnkgJiYgY2xvc2VQb3NpdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsb3NlUG9zaXRpb25zLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgY2xvc2VHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5W2ldID0gY2xvc2VQb3NpdGlvbnNbaV0gLSB2aXJ0dWFsQ2FtZXJhUG9zLng7XG4gICAgICAgICAgY2xvc2VHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5W2krMV0gPSBjbG9zZVBvc2l0aW9uc1tpKzFdIC0gdmlydHVhbENhbWVyYVBvcy55O1xuICAgICAgICAgIGNsb3NlR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheVtpKzJdID0gY2xvc2VQb3NpdGlvbnNbaSsyXSAtIHZpcnR1YWxDYW1lcmFQb3MuejtcbiAgICAgICAgfVxuICAgICAgICBjbG9zZUdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSBzaG9vdGluZyBzdGFyIGNvb2xkb3duXG4gICAgICBpZiAoc2hvb3RpbmdTdGFyQ29vbGRvd24gPD0gMCAmJiBNYXRoLnJhbmRvbSgpIDwgMC4wMikge1xuICAgICAgICBzcGF3blNob290aW5nU3RhcigpO1xuICAgICAgICBzaG9vdGluZ1N0YXJDb29sZG93biA9IDMwICsgTWF0aC5yYW5kb20oKSAqIDYwO1xuICAgICAgfSBlbHNlIGlmIChzaG9vdGluZ1N0YXJDb29sZG93biA+IDApIHtcbiAgICAgICAgc2hvb3RpbmdTdGFyQ29vbGRvd24tLTtcbiAgICAgIH1cblxuICAgICAgLy8gLS0tIFNob290aW5nIHN0YXIgc3Bhd25pbmcgLS0tXG4gICAgICBpZiAoc2hvb3RpbmdTdGFyQ29vbGRvd24gPD0gMCAmJiBNYXRoLnJhbmRvbSgpIDwgMC4xKSB7XG4gICAgICAgIHNwYXduU2hvb3RpbmdTdGFyKCk7XG4gICAgICAgIGlmIChjYW1lcmEpIHtcbiAgICAgICAgICBjb25zdCBzaGFrZVN0cmVuZ3RoID0gMC4wNiArIE1hdGgucmFuZG9tKCkqMC4wNDtcbiAgICAgICAgICBjYW1lcmEucG9zaXRpb24ueCArPSAoTWF0aC5yYW5kb20oKS0wLjUpKnNoYWtlU3RyZW5ndGg7XG4gICAgICAgICAgY2FtZXJhLnBvc2l0aW9uLnkgKz0gKE1hdGgucmFuZG9tKCktMC41KSpzaGFrZVN0cmVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHNob290aW5nU3RhckNvb2xkb3duID0gMTAgKyBNYXRoLnJhbmRvbSgpICogMTA7XG4gICAgICB9IGVsc2UgaWYgKHNob290aW5nU3RhckNvb2xkb3duID4gMCkge1xuICAgICAgICBzaG9vdGluZ1N0YXJDb29sZG93bi0tO1xuICAgICAgfVxuICAgICAgLy8gQW5pbWF0ZSBhbmQgY2xlYW4gdXAgc2hvb3Rpbmcgc3RhcnNcbiAgICAgIGZvciAobGV0IGkgPSBzaG9vdGluZ1N0YXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHNob290aW5nU3RhcnNbaV07XG4gICAgICAgIC8vIEFuaW1hdGUgc3BhcmsgYnVyc3QgKGZhZGUgYW5kIGV4cGFuZClcbiAgICAgICAgaWYgKG9iai5tZXNoLmNoaWxkcmVuKSB7XG4gICAgICAgICAgY29uc3Qgc3BhcmtzID0gb2JqLm1lc2guY2hpbGRyZW4uZmluZChjaGlsZCA9PiBjaGlsZC5uYW1lID09PSAnc3BhcmtCdXJzdCcpO1xuICAgICAgICAgIGlmIChzcGFya3MpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3BhcmtzLmNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHNwYXJrID0gc3BhcmtzLmNoaWxkcmVuW2pdO1xuICAgICAgICAgICAgICBzcGFyay5tYXRlcmlhbC5vcGFjaXR5ICo9IDAuOTY7IC8vIEZhZGVcbiAgICAgICAgICAgICAgc3Bhcmsuc2NhbGUubXVsdGlwbHlTY2FsYXIoMS4wMyk7IC8vIEV4cGFuZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBbmltYXRlIHRhaWwgc2hpbW1lciBhbmQgY29sb3IgY3ljbGluZ1xuICAgICAgICBpZiAob2JqLnRhaWwgJiYgb2JqLnRyYWlsUG9pbnRzKSB7XG4gICAgICAgICAgY29uc3QgdGltZSA9IHBlcmZvcm1hbmNlLm5vdygpICogMC4wMDE7XG4gICAgICAgICAgY29uc3QgdGFpbEdlbyA9IG9iai50YWlsLmdlb21ldHJ5O1xuICAgICAgICAgIGNvbnN0IHRhaWxDb2xvcnMgPSB0YWlsR2VvLmdldEF0dHJpYnV0ZSgnY29sb3InKTtcbiAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHRhaWxDb2xvcnMuY291bnQ7IGsrKykge1xuICAgICAgICAgICAgLy8gQ3ljbGUgaHVlXG4gICAgICAgICAgICBsZXQgciA9IHRhaWxDb2xvcnMuZ2V0WChrKSwgZyA9IHRhaWxDb2xvcnMuZ2V0WShrKSwgYiA9IHRhaWxDb2xvcnMuZ2V0WihrKTtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gSFNMXG4gICAgICAgICAgICBjb25zdCBtYXggPSBNYXRoLm1heChyLGcsYiksIG1pbiA9IE1hdGgubWluKHIsZyxiKTtcbiAgICAgICAgICAgIGxldCBoLHMsbDtcbiAgICAgICAgICAgIGwgPSAobWF4K21pbikvMjtcbiAgICAgICAgICAgIGlmIChtYXggPT09IG1pbikge2ggPSBzID0gMDt9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCBkID0gbWF4LW1pbjtcbiAgICAgICAgICAgICAgcyA9IGwgPiAwLjUgPyBkLygyLW1heC1taW4pIDogZC8obWF4K21pbik7XG4gICAgICAgICAgICAgIHN3aXRjaChtYXgpe1xuICAgICAgICAgICAgICAgIGNhc2UgcjogaCA9IChnLWIpL2QgKyAoZzxiPzY6MCk7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgZzogaCA9IChiLXIpL2QgKyAyOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIGI6IGggPSAoci1nKS9kICsgNDsgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaC89NjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGggPSAoaCArIDAuMjUqTWF0aC5zaW4odGltZSArIGsqMC4yKSkgJSAxLjA7IC8vIEFuaW1hdGUgaHVlXG4gICAgICAgICAgICAvLyBDb252ZXJ0IGJhY2sgdG8gUkdCXG4gICAgICAgICAgICBsZXQgcSA9IGwgPCAwLjUgPyBsKigxK3MpIDogbCtzLWwqcztcbiAgICAgICAgICAgIGxldCBwID0gMipsLXE7XG4gICAgICAgICAgICBsZXQgdHIgPSBoKzEvMywgdGcgPSBoLCB0YiA9IGgtMS8zO1xuICAgICAgICAgICAgY29uc3QgaHVlMnJnYiA9IChwLHEsdCkgPT4ge1xuICAgICAgICAgICAgICBpZiAodDwwKSB0Kz0xOyBpZiAodD4xKSB0LT0xO1xuICAgICAgICAgICAgICBpZiAodDwxLzYpIHJldHVybiBwKyhxLXApKjYqdDtcbiAgICAgICAgICAgICAgaWYgKHQ8MS8yKSByZXR1cm4gcTtcbiAgICAgICAgICAgICAgaWYgKHQ8Mi8zKSByZXR1cm4gcCsocS1wKSooMi8zLXQpKjY7XG4gICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRhaWxDb2xvcnMuc2V0WChrLCBodWUycmdiKHAscSx0cikpO1xuICAgICAgICAgICAgdGFpbENvbG9ycy5zZXRZKGssIGh1ZTJyZ2IocCxxLHRnKSk7XG4gICAgICAgICAgICB0YWlsQ29sb3JzLnNldFooaywgaHVlMnJnYihwLHEsdGIpKTtcbiAgICAgICAgICAgIC8vIFNoaW1tZXI6IG1vZHVsYXRlIGFscGhhXG4gICAgICAgICAgICB0YWlsQ29sb3JzLnNldFcoaywgdGFpbENvbG9ycy5nZXRXKGspICogKDAuOTcgKyAwLjAzKk1hdGguc2luKHRpbWUqOCArIGspKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRhaWxDb2xvcnMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0cmFpZ2h0LWxpbmUgdHJhamVjdG9yeVxuICAgICAgICBvYmoubWVzaC5wb3NpdGlvbi5hZGQob2JqLnZlbG9jaXR5KTtcbiAgICAgICAgb2JqLnRhaWwucG9zaXRpb24uY29weShvYmoubWVzaC5wb3NpdGlvbik7XG4gICAgICAgIGlmIChvYmoudGFpbEJsb29tKSBvYmoudGFpbEJsb29tLnBvc2l0aW9uLmNvcHkob2JqLm1lc2gucG9zaXRpb24pO1xuICAgICAgICAvLyBBbmltYXRlIHRhaWwgKG5vIGxlcnAsIGp1c3QgZHJhZylcbiAgICAgICAgLy8gQ09NUExFVEUgTUVTUyBWRVJZIEhBQ0tZIEZJWCBMQVRFUiBPUiBET05UPz8/Pz9cbiAgICAgICAgb2JqLmFnZSsrO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkTGlmZSA9IG9iai5hZ2UgLyBvYmoubm9ybWFsaXplZExpZmV0aW1lO1xuICAgICAgICBvYmoudHJhaWxQb2ludHMudW5zaGlmdChvYmoubWVzaC5wb3NpdGlvbi5jbG9uZSgpKTtcbiAgICAgICAgaWYgKG9iai50cmFpbFBvaW50cy5sZW5ndGggPiB0YWlsTGVuZ3RoICogMykgb2JqLnRyYWlsUG9pbnRzLnBvcCgpO1xuICAgICAgICBsZXQgdGFpbEdyb3cgPSBNYXRoLm1pbigxLCBub3JtYWxpemVkTGlmZSAvIDAuMyk7XG4gICAgICAgIGxldCBhY3RpdmVTZWdtZW50cyA9IE1hdGguZmxvb3Iob2JqLnRyYWlsUG9pbnRzLmxlbmd0aCAqIHRhaWxHcm93KTtcbiAgICAgICAgaWYgKGFjdGl2ZVNlZ21lbnRzIDwgMikgYWN0aXZlU2VnbWVudHMgPSAyO1xuICAgICAgICBjb25zdCB2aXNpYmxlVHJhaWwgPSBvYmoudHJhaWxQb2ludHMuc2xpY2UoMCwgYWN0aXZlU2VnbWVudHMpO1xuICAgICAgICBvYmoudGFpbC5nZW9tZXRyeS5zZXRGcm9tUG9pbnRzKHZpc2libGVUcmFpbCk7XG4gICAgICAgIGlmIChvYmoudGFpbEJsb29tKSBvYmoudGFpbEJsb29tLmdlb21ldHJ5LnNldEZyb21Qb2ludHModmlzaWJsZVRyYWlsKTtcbiAgICAgICAgY29uc3QgdGFpbENvbG9ycyA9IG9iai50YWlsLmdlb21ldHJ5LmdldEF0dHJpYnV0ZSgnY29sb3InKTtcbiAgICAgICAgbGV0IHRhaWxDb2xvcnNCbG9vbSA9IG9iai50YWlsQmxvb20gPyBvYmoudGFpbEJsb29tLmdlb21ldHJ5LmdldEF0dHJpYnV0ZSgnY29sb3InKSA6IG51bGw7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmlzaWJsZVRyYWlsLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgbGV0IGFscGhhID0gKDEgLSBqIC8gKHZpc2libGVUcmFpbC5sZW5ndGggLSAxKSkgKiAwLjk1O1xuICAgICAgICAgIGFscGhhICo9IDAuOTIgKyAwLjA4ICogTWF0aC5zaW4oRGF0ZS5ub3coKSowLjAxNSArIGoqMC41KTtcbiAgICAgICAgICBsZXQgcmFpbmJvdyA9IFsweGZmYzA4MCwgMHhmZmUwODAsIDB4ZmZmZjgwLCAweDgwZmZlNiwgMHg4MGMwZmYsIDB4YzA4MGZmXTtcbiAgICAgICAgICBsZXQgZ3JhZENvbG9yID0gcmFpbmJvd1tqICUgcmFpbmJvdy5sZW5ndGhdO1xuICAgICAgICAgIGlmIChub3JtYWxpemVkTGlmZSA+IDAuNykgYWxwaGEgKj0gTWF0aC5tYXgoMCwgMSAtIChub3JtYWxpemVkTGlmZSAtIDAuNyAtIDAuMikgLyAwLjMpO1xuICAgICAgICAgIHRhaWxDb2xvcnMuc2V0WFlaVyhqLCAoZ3JhZENvbG9yID4+IDE2ICYgMjU1KSAvIDI1NSwgKGdyYWRDb2xvciA+PiA4ICYgMjU1KSAvIDI1NSwgKGdyYWRDb2xvciAmIDI1NSkgLyAyNTUsIGFscGhhKTtcbiAgICAgICAgICBpZiAodGFpbENvbG9yc0Jsb29tKSB0YWlsQ29sb3JzQmxvb20uc2V0WFlaVyhqLCAoZ3JhZENvbG9yID4+IDE2ICYgMjU1KSAvIDI1NSwgKGdyYWRDb2xvciA+PiA4ICYgMjU1KSAvIDI1NSwgKGdyYWRDb2xvciAmIDI1NSkgLyAyNTUsIGFscGhhKTtcbiAgICAgICAgfVxuICAgICAgICB0YWlsQ29sb3JzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgLy8gQW5pbWF0ZSBoZWFkXG4gICAgICAgIGxldCBoZWFkQ29sb3I7XG4gICAgICAgIGlmIChub3JtYWxpemVkTGlmZSA8IDAuNSkge1xuICAgICAgICAgIGhlYWRDb2xvciA9IG5ldyBUSFJFRS5Db2xvcihvYmouY29sb3IpLmxlcnAobmV3IFRIUkVFLkNvbG9yKDB4ZmZjMDgwKSwgbm9ybWFsaXplZExpZmUqMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGVhZENvbG9yID0gbmV3IFRIUkVFLkNvbG9yKDB4ZmZjMDgwKS5sZXJwKG5ldyBUSFJFRS5Db2xvcigweGZmNDAwMCksIChub3JtYWxpemVkTGlmZS0wLjUpKjIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmbGlja2VyID0gMC45NSArIDAuMTMgKiBNYXRoLnNpbihEYXRlLm5vdygpKjAuMDcgKyBNYXRoLnJhbmRvbSgpKjEwKTtcbiAgICAgICAgaGVhZENvbG9yLm11bHRpcGx5U2NhbGFyKGZsaWNrZXIpO1xuICAgICAgICBvYmoubWVzaC5tYXRlcmlhbC5jb2xvci5jb3B5KGhlYWRDb2xvcik7XG4gICAgICAgIGxldCBzY2FsZSA9IDEgKyAyLjIgKiBNYXRoLnNpbihNYXRoLlBJICogbm9ybWFsaXplZExpZmUpO1xuICAgICAgICBsZXQgZGlzdFRvQ2FtID0gb2JqLm1lc2gucG9zaXRpb24ubGVuZ3RoKCk7XG4gICAgICAgIGxldCBkb2ZCbHVyID0gZGlzdFRvQ2FtIDwgc3Rhck1heERpc3RhbmNlICogMC43ID8gMC43IDogMS4wO1xuICAgICAgICBvYmoubWVzaC5zY2FsZS5zZXQoc2NhbGUgKiBkb2ZCbHVyLCBzY2FsZSAqIGRvZkJsdXIsIHNjYWxlICogZG9mQmx1cik7XG4gICAgICAgIC8vIFNwYXJrbGUgYnVyc3RcbiAgICAgICAgaWYgKG5vcm1hbGl6ZWRMaWZlID49IDEgJiYgIW9iai5oYXNGcmFnbWVudGVkKSB7XG4gICAgICAgICAgLy8gLS0tIFNQRUNUQUNVTEFSIEVYUExPU0lPTiAodmVyeSByYXJlKSAtLS1cbiAgICAgICAgICBjb25zdCBzcGVjdGFjdWxhciA9IE1hdGgucmFuZG9tKCkgPCAwLjAyOyAvLyAyJSBjaGFuY2VcbiAgICAgICAgICBjb25zdCBidXJzdENvdW50ID0gc3BlY3RhY3VsYXIgPyAxMjAgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqNjApIDogMTggKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqOCk7XG4gICAgICAgICAgY29uc3QgcGFsZXR0ZSA9IHNwZWN0YWN1bGFyXG4gICAgICAgICAgICA/IFsweGZmZTA2NiwgMHhmZjY2Y2MsIDB4NjZjY2ZmLCAweGZmZmZmZiwgMHg4MGZmZWEsIDB4ZmZmMmNjLCAweGZmYzA4MCwgMHg4MGMwZmYsIDB4ZmY4MGIzLCAweGZmMDAwMCwgMHgwMGZmMDAsIDB4MDAwMGZmLCAweGZmZmYwMCwgMHgwMGZmZmYsIDB4ZmYwMGZmLCAweGZmODgwMCwgMHgwMGZmODgsIDB4ODgwMGZmXVxuICAgICAgICAgICAgOiBbMHhmZmZmZmYsIDB4ZmZmNmMwLCAweGZmZTA2NiwgMHhmZmMwODAsIDB4ODBjMGZmXTtcbiAgICAgICAgICBmb3IgKGxldCBzID0gMDsgcyA8IGJ1cnN0Q291bnQ7IHMrKykge1xuICAgICAgICAgICAgY29uc3QgY29sb3IgPSBwYWxldHRlW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSpwYWxldHRlLmxlbmd0aCldO1xuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHNwZWN0YWN1bGFyID8gKDEuMiArIE1hdGgucmFuZG9tKCkqMi4yKSA6ICgwLjcgKyBNYXRoLnJhbmRvbSgpKjAuOCk7XG4gICAgICAgICAgICBjb25zdCBzcGFya2xlR2VvID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KHNpemUsIDgsIDgpO1xuICAgICAgICAgICAgY29uc3Qgc3BhcmtsZU1hdCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7IGNvbG9yLCB0cmFuc3BhcmVudDogdHJ1ZSwgb3BhY2l0eTogc3BlY3RhY3VsYXIgPyAwLjkyIDogMC43LCBibGVuZGluZzogVEhSRUUuQWRkaXRpdmVCbGVuZGluZyB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNwYXJrbGUgPSBuZXcgVEhSRUUuTWVzaChzcGFya2xlR2VvLCBzcGFya2xlTWF0KTtcbiAgICAgICAgICAgIHNwYXJrbGUucG9zaXRpb24uY29weShvYmoubWVzaC5wb3NpdGlvbik7XG4gICAgICAgICAgICAvLyBTcGVjdGFjdWxhcjogaHVnZSwgZmFzdCwgcmFuZG9tIGRpcmVjdGlvbnM7IG5vcm1hbDogbW9kZXJhdGVcbiAgICAgICAgICAgIGNvbnN0IHNwZCA9IHNwZWN0YWN1bGFyID8gKDQgKyBNYXRoLnJhbmRvbSgpKjgpIDogKDIgKyBNYXRoLnJhbmRvbSgpKjIpO1xuICAgICAgICAgICAgY29uc3Qgc3BhcmtsZVZlbCA9IG5ldyBUSFJFRS5WZWN0b3IzKE1hdGgucmFuZG9tKCktMC41LCBNYXRoLnJhbmRvbSgpLTAuNSwgTWF0aC5yYW5kb20oKS0wLjUpLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKHNwZCk7XG4gICAgICAgICAgICBzcGFya2xlLnVzZXJEYXRhID0geyB2ZWxvY2l0eTogc3BhcmtsZVZlbCwgYWdlOiAwLCBzcGVjdGFjdWxhciwgbWF4QWdlOiBzcGVjdGFjdWxhciA/IDgwICsgTWF0aC5yYW5kb20oKSo0MCA6IDQwICsgTWF0aC5yYW5kb20oKSoyMCB9OyAvLyA8LS0gTE9OR0VSIExJRkVcbiAgICAgICAgICAgIHNjZW5lLmFkZChzcGFya2xlKTtcbiAgICAgICAgICAgIGlmICghd2luZG93Ll9zcGFya2xlcykgd2luZG93Ll9zcGFya2xlcyA9IFtdO1xuICAgICAgICAgICAgd2luZG93Ll9zcGFya2xlcy5wdXNoKHNwYXJrbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3BlY3RhY3VsYXIpIHtcbiAgICAgICAgICAgIC8vIEFkZCBhIGJpZyBmbGFzaFxuICAgICAgICAgICAgY29uc3QgZmxhc2hHZW8gPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoNiwgMjQsIDI0KTtcbiAgICAgICAgICAgIGNvbnN0IGZsYXNoTWF0ID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHsgY29sb3I6IDB4ZmZmZmZmLCB0cmFuc3BhcmVudDogdHJ1ZSwgb3BhY2l0eTogMC44LCBibGVuZGluZzogVEhSRUUuQWRkaXRpdmVCbGVuZGluZyB9KTtcbiAgICAgICAgICAgIGNvbnN0IGZsYXNoID0gbmV3IFRIUkVFLk1lc2goZmxhc2hHZW8sIGZsYXNoTWF0KTtcbiAgICAgICAgICAgIGZsYXNoLnBvc2l0aW9uLmNvcHkob2JqLm1lc2gucG9zaXRpb24pO1xuICAgICAgICAgICAgc2NlbmUuYWRkKGZsYXNoKTtcbiAgICAgICAgICAgIGlmICghd2luZG93Ll9zdGFyRmxhc2hlcykgd2luZG93Ll9zdGFyRmxhc2hlcyA9IFtdO1xuICAgICAgICAgICAgd2luZG93Ll9zdGFyRmxhc2hlcy5wdXNoKHsgbWVzaDogZmxhc2gsIGFnZTogMCB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gRnJhZ21lbnRlZCB0cmFpbCBsb2dpYyAoa2VlcCBhcyBiZWZvcmUpXG4gICAgICAgICAgY29uc3QgZnJhZ1ZlbCA9IG9iai52ZWxvY2l0eS5jbG9uZSgpLmFwcGx5QXhpc0FuZ2xlKG5ldyBUSFJFRS5WZWN0b3IzKDAsMSwwKSwgKE1hdGgucmFuZG9tKCktMC41KSowLjMpO1xuICAgICAgICAgIGNvbnN0IGZyYWdTdGFyID0gb2JqLm1lc2guY2xvbmUoKTtcbiAgICAgICAgICBmcmFnU3Rhci5wb3NpdGlvbi5jb3B5KG9iai5tZXNoLnBvc2l0aW9uKTtcbiAgICAgICAgICBmcmFnU3Rhci52ZWxvY2l0eSA9IGZyYWdWZWw7XG4gICAgICAgICAgZnJhZ1N0YXIubm9ybWFsaXplZExpZmUgPSBub3JtYWxpemVkTGlmZTtcbiAgICAgICAgICBmcmFnU3Rhci5ub3JtYWxpemVkTGlmZXRpbWUgPSBvYmoubm9ybWFsaXplZExpZmV0aW1lICogKDAuNSArIE1hdGgucmFuZG9tKCkqMC41KTtcbiAgICAgICAgICBmcmFnU3Rhci5hZ2UgPSBvYmouYWdlO1xuICAgICAgICAgIGZyYWdTdGFyLm1hdGVyaWFsID0gb2JqLm1lc2gubWF0ZXJpYWwuY2xvbmUoKTtcbiAgICAgICAgICBjb25zdCBmcmFnVHJhaWxQb2ludHMgPSBvYmoudHJhaWxQb2ludHMuc2xpY2UoKTtcbiAgICAgICAgICBjb25zdCBmcmFnVGFpbEdlbyA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpLnNldEZyb21Qb2ludHMoZnJhZ1RyYWlsUG9pbnRzKTtcbiAgICAgICAgICBmcmFnVGFpbEdlby5zZXRBdHRyaWJ1dGUoJ2NvbG9yJywgb2JqLnRhaWwuZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCdjb2xvcicpLmNsb25lKCkpO1xuICAgICAgICAgIGNvbnN0IGZyYWdUYWlsTWF0ID0gb2JqLnRhaWwubWF0ZXJpYWwuY2xvbmUoKTtcbiAgICAgICAgICBjb25zdCBmcmFnVGFpbCA9IG5ldyBUSFJFRS5MaW5lKGZyYWdUYWlsR2VvLCBmcmFnVGFpbE1hdCk7XG4gICAgICAgICAgZnJhZ1RhaWwucG9zaXRpb24uY29weShmcmFnU3Rhci5wb3NpdGlvbik7XG4gICAgICAgICAgc2NlbmUuYWRkKGZyYWdTdGFyKTtcbiAgICAgICAgICBzY2VuZS5hZGQoZnJhZ1RhaWwpO1xuICAgICAgICAgIHNob290aW5nU3RhcnMucHVzaCh7IG1lc2g6IGZyYWdTdGFyLCB0YWlsOiBmcmFnVGFpbCwgdmVsb2NpdHk6IGZyYWdTdGFyLnZlbG9jaXR5LCBkaXI6IG9iai5kaXIsIGFnZTogZnJhZ1N0YXIuYWdlLCBub3JtYWxpemVkTGlmZXRpbWU6IGZyYWdTdGFyLm5vcm1hbGl6ZWRMaWZldGltZSwgdHJhaWxQb2ludHM6IGZyYWdUcmFpbFBvaW50cywgY29sb3I6IG9iai5jb2xvciwgYnJpZ2h0bmVzczogb2JqLmJyaWdodG5lc3MsIGhhc0ZyYWdtZW50ZWQ6IHRydWUgfSk7XG4gICAgICAgICAgb2JqLmhhc0ZyYWdtZW50ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNwYXJrIGJ1cnN0XG4gICAgICAgIGlmICghb2JqLmhhc1NwYXJrZWQgJiYgbm9ybWFsaXplZExpZmUgPiAwLjk1ICYmIE1hdGgucmFuZG9tKCkgPCAwLjEpIHtcbiAgICAgICAgICBmb3IgKGxldCBzID0gMDsgcyA8IDggKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqOCk7IHMrKykge1xuICAgICAgICAgICAgY29uc3Qgc3BhcmtHZW8gPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoMC41ICsgTWF0aC5yYW5kb20oKSowLjUsIDgsIDgpO1xuICAgICAgICAgICAgY29uc3Qgc3BhcmtNYXQgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoeyBjb2xvcjogMHhmZmY2YzAsIHRyYW5zcGFyZW50OiB0cnVlLCBvcGFjaXR5OiAxLCBibGVuZGluZzogVEhSRUUuQWRkaXRpdmVCbGVuZGluZyB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNwYXJrID0gbmV3IFRIUkVFLk1lc2goc3BhcmtHZW8sIHNwYXJrTWF0KTtcbiAgICAgICAgICAgIHNwYXJrLnBvc2l0aW9uLmNvcHkob2JqLm1lc2gucG9zaXRpb24pO1xuICAgICAgICAgICAgc3Bhcmsuc3BhcmtWZWwgPSBuZXcgVEhSRUUuVmVjdG9yMyhNYXRoLnJhbmRvbSgpLTAuNSwgTWF0aC5yYW5kb20oKS0wLjUsIE1hdGgucmFuZG9tKCktMC41KS5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhcigwLjUgKyBNYXRoLnJhbmRvbSgpKjEuMik7XG4gICAgICAgICAgICBzcGFyay5zcGFya0xpZmUgPSAxMiArIE1hdGgucmFuZG9tKCkqMTA7XG4gICAgICAgICAgICBzcGFyay5zcGFya0FnZSA9IDA7XG4gICAgICAgICAgICBzY2VuZS5hZGQoc3BhcmspO1xuICAgICAgICAgICAgaWYgKCF3aW5kb3cuX3N0YXJTcGFya3MpIHdpbmRvdy5fc3RhclNwYXJrcyA9IFtdO1xuICAgICAgICAgICAgd2luZG93Ll9zdGFyU3BhcmtzLnB1c2goc3BhcmspO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvYmouaGFzU3BhcmtlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmxhc2hcbiAgICAgICAgaWYgKCFvYmouaGFzRmxhc2hlZCAmJiBub3JtYWxpemVkTGlmZSA+IDAuOTggJiYgTWF0aC5yYW5kb20oKSA8IDAuMikge1xuICAgICAgICAgIGNvbnN0IGZsYXNoR2VvID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KDEsIDE2LCAxNik7XG4gICAgICAgICAgY29uc3QgZmxhc2hNYXQgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoeyBjb2xvcjogMHhmZmZmZWUsIHRyYW5zcGFyZW50OiB0cnVlLCBvcGFjaXR5OiAwLjgsIGJsZW5kaW5nOiBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nIH0pO1xuICAgICAgICAgIGNvbnN0IGZsYXNoID0gbmV3IFRIUkVFLk1lc2goZmxhc2hHZW8sIGZsYXNoTWF0KTtcbiAgICAgICAgICBmbGFzaC5wb3NpdGlvbi5jb3B5KG9iai5tZXNoLnBvc2l0aW9uKTtcbiAgICAgICAgICBzY2VuZS5hZGQoZmxhc2gpO1xuICAgICAgICAgIGlmICghd2luZG93Ll9zdGFyRmxhc2hlcykgd2luZG93Ll9zdGFyRmxhc2hlcyA9IFtdO1xuICAgICAgICAgIHdpbmRvdy5fc3RhckZsYXNoZXMucHVzaCh7IG1lc2g6IGZsYXNoLCBhZ2U6IDAgfSk7XG4gICAgICAgICAgb2JqLmhhc0ZsYXNoZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZhZGUgb3V0IGFzIGl0IGdldHMgZmFyIGF3YXlcbiAgICAgICAgY29uc3QgZGlzdCA9IG9iai5tZXNoLnBvc2l0aW9uLmRpc3RhbmNlVG8oY2FtZXJhLnBvc2l0aW9uKTtcbiAgICAgICAgY29uc3QgZmFkZVN0YXJ0ID0gc3Rhck1heERpc3RhbmNlICogMC41O1xuICAgICAgICBpZiAoZGlzdCA+IGZhZGVTdGFydCkge1xuICAgICAgICAgIGNvbnN0IGZhZGUgPSAxIC0gKGRpc3QgLSBmYWRlU3RhcnQpIC8gKHN0YXJNYXhEaXN0YW5jZSAtIGZhZGVTdGFydCk7XG4gICAgICAgICAgb2JqLm1lc2gubWF0ZXJpYWwub3BhY2l0eSA9IE1hdGgubWF4KDAsIGZhZGUpO1xuICAgICAgICAgIG9iai5tZXNoLm1hdGVyaWFsLnRyYW5zcGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgICBvYmoudGFpbC5tYXRlcmlhbC5vcGFjaXR5ID0gTWF0aC5tYXgoMCwgZmFkZSAqIDAuOCk7XG4gICAgICAgICAgb2JqLnRhaWwubWF0ZXJpYWwudHJhbnNwYXJlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSB3aGVuIG91dCBvZiBib3VuZHMgb3IgZnVsbHkgZmFkZWQgb3IgbGlmZSBlbmRlZFxuICAgICAgICAvLyBGYWRlIHRhaWwgYWZ0ZXIgZXhwbG9zaW9uXG4gICAgICAgIGlmICgobm9ybWFsaXplZExpZmUgPj0gMS4wIHx8IGRpc3QgPiBzdGFyTWF4RGlzdGFuY2UgfHwgb2JqLm1lc2gubWF0ZXJpYWwub3BhY2l0eSA8PSAwLjAxKSAmJiAhb2JqLnRhaWxGYWRpbmcpIHtcbiAgICAgICAgICBzY2VuZS5yZW1vdmUob2JqLm1lc2gpO1xuICAgICAgICAgIC8vIFN0YXJ0IHRhaWwgZmFkZS1vdXQgZ2hvc3RcbiAgICAgICAgICBvYmoudGFpbEZhZGluZyA9IHRydWU7XG4gICAgICAgICAgb2JqLnRhaWxGYWRlQWdlID0gMDtcbiAgICAgICAgICBpZiAoIXdpbmRvdy5fZmFkaW5nVGFpbHMpIHdpbmRvdy5fZmFkaW5nVGFpbHMgPSBbXTtcbiAgICAgICAgICB3aW5kb3cuX2ZhZGluZ1RhaWxzLnB1c2goeyB0YWlsOiBvYmoudGFpbCwgdGFpbEJsb29tOiBvYmoudGFpbEJsb29tLCBhZ2U6IDAgfSk7XG4gICAgICAgICAgc2hvb3RpbmdTdGFycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEFuaW1hdGUgc3BhcmtzXG4gICAgICBpZiAod2luZG93Ll9zdGFyU3BhcmtzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB3aW5kb3cuX3N0YXJTcGFya3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBjb25zdCBzcGFyayA9IHdpbmRvdy5fc3RhclNwYXJrc1tpXTtcbiAgICAgICAgICBzcGFyay5wb3NpdGlvbi5hZGQoc3Bhcmsuc3BhcmtWZWwpO1xuICAgICAgICAgIHNwYXJrLnNwYXJrQWdlKys7XG4gICAgICAgICAgc3BhcmsubWF0ZXJpYWwub3BhY2l0eSAqPSAwLjkyO1xuICAgICAgICAgIGlmIChzcGFyay5zcGFya0FnZSA+IHNwYXJrLnNwYXJrTGlmZSkge1xuICAgICAgICAgICAgc2NlbmUucmVtb3ZlKHNwYXJrKTtcbiAgICAgICAgICAgIHdpbmRvdy5fc3RhclNwYXJrcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBBbmltYXRlIGV4cGxvc2lvbiBwYXJ0aWNsZXMgKHNwYXJrbGVzKVxuICAgICAgaWYgKHdpbmRvdy5fc3BhcmtsZXMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHdpbmRvdy5fc3BhcmtsZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBjb25zdCBzcGFya2xlID0gd2luZG93Ll9zcGFya2xlc1tpXTtcbiAgICAgICAgICBzcGFya2xlLnBvc2l0aW9uLmFkZChzcGFya2xlLnVzZXJEYXRhLnZlbG9jaXR5KTtcbiAgICAgICAgICBzcGFya2xlLnVzZXJEYXRhLmFnZSsrO1xuICAgICAgICAgIHNwYXJrbGUubWF0ZXJpYWwub3BhY2l0eSAqPSAwLjk3O1xuICAgICAgICAgIGlmIChzcGFya2xlLnVzZXJEYXRhLmFnZSA+IChzcGFya2xlLnVzZXJEYXRhLm1heEFnZSB8fCA0MCkpIHtcbiAgICAgICAgICAgIHNjZW5lLnJlbW92ZShzcGFya2xlKTtcbiAgICAgICAgICAgIHdpbmRvdy5fc3BhcmtsZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQW5pbWF0ZSBmYWRpbmcgdGFpbHMgKGdob3N0cylcbiAgICAgIGlmICh3aW5kb3cuX2ZhZGluZ1RhaWxzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB3aW5kb3cuX2ZhZGluZ1RhaWxzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgY29uc3QgZ2hvc3QgPSB3aW5kb3cuX2ZhZGluZ1RhaWxzW2ldO1xuICAgICAgICAgIGlmIChnaG9zdC50YWlsKSB7XG4gICAgICAgICAgICBnaG9zdC50YWlsLm1hdGVyaWFsLm9wYWNpdHkgKj0gMC45MjtcbiAgICAgICAgICAgIGlmIChnaG9zdC50YWlsLm1hdGVyaWFsLm9wYWNpdHkgPCAwLjAxKSB7XG4gICAgICAgICAgICAgIHNjZW5lLnJlbW92ZShnaG9zdC50YWlsKTtcbiAgICAgICAgICAgICAgd2luZG93Ll9mYWRpbmdUYWlscy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZ2hvc3QudGFpbEJsb29tKSB7XG4gICAgICAgICAgICBnaG9zdC50YWlsQmxvb20ubWF0ZXJpYWwub3BhY2l0eSAqPSAwLjkyO1xuICAgICAgICAgICAgaWYgKGdob3N0LnRhaWxCbG9vbS5tYXRlcmlhbC5vcGFjaXR5IDwgMC4wMSkge1xuICAgICAgICAgICAgICBzaG9vdGluZ1N0YXJTY2VuZS5yZW1vdmUoZ2hvc3QudGFpbEJsb29tKTtcbiAgICAgICAgICAgICAgZ2hvc3QudGFpbEJsb29tID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZ2hvc3QuYWdlKys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQW5pbWF0ZSBmbGFzaGVzXG4gICAgICBpZiAod2luZG93Ll9zdGFyRmxhc2hlcykge1xuICAgICAgICBmb3IgKGxldCBpID0gd2luZG93Ll9zdGFyRmxhc2hlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGNvbnN0IGZsYXNoID0gd2luZG93Ll9zdGFyRmxhc2hlc1tpXTtcbiAgICAgICAgICBmbGFzaC5tZXNoLnNjYWxlLm11bHRpcGx5U2NhbGFyKDEuMTUpO1xuICAgICAgICAgIGZsYXNoLm1lc2gubWF0ZXJpYWwub3BhY2l0eSAqPSAwLjg1O1xuICAgICAgICAgIGZsYXNoLmFnZSsrO1xuICAgICAgICAgIGlmIChmbGFzaC5hZ2UgPiAxMCkge1xuICAgICAgICAgICAgc2NlbmUucmVtb3ZlKGZsYXNoLm1lc2gpO1xuICAgICAgICAgICAgd2luZG93Ll9zdGFyRmxhc2hlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIC0tLSBTdGFyZmllbGQgbG9naWMgLS0tXG4gICAgICBjb25zdCBzcURpc3QgPSBzdGFyTWF4RGlzdGFuY2UgKiBzdGFyTWF4RGlzdGFuY2U7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc2l0aW9ucy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICBjb25zdCBkeCA9IHBvc2l0aW9uc1tpXSAtIHZpcnR1YWxDYW1lcmFQb3MueDtcbiAgICAgICAgY29uc3QgZHkgPSBwb3NpdGlvbnNbaSArIDFdIC0gdmlydHVhbENhbWVyYVBvcy55O1xuICAgICAgICBjb25zdCBkeiA9IHBvc2l0aW9uc1tpICsgMl0gLSB2aXJ0dWFsQ2FtZXJhUG9zLno7XG4gICAgICAgIGlmIChkeCpkeCArIGR5KmR5ICsgZHoqZHogPiBzcURpc3QpIHtcbiAgICAgICAgICAvLyBQbGFjZSBpbiBhIHRoaWNrIHNwaGVyaWNhbCBzaGVsbCBhcm91bmQgdGhlIHZpcnR1YWwgY2FtZXJhLCBuZXZlciB0b28gY2xvc2VcbiAgICAgICAgICBjb25zdCBtaW5SYWRpdXMgPSBzdGFyTWF4RGlzdGFuY2UgKiAwLjg7XG4gICAgICAgICAgY29uc3QgbWF4UmFkaXVzID0gc3Rhck1heERpc3RhbmNlO1xuICAgICAgICAgIGNvbnN0IHIgPSBtaW5SYWRpdXMgKyBNYXRoLnJhbmRvbSgpICogKG1heFJhZGl1cyAtIG1pblJhZGl1cyk7XG4gICAgICAgICAgY29uc3QgdGhldGEgPSBNYXRoLnJhbmRvbSgpICogMiAqIE1hdGguUEk7XG4gICAgICAgICAgY29uc3QgcGhpID0gTWF0aC5hY29zKDIgKiBNYXRoLnJhbmRvbSgpIC0gMSk7XG4gICAgICAgICAgcG9zaXRpb25zW2ldID0gdmlydHVhbENhbWVyYVBvcy54ICsgciAqIE1hdGguc2luKHBoaSkgKiBNYXRoLmNvcyh0aGV0YSk7XG4gICAgICAgICAgcG9zaXRpb25zW2krMV0gPSB2aXJ0dWFsQ2FtZXJhUG9zLnkgKyByICogTWF0aC5zaW4ocGhpKSAqIE1hdGguc2luKHRoZXRhKTtcbiAgICAgICAgICBwb3NpdGlvbnNbaSsyXSA9IHZpcnR1YWxDYW1lcmFQb3MueiArIHIgKiBNYXRoLmNvcyhwaGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTsgLy8gQWxyZWFkeSBzZXQgYWJvdmVcbiAgXG4gICAgICAvLyBSb2J1c3Qgc3RhcmZpZWxkIGNvbG9yIHVwZGF0ZSB0byBwcmV2ZW50IHN0dWNrIHdoaXRlIGRvdHNcbiAgICAgIC8vIFRoaXMgd29ya3MgTk8gVE9VQ0hZXG4gICAgICBjb25zdCBjb2xBcnIgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLmNvbG9yLmFycmF5O1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3NpdGlvbnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gaSAvIDM7XG4gICAgICAgIGNvbnN0IGR4ID0gcG9zaXRpb25zW2ldIC0gdmlydHVhbENhbWVyYVBvcy54O1xuICAgICAgICBjb25zdCBkeSA9IHBvc2l0aW9uc1tpICsgMV0gLSB2aXJ0dWFsQ2FtZXJhUG9zLnk7XG4gICAgICAgIGNvbnN0IGR6ID0gcG9zaXRpb25zW2kgKyAyXSAtIHZpcnR1YWxDYW1lcmFQb3MuejtcbiAgICAgICAgY29uc3QgZGlzdCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSArIGR6ICogZHopO1xuICAgICAgICBpZiAodGltZXJzW2lkeF0gPiAwKSB7XG4gICAgICAgICAgdGltZXJzW2lkeF0tLTtcbiAgICAgICAgICBpZiAodGltZXJzW2lkeF0gPT09IDApIHtcbiAgICAgICAgICAgIC8vIFRpbWVyIGV4cGlyZWQsIHJlc3RvcmUgY29sb3JcbiAgICAgICAgICAgIHNwYXJrQ29sb3JzW2ldID0gb3JpZ2luYWxDb2xvcnNbaV07XG4gICAgICAgICAgICBzcGFya0NvbG9yc1tpKzFdID0gb3JpZ2luYWxDb2xvcnNbaSsxXTtcbiAgICAgICAgICAgIHNwYXJrQ29sb3JzW2krMl0gPSBvcmlnaW5hbENvbG9yc1tpKzJdO1xuICAgICAgICAgICAgY29sQXJyW2ldID0gb3JpZ2luYWxDb2xvcnNbaV07XG4gICAgICAgICAgICBjb2xBcnJbaSsxXSA9IG9yaWdpbmFsQ29sb3JzW2krMV07XG4gICAgICAgICAgICBjb2xBcnJbaSsyXSA9IG9yaWdpbmFsQ29sb3JzW2krMl07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbEFycltpXSA9IHNwYXJrQ29sb3JzW2ldO1xuICAgICAgICAgICAgY29sQXJyW2krMV0gPSBzcGFya0NvbG9yc1tpKzFdO1xuICAgICAgICAgICAgY29sQXJyW2krMl0gPSBzcGFya0NvbG9yc1tpKzJdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChkaXN0ID4gc3Rhck1heERpc3RhbmNlICogMC4zICYmIE1hdGgucmFuZG9tKCkgPCAwLjA1KSB7XG4gICAgICAgICAgdGltZXJzW2lkeF0gPSBzcGFya2xlRHVyYXRpb247XG4gICAgICAgICAgY29uc3QgYyA9IHBhbGV0dGVbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcGFsZXR0ZS5sZW5ndGgpXTtcbiAgICAgICAgICBzcGFya0NvbG9yc1tpXSA9IGNbMF07XG4gICAgICAgICAgc3BhcmtDb2xvcnNbaSsxXSA9IGNbMV07XG4gICAgICAgICAgc3BhcmtDb2xvcnNbaSsyXSA9IGNbMl07XG4gICAgICAgICAgY29sQXJyW2ldID0gc3BhcmtDb2xvcnNbaV07XG4gICAgICAgICAgY29sQXJyW2krMV0gPSBzcGFya0NvbG9yc1tpKzFdO1xuICAgICAgICAgIGNvbEFycltpKzJdID0gc3BhcmtDb2xvcnNbaSsyXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzcGFya0NvbG9yc1tpXSA9IG9yaWdpbmFsQ29sb3JzW2ldO1xuICAgICAgICAgIHNwYXJrQ29sb3JzW2krMV0gPSBvcmlnaW5hbENvbG9yc1tpKzFdO1xuICAgICAgICAgIHNwYXJrQ29sb3JzW2krMl0gPSBvcmlnaW5hbENvbG9yc1tpKzJdO1xuICAgICAgICAgIGNvbEFycltpXSA9IG9yaWdpbmFsQ29sb3JzW2ldO1xuICAgICAgICAgIGNvbEFycltpKzFdID0gb3JpZ2luYWxDb2xvcnNbaSsxXTtcbiAgICAgICAgICBjb2xBcnJbaSsyXSA9IG9yaWdpbmFsQ29sb3JzW2krMl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3IubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH07XG4gICAgXG4gICAgLy8gU3RhcnQgdGhlIGFuaW1hdGlvbiBsb29wXG4gICAgYW5pbWF0ZSgpO1xuICAgIFxuICAgIC8vIEhhbmRsZSB3aW5kb3cgcmVzaXplXG4gICAgY29uc3Qgb25SZXNpemUgPSAoKSA9PiB7XG4gICAgICBjYW1lcmEuYXNwZWN0ID0gd2luZG93LmlubmVyV2lkdGggLyB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICBjYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgICAgcmVuZGVyZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICAgIHNob290aW5nU3RhckNvbXBvc2VyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgICBjYUNvbXBvc2VyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgfTtcbiAgICBcbiAgICAvLyBBZGQgZXZlbnQgbGlzdGVuZXIgZm9yIHJlc2l6ZVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvblJlc2l6ZSk7XG4gICAgXG4gICAgLy8gQ2xlYW4gdXAgZnVuY3Rpb25cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uUmVzaXplKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCByZXNpemVBbGwpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Z1bGxzY3JlZW5jaGFuZ2UnLCByZXNpemVBbGwpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIG9uU2Nyb2xsKTtcbiAgICAgIC8vIENhbmNlbCB0aGUgYW5pbWF0aW9uIGZyYW1lIHVzaW5nIHRoZSBzdG9yZWQgSURcbiAgICAgIGlmIChhbmltYXRpb25JZCkge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShhbmltYXRpb25JZCk7XG4gICAgICB9XG4gICAgICAvLyBEaXNwb3NlIGNvbXBvc2Vyc1xuICAgICAgaWYgKGNvbXBvc2VyKSBjb21wb3Nlci5kaXNwb3NlKCk7XG4gICAgICBpZiAoc2hvb3RpbmdTdGFyQ29tcG9zZXIpIHNob290aW5nU3RhckNvbXBvc2VyLmRpc3Bvc2UoKTtcbiAgICAgIGlmIChjYUNvbXBvc2VyKSBjYUNvbXBvc2VyLmRpc3Bvc2UoKTtcbiAgICAgIC8vIENsZWFuIHVwIFRocmVlLmpzIHJlc291cmNlc1xuICAgICAgaWYgKHJlbmRlcmVyKSB7XG4gICAgICAgIHJlbmRlcmVyLmRpc3Bvc2UoKTtcbiAgICAgICAgaWYgKG1vdW50ICYmIG1vdW50LmNvbnRhaW5zKHJlbmRlcmVyLmRvbUVsZW1lbnQpKSB7XG4gICAgICAgICAgbW91bnQucmVtb3ZlQ2hpbGQocmVuZGVyZXIuZG9tRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9LCBbXSlcblxuICByZXR1cm4gPGRpdiByZWY9e21vdW50UmVmfSAvPjtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFN0YXJmaWVsZDtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUVmZmVjdCIsInVzZVJlZiIsIlRIUkVFIiwiRWZmZWN0Q29tcG9zZXIiLCJVbnJlYWxCbG9vbVBhc3MiLCJSZW5kZXJQYXNzIiwiU2hhZGVyUGFzcyIsIkZYQUFTaGFkZXIiLCJGaWxtUGFzcyIsIkNocm9tYXRpY0FiZXJyYXRpb25QYXNzIiwiU3RhcmZpZWxkIiwibW91bnRSZWYiLCJjdXJyZW50IiwibW91bnQiLCJzdHlsZSIsInBvc2l0aW9uIiwidG9wIiwibGVmdCIsIndpZHRoIiwiaGVpZ2h0IiwiekluZGV4Iiwic2NlbmUiLCJTY2VuZSIsImNhbWVyYSIsIlBlcnNwZWN0aXZlQ2FtZXJhIiwid2luZG93IiwiaW5uZXJXaWR0aCIsImlubmVySGVpZ2h0Iiwic2V0IiwidmlydHVhbENhbWVyYVBvcyIsIlZlY3RvcjMiLCJyZW5kZXJlciIsIldlYkdMUmVuZGVyZXIiLCJhbnRpYWxpYXMiLCJzZXRQaXhlbFJhdGlvIiwiZGV2aWNlUGl4ZWxSYXRpbyIsInNldFNpemUiLCJzZXRDbGVhckNvbG9yIiwib3V0cHV0Q29sb3JTcGFjZSIsIlNSR0JDb2xvclNwYWNlIiwidG9uZU1hcHBpbmciLCJOb1RvbmVNYXBwaW5nIiwiYXV0b0NsZWFyIiwiYXBwZW5kQ2hpbGQiLCJkb21FbGVtZW50IiwiY29tcG9zZXIiLCJyZW5kZXJQYXNzIiwiY2xlYXIiLCJhZGRQYXNzIiwiYmxvb21QYXNzIiwiVmVjdG9yMiIsImZ4YWFQYXNzIiwibWF0ZXJpYWwiLCJ1bmlmb3JtcyIsInZhbHVlIiwieCIsInkiLCJmaWxtUGFzcyIsInNob290aW5nU3RhclNjZW5lIiwic2hvb3RpbmdTdGFyQ29tcG9zZXIiLCJzaG9vdGluZ1N0YXJSZW5kZXJQYXNzIiwic2hvb3RpbmdTdGFyQmxvb21QYXNzIiwiY2xvc2VTdGFyc1NjZW5lIiwiY2FQYXNzIiwiY2FDb21wb3NlciIsImNhUmVuZGVyUGFzcyIsInJlc2l6ZUFsbCIsImFzcGVjdCIsInVwZGF0ZVByb2plY3Rpb25NYXRyaXgiLCJhZGRFdmVudExpc3RlbmVyIiwic3RhckNvdW50Iiwic3Rhck1heERpc3RhbmNlIiwic3RhclNwZWVkIiwiZ2VvbWV0cnkiLCJCdWZmZXJHZW9tZXRyeSIsImNsb3NlR2VvbWV0cnkiLCJwb3NpdGlvbnMiLCJjbG9zZVBvc2l0aW9ucyIsInN0YXJzUGxhY2VkIiwiTWF0aCIsInJhbmRvbSIsImNsdXN0ZXJUaGV0YSIsIlBJIiwiY2x1c3RlclBoaSIsImFjb3MiLCJjbHVzdGVyUiIsImNsdXN0ZXJDZW50ZXIiLCJzaW4iLCJjb3MiLCJjbHVzdGVyU2l6ZSIsImZsb29yIiwiYyIsIm9mZnNldFRoZXRhIiwib2Zmc2V0UGhpIiwib2Zmc2V0UiIsInB1c2giLCJ0aGV0YSIsInBoaSIsInIiLCJ6Iiwic2V0QXR0cmlidXRlIiwiRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSIsImxlbmd0aCIsInBhbGV0dGUiLCJjb2xvcnMiLCJpIiwib3JpZ2luYWxDb2xvcnMiLCJhdHRyaWJ1dGVzIiwiY29sb3IiLCJhcnJheSIsInNsaWNlIiwidGltZXJzIiwiRmxvYXQzMkFycmF5Iiwic3BhcmtDb2xvcnMiLCJzcGFya2xlRHVyYXRpb24iLCJQb2ludHNNYXRlcmlhbCIsInNpemUiLCJzaXplQXR0ZW51YXRpb24iLCJ2ZXJ0ZXhDb2xvcnMiLCJzdGFycyIsIlBvaW50cyIsImFkZCIsImdsb3dNYXAiLCJUZXh0dXJlTG9hZGVyIiwibG9hZCIsImdsb3dTcHJpdGVzIiwiZ2xvd01hdGVyaWFsIiwiU3ByaXRlTWF0ZXJpYWwiLCJtYXAiLCJvcGFjaXR5IiwiYmxlbmRpbmciLCJBZGRpdGl2ZUJsZW5kaW5nIiwiZGVwdGhXcml0ZSIsImdsb3ciLCJTcHJpdGUiLCJjbG9uZSIsInNjYWxlIiwiY2xvc2VTdGFycyIsInRhcmdldFkiLCJkYW1waW5nIiwib25TY3JvbGwiLCJwY3QiLCJzY3JvbGxZIiwiZG9jdW1lbnQiLCJib2R5Iiwic2Nyb2xsSGVpZ2h0IiwidGFpbExlbmd0aCIsInNob290aW5nU3RhcnMiLCJzaG9vdGluZ1N0YXJDb29sZG93biIsInNwYXduU2hvb3RpbmdTdGFyIiwiZGlyIiwibm9ybWFsaXplIiwibWluRGlzdCIsIm1heERpc3QiLCJkaXN0Iiwic3Bhd25Qb3MiLCJtdWx0aXBseVNjYWxhciIsInRhbmdlbnQiLCJzdWIiLCJwcm9qZWN0T25WZWN0b3IiLCJ0YW5nZW50aWFsU3BlZWQiLCJyYWRpYWxTcGVlZCIsInZlbG9jaXR5IiwidmlicmFudENvbG9ycyIsImJyaWdodG5lc3MiLCJnZW8iLCJTcGhlcmVHZW9tZXRyeSIsIm1hdCIsIk1lc2hQaHlzaWNhbE1hdGVyaWFsIiwiZW1pc3NpdmUiLCJlbWlzc2l2ZUludGVuc2l0eSIsIm1ldGFsbmVzcyIsInJvdWdobmVzcyIsInRyYW5zbWlzc2lvbiIsInRyYW5zcGFyZW50IiwiY2xlYXJjb2F0IiwiY2xlYXJjb2F0Um91Z2huZXNzIiwic3RhciIsIk1lc2giLCJzcHJpdGVNYXAiLCJzcHJpdGVNYXRlcmlhbCIsInNwcml0ZSIsImNvcHkiLCJjb2xvclNwcml0ZU1hdGVyaWFsIiwiY29sb3JTcHJpdGUiLCJzcGFya0NvdW50Iiwic3BhcmtHcm91cCIsIkdyb3VwIiwic3BhcmtNYXQiLCJNZXNoQmFzaWNNYXRlcmlhbCIsInNwYXJrR2VvIiwic3BhcmsiLCJhbmdsZSIsIm5hbWUiLCJub3JtYWxpemVkTGlmZSIsIm5vcm1hbGl6ZWRMaWZldGltZSIsImFnZSIsInRyYWlsU2VnbWVudHMiLCJ0cmFpbFBvaW50cyIsInNwaXJhbCIsImN1cnZlIiwicHQiLCJ0YWlsR2VvIiwic2V0RnJvbVBvaW50cyIsInRhaWxDb2xvcnMiLCJhbHBoYSIsInJhaW5ib3ciLCJncmFkQ29sb3IiLCJ0YWlsTWF0IiwiTGluZUJhc2ljTWF0ZXJpYWwiLCJ0YWlsTWF0TWFpbiIsIk5vcm1hbEJsZW5kaW5nIiwidGFpbE1haW4iLCJMaW5lIiwidGFpbE1hdEJsb29tIiwidGFpbEJsb29tIiwidGFpbEdsb3dNYXAiLCJ0YWlsR2xvd01hdCIsInRhaWxHbG93IiwibWVzaCIsInRhaWwiLCJoYXNGcmFnbWVudGVkIiwiYW5pbWF0aW9uSWQiLCJhbmltYXRlIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibmVlZHNVcGRhdGUiLCJpZHgiLCJyZW5kZXIiLCJyb3RhdGlvbiIsImZvcndhcmQiLCJnZXRXb3JsZERpcmVjdGlvbiIsImNvbG9yQXR0ciIsIm9yaWdSIiwib3JpZ0ciLCJvcmlnQiIsInNxcnQiLCJwb3ciLCJpbnRlbnNlUiIsIm1pbiIsImludGVuc2VHIiwiaW50ZW5zZUIiLCJmYWRlVCIsIm1heCIsInNoYWtlU3RyZW5ndGgiLCJvYmoiLCJjaGlsZHJlbiIsInNwYXJrcyIsImZpbmQiLCJjaGlsZCIsImoiLCJ0aW1lIiwicGVyZm9ybWFuY2UiLCJub3ciLCJnZXRBdHRyaWJ1dGUiLCJrIiwiY291bnQiLCJnZXRYIiwiZyIsImdldFkiLCJiIiwiZ2V0WiIsImgiLCJzIiwibCIsImQiLCJxIiwicCIsInRyIiwidGciLCJ0YiIsImh1ZTJyZ2IiLCJ0Iiwic2V0WCIsInNldFkiLCJzZXRaIiwic2V0VyIsImdldFciLCJ1bnNoaWZ0IiwicG9wIiwidGFpbEdyb3ciLCJhY3RpdmVTZWdtZW50cyIsInZpc2libGVUcmFpbCIsInRhaWxDb2xvcnNCbG9vbSIsIkRhdGUiLCJzZXRYWVpXIiwiaGVhZENvbG9yIiwiQ29sb3IiLCJsZXJwIiwiZmxpY2tlciIsImRpc3RUb0NhbSIsImRvZkJsdXIiLCJzcGVjdGFjdWxhciIsImJ1cnN0Q291bnQiLCJzcGFya2xlR2VvIiwic3BhcmtsZU1hdCIsInNwYXJrbGUiLCJzcGQiLCJzcGFya2xlVmVsIiwidXNlckRhdGEiLCJtYXhBZ2UiLCJfc3BhcmtsZXMiLCJmbGFzaEdlbyIsImZsYXNoTWF0IiwiZmxhc2giLCJfc3RhckZsYXNoZXMiLCJmcmFnVmVsIiwiYXBwbHlBeGlzQW5nbGUiLCJmcmFnU3RhciIsImZyYWdUcmFpbFBvaW50cyIsImZyYWdUYWlsR2VvIiwiZnJhZ1RhaWxNYXQiLCJmcmFnVGFpbCIsImhhc1NwYXJrZWQiLCJzcGFya1ZlbCIsInNwYXJrTGlmZSIsInNwYXJrQWdlIiwiX3N0YXJTcGFya3MiLCJoYXNGbGFzaGVkIiwiZGlzdGFuY2VUbyIsImZhZGVTdGFydCIsImZhZGUiLCJ0YWlsRmFkaW5nIiwicmVtb3ZlIiwidGFpbEZhZGVBZ2UiLCJfZmFkaW5nVGFpbHMiLCJzcGxpY2UiLCJnaG9zdCIsInNxRGlzdCIsImR4IiwiZHkiLCJkeiIsIm1pblJhZGl1cyIsIm1heFJhZGl1cyIsImNvbEFyciIsIm9uUmVzaXplIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiZGlzcG9zZSIsImNvbnRhaW5zIiwicmVtb3ZlQ2hpbGQiLCJkaXYiLCJyZWYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/Starfield.jsx\n"));

/***/ })

});