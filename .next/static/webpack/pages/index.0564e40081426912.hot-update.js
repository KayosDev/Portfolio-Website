"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./components/Starfield.jsx":
/*!**********************************!*\
  !*** ./components/Starfield.jsx ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar _s = $RefreshSig$();\n\n\nconst Starfield = ()=>{\n    _s();\n    const mountRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // Defensive: always use .current for refs\n        if (!mountRef.current) return;\n        const mount = mountRef.current;\n        mount.style.position = \"fixed\";\n        mount.style.top = \"0\";\n        mount.style.left = \"0\";\n        mount.style.width = \"100%\";\n        mount.style.height = \"100%\";\n        mount.style.zIndex = \"0\";\n        // Scene & Renderer\n        const scene = new three__WEBPACK_IMPORTED_MODULE_2__.Scene();\n        const camera = new three__WEBPACK_IMPORTED_MODULE_2__.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);\n        camera.position.set(0, 0, 0);\n        // Virtual position to simulate infinite travel\n        let virtualCameraPos = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0, 0);\n        const renderer = new three__WEBPACK_IMPORTED_MODULE_2__.WebGLRenderer({\n            antialias: true\n        });\n        renderer.setPixelRatio(window.devicePixelRatio);\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        renderer.setClearColor(0x000000, 1);\n        mount.appendChild(renderer.domElement);\n        // Starfield\n        const starCount = 3000;\n        const starMaxDistance = 2000;\n        const starSpeed = 1;\n        const geometry = new three__WEBPACK_IMPORTED_MODULE_2__.BufferGeometry();\n        const positions = [];\n        let starsPlaced = 0;\n        while(starsPlaced < starCount){\n            // With 1% chance, spawn a star cluster (10-30 stars)\n            if (Math.random() < 0.01 && starsPlaced < starCount - 10) {\n                const clusterTheta = Math.random() * 2 * Math.PI;\n                const clusterPhi = Math.acos(2 * Math.random() - 1);\n                const clusterR = Math.random() * starMaxDistance;\n                const clusterCenter = [\n                    clusterR * Math.sin(clusterPhi) * Math.cos(clusterTheta),\n                    clusterR * Math.sin(clusterPhi) * Math.sin(clusterTheta),\n                    clusterR * Math.cos(clusterPhi)\n                ];\n                const clusterSize = 10 + Math.floor(Math.random() * 20); // 10-30 stars\n                for(let c = 0; c < clusterSize && starsPlaced < starCount; c++){\n                    // Each star in cluster is within 30 units of center\n                    const offsetTheta = Math.random() * 2 * Math.PI;\n                    const offsetPhi = Math.acos(2 * Math.random() - 1);\n                    const offsetR = Math.random() * 30; // cluster radius\n                    positions.push(clusterCenter[0] + offsetR * Math.sin(offsetPhi) * Math.cos(offsetTheta), clusterCenter[1] + offsetR * Math.sin(offsetPhi) * Math.sin(offsetTheta), clusterCenter[2] + offsetR * Math.cos(offsetPhi));\n                    starsPlaced++;\n                }\n            } else {\n                // Normal single star\n                const theta = Math.random() * 2 * Math.PI;\n                const phi = Math.acos(2 * Math.random() - 1);\n                const r = Math.random() * starMaxDistance;\n                positions.push(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));\n                starsPlaced++;\n            }\n        }\n        geometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_2__.Float32BufferAttribute(positions, 3));\n        const palette = [\n            [\n                1.0,\n                0.5,\n                0.5\n            ],\n            [\n                1.0,\n                0.75,\n                0.4\n            ],\n            [\n                1.0,\n                1.0,\n                0.9\n            ],\n            [\n                1.0,\n                1.0,\n                1.0\n            ],\n            [\n                0.4,\n                0.5,\n                1.0\n            ]\n        ];\n        const colors = [];\n        for(let i = 0; i < starCount; i++){\n            const c = palette[Math.floor(Math.random() * palette.length)];\n            colors.push(...c);\n        }\n        geometry.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_2__.Float32BufferAttribute(colors, 3));\n        const originalColors = geometry.attributes.color.array.slice();\n        const timers = new Float32Array(starCount);\n        const sparkColors = new Float32Array(starCount * 3);\n        const sparkleDuration = 180;\n        const material = new three__WEBPACK_IMPORTED_MODULE_2__.PointsMaterial({\n            size: 3.5,\n            sizeAttenuation: true,\n            vertexColors: true\n        });\n        const stars = new three__WEBPACK_IMPORTED_MODULE_2__.Points(geometry, material);\n        scene.add(stars);\n        let targetY = 0;\n        const damping = 0.05;\n        const onScroll = ()=>{\n            const pct = window.scrollY / (document.body.scrollHeight - window.innerHeight);\n            targetY = pct * Math.PI * 2;\n        };\n        window.addEventListener(\"scroll\", onScroll);\n        // --- Nebula Clouds ---\n        const nebulaTextures = [\n            \"/nebula1.png\",\n            \"/nebula2.png\",\n            \"/nebula3.png\"\n        ];\n        const nebulaClouds = [];\n        function spawnNebulaCloud() {\n            const textureUrl = nebulaTextures[Math.floor(Math.random() * nebulaTextures.length)];\n            const tex = new three__WEBPACK_IMPORTED_MODULE_2__.TextureLoader().load(textureUrl);\n            const color = new three__WEBPACK_IMPORTED_MODULE_2__.Color().setHSL(Math.random(), 0.7, 0.5);\n            const mat = new three__WEBPACK_IMPORTED_MODULE_2__.SpriteMaterial({\n                map: tex,\n                color: color,\n                transparent: true,\n                opacity: 0.0,\n                depthWrite: false,\n                blending: three__WEBPACK_IMPORTED_MODULE_2__.AdditiveBlending\n            });\n            const sprite = new three__WEBPACK_IMPORTED_MODULE_2__.Sprite(mat);\n            // Place nebula far from camera, random direction\n            const dir = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();\n            const dist = starMaxDistance * (0.7 + Math.random() * 0.3);\n            sprite.position.copy(dir.multiplyScalar(dist));\n            const scale = 400 + Math.random() * 400;\n            sprite.scale.set(scale, scale, 1);\n            sprite.material.opacity = 0.0;\n            scene.add(sprite);\n            nebulaClouds.push({\n                sprite,\n                age: 0,\n                fadeIn: true,\n                fadeOut: false,\n                lifetime: 1200 + Math.random() * 1200,\n                color,\n                rotSpeed: (Math.random() - 0.5) * 0.005\n            });\n        }\n        // --- Shooting Stars ---\n        const tailLength = 32; // Increase for longer tails\n        const shootingStars = [];\n        let shootingStarCooldown = 0;\n        // Spawn a shooting star with a stunning glowing tail\n        function spawnShootingStar() {\n            // Pick a random direction on the sphere for the spawn location\n            const dir = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();\n            // Ensure shooting stars never spawn close to the camera (at least 70% of max distance)\n            const minDist = starMaxDistance * 0.7;\n            const maxDist = starMaxDistance * 1.0;\n            const dist = minDist + Math.random() * (maxDist - minDist);\n            const spawnPos = dir.clone().multiplyScalar(dist);\n            // Tangential velocity: perpendicular to dir\n            let tangent = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1);\n            tangent = tangent.sub(tangent.clone().projectOnVector(dir)).normalize();\n            // Mix in a small radial component (inward or outward)\n            const tangentialSpeed = starSpeed * (2.5 + Math.random() * 2.5); // much faster\n            const radialSpeed = starSpeed * (Math.random() - 0.5) * 0.3; // more dramatic\n            const velocity = tangent.multiplyScalar(tangentialSpeed).add(dir.clone().multiplyScalar(radialSpeed));\n            // Stunning color gradient for the head\n            const vibrantColors = [\n                0xffe066,\n                0xff66cc,\n                0x66ccff,\n                0xffffff,\n                0x80ffea,\n                0xfff2cc,\n                0xffc080,\n                0x80c0ff,\n                0xff80b3\n            ];\n            const color = vibrantColors[Math.floor(Math.random() * vibrantColors.length)];\n            // Star brightness and size (always small and subtle)\n            const brightness = 2.5 + Math.random() * 1.5;\n            const geo = new three__WEBPACK_IMPORTED_MODULE_2__.SphereGeometry(0.7 + Math.random() * 0.5, 16, 16); // Small sphere\n            const mat = new three__WEBPACK_IMPORTED_MODULE_2__.MeshPhysicalMaterial({\n                color: color,\n                emissive: color,\n                emissiveIntensity: 2.5,\n                metalness: 0.7,\n                roughness: 0.3,\n                transmission: 0.7,\n                opacity: 0.98,\n                transparent: true,\n                clearcoat: 0.8,\n                clearcoatRoughness: 0.2\n            });\n            const star = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(geo, mat);\n            // Add a glowing sprite for extra glow\n            const spriteMap = new three__WEBPACK_IMPORTED_MODULE_2__.TextureLoader().load(\"https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/sprites/glow.png\");\n            const spriteMaterial = new three__WEBPACK_IMPORTED_MODULE_2__.SpriteMaterial({\n                map: spriteMap,\n                color: color,\n                opacity: 0.8,\n                blending: three__WEBPACK_IMPORTED_MODULE_2__.AdditiveBlending\n            });\n            const sprite = new three__WEBPACK_IMPORTED_MODULE_2__.Sprite(spriteMaterial);\n            sprite.scale.set(30, 30, 1);\n            sprite.position.copy(star.position);\n            star.add(sprite);\n            // Add dynamic spark burst at the head\n            const sparkCount = 18 + Math.floor(Math.random() * 8);\n            const sparkGroup = new three__WEBPACK_IMPORTED_MODULE_2__.Group();\n            for(let i = 0; i < sparkCount; i++){\n                const sparkMat = new three__WEBPACK_IMPORTED_MODULE_2__.MeshBasicMaterial({\n                    color: vibrantColors[Math.floor(Math.random() * vibrantColors.length)],\n                    transparent: true,\n                    opacity: 0.8\n                });\n                const sparkGeo = new three__WEBPACK_IMPORTED_MODULE_2__.SphereGeometry(0.07 + Math.random() * 0.06, 8, 8);\n                const spark = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(sparkGeo, sparkMat);\n                const angle = i / sparkCount * Math.PI * 2;\n                spark.position.set(Math.cos(angle) * 1.2, Math.sin(angle) * 1.2, Math.random() * 0.4 - 0.2);\n                sparkGroup.add(spark);\n            }\n            sparkGroup.name = \"sparkBurst\";\n            star.add(sparkGroup);\n            star.position.copy(spawnPos);\n            star.velocity = velocity;\n            star.normalizedLife = 0.0;\n            star.normalizedLifetime = 80 + Math.random() * 80; // Longer, more dramatic\n            star.age = 0;\n            // --- Stunning Meteor Tail (very long, multi-color, glowing, fading, and 3D curve) ---\n            const trailSegments = tailLength * 3; // Even longer tail\n            const trailPoints = [];\n            for(let i = 0; i < trailSegments; i++){\n                // Add a 3D spiral/curve for more depth\n                const spiral = Math.sin(i * 0.25) * 8;\n                const curve = Math.cos(i * 0.15) * 4;\n                const pt = star.position.clone().add(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(spiral, curve, -i * 3));\n                trailPoints.push(pt);\n            }\n            const tailGeo = new three__WEBPACK_IMPORTED_MODULE_2__.BufferGeometry().setFromPoints(trailPoints);\n            // Per-vertex color (multi-color rainbow gradient)\n            const tailColors = [];\n            for(let i = 0; i < trailSegments; i++){\n                // Alpha fades out along the tail\n                const alpha = (1 - i / (trailSegments - 1)) * 0.99;\n                // Rainbow gradient\n                const rainbow = [\n                    0xffe066,\n                    0xff66cc,\n                    0x66ccff,\n                    0xffffff,\n                    0x80ffea,\n                    0xfff2cc,\n                    0xffc080,\n                    0x80c0ff,\n                    0xff80b3\n                ];\n                const gradColor = rainbow[Math.floor(i / trailSegments * rainbow.length)];\n                tailColors.push((gradColor >> 16 & 255) / 255, (gradColor >> 8 & 255) / 255, (gradColor & 255) / 255, alpha);\n            }\n            tailGeo.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_2__.Float32BufferAttribute(tailColors, 4));\n            // Additive blending for glow\n            const tailMat = new three__WEBPACK_IMPORTED_MODULE_2__.LineBasicMaterial({\n                vertexColors: true,\n                transparent: true,\n                opacity: 1.0,\n                blending: three__WEBPACK_IMPORTED_MODULE_2__.AdditiveBlending\n            });\n            const tail = new three__WEBPACK_IMPORTED_MODULE_2__.Line(tailGeo, tailMat);\n            tail.position.copy(star.position);\n            // Add to scene\n            scene.add(star);\n            scene.add(tail);\n            shootingStars.push({\n                mesh: star,\n                tail,\n                velocity: star.velocity,\n                dir,\n                age: 0,\n                normalizedLifetime: star.normalizedLifetime,\n                trailPoints,\n                color,\n                brightness,\n                hasFragmented: false\n            });\n        }\n        const animate = ()=>{\n            try {\n                requestAnimationFrame(animate);\n                // Occasionally spawn a nebula cloud\n                if (Math.random() < 0.002 && nebulaClouds.length < 6) {\n                    spawnNebulaCloud();\n                }\n                // Animate nebula clouds\n                for(let i = nebulaClouds.length - 1; i >= 0; i--){\n                    const cloud = nebulaClouds[i];\n                    cloud.age++;\n                    // Fade in\n                    if (cloud.fadeIn && cloud.sprite.material.opacity < 0.55) {\n                        cloud.sprite.material.opacity += 0.009;\n                        if (cloud.sprite.material.opacity >= 0.55) cloud.fadeIn = false;\n                    }\n                    // Fade out\n                    if (cloud.age > cloud.lifetime * 0.7) {\n                        cloud.fadeOut = true;\n                    }\n                    if (cloud.fadeOut) {\n                        cloud.sprite.material.opacity -= 0.006;\n                    }\n                    // Remove when fully faded\n                    if (cloud.sprite.material.opacity <= 0) {\n                        scene.remove(cloud.sprite);\n                        nebulaClouds.splice(i, 1);\n                        continue;\n                    }\n                    // Slow drift and rotation\n                    cloud.sprite.position.x += Math.sin(cloud.age * 0.001 + i) * 0.09;\n                    cloud.sprite.position.y += Math.cos(cloud.age * 0.0012 - i) * 0.07;\n                    cloud.sprite.material.rotation += cloud.rotSpeed;\n                    // Animate color gently\n                    cloud.sprite.material.color.offsetHSL(0.0007 * Math.sin(cloud.age * 0.0007 + i), 0, 0);\n                }\n                camera.rotation.y += (targetY - camera.rotation.y) * damping;\n                // Move the virtual camera position in the direction the camera is facing\n                const forward = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n                camera.getWorldDirection(forward);\n                virtualCameraPos.add(forward.multiplyScalar(starSpeed));\n                // Offset all stars by -virtualCameraPos (floating origin)\n                for(let i = 0; i < positions.length; i += 3){\n                    geometry.attributes.position.array[i] = positions[i] - virtualCameraPos.x;\n                    geometry.attributes.position.array[i + 1] = positions[i + 1] - virtualCameraPos.y;\n                    geometry.attributes.position.array[i + 2] = positions[i + 2] - virtualCameraPos.z;\n                }\n                geometry.attributes.position.needsUpdate = true;\n                // --- Shooting star spawning ---\n                // DEV: Make shooting stars super common (spawn every frame if cooldown allows)\n                if (shootingStarCooldown <= 0 && Math.random() < 0.1) {\n                    spawnShootingStar();\n                    // Subtle camera shake when a shooting star appears\n                    if (camera) {\n                        const shakeStrength = 0.06 + Math.random() * 0.04;\n                        camera.position.x += (Math.random() - 0.5) * shakeStrength;\n                        camera.position.y += (Math.random() - 0.5) * shakeStrength;\n                    }\n                    shootingStarCooldown = 10 + Math.random() * 10; // Longer cooldown for perf\n                } else if (shootingStarCooldown > 0) {\n                    shootingStarCooldown--;\n                }\n                // Animate and clean up shooting stars\n                for(let i = shootingStars.length - 1; i >= 0; i--){\n                    const obj = shootingStars[i];\n                    // Animate spark burst (fade and expand)\n                    if (obj.mesh.children) {\n                        const sparks = obj.mesh.children.find((child)=>child.name === \"sparkBurst\");\n                        if (sparks) {\n                            for(let j = 0; j < sparks.children.length; j++){\n                                const spark = sparks.children[j];\n                                spark.material.opacity *= 0.96; // Fade\n                                spark.scale.multiplyScalar(1.03); // Expand\n                            }\n                        }\n                    }\n                    // Animate tail shimmer and color cycling\n                    if (obj.tail && obj.trailPoints) {\n                        const time = performance.now() * 0.001;\n                        const tailGeo = obj.tail.geometry;\n                        const tailColors = tailGeo.getAttribute(\"color\");\n                        for(let k = 0; k < tailColors.count; k++){\n                            // Cycle hue\n                            let r = tailColors.getX(k), g = tailColors.getY(k), b = tailColors.getZ(k);\n                            // Convert to HSL\n                            const max = Math.max(r, g, b), min = Math.min(r, g, b);\n                            let h, s, l;\n                            l = (max + min) / 2;\n                            if (max === min) {\n                                h = s = 0;\n                            } else {\n                                const d = max - min;\n                                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n                                switch(max){\n                                    case r:\n                                        h = (g - b) / d + (g < b ? 6 : 0);\n                                        break;\n                                    case g:\n                                        h = (b - r) / d + 2;\n                                        break;\n                                    case b:\n                                        h = (r - g) / d + 4;\n                                        break;\n                                }\n                                h /= 6;\n                            }\n                            h = (h + 0.25 * Math.sin(time + k * 0.2)) % 1.0; // Animate hue\n                            // Convert back to RGB\n                            let q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n                            let p = 2 * l - q;\n                            let tr = h + 1 / 3, tg = h, tb = h - 1 / 3;\n                            const hue2rgb = (p, q, t)=>{\n                                if (t < 0) t += 1;\n                                if (t > 1) t -= 1;\n                                if (t < 1 / 6) return p + (q - p) * 6 * t;\n                                if (t < 1 / 2) return q;\n                                if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n                                return p;\n                            };\n                            tailColors.setX(k, hue2rgb(p, q, tr));\n                            tailColors.setY(k, hue2rgb(p, q, tg));\n                            tailColors.setZ(k, hue2rgb(p, q, tb));\n                            // Shimmer: modulate alpha\n                            tailColors.setW(k, tailColors.getW(k) * (0.97 + 0.03 * Math.sin(time * 8 + k)));\n                        }\n                        tailColors.needsUpdate = true;\n                    }\n                    // Straight-line trajectory\n                    obj.mesh.position.add(obj.velocity);\n                    obj.tail.position.copy(obj.mesh.position);\n                    // Animate tail (no lerp, just drag)\n                    obj.age++;\n                    const normalizedLife = obj.age / obj.normalizedLifetime;\n                    obj.trailPoints.unshift(obj.mesh.position.clone());\n                    if (obj.trailPoints.length > tailLength * 3) obj.trailPoints.pop();\n                    let tailGrow = Math.min(1, normalizedLife / 0.3);\n                    let activeSegments = Math.floor(obj.trailPoints.length * tailGrow);\n                    if (activeSegments < 2) activeSegments = 2;\n                    const visibleTrail = obj.trailPoints.slice(0, activeSegments);\n                    obj.tail.geometry.setFromPoints(visibleTrail);\n                    const tailColors = obj.tail.geometry.getAttribute(\"color\");\n                    for(let j = 0; j < visibleTrail.length; j++){\n                        let alpha = (1 - j / (visibleTrail.length - 1)) * 0.95;\n                        alpha *= 0.92 + 0.08 * Math.sin(Date.now() * 0.015 + j * 0.5);\n                        let rainbow = [\n                            0xffc080,\n                            0xffe080,\n                            0xffff80,\n                            0x80ffe6,\n                            0x80c0ff,\n                            0xc080ff\n                        ];\n                        let gradColor = rainbow[j % rainbow.length];\n                        if (normalizedLife > 0.7) alpha *= Math.max(0, 1 - (normalizedLife - 0.7 - 0.2) / 0.3);\n                        tailColors.setXYZW(j, (gradColor >> 16 & 255) / 255, (gradColor >> 8 & 255) / 255, (gradColor & 255) / 255, alpha);\n                    }\n                    tailColors.needsUpdate = true;\n                    // Animate head\n                    let headColor;\n                    if (normalizedLife < 0.5) {\n                        headColor = new three__WEBPACK_IMPORTED_MODULE_2__.Color(obj.color).lerp(new three__WEBPACK_IMPORTED_MODULE_2__.Color(0xffc080), normalizedLife * 2);\n                    } else {\n                        headColor = new three__WEBPACK_IMPORTED_MODULE_2__.Color(0xffc080).lerp(new three__WEBPACK_IMPORTED_MODULE_2__.Color(0xff4000), (normalizedLife - 0.5) * 2);\n                    }\n                    let flicker = 0.95 + 0.13 * Math.sin(Date.now() * 0.07 + Math.random() * 10);\n                    headColor.multiplyScalar(flicker);\n                    obj.mesh.material.color.copy(headColor);\n                    let scale = 1 + 2.2 * Math.sin(Math.PI * normalizedLife);\n                    let distToCam = obj.mesh.position.length();\n                    let dofBlur = distToCam < starMaxDistance * 0.7 ? 0.7 : 1.0;\n                    obj.mesh.scale.set(scale * dofBlur, scale * dofBlur, scale * dofBlur);\n                    // Sparkle burst\n                    if (normalizedLife >= 1 && !obj.hasFragmented) {\n                        for(let s = 0; s < 9; s++){\n                            const sparkleGeo = new three__WEBPACK_IMPORTED_MODULE_2__.SphereGeometry(0.7 + Math.random() * 0.8, 8, 8);\n                            const sparkleMat = new three__WEBPACK_IMPORTED_MODULE_2__.MeshBasicMaterial({\n                                color: 0xffffff,\n                                transparent: true,\n                                opacity: 0.7,\n                                blending: three__WEBPACK_IMPORTED_MODULE_2__.AdditiveBlending\n                            });\n                            const sparkle = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(sparkleGeo, sparkleMat);\n                            sparkle.position.copy(obj.mesh.position);\n                            const sparkleVel = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize().multiplyScalar(2 + Math.random() * 2);\n                            sparkle.userData = {\n                                velocity: sparkleVel,\n                                age: 0\n                            };\n                            scene.add(sparkle);\n                            if (!window._sparkles) window._sparkles = [];\n                            window._sparkles.push(sparkle);\n                        }\n                        const fragVel = obj.velocity.clone().applyAxisAngle(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 1, 0), (Math.random() - 0.5) * 0.3);\n                        const fragStar = obj.mesh.clone();\n                        fragStar.position.copy(obj.mesh.position);\n                        fragStar.velocity = fragVel;\n                        fragStar.normalizedLife = normalizedLife;\n                        fragStar.normalizedLifetime = obj.normalizedLifetime * (0.5 + Math.random() * 0.5);\n                        fragStar.age = obj.age;\n                        fragStar.material = obj.mesh.material.clone();\n                        const fragTrailPoints = obj.trailPoints.slice();\n                        const fragTailGeo = new three__WEBPACK_IMPORTED_MODULE_2__.BufferGeometry().setFromPoints(fragTrailPoints);\n                        fragTailGeo.setAttribute(\"color\", obj.tail.geometry.getAttribute(\"color\").clone());\n                        const fragTailMat = obj.tail.material.clone();\n                        const fragTail = new three__WEBPACK_IMPORTED_MODULE_2__.Line(fragTailGeo, fragTailMat);\n                        fragTail.position.copy(fragStar.position);\n                        scene.add(fragStar);\n                        scene.add(fragTail);\n                        shootingStars.push({\n                            mesh: fragStar,\n                            tail: fragTail,\n                            velocity: fragStar.velocity,\n                            dir: obj.dir,\n                            age: fragStar.age,\n                            normalizedLifetime: fragStar.normalizedLifetime,\n                            trailPoints: fragTrailPoints,\n                            color: obj.color,\n                            brightness: obj.brightness,\n                            hasFragmented: true\n                        });\n                        obj.hasFragmented = true;\n                    }\n                    // Spark burst\n                    if (!obj.hasSparked && normalizedLife > 0.95 && Math.random() < 0.1) {\n                        for(let s = 0; s < 8 + Math.floor(Math.random() * 8); s++){\n                            const sparkGeo = new three__WEBPACK_IMPORTED_MODULE_2__.SphereGeometry(0.5 + Math.random() * 0.5, 8, 8);\n                            const sparkMat = new three__WEBPACK_IMPORTED_MODULE_2__.MeshBasicMaterial({\n                                color: 0xfff6c0,\n                                transparent: true,\n                                opacity: 1,\n                                blending: three__WEBPACK_IMPORTED_MODULE_2__.AdditiveBlending\n                            });\n                            const spark = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(sparkGeo, sparkMat);\n                            spark.position.copy(obj.mesh.position);\n                            spark.sparkVel = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize().multiplyScalar(0.5 + Math.random() * 1.2);\n                            spark.sparkLife = 12 + Math.random() * 10;\n                            spark.sparkAge = 0;\n                            scene.add(spark);\n                            if (!window._starSparks) window._starSparks = [];\n                            window._starSparks.push(spark);\n                        }\n                        obj.hasSparked = true;\n                    }\n                    // Flash\n                    if (!obj.hasFlashed && normalizedLife > 0.98 && Math.random() < 0.2) {\n                        const flashGeo = new three__WEBPACK_IMPORTED_MODULE_2__.SphereGeometry(1, 16, 16);\n                        const flashMat = new three__WEBPACK_IMPORTED_MODULE_2__.MeshBasicMaterial({\n                            color: 0xffffee,\n                            transparent: true,\n                            opacity: 0.8,\n                            blending: three__WEBPACK_IMPORTED_MODULE_2__.AdditiveBlending\n                        });\n                        const flash = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(flashGeo, flashMat);\n                        flash.position.copy(obj.mesh.position);\n                        scene.add(flash);\n                        if (!window._starFlashes) window._starFlashes = [];\n                        window._starFlashes.push({\n                            mesh: flash,\n                            age: 0\n                        });\n                        obj.hasFlashed = true;\n                    }\n                    // Fade out as it gets far away\n                    const dist = obj.mesh.position.distanceTo(camera.position);\n                    const fadeStart = starMaxDistance * 0.5;\n                    if (dist > fadeStart) {\n                        const fade = 1 - (dist - fadeStart) / (starMaxDistance - fadeStart);\n                        obj.mesh.material.opacity = Math.max(0, fade);\n                        obj.mesh.material.transparent = true;\n                        obj.tail.material.opacity = Math.max(0, fade * 0.8);\n                        obj.tail.material.transparent = true;\n                    }\n                    // Remove when out of bounds or fully faded or life ended\n                    if (normalizedLife >= 1.0 || dist > starMaxDistance || obj.mesh.material.opacity <= 0.01) {\n                        scene.remove(obj.mesh);\n                        scene.remove(obj.tail);\n                        shootingStars.splice(i, 1);\n                    }\n                }\n                // Animate sparks\n                if (window._starSparks) {\n                    for(let i = window._starSparks.length - 1; i >= 0; i--){\n                        const spark = window._starSparks[i];\n                        spark.position.add(spark.sparkVel);\n                        spark.sparkAge++;\n                        spark.material.opacity *= 0.85;\n                        if (spark.sparkAge > spark.sparkLife) {\n                            scene.remove(spark);\n                            window._starSparks.splice(i, 1);\n                        }\n                    }\n                }\n                // Animate flashes\n                if (window._starFlashes) {\n                    for(let i = window._starFlashes.length - 1; i >= 0; i--){\n                        const flash = window._starFlashes[i];\n                        flash.mesh.scale.multiplyScalar(1.15);\n                        flash.mesh.material.opacity *= 0.85;\n                        flash.age++;\n                        if (flash.age > 10) {\n                            scene.remove(flash.mesh);\n                            window._starFlashes.splice(i, 1);\n                        }\n                    }\n                }\n                // --- Starfield logic ---\n                const sqDist = starMaxDistance * starMaxDistance;\n                for(let i = 0; i < positions.length; i += 3){\n                    const dx = positions[i] - virtualCameraPos.x;\n                    const dy = positions[i + 1] - virtualCameraPos.y;\n                    const dz = positions[i + 2] - virtualCameraPos.z;\n                    if (dx * dx + dy * dy + dz * dz > sqDist) {\n                        // Place in a thick spherical shell around the virtual camera, never too close\n                        const minRadius = starMaxDistance * 0.8;\n                        const maxRadius = starMaxDistance;\n                        const r = minRadius + Math.random() * (maxRadius - minRadius);\n                        const theta = Math.random() * 2 * Math.PI;\n                        const phi = Math.acos(2 * Math.random() - 1);\n                        positions[i] = virtualCameraPos.x + r * Math.sin(phi) * Math.cos(theta);\n                        positions[i + 1] = virtualCameraPos.y + r * Math.sin(phi) * Math.sin(theta);\n                        positions[i + 2] = virtualCameraPos.z + r * Math.cos(phi);\n                    }\n                }\n                // geometry.attributes.position.needsUpdate = true; // Already set above\n                // Robust starfield color update to prevent stuck white dots\n                const colArr = geometry.attributes.color.array;\n                for(let i = 0; i < positions.length; i += 3){\n                    const idx = i / 3;\n                    const dx = positions[i] - virtualCameraPos.x;\n                    const dy = positions[i + 1] - virtualCameraPos.y;\n                    const dz = positions[i + 2] - virtualCameraPos.z;\n                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);\n                    if (timers[idx] > 0) {\n                        timers[idx]--;\n                        if (timers[idx] === 0) {\n                            // Timer expired, restore color\n                            sparkColors[i] = originalColors[i];\n                            sparkColors[i + 1] = originalColors[i + 1];\n                            sparkColors[i + 2] = originalColors[i + 2];\n                            colArr[i] = originalColors[i];\n                            colArr[i + 1] = originalColors[i + 1];\n                            colArr[i + 2] = originalColors[i + 2];\n                        } else {\n                            colArr[i] = sparkColors[i];\n                            colArr[i + 1] = sparkColors[i + 1];\n                            colArr[i + 2] = sparkColors[i + 2];\n                        }\n                    } else if (dist > starMaxDistance * 0.3 && Math.random() < 0.05) {\n                        timers[idx] = sparkleDuration;\n                        const c = palette[Math.floor(Math.random() * palette.length)];\n                        sparkColors[i] = c[0];\n                        sparkColors[i + 1] = c[1];\n                        sparkColors[i + 2] = c[2];\n                        colArr[i] = sparkColors[i];\n                        colArr[i + 1] = sparkColors[i + 1];\n                        colArr[i + 2] = sparkColors[i + 2];\n                    } else {\n                        sparkColors[i] = originalColors[i];\n                        sparkColors[i + 1] = originalColors[i + 1];\n                        sparkColors[i + 2] = originalColors[i + 2];\n                        colArr[i] = originalColors[i];\n                        colArr[i + 1] = originalColors[i + 1];\n                        colArr[i + 2] = originalColors[i + 2];\n                    }\n                }\n                geometry.attributes.color.needsUpdate = true;\n                renderer.render(scene, camera);\n            } catch (err) {\n                // Defensive: log error with context\n                console.error(\"Starfield animation error:\", err);\n            }\n        };\n        animate(); // Start the render loop\n        const onResize = ()=>{\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        };\n        window.addEventListener(\"resize\", onResize);\n        return ()=>{\n            window.removeEventListener(\"scroll\", onScroll);\n            window.removeEventListener(\"resize\", onResize);\n            mount.removeChild(renderer.domElement);\n        };\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: mountRef\n    }, void 0, false, {\n        fileName: \"/home/kayosdev/Websites/Portfolio/components/Starfield.jsx\",\n        lineNumber: 572,\n        columnNumber: 10\n    }, undefined);\n};\n_s(Starfield, \"V9/qkEdV8GfsDZk7lMTA1T8g5Ps=\");\n_c = Starfield;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Starfield);\nvar _c;\n$RefreshReg$(_c, \"Starfield\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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d0I7UUFFbkMsTUFBTW9HLFdBQVc7WUFDZnhRLE9BQU95USxNQUFNLEdBQUd2USxPQUFPQyxVQUFVLEdBQUdELE9BQU9FLFdBQVc7WUFDdERKLE9BQU8wUSxzQkFBc0I7WUFDN0JsUSxTQUFTSyxPQUFPLENBQUNYLE9BQU9DLFVBQVUsRUFBRUQsT0FBT0UsV0FBVztRQUN4RDtRQUNBRixPQUFPeUUsZ0JBQWdCLENBQUMsVUFBVTZMO1FBRWxDLE9BQU87WUFDTHRRLE9BQU95USxtQkFBbUIsQ0FBQyxVQUFVdE07WUFDckNuRSxPQUFPeVEsbUJBQW1CLENBQUMsVUFBVUg7WUFDckNsUixNQUFNc1IsV0FBVyxDQUFDcFEsU0FBU1EsVUFBVTtRQUN2QztJQUNGLEdBQUcsRUFBRTtJQUVMLHFCQUFPLDhEQUFDNlA7UUFBSUMsS0FBSzFSOzs7Ozs7QUFDbkI7R0F6akJNRDtLQUFBQTtBQTJqQk4sK0RBQWVBLFNBQVNBLEVBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9TdGFyZmllbGQuanN4P2YxYTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuXG5jb25zdCBTdGFyZmllbGQgPSAoKSA9PiB7XG4gIGNvbnN0IG1vdW50UmVmID0gdXNlUmVmKG51bGwpXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBEZWZlbnNpdmU6IGFsd2F5cyB1c2UgLmN1cnJlbnQgZm9yIHJlZnNcbiAgICBpZiAoIW1vdW50UmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICBjb25zdCBtb3VudCA9IG1vdW50UmVmLmN1cnJlbnRcbiAgICBtb3VudC5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCdcbiAgICBtb3VudC5zdHlsZS50b3AgPSAnMCdcbiAgICBtb3VudC5zdHlsZS5sZWZ0ID0gJzAnXG4gICAgbW91bnQuc3R5bGUud2lkdGggPSAnMTAwJSdcbiAgICBtb3VudC5zdHlsZS5oZWlnaHQgPSAnMTAwJSdcbiAgICBtb3VudC5zdHlsZS56SW5kZXggPSAnMCdcblxuICAgIC8vIFNjZW5lICYgUmVuZGVyZXJcbiAgICBjb25zdCBzY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpXG4gICAgY29uc3QgY2FtZXJhID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKDc1LCB3aW5kb3cuaW5uZXJXaWR0aCAvIHdpbmRvdy5pbm5lckhlaWdodCwgMC4xLCA1MDAwKVxuICAgIGNhbWVyYS5wb3NpdGlvbi5zZXQoMCwgMCwgMCk7XG4gICAgLy8gVmlydHVhbCBwb3NpdGlvbiB0byBzaW11bGF0ZSBpbmZpbml0ZSB0cmF2ZWxcbiAgICBsZXQgdmlydHVhbENhbWVyYVBvcyA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDApO1xuICAgIGNvbnN0IHJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoeyBhbnRpYWxpYXM6IHRydWUgfSlcbiAgICByZW5kZXJlci5zZXRQaXhlbFJhdGlvKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKVxuICAgIHJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodClcbiAgICByZW5kZXJlci5zZXRDbGVhckNvbG9yKDB4MDAwMDAwLCAxKTtcbiAgICBtb3VudC5hcHBlbmRDaGlsZChyZW5kZXJlci5kb21FbGVtZW50KVxuXG4gICAgLy8gU3RhcmZpZWxkXG4gICAgY29uc3Qgc3RhckNvdW50ID0gMzAwMFxuICAgIGNvbnN0IHN0YXJNYXhEaXN0YW5jZSA9IDIwMDBcbiAgICBjb25zdCBzdGFyU3BlZWQgPSAxXG4gICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKVxuICAgIGNvbnN0IHBvc2l0aW9ucyA9IFtdO1xuICAgIGxldCBzdGFyc1BsYWNlZCA9IDA7XG4gICAgd2hpbGUgKHN0YXJzUGxhY2VkIDwgc3RhckNvdW50KSB7XG4gICAgICAvLyBXaXRoIDElIGNoYW5jZSwgc3Bhd24gYSBzdGFyIGNsdXN0ZXIgKDEwLTMwIHN0YXJzKVxuICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPCAwLjAxICYmIHN0YXJzUGxhY2VkIDwgc3RhckNvdW50IC0gMTApIHtcbiAgICAgICAgY29uc3QgY2x1c3RlclRoZXRhID0gTWF0aC5yYW5kb20oKSAqIDIgKiBNYXRoLlBJO1xuICAgICAgICBjb25zdCBjbHVzdGVyUGhpID0gTWF0aC5hY29zKDIgKiBNYXRoLnJhbmRvbSgpIC0gMSk7XG4gICAgICAgIGNvbnN0IGNsdXN0ZXJSID0gTWF0aC5yYW5kb20oKSAqIHN0YXJNYXhEaXN0YW5jZTtcbiAgICAgICAgY29uc3QgY2x1c3RlckNlbnRlciA9IFtcbiAgICAgICAgICBjbHVzdGVyUiAqIE1hdGguc2luKGNsdXN0ZXJQaGkpICogTWF0aC5jb3MoY2x1c3RlclRoZXRhKSxcbiAgICAgICAgICBjbHVzdGVyUiAqIE1hdGguc2luKGNsdXN0ZXJQaGkpICogTWF0aC5zaW4oY2x1c3RlclRoZXRhKSxcbiAgICAgICAgICBjbHVzdGVyUiAqIE1hdGguY29zKGNsdXN0ZXJQaGkpXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGNsdXN0ZXJTaXplID0gMTAgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyMCk7IC8vIDEwLTMwIHN0YXJzXG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgY2x1c3RlclNpemUgJiYgc3RhcnNQbGFjZWQgPCBzdGFyQ291bnQ7IGMrKykge1xuICAgICAgICAgIC8vIEVhY2ggc3RhciBpbiBjbHVzdGVyIGlzIHdpdGhpbiAzMCB1bml0cyBvZiBjZW50ZXJcbiAgICAgICAgICBjb25zdCBvZmZzZXRUaGV0YSA9IE1hdGgucmFuZG9tKCkgKiAyICogTWF0aC5QSTtcbiAgICAgICAgICBjb25zdCBvZmZzZXRQaGkgPSBNYXRoLmFjb3MoMiAqIE1hdGgucmFuZG9tKCkgLSAxKTtcbiAgICAgICAgICBjb25zdCBvZmZzZXRSID0gTWF0aC5yYW5kb20oKSAqIDMwOyAvLyBjbHVzdGVyIHJhZGl1c1xuICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKFxuICAgICAgICAgICAgY2x1c3RlckNlbnRlclswXSArIG9mZnNldFIgKiBNYXRoLnNpbihvZmZzZXRQaGkpICogTWF0aC5jb3Mob2Zmc2V0VGhldGEpLFxuICAgICAgICAgICAgY2x1c3RlckNlbnRlclsxXSArIG9mZnNldFIgKiBNYXRoLnNpbihvZmZzZXRQaGkpICogTWF0aC5zaW4ob2Zmc2V0VGhldGEpLFxuICAgICAgICAgICAgY2x1c3RlckNlbnRlclsyXSArIG9mZnNldFIgKiBNYXRoLmNvcyhvZmZzZXRQaGkpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzdGFyc1BsYWNlZCsrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb3JtYWwgc2luZ2xlIHN0YXJcbiAgICAgICAgY29uc3QgdGhldGEgPSBNYXRoLnJhbmRvbSgpICogMiAqIE1hdGguUEk7XG4gICAgICAgIGNvbnN0IHBoaSA9IE1hdGguYWNvcygyICogTWF0aC5yYW5kb20oKSAtIDEpO1xuICAgICAgICBjb25zdCByID0gTWF0aC5yYW5kb20oKSAqIHN0YXJNYXhEaXN0YW5jZTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goXG4gICAgICAgICAgciAqIE1hdGguc2luKHBoaSkgKiBNYXRoLmNvcyh0aGV0YSksXG4gICAgICAgICAgciAqIE1hdGguc2luKHBoaSkgKiBNYXRoLnNpbih0aGV0YSksXG4gICAgICAgICAgciAqIE1hdGguY29zKHBoaSlcbiAgICAgICAgKTtcbiAgICAgICAgc3RhcnNQbGFjZWQrKztcbiAgICAgIH1cbiAgICB9XG4gICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBUSFJFRS5GbG9hdDMyQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9ucywgMykpXG5cbiAgICBjb25zdCBwYWxldHRlID0gW1xuICAgICAgWzEuMCwgMC41LCAwLjVdLFxuICAgICAgWzEuMCwgMC43NSwgMC40XSxcbiAgICAgIFsxLjAsIDEuMCwgMC45XSxcbiAgICAgIFsxLjAsIDEuMCwgMS4wXSxcbiAgICAgIFswLjQsIDAuNSwgMS4wXSxcbiAgICBdXG4gICAgY29uc3QgY29sb3JzID0gW11cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXJDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBjID0gcGFsZXR0ZVtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBwYWxldHRlLmxlbmd0aCldXG4gICAgICBjb2xvcnMucHVzaCguLi5jKVxuICAgIH1cbiAgICBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2NvbG9yJywgbmV3IFRIUkVFLkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoY29sb3JzLCAzKSlcblxuICAgIGNvbnN0IG9yaWdpbmFsQ29sb3JzID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvci5hcnJheS5zbGljZSgpXG4gICAgY29uc3QgdGltZXJzID0gbmV3IEZsb2F0MzJBcnJheShzdGFyQ291bnQpXG4gICAgY29uc3Qgc3BhcmtDb2xvcnMgPSBuZXcgRmxvYXQzMkFycmF5KHN0YXJDb3VudCAqIDMpXG4gICAgY29uc3Qgc3BhcmtsZUR1cmF0aW9uID0gMTgwXG5cbiAgICBjb25zdCBtYXRlcmlhbCA9IG5ldyBUSFJFRS5Qb2ludHNNYXRlcmlhbCh7IHNpemU6IDMuNSwgc2l6ZUF0dGVudWF0aW9uOiB0cnVlLCB2ZXJ0ZXhDb2xvcnM6IHRydWUgfSlcbiAgICBjb25zdCBzdGFycyA9IG5ldyBUSFJFRS5Qb2ludHMoZ2VvbWV0cnksIG1hdGVyaWFsKVxuICAgIHNjZW5lLmFkZChzdGFycylcblxuICAgIGxldCB0YXJnZXRZID0gMFxuICAgIGNvbnN0IGRhbXBpbmcgPSAwLjA1XG4gICAgY29uc3Qgb25TY3JvbGwgPSAoKSA9PiB7XG4gICAgICBjb25zdCBwY3QgPSB3aW5kb3cuc2Nyb2xsWSAvIChkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCAtIHdpbmRvdy5pbm5lckhlaWdodClcbiAgICAgIHRhcmdldFkgPSBwY3QgKiBNYXRoLlBJICogMlxuICAgIH1cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25TY3JvbGwpXG5cbiAgICAvLyAtLS0gTmVidWxhIENsb3VkcyAtLS1cbiAgICBjb25zdCBuZWJ1bGFUZXh0dXJlcyA9IFtcbiAgICAgICcvbmVidWxhMS5wbmcnLFxuICAgICAgJy9uZWJ1bGEyLnBuZycsXG4gICAgICAnL25lYnVsYTMucG5nJyxcbiAgICBdO1xuICAgIGNvbnN0IG5lYnVsYUNsb3VkcyA9IFtdO1xuICAgIGZ1bmN0aW9uIHNwYXduTmVidWxhQ2xvdWQoKSB7XG4gICAgICBjb25zdCB0ZXh0dXJlVXJsID0gbmVidWxhVGV4dHVyZXNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKm5lYnVsYVRleHR1cmVzLmxlbmd0aCldO1xuICAgICAgY29uc3QgdGV4ID0gbmV3IFRIUkVFLlRleHR1cmVMb2FkZXIoKS5sb2FkKHRleHR1cmVVcmwpO1xuICAgICAgY29uc3QgY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoKS5zZXRIU0woTWF0aC5yYW5kb20oKSwgMC43LCAwLjUpO1xuICAgICAgY29uc3QgbWF0ID0gbmV3IFRIUkVFLlNwcml0ZU1hdGVyaWFsKHsgbWFwOiB0ZXgsIGNvbG9yOiBjb2xvciwgdHJhbnNwYXJlbnQ6IHRydWUsIG9wYWNpdHk6IDAuMCwgZGVwdGhXcml0ZTogZmFsc2UsIGJsZW5kaW5nOiBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nIH0pO1xuICAgICAgY29uc3Qgc3ByaXRlID0gbmV3IFRIUkVFLlNwcml0ZShtYXQpO1xuICAgICAgLy8gUGxhY2UgbmVidWxhIGZhciBmcm9tIGNhbWVyYSwgcmFuZG9tIGRpcmVjdGlvblxuICAgICAgY29uc3QgZGlyID0gbmV3IFRIUkVFLlZlY3RvcjMoTWF0aC5yYW5kb20oKSoyLTEsIE1hdGgucmFuZG9tKCkqMi0xLCBNYXRoLnJhbmRvbSgpKjItMSkubm9ybWFsaXplKCk7XG4gICAgICBjb25zdCBkaXN0ID0gc3Rhck1heERpc3RhbmNlICogKDAuNyArIE1hdGgucmFuZG9tKCkqMC4zKTtcbiAgICAgIHNwcml0ZS5wb3NpdGlvbi5jb3B5KGRpci5tdWx0aXBseVNjYWxhcihkaXN0KSk7XG4gICAgICBjb25zdCBzY2FsZSA9IDQwMCArIE1hdGgucmFuZG9tKCkqNDAwO1xuICAgICAgc3ByaXRlLnNjYWxlLnNldChzY2FsZSwgc2NhbGUsIDEpO1xuICAgICAgc3ByaXRlLm1hdGVyaWFsLm9wYWNpdHkgPSAwLjA7XG4gICAgICBzY2VuZS5hZGQoc3ByaXRlKTtcbiAgICAgIG5lYnVsYUNsb3Vkcy5wdXNoKHsgc3ByaXRlLCBhZ2U6IDAsIGZhZGVJbjogdHJ1ZSwgZmFkZU91dDogZmFsc2UsIGxpZmV0aW1lOiAxMjAwICsgTWF0aC5yYW5kb20oKSoxMjAwLCBjb2xvciwgcm90U3BlZWQ6IChNYXRoLnJhbmRvbSgpLTAuNSkqMC4wMDUgfSk7XG4gICAgfVxuXG4gICAgLy8gLS0tIFNob290aW5nIFN0YXJzIC0tLVxuICAgIGNvbnN0IHRhaWxMZW5ndGggPSAzMjsgLy8gSW5jcmVhc2UgZm9yIGxvbmdlciB0YWlsc1xuICAgIGNvbnN0IHNob290aW5nU3RhcnMgPSBbXTtcbiAgICBsZXQgc2hvb3RpbmdTdGFyQ29vbGRvd24gPSAwO1xuICAgIC8vIFNwYXduIGEgc2hvb3Rpbmcgc3RhciB3aXRoIGEgc3R1bm5pbmcgZ2xvd2luZyB0YWlsXG4gICAgZnVuY3Rpb24gc3Bhd25TaG9vdGluZ1N0YXIoKSB7XG4gICAgICAvLyBQaWNrIGEgcmFuZG9tIGRpcmVjdGlvbiBvbiB0aGUgc3BoZXJlIGZvciB0aGUgc3Bhd24gbG9jYXRpb25cbiAgICAgIGNvbnN0IGRpciA9IG5ldyBUSFJFRS5WZWN0b3IzKE1hdGgucmFuZG9tKCkqMi0xLCBNYXRoLnJhbmRvbSgpKjItMSwgTWF0aC5yYW5kb20oKSoyLTEpLm5vcm1hbGl6ZSgpO1xuICAgICAgLy8gRW5zdXJlIHNob290aW5nIHN0YXJzIG5ldmVyIHNwYXduIGNsb3NlIHRvIHRoZSBjYW1lcmEgKGF0IGxlYXN0IDcwJSBvZiBtYXggZGlzdGFuY2UpXG4gICAgICBjb25zdCBtaW5EaXN0ID0gc3Rhck1heERpc3RhbmNlICogMC43O1xuICAgICAgY29uc3QgbWF4RGlzdCA9IHN0YXJNYXhEaXN0YW5jZSAqIDEuMDtcbiAgICAgIGNvbnN0IGRpc3QgPSBtaW5EaXN0ICsgTWF0aC5yYW5kb20oKSAqIChtYXhEaXN0IC0gbWluRGlzdCk7XG4gICAgICBjb25zdCBzcGF3blBvcyA9IGRpci5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKGRpc3QpO1xuICAgICAgLy8gVGFuZ2VudGlhbCB2ZWxvY2l0eTogcGVycGVuZGljdWxhciB0byBkaXJcbiAgICAgIGxldCB0YW5nZW50ID0gbmV3IFRIUkVFLlZlY3RvcjMoTWF0aC5yYW5kb20oKSoyLTEsIE1hdGgucmFuZG9tKCkqMi0xLCBNYXRoLnJhbmRvbSgpKjItMSk7XG4gICAgICB0YW5nZW50ID0gdGFuZ2VudC5zdWIodGFuZ2VudC5jbG9uZSgpLnByb2plY3RPblZlY3RvcihkaXIpKS5ub3JtYWxpemUoKTtcbiAgICAgIC8vIE1peCBpbiBhIHNtYWxsIHJhZGlhbCBjb21wb25lbnQgKGlud2FyZCBvciBvdXR3YXJkKVxuICAgICAgY29uc3QgdGFuZ2VudGlhbFNwZWVkID0gc3RhclNwZWVkICogKDIuNSArIE1hdGgucmFuZG9tKCkgKiAyLjUpOyAvLyBtdWNoIGZhc3RlclxuICAgICAgY29uc3QgcmFkaWFsU3BlZWQgPSBzdGFyU3BlZWQgKiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAwLjM7IC8vIG1vcmUgZHJhbWF0aWNcbiAgICAgIGNvbnN0IHZlbG9jaXR5ID0gdGFuZ2VudC5tdWx0aXBseVNjYWxhcih0YW5nZW50aWFsU3BlZWQpLmFkZChkaXIuY2xvbmUoKS5tdWx0aXBseVNjYWxhcihyYWRpYWxTcGVlZCkpO1xuXG4gICAgICAvLyBTdHVubmluZyBjb2xvciBncmFkaWVudCBmb3IgdGhlIGhlYWRcbiAgICAgIGNvbnN0IHZpYnJhbnRDb2xvcnMgPSBbMHhmZmUwNjYsIDB4ZmY2NmNjLCAweDY2Y2NmZiwgMHhmZmZmZmYsIDB4ODBmZmVhLCAweGZmZjJjYywgMHhmZmMwODAsIDB4ODBjMGZmLCAweGZmODBiM107XG4gICAgICBjb25zdCBjb2xvciA9IHZpYnJhbnRDb2xvcnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKnZpYnJhbnRDb2xvcnMubGVuZ3RoKV07XG4gICAgICAvLyBTdGFyIGJyaWdodG5lc3MgYW5kIHNpemUgKGFsd2F5cyBzbWFsbCBhbmQgc3VidGxlKVxuICAgICAgY29uc3QgYnJpZ2h0bmVzcyA9IDIuNSArIE1hdGgucmFuZG9tKCkqMS41O1xuICAgICAgY29uc3QgZ2VvID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KDAuNyArIE1hdGgucmFuZG9tKCkqMC41LCAxNiwgMTYpOyAvLyBTbWFsbCBzcGhlcmVcbiAgICAgIGNvbnN0IG1hdCA9IG5ldyBUSFJFRS5NZXNoUGh5c2ljYWxNYXRlcmlhbCh7XG4gICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgZW1pc3NpdmU6IGNvbG9yLFxuICAgICAgICBlbWlzc2l2ZUludGVuc2l0eTogMi41LFxuICAgICAgICBtZXRhbG5lc3M6IDAuNyxcbiAgICAgICAgcm91Z2huZXNzOiAwLjMsXG4gICAgICAgIHRyYW5zbWlzc2lvbjogMC43LFxuICAgICAgICBvcGFjaXR5OiAwLjk4LFxuICAgICAgICB0cmFuc3BhcmVudDogdHJ1ZSxcbiAgICAgICAgY2xlYXJjb2F0OiAwLjgsXG4gICAgICAgIGNsZWFyY29hdFJvdWdobmVzczogMC4yLFxuICAgICAgfSk7XG4gICAgICBjb25zdCBzdGFyID0gbmV3IFRIUkVFLk1lc2goZ2VvLCBtYXQpO1xuICAgICAgLy8gQWRkIGEgZ2xvd2luZyBzcHJpdGUgZm9yIGV4dHJhIGdsb3dcbiAgICAgIGNvbnN0IHNwcml0ZU1hcCA9IG5ldyBUSFJFRS5UZXh0dXJlTG9hZGVyKCkubG9hZCgnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL21yZG9vYi90aHJlZS5qcy9tYXN0ZXIvZXhhbXBsZXMvdGV4dHVyZXMvc3ByaXRlcy9nbG93LnBuZycpO1xuICAgICAgY29uc3Qgc3ByaXRlTWF0ZXJpYWwgPSBuZXcgVEhSRUUuU3ByaXRlTWF0ZXJpYWwoeyBtYXA6IHNwcml0ZU1hcCwgY29sb3I6IGNvbG9yLCBvcGFjaXR5OiAwLjgsIGJsZW5kaW5nOiBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nIH0pO1xuICAgICAgY29uc3Qgc3ByaXRlID0gbmV3IFRIUkVFLlNwcml0ZShzcHJpdGVNYXRlcmlhbCk7XG4gICAgICBzcHJpdGUuc2NhbGUuc2V0KDMwLCAzMCwgMSk7XG4gICAgICBzcHJpdGUucG9zaXRpb24uY29weShzdGFyLnBvc2l0aW9uKTtcbiAgICAgIHN0YXIuYWRkKHNwcml0ZSk7XG4gICAgICAvLyBBZGQgZHluYW1pYyBzcGFyayBidXJzdCBhdCB0aGUgaGVhZFxuICAgICAgY29uc3Qgc3BhcmtDb3VudCA9IDE4ICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKjgpO1xuICAgICAgY29uc3Qgc3BhcmtHcm91cCA9IG5ldyBUSFJFRS5Hcm91cCgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGFya0NvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3Qgc3BhcmtNYXQgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoeyBjb2xvcjogdmlicmFudENvbG9yc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqdmlicmFudENvbG9ycy5sZW5ndGgpXSwgdHJhbnNwYXJlbnQ6IHRydWUsIG9wYWNpdHk6IDAuOCB9KTtcbiAgICAgICAgY29uc3Qgc3BhcmtHZW8gPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoMC4wNyArIE1hdGgucmFuZG9tKCkqMC4wNiwgOCwgOCk7XG4gICAgICAgIGNvbnN0IHNwYXJrID0gbmV3IFRIUkVFLk1lc2goc3BhcmtHZW8sIHNwYXJrTWF0KTtcbiAgICAgICAgY29uc3QgYW5nbGUgPSAoaSAvIHNwYXJrQ291bnQpICogTWF0aC5QSSAqIDI7XG4gICAgICAgIHNwYXJrLnBvc2l0aW9uLnNldChNYXRoLmNvcyhhbmdsZSkqMS4yLCBNYXRoLnNpbihhbmdsZSkqMS4yLCBNYXRoLnJhbmRvbSgpKjAuNC0wLjIpO1xuICAgICAgICBzcGFya0dyb3VwLmFkZChzcGFyayk7XG4gICAgICB9XG4gICAgICBzcGFya0dyb3VwLm5hbWUgPSAnc3BhcmtCdXJzdCc7XG4gICAgICBzdGFyLmFkZChzcGFya0dyb3VwKTtcbiAgICAgIHN0YXIucG9zaXRpb24uY29weShzcGF3blBvcyk7XG4gICAgICBzdGFyLnZlbG9jaXR5ID0gdmVsb2NpdHk7XG4gICAgICBzdGFyLm5vcm1hbGl6ZWRMaWZlID0gMC4wO1xuICAgICAgc3Rhci5ub3JtYWxpemVkTGlmZXRpbWUgPSA4MCArIE1hdGgucmFuZG9tKCkgKiA4MDsgLy8gTG9uZ2VyLCBtb3JlIGRyYW1hdGljXG4gICAgICBzdGFyLmFnZSA9IDA7XG4gICAgICAvLyAtLS0gU3R1bm5pbmcgTWV0ZW9yIFRhaWwgKHZlcnkgbG9uZywgbXVsdGktY29sb3IsIGdsb3dpbmcsIGZhZGluZywgYW5kIDNEIGN1cnZlKSAtLS1cbiAgICAgIGNvbnN0IHRyYWlsU2VnbWVudHMgPSB0YWlsTGVuZ3RoICogMzsgLy8gRXZlbiBsb25nZXIgdGFpbFxuICAgICAgY29uc3QgdHJhaWxQb2ludHMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhaWxTZWdtZW50czsgaSsrKSB7XG4gICAgICAgIC8vIEFkZCBhIDNEIHNwaXJhbC9jdXJ2ZSBmb3IgbW9yZSBkZXB0aFxuICAgICAgICBjb25zdCBzcGlyYWwgPSBNYXRoLnNpbihpICogMC4yNSkgKiA4O1xuICAgICAgICBjb25zdCBjdXJ2ZSA9IE1hdGguY29zKGkgKiAwLjE1KSAqIDQ7XG4gICAgICAgIGNvbnN0IHB0ID0gc3Rhci5wb3NpdGlvbi5jbG9uZSgpLmFkZChuZXcgVEhSRUUuVmVjdG9yMyhzcGlyYWwsIGN1cnZlLCAtaSAqIDMpKTtcbiAgICAgICAgdHJhaWxQb2ludHMucHVzaChwdCk7XG4gICAgICB9XG4gICAgICBjb25zdCB0YWlsR2VvID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCkuc2V0RnJvbVBvaW50cyh0cmFpbFBvaW50cyk7XG4gICAgICAvLyBQZXItdmVydGV4IGNvbG9yIChtdWx0aS1jb2xvciByYWluYm93IGdyYWRpZW50KVxuICAgICAgY29uc3QgdGFpbENvbG9ycyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFpbFNlZ21lbnRzOyBpKyspIHtcbiAgICAgICAgLy8gQWxwaGEgZmFkZXMgb3V0IGFsb25nIHRoZSB0YWlsXG4gICAgICAgIGNvbnN0IGFscGhhID0gKDEgLSBpIC8gKHRyYWlsU2VnbWVudHMgLSAxKSkgKiAwLjk5O1xuICAgICAgICAvLyBSYWluYm93IGdyYWRpZW50XG4gICAgICAgIGNvbnN0IHJhaW5ib3cgPSBbMHhmZmUwNjYsIDB4ZmY2NmNjLCAweDY2Y2NmZiwgMHhmZmZmZmYsIDB4ODBmZmVhLCAweGZmZjJjYywgMHhmZmMwODAsIDB4ODBjMGZmLCAweGZmODBiM107XG4gICAgICAgIGNvbnN0IGdyYWRDb2xvciA9IHJhaW5ib3dbTWF0aC5mbG9vcigoaSAvIHRyYWlsU2VnbWVudHMpICogcmFpbmJvdy5sZW5ndGgpXTtcbiAgICAgICAgdGFpbENvbG9ycy5wdXNoKChncmFkQ29sb3IgPj4gMTYgJiAyNTUpIC8gMjU1LCAoZ3JhZENvbG9yID4+IDggJiAyNTUpIC8gMjU1LCAoZ3JhZENvbG9yICYgMjU1KSAvIDI1NSwgYWxwaGEpO1xuICAgICAgfVxuICAgICAgdGFpbEdlby5zZXRBdHRyaWJ1dGUoJ2NvbG9yJywgbmV3IFRIUkVFLkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodGFpbENvbG9ycywgNCkpO1xuICAgICAgLy8gQWRkaXRpdmUgYmxlbmRpbmcgZm9yIGdsb3dcbiAgICAgIGNvbnN0IHRhaWxNYXQgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoeyB2ZXJ0ZXhDb2xvcnM6IHRydWUsIHRyYW5zcGFyZW50OiB0cnVlLCBvcGFjaXR5OiAxLjAsIGJsZW5kaW5nOiBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nIH0pO1xuICAgICAgY29uc3QgdGFpbCA9IG5ldyBUSFJFRS5MaW5lKHRhaWxHZW8sIHRhaWxNYXQpO1xuICAgICAgdGFpbC5wb3NpdGlvbi5jb3B5KHN0YXIucG9zaXRpb24pO1xuICAgICAgLy8gQWRkIHRvIHNjZW5lXG4gICAgICBzY2VuZS5hZGQoc3Rhcik7XG4gICAgICBzY2VuZS5hZGQodGFpbCk7XG4gICAgICBzaG9vdGluZ1N0YXJzLnB1c2goeyBtZXNoOiBzdGFyLCB0YWlsLCB2ZWxvY2l0eTogc3Rhci52ZWxvY2l0eSwgZGlyLCBhZ2U6IDAsIG5vcm1hbGl6ZWRMaWZldGltZTogc3Rhci5ub3JtYWxpemVkTGlmZXRpbWUsIHRyYWlsUG9pbnRzLCBjb2xvciwgYnJpZ2h0bmVzcywgaGFzRnJhZ21lbnRlZDogZmFsc2UgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgYW5pbWF0ZSA9ICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG4gICAgICAvLyBPY2Nhc2lvbmFsbHkgc3Bhd24gYSBuZWJ1bGEgY2xvdWRcbiAgICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgMC4wMDIgJiYgbmVidWxhQ2xvdWRzLmxlbmd0aCA8IDYpIHtcbiAgICAgICAgc3Bhd25OZWJ1bGFDbG91ZCgpO1xuICAgICAgfVxuICAgICAgLy8gQW5pbWF0ZSBuZWJ1bGEgY2xvdWRzXG4gICAgICBmb3IgKGxldCBpID0gbmVidWxhQ2xvdWRzLmxlbmd0aC0xOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBjbG91ZCA9IG5lYnVsYUNsb3Vkc1tpXTtcbiAgICAgICAgY2xvdWQuYWdlKys7XG4gICAgICAgIC8vIEZhZGUgaW5cbiAgICAgICAgaWYgKGNsb3VkLmZhZGVJbiAmJiBjbG91ZC5zcHJpdGUubWF0ZXJpYWwub3BhY2l0eSA8IDAuNTUpIHtcbiAgICAgICAgICBjbG91ZC5zcHJpdGUubWF0ZXJpYWwub3BhY2l0eSArPSAwLjAwOTtcbiAgICAgICAgICBpZiAoY2xvdWQuc3ByaXRlLm1hdGVyaWFsLm9wYWNpdHkgPj0gMC41NSkgY2xvdWQuZmFkZUluID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmFkZSBvdXRcbiAgICAgICAgaWYgKGNsb3VkLmFnZSA+IGNsb3VkLmxpZmV0aW1lICogMC43KSB7XG4gICAgICAgICAgY2xvdWQuZmFkZU91dCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsb3VkLmZhZGVPdXQpIHtcbiAgICAgICAgICBjbG91ZC5zcHJpdGUubWF0ZXJpYWwub3BhY2l0eSAtPSAwLjAwNjtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgd2hlbiBmdWxseSBmYWRlZFxuICAgICAgICBpZiAoY2xvdWQuc3ByaXRlLm1hdGVyaWFsLm9wYWNpdHkgPD0gMCkge1xuICAgICAgICAgIHNjZW5lLnJlbW92ZShjbG91ZC5zcHJpdGUpO1xuICAgICAgICAgIG5lYnVsYUNsb3Vkcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2xvdyBkcmlmdCBhbmQgcm90YXRpb25cbiAgICAgICAgY2xvdWQuc3ByaXRlLnBvc2l0aW9uLnggKz0gTWF0aC5zaW4oY2xvdWQuYWdlKjAuMDAxICsgaSkgKiAwLjA5O1xuICAgICAgICBjbG91ZC5zcHJpdGUucG9zaXRpb24ueSArPSBNYXRoLmNvcyhjbG91ZC5hZ2UqMC4wMDEyIC0gaSkgKiAwLjA3O1xuICAgICAgICBjbG91ZC5zcHJpdGUubWF0ZXJpYWwucm90YXRpb24gKz0gY2xvdWQucm90U3BlZWQ7XG4gICAgICAgIC8vIEFuaW1hdGUgY29sb3IgZ2VudGx5XG4gICAgICAgIGNsb3VkLnNwcml0ZS5tYXRlcmlhbC5jb2xvci5vZmZzZXRIU0woMC4wMDA3Kk1hdGguc2luKGNsb3VkLmFnZSowLjAwMDcraSksIDAsIDApO1xuICAgICAgfVxuICAgICAgY2FtZXJhLnJvdGF0aW9uLnkgKz0gKHRhcmdldFkgLSBjYW1lcmEucm90YXRpb24ueSkgKiBkYW1waW5nO1xuICAgICAgLy8gTW92ZSB0aGUgdmlydHVhbCBjYW1lcmEgcG9zaXRpb24gaW4gdGhlIGRpcmVjdGlvbiB0aGUgY2FtZXJhIGlzIGZhY2luZ1xuICAgICAgY29uc3QgZm9yd2FyZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICBjYW1lcmEuZ2V0V29ybGREaXJlY3Rpb24oZm9yd2FyZCk7XG4gICAgICB2aXJ0dWFsQ2FtZXJhUG9zLmFkZChmb3J3YXJkLm11bHRpcGx5U2NhbGFyKHN0YXJTcGVlZCkpO1xuICAgICAgLy8gT2Zmc2V0IGFsbCBzdGFycyBieSAtdmlydHVhbENhbWVyYVBvcyAoZmxvYXRpbmcgb3JpZ2luKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3NpdGlvbnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheVtpXSA9IHBvc2l0aW9uc1tpXSAtIHZpcnR1YWxDYW1lcmFQb3MueDtcbiAgICAgICAgZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheVtpKzFdID0gcG9zaXRpb25zW2krMV0gLSB2aXJ0dWFsQ2FtZXJhUG9zLnk7XG4gICAgICAgIGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXlbaSsyXSA9IHBvc2l0aW9uc1tpKzJdIC0gdmlydHVhbENhbWVyYVBvcy56O1xuICAgICAgfVxuICAgICAgZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAgIC8vIC0tLSBTaG9vdGluZyBzdGFyIHNwYXduaW5nIC0tLVxuICAgICAgLy8gREVWOiBNYWtlIHNob290aW5nIHN0YXJzIHN1cGVyIGNvbW1vbiAoc3Bhd24gZXZlcnkgZnJhbWUgaWYgY29vbGRvd24gYWxsb3dzKVxuICAgICAgaWYgKHNob290aW5nU3RhckNvb2xkb3duIDw9IDAgJiYgTWF0aC5yYW5kb20oKSA8IDAuMSkgeyAvLyBTaG9vdGluZyBTdGFyIFNwYXduIFJhdGUgKHRocm90dGxlZClcbiAgICAgICAgc3Bhd25TaG9vdGluZ1N0YXIoKTtcbiAgICAgICAgLy8gU3VidGxlIGNhbWVyYSBzaGFrZSB3aGVuIGEgc2hvb3Rpbmcgc3RhciBhcHBlYXJzXG4gICAgICAgIGlmIChjYW1lcmEpIHtcbiAgICAgICAgICBjb25zdCBzaGFrZVN0cmVuZ3RoID0gMC4wNiArIE1hdGgucmFuZG9tKCkqMC4wNDtcbiAgICAgICAgICBjYW1lcmEucG9zaXRpb24ueCArPSAoTWF0aC5yYW5kb20oKS0wLjUpKnNoYWtlU3RyZW5ndGg7XG4gICAgICAgICAgY2FtZXJhLnBvc2l0aW9uLnkgKz0gKE1hdGgucmFuZG9tKCktMC41KSpzaGFrZVN0cmVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHNob290aW5nU3RhckNvb2xkb3duID0gMTAgKyBNYXRoLnJhbmRvbSgpICogMTA7IC8vIExvbmdlciBjb29sZG93biBmb3IgcGVyZlxuICAgICAgfSBlbHNlIGlmIChzaG9vdGluZ1N0YXJDb29sZG93biA+IDApIHtcbiAgICAgICAgc2hvb3RpbmdTdGFyQ29vbGRvd24tLTtcbiAgICAgIH1cbiAgICAgIC8vIEFuaW1hdGUgYW5kIGNsZWFuIHVwIHNob290aW5nIHN0YXJzXG4gICAgICBmb3IgKGxldCBpID0gc2hvb3RpbmdTdGFycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBvYmogPSBzaG9vdGluZ1N0YXJzW2ldO1xuICAgICAgICAvLyBBbmltYXRlIHNwYXJrIGJ1cnN0IChmYWRlIGFuZCBleHBhbmQpXG4gICAgICAgIGlmIChvYmoubWVzaC5jaGlsZHJlbikge1xuICAgICAgICAgIGNvbnN0IHNwYXJrcyA9IG9iai5tZXNoLmNoaWxkcmVuLmZpbmQoY2hpbGQgPT4gY2hpbGQubmFtZSA9PT0gJ3NwYXJrQnVyc3QnKTtcbiAgICAgICAgICBpZiAoc3BhcmtzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNwYXJrcy5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICBjb25zdCBzcGFyayA9IHNwYXJrcy5jaGlsZHJlbltqXTtcbiAgICAgICAgICAgICAgc3BhcmsubWF0ZXJpYWwub3BhY2l0eSAqPSAwLjk2OyAvLyBGYWRlXG4gICAgICAgICAgICAgIHNwYXJrLnNjYWxlLm11bHRpcGx5U2NhbGFyKDEuMDMpOyAvLyBFeHBhbmRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQW5pbWF0ZSB0YWlsIHNoaW1tZXIgYW5kIGNvbG9yIGN5Y2xpbmdcbiAgICAgICAgaWYgKG9iai50YWlsICYmIG9iai50cmFpbFBvaW50cykge1xuICAgICAgICAgIGNvbnN0IHRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAqIDAuMDAxO1xuICAgICAgICAgIGNvbnN0IHRhaWxHZW8gPSBvYmoudGFpbC5nZW9tZXRyeTtcbiAgICAgICAgICBjb25zdCB0YWlsQ29sb3JzID0gdGFpbEdlby5nZXRBdHRyaWJ1dGUoJ2NvbG9yJyk7XG4gICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCB0YWlsQ29sb3JzLmNvdW50OyBrKyspIHtcbiAgICAgICAgICAgIC8vIEN5Y2xlIGh1ZVxuICAgICAgICAgICAgbGV0IHIgPSB0YWlsQ29sb3JzLmdldFgoayksIGcgPSB0YWlsQ29sb3JzLmdldFkoayksIGIgPSB0YWlsQ29sb3JzLmdldFooayk7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRvIEhTTFxuICAgICAgICAgICAgY29uc3QgbWF4ID0gTWF0aC5tYXgocixnLGIpLCBtaW4gPSBNYXRoLm1pbihyLGcsYik7XG4gICAgICAgICAgICBsZXQgaCxzLGw7XG4gICAgICAgICAgICBsID0gKG1heCttaW4pLzI7XG4gICAgICAgICAgICBpZiAobWF4ID09PSBtaW4pIHtoID0gcyA9IDA7fSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3QgZCA9IG1heC1taW47XG4gICAgICAgICAgICAgIHMgPSBsID4gMC41ID8gZC8oMi1tYXgtbWluKSA6IGQvKG1heCttaW4pO1xuICAgICAgICAgICAgICBzd2l0Y2gobWF4KXtcbiAgICAgICAgICAgICAgICBjYXNlIHI6IGggPSAoZy1iKS9kICsgKGc8Yj82OjApOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIGc6IGggPSAoYi1yKS9kICsgMjsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBiOiBoID0gKHItZykvZCArIDQ7IGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGgvPTY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoID0gKGggKyAwLjI1Kk1hdGguc2luKHRpbWUgKyBrKjAuMikpICUgMS4wOyAvLyBBbmltYXRlIGh1ZVxuICAgICAgICAgICAgLy8gQ29udmVydCBiYWNrIHRvIFJHQlxuICAgICAgICAgICAgbGV0IHEgPSBsIDwgMC41ID8gbCooMStzKSA6IGwrcy1sKnM7XG4gICAgICAgICAgICBsZXQgcCA9IDIqbC1xO1xuICAgICAgICAgICAgbGV0IHRyID0gaCsxLzMsIHRnID0gaCwgdGIgPSBoLTEvMztcbiAgICAgICAgICAgIGNvbnN0IGh1ZTJyZ2IgPSAocCxxLHQpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHQ8MCkgdCs9MTsgaWYgKHQ+MSkgdC09MTtcbiAgICAgICAgICAgICAgaWYgKHQ8MS82KSByZXR1cm4gcCsocS1wKSo2KnQ7XG4gICAgICAgICAgICAgIGlmICh0PDEvMikgcmV0dXJuIHE7XG4gICAgICAgICAgICAgIGlmICh0PDIvMykgcmV0dXJuIHArKHEtcCkqKDIvMy10KSo2O1xuICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0YWlsQ29sb3JzLnNldFgoaywgaHVlMnJnYihwLHEsdHIpKTtcbiAgICAgICAgICAgIHRhaWxDb2xvcnMuc2V0WShrLCBodWUycmdiKHAscSx0ZykpO1xuICAgICAgICAgICAgdGFpbENvbG9ycy5zZXRaKGssIGh1ZTJyZ2IocCxxLHRiKSk7XG4gICAgICAgICAgICAvLyBTaGltbWVyOiBtb2R1bGF0ZSBhbHBoYVxuICAgICAgICAgICAgdGFpbENvbG9ycy5zZXRXKGssIHRhaWxDb2xvcnMuZ2V0VyhrKSAqICgwLjk3ICsgMC4wMypNYXRoLnNpbih0aW1lKjggKyBrKSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0YWlsQ29sb3JzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdHJhaWdodC1saW5lIHRyYWplY3RvcnlcbiAgICAgICAgb2JqLm1lc2gucG9zaXRpb24uYWRkKG9iai52ZWxvY2l0eSk7XG4gICAgICAgIG9iai50YWlsLnBvc2l0aW9uLmNvcHkob2JqLm1lc2gucG9zaXRpb24pO1xuICAgICAgICAvLyBBbmltYXRlIHRhaWwgKG5vIGxlcnAsIGp1c3QgZHJhZylcbiAgICAgICAgb2JqLmFnZSsrO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkTGlmZSA9IG9iai5hZ2UgLyBvYmoubm9ybWFsaXplZExpZmV0aW1lO1xuICAgICAgICBvYmoudHJhaWxQb2ludHMudW5zaGlmdChvYmoubWVzaC5wb3NpdGlvbi5jbG9uZSgpKTtcbiAgICAgICAgaWYgKG9iai50cmFpbFBvaW50cy5sZW5ndGggPiB0YWlsTGVuZ3RoICogMykgb2JqLnRyYWlsUG9pbnRzLnBvcCgpO1xuICAgICAgICBsZXQgdGFpbEdyb3cgPSBNYXRoLm1pbigxLCBub3JtYWxpemVkTGlmZSAvIDAuMyk7XG4gICAgICAgIGxldCBhY3RpdmVTZWdtZW50cyA9IE1hdGguZmxvb3Iob2JqLnRyYWlsUG9pbnRzLmxlbmd0aCAqIHRhaWxHcm93KTtcbiAgICAgICAgaWYgKGFjdGl2ZVNlZ21lbnRzIDwgMikgYWN0aXZlU2VnbWVudHMgPSAyO1xuICAgICAgICBjb25zdCB2aXNpYmxlVHJhaWwgPSBvYmoudHJhaWxQb2ludHMuc2xpY2UoMCwgYWN0aXZlU2VnbWVudHMpO1xuICAgICAgICBvYmoudGFpbC5nZW9tZXRyeS5zZXRGcm9tUG9pbnRzKHZpc2libGVUcmFpbCk7XG4gICAgICAgIGNvbnN0IHRhaWxDb2xvcnMgPSBvYmoudGFpbC5nZW9tZXRyeS5nZXRBdHRyaWJ1dGUoJ2NvbG9yJyk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmlzaWJsZVRyYWlsLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgbGV0IGFscGhhID0gKDEgLSBqIC8gKHZpc2libGVUcmFpbC5sZW5ndGggLSAxKSkgKiAwLjk1O1xuICAgICAgICAgIGFscGhhICo9IDAuOTIgKyAwLjA4ICogTWF0aC5zaW4oRGF0ZS5ub3coKSowLjAxNSArIGoqMC41KTtcbiAgICAgICAgICBsZXQgcmFpbmJvdyA9IFsweGZmYzA4MCwgMHhmZmUwODAsIDB4ZmZmZjgwLCAweDgwZmZlNiwgMHg4MGMwZmYsIDB4YzA4MGZmXTtcbiAgICAgICAgICBsZXQgZ3JhZENvbG9yID0gcmFpbmJvd1tqICUgcmFpbmJvdy5sZW5ndGhdO1xuICAgICAgICAgIGlmIChub3JtYWxpemVkTGlmZSA+IDAuNykgYWxwaGEgKj0gTWF0aC5tYXgoMCwgMSAtIChub3JtYWxpemVkTGlmZSAtIDAuNyAtIDAuMikgLyAwLjMpO1xuICAgICAgICAgIHRhaWxDb2xvcnMuc2V0WFlaVyhqLCAoZ3JhZENvbG9yID4+IDE2ICYgMjU1KSAvIDI1NSwgKGdyYWRDb2xvciA+PiA4ICYgMjU1KSAvIDI1NSwgKGdyYWRDb2xvciAmIDI1NSkgLyAyNTUsIGFscGhhKTtcbiAgICAgICAgfVxuICAgICAgICB0YWlsQ29sb3JzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgLy8gQW5pbWF0ZSBoZWFkXG4gICAgICAgIGxldCBoZWFkQ29sb3I7XG4gICAgICAgIGlmIChub3JtYWxpemVkTGlmZSA8IDAuNSkge1xuICAgICAgICAgIGhlYWRDb2xvciA9IG5ldyBUSFJFRS5Db2xvcihvYmouY29sb3IpLmxlcnAobmV3IFRIUkVFLkNvbG9yKDB4ZmZjMDgwKSwgbm9ybWFsaXplZExpZmUqMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGVhZENvbG9yID0gbmV3IFRIUkVFLkNvbG9yKDB4ZmZjMDgwKS5sZXJwKG5ldyBUSFJFRS5Db2xvcigweGZmNDAwMCksIChub3JtYWxpemVkTGlmZS0wLjUpKjIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmbGlja2VyID0gMC45NSArIDAuMTMgKiBNYXRoLnNpbihEYXRlLm5vdygpKjAuMDcgKyBNYXRoLnJhbmRvbSgpKjEwKTtcbiAgICAgICAgaGVhZENvbG9yLm11bHRpcGx5U2NhbGFyKGZsaWNrZXIpO1xuICAgICAgICBvYmoubWVzaC5tYXRlcmlhbC5jb2xvci5jb3B5KGhlYWRDb2xvcik7XG4gICAgICAgIGxldCBzY2FsZSA9IDEgKyAyLjIgKiBNYXRoLnNpbihNYXRoLlBJICogbm9ybWFsaXplZExpZmUpO1xuICAgICAgICBsZXQgZGlzdFRvQ2FtID0gb2JqLm1lc2gucG9zaXRpb24ubGVuZ3RoKCk7XG4gICAgICAgIGxldCBkb2ZCbHVyID0gZGlzdFRvQ2FtIDwgc3Rhck1heERpc3RhbmNlICogMC43ID8gMC43IDogMS4wO1xuICAgICAgICBvYmoubWVzaC5zY2FsZS5zZXQoc2NhbGUgKiBkb2ZCbHVyLCBzY2FsZSAqIGRvZkJsdXIsIHNjYWxlICogZG9mQmx1cik7XG4gICAgICAgIC8vIFNwYXJrbGUgYnVyc3RcbiAgICAgICAgaWYgKG5vcm1hbGl6ZWRMaWZlID49IDEgJiYgIW9iai5oYXNGcmFnbWVudGVkKSB7XG4gICAgICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCA5OyBzKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNwYXJrbGVHZW8gPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoMC43ICsgTWF0aC5yYW5kb20oKSowLjgsIDgsIDgpO1xuICAgICAgICAgICAgY29uc3Qgc3BhcmtsZU1hdCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7IGNvbG9yOiAweGZmZmZmZiwgdHJhbnNwYXJlbnQ6IHRydWUsIG9wYWNpdHk6IDAuNywgYmxlbmRpbmc6IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmcgfSk7XG4gICAgICAgICAgICBjb25zdCBzcGFya2xlID0gbmV3IFRIUkVFLk1lc2goc3BhcmtsZUdlbywgc3BhcmtsZU1hdCk7XG4gICAgICAgICAgICBzcGFya2xlLnBvc2l0aW9uLmNvcHkob2JqLm1lc2gucG9zaXRpb24pO1xuICAgICAgICAgICAgY29uc3Qgc3BhcmtsZVZlbCA9IG5ldyBUSFJFRS5WZWN0b3IzKE1hdGgucmFuZG9tKCktMC41LCBNYXRoLnJhbmRvbSgpLTAuNSwgTWF0aC5yYW5kb20oKS0wLjUpLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKDIrTWF0aC5yYW5kb20oKSoyKTtcbiAgICAgICAgICAgIHNwYXJrbGUudXNlckRhdGEgPSB7IHZlbG9jaXR5OiBzcGFya2xlVmVsLCBhZ2U6IDAgfTtcbiAgICAgICAgICAgIHNjZW5lLmFkZChzcGFya2xlKTtcbiAgICAgICAgICAgIGlmICghd2luZG93Ll9zcGFya2xlcykgd2luZG93Ll9zcGFya2xlcyA9IFtdO1xuICAgICAgICAgICAgd2luZG93Ll9zcGFya2xlcy5wdXNoKHNwYXJrbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBmcmFnVmVsID0gb2JqLnZlbG9jaXR5LmNsb25lKCkuYXBwbHlBeGlzQW5nbGUobmV3IFRIUkVFLlZlY3RvcjMoMCwxLDApLCAoTWF0aC5yYW5kb20oKS0wLjUpKjAuMyk7XG4gICAgICAgICAgY29uc3QgZnJhZ1N0YXIgPSBvYmoubWVzaC5jbG9uZSgpO1xuICAgICAgICAgIGZyYWdTdGFyLnBvc2l0aW9uLmNvcHkob2JqLm1lc2gucG9zaXRpb24pO1xuICAgICAgICAgIGZyYWdTdGFyLnZlbG9jaXR5ID0gZnJhZ1ZlbDtcbiAgICAgICAgICBmcmFnU3Rhci5ub3JtYWxpemVkTGlmZSA9IG5vcm1hbGl6ZWRMaWZlO1xuICAgICAgICAgIGZyYWdTdGFyLm5vcm1hbGl6ZWRMaWZldGltZSA9IG9iai5ub3JtYWxpemVkTGlmZXRpbWUgKiAoMC41ICsgTWF0aC5yYW5kb20oKSowLjUpO1xuICAgICAgICAgIGZyYWdTdGFyLmFnZSA9IG9iai5hZ2U7XG4gICAgICAgICAgZnJhZ1N0YXIubWF0ZXJpYWwgPSBvYmoubWVzaC5tYXRlcmlhbC5jbG9uZSgpO1xuICAgICAgICAgIGNvbnN0IGZyYWdUcmFpbFBvaW50cyA9IG9iai50cmFpbFBvaW50cy5zbGljZSgpO1xuICAgICAgICAgIGNvbnN0IGZyYWdUYWlsR2VvID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCkuc2V0RnJvbVBvaW50cyhmcmFnVHJhaWxQb2ludHMpO1xuICAgICAgICAgIGZyYWdUYWlsR2VvLnNldEF0dHJpYnV0ZSgnY29sb3InLCBvYmoudGFpbC5nZW9tZXRyeS5nZXRBdHRyaWJ1dGUoJ2NvbG9yJykuY2xvbmUoKSk7XG4gICAgICAgICAgY29uc3QgZnJhZ1RhaWxNYXQgPSBvYmoudGFpbC5tYXRlcmlhbC5jbG9uZSgpO1xuICAgICAgICAgIGNvbnN0IGZyYWdUYWlsID0gbmV3IFRIUkVFLkxpbmUoZnJhZ1RhaWxHZW8sIGZyYWdUYWlsTWF0KTtcbiAgICAgICAgICBmcmFnVGFpbC5wb3NpdGlvbi5jb3B5KGZyYWdTdGFyLnBvc2l0aW9uKTtcbiAgICAgICAgICBzY2VuZS5hZGQoZnJhZ1N0YXIpO1xuICAgICAgICAgIHNjZW5lLmFkZChmcmFnVGFpbCk7XG4gICAgICAgICAgc2hvb3RpbmdTdGFycy5wdXNoKHsgbWVzaDogZnJhZ1N0YXIsIHRhaWw6IGZyYWdUYWlsLCB2ZWxvY2l0eTogZnJhZ1N0YXIudmVsb2NpdHksIGRpcjogb2JqLmRpciwgYWdlOiBmcmFnU3Rhci5hZ2UsIG5vcm1hbGl6ZWRMaWZldGltZTogZnJhZ1N0YXIubm9ybWFsaXplZExpZmV0aW1lLCB0cmFpbFBvaW50czogZnJhZ1RyYWlsUG9pbnRzLCBjb2xvcjogb2JqLmNvbG9yLCBicmlnaHRuZXNzOiBvYmouYnJpZ2h0bmVzcywgaGFzRnJhZ21lbnRlZDogdHJ1ZSB9KTtcbiAgICAgICAgICBvYmouaGFzRnJhZ21lbnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3BhcmsgYnVyc3RcbiAgICAgICAgaWYgKCFvYmouaGFzU3BhcmtlZCAmJiBub3JtYWxpemVkTGlmZSA+IDAuOTUgJiYgTWF0aC5yYW5kb20oKSA8IDAuMSkge1xuICAgICAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgOCArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSo4KTsgcysrKSB7XG4gICAgICAgICAgICBjb25zdCBzcGFya0dlbyA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeSgwLjUgKyBNYXRoLnJhbmRvbSgpKjAuNSwgOCwgOCk7XG4gICAgICAgICAgICBjb25zdCBzcGFya01hdCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7IGNvbG9yOiAweGZmZjZjMCwgdHJhbnNwYXJlbnQ6IHRydWUsIG9wYWNpdHk6IDEsIGJsZW5kaW5nOiBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nIH0pO1xuICAgICAgICAgICAgY29uc3Qgc3BhcmsgPSBuZXcgVEhSRUUuTWVzaChzcGFya0dlbywgc3BhcmtNYXQpO1xuICAgICAgICAgICAgc3BhcmsucG9zaXRpb24uY29weShvYmoubWVzaC5wb3NpdGlvbik7XG4gICAgICAgICAgICBzcGFyay5zcGFya1ZlbCA9IG5ldyBUSFJFRS5WZWN0b3IzKE1hdGgucmFuZG9tKCktMC41LCBNYXRoLnJhbmRvbSgpLTAuNSwgTWF0aC5yYW5kb20oKS0wLjUpLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKDAuNSArIE1hdGgucmFuZG9tKCkqMS4yKTtcbiAgICAgICAgICAgIHNwYXJrLnNwYXJrTGlmZSA9IDEyICsgTWF0aC5yYW5kb20oKSoxMDtcbiAgICAgICAgICAgIHNwYXJrLnNwYXJrQWdlID0gMDtcbiAgICAgICAgICAgIHNjZW5lLmFkZChzcGFyayk7XG4gICAgICAgICAgICBpZiAoIXdpbmRvdy5fc3RhclNwYXJrcykgd2luZG93Ll9zdGFyU3BhcmtzID0gW107XG4gICAgICAgICAgICB3aW5kb3cuX3N0YXJTcGFya3MucHVzaChzcGFyayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9iai5oYXNTcGFya2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGbGFzaFxuICAgICAgICBpZiAoIW9iai5oYXNGbGFzaGVkICYmIG5vcm1hbGl6ZWRMaWZlID4gMC45OCAmJiBNYXRoLnJhbmRvbSgpIDwgMC4yKSB7XG4gICAgICAgICAgY29uc3QgZmxhc2hHZW8gPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoMSwgMTYsIDE2KTtcbiAgICAgICAgICBjb25zdCBmbGFzaE1hdCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7IGNvbG9yOiAweGZmZmZlZSwgdHJhbnNwYXJlbnQ6IHRydWUsIG9wYWNpdHk6IDAuOCwgYmxlbmRpbmc6IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmcgfSk7XG4gICAgICAgICAgY29uc3QgZmxhc2ggPSBuZXcgVEhSRUUuTWVzaChmbGFzaEdlbywgZmxhc2hNYXQpO1xuICAgICAgICAgIGZsYXNoLnBvc2l0aW9uLmNvcHkob2JqLm1lc2gucG9zaXRpb24pO1xuICAgICAgICAgIHNjZW5lLmFkZChmbGFzaCk7XG4gICAgICAgICAgaWYgKCF3aW5kb3cuX3N0YXJGbGFzaGVzKSB3aW5kb3cuX3N0YXJGbGFzaGVzID0gW107XG4gICAgICAgICAgd2luZG93Ll9zdGFyRmxhc2hlcy5wdXNoKHsgbWVzaDogZmxhc2gsIGFnZTogMCB9KTtcbiAgICAgICAgICBvYmouaGFzRmxhc2hlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmFkZSBvdXQgYXMgaXQgZ2V0cyBmYXIgYXdheVxuICAgICAgICBjb25zdCBkaXN0ID0gb2JqLm1lc2gucG9zaXRpb24uZGlzdGFuY2VUbyhjYW1lcmEucG9zaXRpb24pO1xuICAgICAgICBjb25zdCBmYWRlU3RhcnQgPSBzdGFyTWF4RGlzdGFuY2UgKiAwLjU7XG4gICAgICAgIGlmIChkaXN0ID4gZmFkZVN0YXJ0KSB7XG4gICAgICAgICAgY29uc3QgZmFkZSA9IDEgLSAoZGlzdCAtIGZhZGVTdGFydCkgLyAoc3Rhck1heERpc3RhbmNlIC0gZmFkZVN0YXJ0KTtcbiAgICAgICAgICBvYmoubWVzaC5tYXRlcmlhbC5vcGFjaXR5ID0gTWF0aC5tYXgoMCwgZmFkZSk7XG4gICAgICAgICAgb2JqLm1lc2gubWF0ZXJpYWwudHJhbnNwYXJlbnQgPSB0cnVlO1xuICAgICAgICAgIG9iai50YWlsLm1hdGVyaWFsLm9wYWNpdHkgPSBNYXRoLm1heCgwLCBmYWRlICogMC44KTtcbiAgICAgICAgICBvYmoudGFpbC5tYXRlcmlhbC50cmFuc3BhcmVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHdoZW4gb3V0IG9mIGJvdW5kcyBvciBmdWxseSBmYWRlZCBvciBsaWZlIGVuZGVkXG4gICAgICAgIGlmIChub3JtYWxpemVkTGlmZSA+PSAxLjAgfHwgZGlzdCA+IHN0YXJNYXhEaXN0YW5jZSB8fCBvYmoubWVzaC5tYXRlcmlhbC5vcGFjaXR5IDw9IDAuMDEpIHtcbiAgICAgICAgICBzY2VuZS5yZW1vdmUob2JqLm1lc2gpO1xuICAgICAgICAgIHNjZW5lLnJlbW92ZShvYmoudGFpbCk7XG4gICAgICAgICAgc2hvb3RpbmdTdGFycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEFuaW1hdGUgc3BhcmtzXG4gICAgICBpZiAod2luZG93Ll9zdGFyU3BhcmtzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB3aW5kb3cuX3N0YXJTcGFya3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBjb25zdCBzcGFyayA9IHdpbmRvdy5fc3RhclNwYXJrc1tpXTtcbiAgICAgICAgICBzcGFyay5wb3NpdGlvbi5hZGQoc3Bhcmsuc3BhcmtWZWwpO1xuICAgICAgICAgIHNwYXJrLnNwYXJrQWdlKys7XG4gICAgICAgICAgc3BhcmsubWF0ZXJpYWwub3BhY2l0eSAqPSAwLjg1O1xuICAgICAgICAgIGlmIChzcGFyay5zcGFya0FnZSA+IHNwYXJrLnNwYXJrTGlmZSkge1xuICAgICAgICAgICAgc2NlbmUucmVtb3ZlKHNwYXJrKTtcbiAgICAgICAgICAgIHdpbmRvdy5fc3RhclNwYXJrcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBBbmltYXRlIGZsYXNoZXNcbiAgICAgIGlmICh3aW5kb3cuX3N0YXJGbGFzaGVzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB3aW5kb3cuX3N0YXJGbGFzaGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgY29uc3QgZmxhc2ggPSB3aW5kb3cuX3N0YXJGbGFzaGVzW2ldO1xuICAgICAgICAgIGZsYXNoLm1lc2guc2NhbGUubXVsdGlwbHlTY2FsYXIoMS4xNSk7XG4gICAgICAgICAgZmxhc2gubWVzaC5tYXRlcmlhbC5vcGFjaXR5ICo9IDAuODU7XG4gICAgICAgICAgZmxhc2guYWdlKys7XG4gICAgICAgICAgaWYgKGZsYXNoLmFnZSA+IDEwKSB7XG4gICAgICAgICAgICBzY2VuZS5yZW1vdmUoZmxhc2gubWVzaCk7XG4gICAgICAgICAgICB3aW5kb3cuX3N0YXJGbGFzaGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gLS0tIFN0YXJmaWVsZCBsb2dpYyAtLS1cbiAgICAgIGNvbnN0IHNxRGlzdCA9IHN0YXJNYXhEaXN0YW5jZSAqIHN0YXJNYXhEaXN0YW5jZTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIGNvbnN0IGR4ID0gcG9zaXRpb25zW2ldIC0gdmlydHVhbENhbWVyYVBvcy54O1xuICAgICAgICBjb25zdCBkeSA9IHBvc2l0aW9uc1tpICsgMV0gLSB2aXJ0dWFsQ2FtZXJhUG9zLnk7XG4gICAgICAgIGNvbnN0IGR6ID0gcG9zaXRpb25zW2kgKyAyXSAtIHZpcnR1YWxDYW1lcmFQb3MuejtcbiAgICAgICAgaWYgKGR4KmR4ICsgZHkqZHkgKyBkeipkeiA+IHNxRGlzdCkge1xuICAgICAgICAgIC8vIFBsYWNlIGluIGEgdGhpY2sgc3BoZXJpY2FsIHNoZWxsIGFyb3VuZCB0aGUgdmlydHVhbCBjYW1lcmEsIG5ldmVyIHRvbyBjbG9zZVxuICAgICAgICAgIGNvbnN0IG1pblJhZGl1cyA9IHN0YXJNYXhEaXN0YW5jZSAqIDAuODtcbiAgICAgICAgICBjb25zdCBtYXhSYWRpdXMgPSBzdGFyTWF4RGlzdGFuY2U7XG4gICAgICAgICAgY29uc3QgciA9IG1pblJhZGl1cyArIE1hdGgucmFuZG9tKCkgKiAobWF4UmFkaXVzIC0gbWluUmFkaXVzKTtcbiAgICAgICAgICBjb25zdCB0aGV0YSA9IE1hdGgucmFuZG9tKCkgKiAyICogTWF0aC5QSTtcbiAgICAgICAgICBjb25zdCBwaGkgPSBNYXRoLmFjb3MoMiAqIE1hdGgucmFuZG9tKCkgLSAxKTtcbiAgICAgICAgICBwb3NpdGlvbnNbaV0gPSB2aXJ0dWFsQ2FtZXJhUG9zLnggKyByICogTWF0aC5zaW4ocGhpKSAqIE1hdGguY29zKHRoZXRhKTtcbiAgICAgICAgICBwb3NpdGlvbnNbaSsxXSA9IHZpcnR1YWxDYW1lcmFQb3MueSArIHIgKiBNYXRoLnNpbihwaGkpICogTWF0aC5zaW4odGhldGEpO1xuICAgICAgICAgIHBvc2l0aW9uc1tpKzJdID0gdmlydHVhbENhbWVyYVBvcy56ICsgciAqIE1hdGguY29zKHBoaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlOyAvLyBBbHJlYWR5IHNldCBhYm92ZVxuXG4gICAgICAvLyBSb2J1c3Qgc3RhcmZpZWxkIGNvbG9yIHVwZGF0ZSB0byBwcmV2ZW50IHN0dWNrIHdoaXRlIGRvdHNcbiAgICAgIGNvbnN0IGNvbEFyciA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3IuYXJyYXk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc2l0aW9ucy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICBjb25zdCBpZHggPSBpIC8gMztcbiAgICAgICAgY29uc3QgZHggPSBwb3NpdGlvbnNbaV0gLSB2aXJ0dWFsQ2FtZXJhUG9zLng7XG4gICAgICAgIGNvbnN0IGR5ID0gcG9zaXRpb25zW2kgKyAxXSAtIHZpcnR1YWxDYW1lcmFQb3MueTtcbiAgICAgICAgY29uc3QgZHogPSBwb3NpdGlvbnNbaSArIDJdIC0gdmlydHVhbENhbWVyYVBvcy56O1xuICAgICAgICBjb25zdCBkaXN0ID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkeik7XG4gICAgICAgIGlmICh0aW1lcnNbaWR4XSA+IDApIHtcbiAgICAgICAgICB0aW1lcnNbaWR4XS0tO1xuICAgICAgICAgIGlmICh0aW1lcnNbaWR4XSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gVGltZXIgZXhwaXJlZCwgcmVzdG9yZSBjb2xvclxuICAgICAgICAgICAgc3BhcmtDb2xvcnNbaV0gPSBvcmlnaW5hbENvbG9yc1tpXTtcbiAgICAgICAgICAgIHNwYXJrQ29sb3JzW2krMV0gPSBvcmlnaW5hbENvbG9yc1tpKzFdO1xuICAgICAgICAgICAgc3BhcmtDb2xvcnNbaSsyXSA9IG9yaWdpbmFsQ29sb3JzW2krMl07XG4gICAgICAgICAgICBjb2xBcnJbaV0gPSBvcmlnaW5hbENvbG9yc1tpXTtcbiAgICAgICAgICAgIGNvbEFycltpKzFdID0gb3JpZ2luYWxDb2xvcnNbaSsxXTtcbiAgICAgICAgICAgIGNvbEFycltpKzJdID0gb3JpZ2luYWxDb2xvcnNbaSsyXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29sQXJyW2ldID0gc3BhcmtDb2xvcnNbaV07XG4gICAgICAgICAgICBjb2xBcnJbaSsxXSA9IHNwYXJrQ29sb3JzW2krMV07XG4gICAgICAgICAgICBjb2xBcnJbaSsyXSA9IHNwYXJrQ29sb3JzW2krMl07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRpc3QgPiBzdGFyTWF4RGlzdGFuY2UgKiAwLjMgJiYgTWF0aC5yYW5kb20oKSA8IDAuMDUpIHtcbiAgICAgICAgICB0aW1lcnNbaWR4XSA9IHNwYXJrbGVEdXJhdGlvbjtcbiAgICAgICAgICBjb25zdCBjID0gcGFsZXR0ZVtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBwYWxldHRlLmxlbmd0aCldO1xuICAgICAgICAgIHNwYXJrQ29sb3JzW2ldID0gY1swXTtcbiAgICAgICAgICBzcGFya0NvbG9yc1tpKzFdID0gY1sxXTtcbiAgICAgICAgICBzcGFya0NvbG9yc1tpKzJdID0gY1syXTtcbiAgICAgICAgICBjb2xBcnJbaV0gPSBzcGFya0NvbG9yc1tpXTtcbiAgICAgICAgICBjb2xBcnJbaSsxXSA9IHNwYXJrQ29sb3JzW2krMV07XG4gICAgICAgICAgY29sQXJyW2krMl0gPSBzcGFya0NvbG9yc1tpKzJdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNwYXJrQ29sb3JzW2ldID0gb3JpZ2luYWxDb2xvcnNbaV07XG4gICAgICAgICAgc3BhcmtDb2xvcnNbaSsxXSA9IG9yaWdpbmFsQ29sb3JzW2krMV07XG4gICAgICAgICAgc3BhcmtDb2xvcnNbaSsyXSA9IG9yaWdpbmFsQ29sb3JzW2krMl07XG4gICAgICAgICAgY29sQXJyW2ldID0gb3JpZ2luYWxDb2xvcnNbaV07XG4gICAgICAgICAgY29sQXJyW2krMV0gPSBvcmlnaW5hbENvbG9yc1tpKzFdO1xuICAgICAgICAgIGNvbEFycltpKzJdID0gb3JpZ2luYWxDb2xvcnNbaSsyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvci5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIHJlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FtZXJhKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBEZWZlbnNpdmU6IGxvZyBlcnJvciB3aXRoIGNvbnRleHRcbiAgICAgICAgY29uc29sZS5lcnJvcignU3RhcmZpZWxkIGFuaW1hdGlvbiBlcnJvcjonLCBlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBhbmltYXRlKCk7IC8vIFN0YXJ0IHRoZSByZW5kZXIgbG9vcFxuXG4gICAgY29uc3Qgb25SZXNpemUgPSAoKSA9PiB7XG4gICAgICBjYW1lcmEuYXNwZWN0ID0gd2luZG93LmlubmVyV2lkdGggLyB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICBjYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuICAgICAgcmVuZGVyZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvblJlc2l6ZSlcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25TY3JvbGwpXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25SZXNpemUpXG4gICAgICBtb3VudC5yZW1vdmVDaGlsZChyZW5kZXJlci5kb21FbGVtZW50KVxuICAgIH1cbiAgfSwgW10pXG5cbiAgcmV0dXJuIDxkaXYgcmVmPXttb3VudFJlZn0gLz5cbn1cblxuZXhwb3J0IGRlZmF1bHQgU3RhcmZpZWxkXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJUSFJFRSIsIlN0YXJmaWVsZCIsIm1vdW50UmVmIiwiY3VycmVudCIsIm1vdW50Iiwic3R5bGUiLCJwb3NpdGlvbiIsInRvcCIsImxlZnQiLCJ3aWR0aCIsImhlaWdodCIsInpJbmRleCIsInNjZW5lIiwiU2NlbmUiLCJjYW1lcmEiLCJQZXJzcGVjdGl2ZUNhbWVyYSIsIndpbmRvdyIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsInNldCIsInZpcnR1YWxDYW1lcmFQb3MiLCJWZWN0b3IzIiwicmVuZGVyZXIiLCJXZWJHTFJlbmRlcmVyIiwiYW50aWFsaWFzIiwic2V0UGl4ZWxSYXRpbyIsImRldmljZVBpeGVsUmF0aW8iLCJzZXRTaXplIiwic2V0Q2xlYXJDb2xvciIsImFwcGVuZENoaWxkIiwiZG9tRWxlbWVudCIsInN0YXJDb3VudCIsInN0YXJNYXhEaXN0YW5jZSIsInN0YXJTcGVlZCIsImdlb21ldHJ5IiwiQnVmZmVyR2VvbWV0cnkiLCJwb3NpdGlvbnMiLCJzdGFyc1BsYWNlZCIsIk1hdGgiLCJyYW5kb20iLCJjbHVzdGVyVGhldGEiLCJQSSIsImNsdXN0ZXJQaGkiLCJhY29zIiwiY2x1c3RlclIiLCJjbHVzdGVyQ2VudGVyIiwic2luIiwiY29zIiwiY2x1c3RlclNpemUiLCJmbG9vciIsImMiLCJvZmZzZXRUaGV0YSIsIm9mZnNldFBoaSIsIm9mZnNldFIiLCJwdXNoIiwidGhldGEiLCJwaGkiLCJyIiwic2V0QXR0cmlidXRlIiwiRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSIsInBhbGV0dGUiLCJjb2xvcnMiLCJpIiwibGVuZ3RoIiwib3JpZ2luYWxDb2xvcnMiLCJhdHRyaWJ1dGVzIiwiY29sb3IiLCJhcnJheSIsInNsaWNlIiwidGltZXJzIiwiRmxvYXQzMkFycmF5Iiwic3BhcmtDb2xvcnMiLCJzcGFya2xlRHVyYXRpb24iLCJtYXRlcmlhbCIsIlBvaW50c01hdGVyaWFsIiwic2l6ZSIsInNpemVBdHRlbnVhdGlvbiIsInZlcnRleENvbG9ycyIsInN0YXJzIiwiUG9pbnRzIiwiYWRkIiwidGFyZ2V0WSIsImRhbXBpbmciLCJvblNjcm9sbCIsInBjdCIsInNjcm9sbFkiLCJkb2N1bWVudCIsImJvZHkiLCJzY3JvbGxIZWlnaHQiLCJhZGRFdmVudExpc3RlbmVyIiwibmVidWxhVGV4dHVyZXMiLCJuZWJ1bGFDbG91ZHMiLCJzcGF3bk5lYnVsYUNsb3VkIiwidGV4dHVyZVVybCIsInRleCIsIlRleHR1cmVMb2FkZXIiLCJsb2FkIiwiQ29sb3IiLCJzZXRIU0wiLCJtYXQiLCJTcHJpdGVNYXRlcmlhbCIsIm1hcCIsInRyYW5zcGFyZW50Iiwib3BhY2l0eSIsImRlcHRoV3JpdGUiLCJibGVuZGluZyIsIkFkZGl0aXZlQmxlbmRpbmciLCJzcHJpdGUiLCJTcHJpdGUiLCJkaXIiLCJub3JtYWxpemUiLCJkaXN0IiwiY29weSIsIm11bHRpcGx5U2NhbGFyIiwic2NhbGUiLCJhZ2UiLCJmYWRlSW4iLCJmYWRlT3V0IiwibGlmZXRpbWUiLCJyb3RTcGVlZCIsInRhaWxMZW5ndGgiLCJzaG9vdGluZ1N0YXJzIiwic2hvb3RpbmdTdGFyQ29vbGRvd24iLCJzcGF3blNob290aW5nU3RhciIsIm1pbkRpc3QiLCJtYXhEaXN0Iiwic3Bhd25Qb3MiLCJjbG9uZSIsInRhbmdlbnQiLCJzdWIiLCJwcm9qZWN0T25WZWN0b3IiLCJ0YW5nZW50aWFsU3BlZWQiLCJyYWRpYWxTcGVlZCIsInZlbG9jaXR5IiwidmlicmFudENvbG9ycyIsImJyaWdodG5lc3MiLCJnZW8iLCJTcGhlcmVHZW9tZXRyeSIsIk1lc2hQaHlzaWNhbE1hdGVyaWFsIiwiZW1pc3NpdmUiLCJlbWlzc2l2ZUludGVuc2l0eSIsIm1ldGFsbmVzcyIsInJvdWdobmVzcyIsInRyYW5zbWlzc2lvbiIsImNsZWFyY29hdCIsImNsZWFyY29hdFJvdWdobmVzcyIsInN0YXIiLCJNZXNoIiwic3ByaXRlTWFwIiwic3ByaXRlTWF0ZXJpYWwiLCJzcGFya0NvdW50Iiwic3BhcmtHcm91cCIsIkdyb3VwIiwic3BhcmtNYXQiLCJNZXNoQmFzaWNNYXRlcmlhbCIsInNwYXJrR2VvIiwic3BhcmsiLCJhbmdsZSIsIm5hbWUiLCJub3JtYWxpemVkTGlmZSIsIm5vcm1hbGl6ZWRMaWZldGltZSIsInRyYWlsU2VnbWVudHMiLCJ0cmFpbFBvaW50cyIsInNwaXJhbCIsImN1cnZlIiwicHQiLCJ0YWlsR2VvIiwic2V0RnJvbVBvaW50cyIsInRhaWxDb2xvcnMiLCJhbHBoYSIsInJhaW5ib3ciLCJncmFkQ29sb3IiLCJ0YWlsTWF0IiwiTGluZUJhc2ljTWF0ZXJpYWwiLCJ0YWlsIiwiTGluZSIsIm1lc2giLCJoYXNGcmFnbWVudGVkIiwiYW5pbWF0ZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNsb3VkIiwicmVtb3ZlIiwic3BsaWNlIiwieCIsInkiLCJyb3RhdGlvbiIsIm9mZnNldEhTTCIsImZvcndhcmQiLCJnZXRXb3JsZERpcmVjdGlvbiIsInoiLCJuZWVkc1VwZGF0ZSIsInNoYWtlU3RyZW5ndGgiLCJvYmoiLCJjaGlsZHJlbiIsInNwYXJrcyIsImZpbmQiLCJjaGlsZCIsImoiLCJ0aW1lIiwicGVyZm9ybWFuY2UiLCJub3ciLCJnZXRBdHRyaWJ1dGUiLCJrIiwiY291bnQiLCJnZXRYIiwiZyIsImdldFkiLCJiIiwiZ2V0WiIsIm1heCIsIm1pbiIsImgiLCJzIiwibCIsImQiLCJxIiwicCIsInRyIiwidGciLCJ0YiIsImh1ZTJyZ2IiLCJ0Iiwic2V0WCIsInNldFkiLCJzZXRaIiwic2V0VyIsImdldFciLCJ1bnNoaWZ0IiwicG9wIiwidGFpbEdyb3ciLCJhY3RpdmVTZWdtZW50cyIsInZpc2libGVUcmFpbCIsIkRhdGUiLCJzZXRYWVpXIiwiaGVhZENvbG9yIiwibGVycCIsImZsaWNrZXIiLCJkaXN0VG9DYW0iLCJkb2ZCbHVyIiwic3BhcmtsZUdlbyIsInNwYXJrbGVNYXQiLCJzcGFya2xlIiwic3BhcmtsZVZlbCIsInVzZXJEYXRhIiwiX3NwYXJrbGVzIiwiZnJhZ1ZlbCIsImFwcGx5QXhpc0FuZ2xlIiwiZnJhZ1N0YXIiLCJmcmFnVHJhaWxQb2ludHMiLCJmcmFnVGFpbEdlbyIsImZyYWdUYWlsTWF0IiwiZnJhZ1RhaWwiLCJoYXNTcGFya2VkIiwic3BhcmtWZWwiLCJzcGFya0xpZmUiLCJzcGFya0FnZSIsIl9zdGFyU3BhcmtzIiwiaGFzRmxhc2hlZCIsImZsYXNoR2VvIiwiZmxhc2hNYXQiLCJmbGFzaCIsIl9zdGFyRmxhc2hlcyIsImRpc3RhbmNlVG8iLCJmYWRlU3RhcnQiLCJmYWRlIiwic3FEaXN0IiwiZHgiLCJkeSIsImR6IiwibWluUmFkaXVzIiwibWF4UmFkaXVzIiwiY29sQXJyIiwiaWR4Iiwic3FydCIsInJlbmRlciIsImVyciIsImNvbnNvbGUiLCJlcnJvciIsIm9uUmVzaXplIiwiYXNwZWN0IiwidXBkYXRlUHJvamVjdGlvbk1hdHJpeCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJyZW1vdmVDaGlsZCIsImRpdiIsInJlZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./components/Starfield.jsx\n"));

/***/ })

});