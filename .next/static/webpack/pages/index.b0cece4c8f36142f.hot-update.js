"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./components/Starfield.jsx":
/*!**********************************!*\
  !*** ./components/Starfield.jsx ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nvar _s = $RefreshSig$();\n\n\nconst Starfield = ()=>{\n    _s();\n    const mountRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // Defensive: always use .current for refs\n        if (!mountRef.current) return;\n        const mount = mountRef.current;\n        mount.style.position = \"fixed\";\n        mount.style.top = \"0\";\n        mount.style.left = \"0\";\n        mount.style.width = \"100%\";\n        mount.style.height = \"100%\";\n        mount.style.zIndex = \"0\";\n        // Scene & Renderer\n        const scene = new three__WEBPACK_IMPORTED_MODULE_2__.Scene();\n        const camera = new three__WEBPACK_IMPORTED_MODULE_2__.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);\n        camera.position.set(0, 0, 0);\n        // Virtual position to simulate infinite travel\n        let virtualCameraPos = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0, 0);\n        const renderer = new three__WEBPACK_IMPORTED_MODULE_2__.WebGLRenderer({\n            antialias: true\n        });\n        renderer.setPixelRatio(window.devicePixelRatio);\n        renderer.setSize(window.innerWidth, window.innerHeight);\n        renderer.setClearColor(0x000000, 1);\n        mount.appendChild(renderer.domElement);\n        // Starfield\n        const starCount = 3000;\n        const starMaxDistance = 2000;\n        const starSpeed = 1;\n        const geometry = new three__WEBPACK_IMPORTED_MODULE_2__.BufferGeometry();\n        const positions = [];\n        let starsPlaced = 0;\n        while(starsPlaced < starCount){\n            // With 1% chance, spawn a star cluster (10-30 stars)\n            if (Math.random() < 0.01 && starsPlaced < starCount - 10) {\n                const clusterTheta = Math.random() * 2 * Math.PI;\n                const clusterPhi = Math.acos(2 * Math.random() - 1);\n                const clusterR = Math.random() * starMaxDistance;\n                const clusterCenter = [\n                    clusterR * Math.sin(clusterPhi) * Math.cos(clusterTheta),\n                    clusterR * Math.sin(clusterPhi) * Math.sin(clusterTheta),\n                    clusterR * Math.cos(clusterPhi)\n                ];\n                const clusterSize = 10 + Math.floor(Math.random() * 20); // 10-30 stars\n                for(let c = 0; c < clusterSize && starsPlaced < starCount; c++){\n                    // Each star in cluster is within 30 units of center\n                    const offsetTheta = Math.random() * 2 * Math.PI;\n                    const offsetPhi = Math.acos(2 * Math.random() - 1);\n                    const offsetR = Math.random() * 30; // cluster radius\n                    positions.push(clusterCenter[0] + offsetR * Math.sin(offsetPhi) * Math.cos(offsetTheta), clusterCenter[1] + offsetR * Math.sin(offsetPhi) * Math.sin(offsetTheta), clusterCenter[2] + offsetR * Math.cos(offsetPhi));\n                    starsPlaced++;\n                }\n            } else {\n                // Normal single star\n                const theta = Math.random() * 2 * Math.PI;\n                const phi = Math.acos(2 * Math.random() - 1);\n                const r = Math.random() * starMaxDistance;\n                positions.push(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));\n                starsPlaced++;\n            }\n        }\n        geometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_2__.Float32BufferAttribute(positions, 3));\n        const palette = [\n            [\n                1.0,\n                0.5,\n                0.5\n            ],\n            [\n                1.0,\n                0.75,\n                0.4\n            ],\n            [\n                1.0,\n                1.0,\n                0.9\n            ],\n            [\n                1.0,\n                1.0,\n                1.0\n            ],\n            [\n                0.4,\n                0.5,\n                1.0\n            ]\n        ];\n        const colors = [];\n        for(let i = 0; i < starCount; i++){\n            const c = palette[Math.floor(Math.random() * palette.length)];\n            colors.push(...c);\n        }\n        geometry.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_2__.Float32BufferAttribute(colors, 3));\n        const originalColors = geometry.attributes.color.array.slice();\n        const timers = new Float32Array(starCount);\n        const sparkColors = new Float32Array(starCount * 3);\n        const sparkleDuration = 180;\n        const material = new three__WEBPACK_IMPORTED_MODULE_2__.PointsMaterial({\n            size: 3.5,\n            sizeAttenuation: true,\n            vertexColors: true\n        });\n        const stars = new three__WEBPACK_IMPORTED_MODULE_2__.Points(geometry, material);\n        scene.add(stars);\n        let targetY = 0;\n        const damping = 0.05;\n        const onScroll = ()=>{\n            const pct = window.scrollY / (document.body.scrollHeight - window.innerHeight);\n            targetY = pct * Math.PI * 2;\n        };\n        window.addEventListener(\"scroll\", onScroll);\n        // --- Nebula Clouds ---\n        // DEV: Use a visible, public nebula image for debugging\n        const nebulaTextures = [\n            \"https://upload.wikimedia.org/wikipedia/commons/7/7d/Eagle_nebula_pillars.png\",\n            \"https://upload.wikimedia.org/wikipedia/commons/5/5f/NGC_604.png\",\n            \"https://upload.wikimedia.org/wikipedia/commons/5/5c/NGC_2818_Hubble_WikiSky.jpg\"\n        ];\n        const nebulaClouds = [];\n        function spawnNebulaCloud() {\n            const textureUrl = nebulaTextures[Math.floor(Math.random() * nebulaTextures.length)];\n            const tex = new three__WEBPACK_IMPORTED_MODULE_2__.TextureLoader().load(textureUrl);\n            const color = new three__WEBPACK_IMPORTED_MODULE_2__.Color().setHSL(Math.random(), 0.7, 0.5);\n            const mat = new three__WEBPACK_IMPORTED_MODULE_2__.SpriteMaterial({\n                map: tex,\n                color: color,\n                transparent: true,\n                opacity: 1.0,\n                depthWrite: false,\n                blending: three__WEBPACK_IMPORTED_MODULE_2__.AdditiveBlending\n            });\n            const sprite = new three__WEBPACK_IMPORTED_MODULE_2__.Sprite(mat);\n            // DEBUG: Place nebula directly in front of camera, close up\n            const camDir = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n            camera.getWorldDirection(camDir);\n            sprite.position.copy(camera.position).add(camDir.multiplyScalar(300));\n            const scale = 600;\n            sprite.scale.set(scale, scale, 1);\n            sprite.material.opacity = 1.0;\n            scene.add(sprite);\n            console.log(\"Spawning nebula at\", sprite.position, \"using\", textureUrl);\n            nebulaClouds.push({\n                sprite,\n                age: 0,\n                fadeIn: false,\n                fadeOut: false,\n                lifetime: 1200 + Math.random() * 1200,\n                color,\n                rotSpeed: (Math.random() - 0.5) * 0.005\n            });\n        }\n        // --- Shooting Stars ---\n        const tailLength = 32; // Increase for longer tails\n        const shootingStars = [];\n        let shootingStarCooldown = 0;\n        // Spawn a shooting star with a stunning glowing tail\n        function spawnShootingStar() {\n            // Pick a random direction on the sphere for the spawn location\n            const dir = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();\n            // Ensure shooting stars never spawn close to the camera (at least 70% of max distance)\n            const minDist = starMaxDistance * 0.7;\n            const maxDist = starMaxDistance * 1.0;\n            const dist = minDist + Math.random() * (maxDist - minDist);\n            const spawnPos = dir.clone().multiplyScalar(dist);\n            // Tangential velocity: perpendicular to dir\n            let tangent = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1);\n            tangent = tangent.sub(tangent.clone().projectOnVector(dir)).normalize();\n            // Mix in a small radial component (inward or outward)\n            const tangentialSpeed = starSpeed * (2.5 + Math.random() * 2.5); // much faster\n            const radialSpeed = starSpeed * (Math.random() - 0.5) * 0.3; // more dramatic\n            const velocity = tangent.multiplyScalar(tangentialSpeed).add(dir.clone().multiplyScalar(radialSpeed));\n            // Stunning color gradient for the head\n            const vibrantColors = [\n                0xffe066,\n                0xff66cc,\n                0x66ccff,\n                0xffffff,\n                0x80ffea,\n                0xfff2cc,\n                0xffc080,\n                0x80c0ff,\n                0xff80b3\n            ];\n            const color = vibrantColors[Math.floor(Math.random() * vibrantColors.length)];\n            // Star brightness and size (always small and subtle)\n            const brightness = 2.5 + Math.random() * 1.5;\n            const geo = new three__WEBPACK_IMPORTED_MODULE_2__.SphereGeometry(0.7 + Math.random() * 0.5, 16, 16); // Small sphere\n            const mat = new three__WEBPACK_IMPORTED_MODULE_2__.MeshPhysicalMaterial({\n                color: color,\n                emissive: color,\n                emissiveIntensity: 2.5,\n                metalness: 0.7,\n                roughness: 0.3,\n                transmission: 0.7,\n                opacity: 0.98,\n                transparent: true,\n                clearcoat: 0.8,\n                clearcoatRoughness: 0.2\n            });\n            const star = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(geo, mat);\n            // Add a glowing sprite for extra glow\n            const spriteMap = new three__WEBPACK_IMPORTED_MODULE_2__.TextureLoader().load(\"https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/sprites/glow.png\");\n            const spriteMaterial = new three__WEBPACK_IMPORTED_MODULE_2__.SpriteMaterial({\n                map: spriteMap,\n                color: color,\n                opacity: 0.8,\n                blending: three__WEBPACK_IMPORTED_MODULE_2__.AdditiveBlending\n            });\n            const sprite = new three__WEBPACK_IMPORTED_MODULE_2__.Sprite(spriteMaterial);\n            sprite.scale.set(30, 30, 1);\n            sprite.position.copy(star.position);\n            star.add(sprite);\n            // Add dynamic spark burst at the head\n            const sparkCount = 18 + Math.floor(Math.random() * 8);\n            const sparkGroup = new three__WEBPACK_IMPORTED_MODULE_2__.Group();\n            for(let i = 0; i < sparkCount; i++){\n                const sparkMat = new three__WEBPACK_IMPORTED_MODULE_2__.MeshBasicMaterial({\n                    color: vibrantColors[Math.floor(Math.random() * vibrantColors.length)],\n                    transparent: true,\n                    opacity: 0.8\n                });\n                const sparkGeo = new three__WEBPACK_IMPORTED_MODULE_2__.SphereGeometry(0.07 + Math.random() * 0.06, 8, 8);\n                const spark = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(sparkGeo, sparkMat);\n                const angle = i / sparkCount * Math.PI * 2;\n                spark.position.set(Math.cos(angle) * 1.2, Math.sin(angle) * 1.2, Math.random() * 0.4 - 0.2);\n                sparkGroup.add(spark);\n            }\n            sparkGroup.name = \"sparkBurst\";\n            star.add(sparkGroup);\n            star.position.copy(spawnPos);\n            star.velocity = velocity;\n            star.normalizedLife = 0.0;\n            star.normalizedLifetime = 80 + Math.random() * 80; // Longer, more dramatic\n            star.age = 0;\n            // --- Stunning Meteor Tail (very long, multi-color, glowing, fading, and 3D curve) ---\n            const trailSegments = tailLength * 3; // Even longer tail\n            const trailPoints = [];\n            for(let i = 0; i < trailSegments; i++){\n                // Add a 3D spiral/curve for more depth\n                const spiral = Math.sin(i * 0.25) * 8;\n                const curve = Math.cos(i * 0.15) * 4;\n                const pt = star.position.clone().add(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(spiral, curve, -i * 3));\n                trailPoints.push(pt);\n            }\n            const tailGeo = new three__WEBPACK_IMPORTED_MODULE_2__.BufferGeometry().setFromPoints(trailPoints);\n            // Per-vertex color (multi-color rainbow gradient)\n            const tailColors = [];\n            for(let i = 0; i < trailSegments; i++){\n                // Alpha fades out along the tail\n                const alpha = (1 - i / (trailSegments - 1)) * 0.99;\n                // Rainbow gradient\n                const rainbow = [\n                    0xffe066,\n                    0xff66cc,\n                    0x66ccff,\n                    0xffffff,\n                    0x80ffea,\n                    0xfff2cc,\n                    0xffc080,\n                    0x80c0ff,\n                    0xff80b3\n                ];\n                const gradColor = rainbow[Math.floor(i / trailSegments * rainbow.length)];\n                tailColors.push((gradColor >> 16 & 255) / 255, (gradColor >> 8 & 255) / 255, (gradColor & 255) / 255, alpha);\n            }\n            tailGeo.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_2__.Float32BufferAttribute(tailColors, 4));\n            // Additive blending for glow\n            const tailMat = new three__WEBPACK_IMPORTED_MODULE_2__.LineBasicMaterial({\n                vertexColors: true,\n                transparent: true,\n                opacity: 1.0,\n                blending: three__WEBPACK_IMPORTED_MODULE_2__.AdditiveBlending\n            });\n            const tail = new three__WEBPACK_IMPORTED_MODULE_2__.Line(tailGeo, tailMat);\n            tail.position.copy(star.position);\n            // Add to scene\n            scene.add(star);\n            scene.add(tail);\n            shootingStars.push({\n                mesh: star,\n                tail,\n                velocity: star.velocity,\n                dir,\n                age: 0,\n                normalizedLifetime: star.normalizedLifetime,\n                trailPoints,\n                color,\n                brightness,\n                hasFragmented: false\n            });\n        }\n        const animate = ()=>{\n            try {\n                requestAnimationFrame(animate);\n                // Occasionally spawn a nebula cloud\n                // DEV: Spawn a lot of nebulae for testing\n                if (Math.random() < 0.25 && nebulaClouds.length < 30) {\n                    spawnNebulaCloud();\n                }\n                // Animate nebula clouds\n                for(let i = nebulaClouds.length - 1; i >= 0; i--){\n                    const cloud = nebulaClouds[i];\n                    cloud.age++;\n                    // Fade in\n                    if (cloud.fadeIn && cloud.sprite.material.opacity < 0.55) {\n                        cloud.sprite.material.opacity += 0.009;\n                        if (cloud.sprite.material.opacity >= 0.55) cloud.fadeIn = false;\n                    }\n                    // Fade out\n                    if (cloud.age > cloud.lifetime * 0.7) {\n                        cloud.fadeOut = true;\n                    }\n                    if (cloud.fadeOut) {\n                        cloud.sprite.material.opacity -= 0.006;\n                    }\n                    // Remove when fully faded\n                    if (cloud.sprite.material.opacity <= 0) {\n                        scene.remove(cloud.sprite);\n                        nebulaClouds.splice(i, 1);\n                        continue;\n                    }\n                    // Slow drift and rotation\n                    cloud.sprite.position.x += Math.sin(cloud.age * 0.001 + i) * 0.09;\n                    cloud.sprite.position.y += Math.cos(cloud.age * 0.0012 - i) * 0.07;\n                    cloud.sprite.material.rotation += cloud.rotSpeed;\n                    // Animate color gently\n                    cloud.sprite.material.color.offsetHSL(0.0007 * Math.sin(cloud.age * 0.0007 + i), 0, 0);\n                }\n                camera.rotation.y += (targetY - camera.rotation.y) * damping;\n                // Move the virtual camera position in the direction the camera is facing\n                const forward = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n                camera.getWorldDirection(forward);\n                virtualCameraPos.add(forward.multiplyScalar(starSpeed));\n                // Offset all stars by -virtualCameraPos (floating origin)\n                for(let i = 0; i < positions.length; i += 3){\n                    geometry.attributes.position.array[i] = positions[i] - virtualCameraPos.x;\n                    geometry.attributes.position.array[i + 1] = positions[i + 1] - virtualCameraPos.y;\n                    geometry.attributes.position.array[i + 2] = positions[i + 2] - virtualCameraPos.z;\n                }\n                geometry.attributes.position.needsUpdate = true;\n                // --- Shooting star spawning ---\n                // DEV: Make shooting stars super common (spawn every frame if cooldown allows)\n                if (shootingStarCooldown <= 0 && Math.random() < 0.1) {\n                    spawnShootingStar();\n                    // Subtle camera shake when a shooting star appears\n                    if (camera) {\n                        const shakeStrength = 0.06 + Math.random() * 0.04;\n                        camera.position.x += (Math.random() - 0.5) * shakeStrength;\n                        camera.position.y += (Math.random() - 0.5) * shakeStrength;\n                    }\n                    shootingStarCooldown = 10 + Math.random() * 10; // Longer cooldown for perf\n                } else if (shootingStarCooldown > 0) {\n                    shootingStarCooldown--;\n                }\n                // Animate and clean up shooting stars\n                for(let i = shootingStars.length - 1; i >= 0; i--){\n                    const obj = shootingStars[i];\n                    // Animate spark burst (fade and expand)\n                    if (obj.mesh.children) {\n                        const sparks = obj.mesh.children.find((child)=>child.name === \"sparkBurst\");\n                        if (sparks) {\n                            for(let j = 0; j < sparks.children.length; j++){\n                                const spark = sparks.children[j];\n                                spark.material.opacity *= 0.96; // Fade\n                                spark.scale.multiplyScalar(1.03); // Expand\n                            }\n                        }\n                    }\n                    // Animate tail shimmer and color cycling\n                    if (obj.tail && obj.trailPoints) {\n                        const time = performance.now() * 0.001;\n                        const tailGeo = obj.tail.geometry;\n                        const tailColors = tailGeo.getAttribute(\"color\");\n                        for(let k = 0; k < tailColors.count; k++){\n                            // Cycle hue\n                            let r = tailColors.getX(k), g = tailColors.getY(k), b = tailColors.getZ(k);\n                            // Convert to HSL\n                            const max = Math.max(r, g, b), min = Math.min(r, g, b);\n                            let h, s, l;\n                            l = (max + min) / 2;\n                            if (max === min) {\n                                h = s = 0;\n                            } else {\n                                const d = max - min;\n                                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n                                switch(max){\n                                    case r:\n                                        h = (g - b) / d + (g < b ? 6 : 0);\n                                        break;\n                                    case g:\n                                        h = (b - r) / d + 2;\n                                        break;\n                                    case b:\n                                        h = (r - g) / d + 4;\n                                        break;\n                                }\n                                h /= 6;\n                            }\n                            h = (h + 0.25 * Math.sin(time + k * 0.2)) % 1.0; // Animate hue\n                            // Convert back to RGB\n                            let q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n                            let p = 2 * l - q;\n                            let tr = h + 1 / 3, tg = h, tb = h - 1 / 3;\n                            const hue2rgb = (p, q, t)=>{\n                                if (t < 0) t += 1;\n                                if (t > 1) t -= 1;\n                                if (t < 1 / 6) return p + (q - p) * 6 * t;\n                                if (t < 1 / 2) return q;\n                                if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n                                return p;\n                            };\n                            tailColors.setX(k, hue2rgb(p, q, tr));\n                            tailColors.setY(k, hue2rgb(p, q, tg));\n                            tailColors.setZ(k, hue2rgb(p, q, tb));\n                            // Shimmer: modulate alpha\n                            tailColors.setW(k, tailColors.getW(k) * (0.97 + 0.03 * Math.sin(time * 8 + k)));\n                        }\n                        tailColors.needsUpdate = true;\n                    }\n                    // Straight-line trajectory\n                    obj.mesh.position.add(obj.velocity);\n                    obj.tail.position.copy(obj.mesh.position);\n                    // Animate tail (no lerp, just drag)\n                    obj.age++;\n                    const normalizedLife = obj.age / obj.normalizedLifetime;\n                    obj.trailPoints.unshift(obj.mesh.position.clone());\n                    if (obj.trailPoints.length > tailLength * 3) obj.trailPoints.pop();\n                    let tailGrow = Math.min(1, normalizedLife / 0.3);\n                    let activeSegments = Math.floor(obj.trailPoints.length * tailGrow);\n                    if (activeSegments < 2) activeSegments = 2;\n                    const visibleTrail = obj.trailPoints.slice(0, activeSegments);\n                    obj.tail.geometry.setFromPoints(visibleTrail);\n                    const tailColors = obj.tail.geometry.getAttribute(\"color\");\n                    for(let j = 0; j < visibleTrail.length; j++){\n                        let alpha = (1 - j / (visibleTrail.length - 1)) * 0.95;\n                        alpha *= 0.92 + 0.08 * Math.sin(Date.now() * 0.015 + j * 0.5);\n                        let rainbow = [\n                            0xffc080,\n                            0xffe080,\n                            0xffff80,\n                            0x80ffe6,\n                            0x80c0ff,\n                            0xc080ff\n                        ];\n                        let gradColor = rainbow[j % rainbow.length];\n                        if (normalizedLife > 0.7) alpha *= Math.max(0, 1 - (normalizedLife - 0.7 - 0.2) / 0.3);\n                        tailColors.setXYZW(j, (gradColor >> 16 & 255) / 255, (gradColor >> 8 & 255) / 255, (gradColor & 255) / 255, alpha);\n                    }\n                    tailColors.needsUpdate = true;\n                    // Animate head\n                    let headColor;\n                    if (normalizedLife < 0.5) {\n                        headColor = new three__WEBPACK_IMPORTED_MODULE_2__.Color(obj.color).lerp(new three__WEBPACK_IMPORTED_MODULE_2__.Color(0xffc080), normalizedLife * 2);\n                    } else {\n                        headColor = new three__WEBPACK_IMPORTED_MODULE_2__.Color(0xffc080).lerp(new three__WEBPACK_IMPORTED_MODULE_2__.Color(0xff4000), (normalizedLife - 0.5) * 2);\n                    }\n                    let flicker = 0.95 + 0.13 * Math.sin(Date.now() * 0.07 + Math.random() * 10);\n                    headColor.multiplyScalar(flicker);\n                    obj.mesh.material.color.copy(headColor);\n                    let scale = 1 + 2.2 * Math.sin(Math.PI * normalizedLife);\n                    let distToCam = obj.mesh.position.length();\n                    let dofBlur = distToCam < starMaxDistance * 0.7 ? 0.7 : 1.0;\n                    obj.mesh.scale.set(scale * dofBlur, scale * dofBlur, scale * dofBlur);\n                    // Sparkle burst\n                    if (normalizedLife >= 1 && !obj.hasFragmented) {\n                        for(let s = 0; s < 9; s++){\n                            const sparkleGeo = new three__WEBPACK_IMPORTED_MODULE_2__.SphereGeometry(0.7 + Math.random() * 0.8, 8, 8);\n                            const sparkleMat = new three__WEBPACK_IMPORTED_MODULE_2__.MeshBasicMaterial({\n                                color: 0xffffff,\n                                transparent: true,\n                                opacity: 0.7,\n                                blending: three__WEBPACK_IMPORTED_MODULE_2__.AdditiveBlending\n                            });\n                            const sparkle = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(sparkleGeo, sparkleMat);\n                            sparkle.position.copy(obj.mesh.position);\n                            const sparkleVel = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize().multiplyScalar(2 + Math.random() * 2);\n                            sparkle.userData = {\n                                velocity: sparkleVel,\n                                age: 0\n                            };\n                            scene.add(sparkle);\n                            if (!window._sparkles) window._sparkles = [];\n                            window._sparkles.push(sparkle);\n                        }\n                        const fragVel = obj.velocity.clone().applyAxisAngle(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 1, 0), (Math.random() - 0.5) * 0.3);\n                        const fragStar = obj.mesh.clone();\n                        fragStar.position.copy(obj.mesh.position);\n                        fragStar.velocity = fragVel;\n                        fragStar.normalizedLife = normalizedLife;\n                        fragStar.normalizedLifetime = obj.normalizedLifetime * (0.5 + Math.random() * 0.5);\n                        fragStar.age = obj.age;\n                        fragStar.material = obj.mesh.material.clone();\n                        const fragTrailPoints = obj.trailPoints.slice();\n                        const fragTailGeo = new three__WEBPACK_IMPORTED_MODULE_2__.BufferGeometry().setFromPoints(fragTrailPoints);\n                        fragTailGeo.setAttribute(\"color\", obj.tail.geometry.getAttribute(\"color\").clone());\n                        const fragTailMat = obj.tail.material.clone();\n                        const fragTail = new three__WEBPACK_IMPORTED_MODULE_2__.Line(fragTailGeo, fragTailMat);\n                        fragTail.position.copy(fragStar.position);\n                        scene.add(fragStar);\n                        scene.add(fragTail);\n                        shootingStars.push({\n                            mesh: fragStar,\n                            tail: fragTail,\n                            velocity: fragStar.velocity,\n                            dir: obj.dir,\n                            age: fragStar.age,\n                            normalizedLifetime: fragStar.normalizedLifetime,\n                            trailPoints: fragTrailPoints,\n                            color: obj.color,\n                            brightness: obj.brightness,\n                            hasFragmented: true\n                        });\n                        obj.hasFragmented = true;\n                    }\n                    // Spark burst\n                    if (!obj.hasSparked && normalizedLife > 0.95 && Math.random() < 0.1) {\n                        for(let s = 0; s < 8 + Math.floor(Math.random() * 8); s++){\n                            const sparkGeo = new three__WEBPACK_IMPORTED_MODULE_2__.SphereGeometry(0.5 + Math.random() * 0.5, 8, 8);\n                            const sparkMat = new three__WEBPACK_IMPORTED_MODULE_2__.MeshBasicMaterial({\n                                color: 0xfff6c0,\n                                transparent: true,\n                                opacity: 1,\n                                blending: three__WEBPACK_IMPORTED_MODULE_2__.AdditiveBlending\n                            });\n                            const spark = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(sparkGeo, sparkMat);\n                            spark.position.copy(obj.mesh.position);\n                            spark.sparkVel = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize().multiplyScalar(0.5 + Math.random() * 1.2);\n                            spark.sparkLife = 12 + Math.random() * 10;\n                            spark.sparkAge = 0;\n                            scene.add(spark);\n                            if (!window._starSparks) window._starSparks = [];\n                            window._starSparks.push(spark);\n                        }\n                        obj.hasSparked = true;\n                    }\n                    // Flash\n                    if (!obj.hasFlashed && normalizedLife > 0.98 && Math.random() < 0.2) {\n                        const flashGeo = new three__WEBPACK_IMPORTED_MODULE_2__.SphereGeometry(1, 16, 16);\n                        const flashMat = new three__WEBPACK_IMPORTED_MODULE_2__.MeshBasicMaterial({\n                            color: 0xffffee,\n                            transparent: true,\n                            opacity: 0.8,\n                            blending: three__WEBPACK_IMPORTED_MODULE_2__.AdditiveBlending\n                        });\n                        const flash = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(flashGeo, flashMat);\n                        flash.position.copy(obj.mesh.position);\n                        scene.add(flash);\n                        if (!window._starFlashes) window._starFlashes = [];\n                        window._starFlashes.push({\n                            mesh: flash,\n                            age: 0\n                        });\n                        obj.hasFlashed = true;\n                    }\n                    // Fade out as it gets far away\n                    const dist = obj.mesh.position.distanceTo(camera.position);\n                    const fadeStart = starMaxDistance * 0.5;\n                    if (dist > fadeStart) {\n                        const fade = 1 - (dist - fadeStart) / (starMaxDistance - fadeStart);\n                        obj.mesh.material.opacity = Math.max(0, fade);\n                        obj.mesh.material.transparent = true;\n                        obj.tail.material.opacity = Math.max(0, fade * 0.8);\n                        obj.tail.material.transparent = true;\n                    }\n                    // Remove when out of bounds or fully faded or life ended\n                    if (normalizedLife >= 1.0 || dist > starMaxDistance || obj.mesh.material.opacity <= 0.01) {\n                        scene.remove(obj.mesh);\n                        scene.remove(obj.tail);\n                        shootingStars.splice(i, 1);\n                    }\n                }\n                // Animate sparks\n                if (window._starSparks) {\n                    for(let i = window._starSparks.length - 1; i >= 0; i--){\n                        const spark = window._starSparks[i];\n                        spark.position.add(spark.sparkVel);\n                        spark.sparkAge++;\n                        spark.material.opacity *= 0.85;\n                        if (spark.sparkAge > spark.sparkLife) {\n                            scene.remove(spark);\n                            window._starSparks.splice(i, 1);\n                        }\n                    }\n                }\n                // Animate flashes\n                if (window._starFlashes) {\n                    for(let i = window._starFlashes.length - 1; i >= 0; i--){\n                        const flash = window._starFlashes[i];\n                        flash.mesh.scale.multiplyScalar(1.15);\n                        flash.mesh.material.opacity *= 0.85;\n                        flash.age++;\n                        if (flash.age > 10) {\n                            scene.remove(flash.mesh);\n                            window._starFlashes.splice(i, 1);\n                        }\n                    }\n                }\n                // --- Starfield logic ---\n                const sqDist = starMaxDistance * starMaxDistance;\n                for(let i = 0; i < positions.length; i += 3){\n                    const dx = positions[i] - virtualCameraPos.x;\n                    const dy = positions[i + 1] - virtualCameraPos.y;\n                    const dz = positions[i + 2] - virtualCameraPos.z;\n                    if (dx * dx + dy * dy + dz * dz > sqDist) {\n                        // Place in a thick spherical shell around the virtual camera, never too close\n                        const minRadius = starMaxDistance * 0.8;\n                        const maxRadius = starMaxDistance;\n                        const r = minRadius + Math.random() * (maxRadius - minRadius);\n                        const theta = Math.random() * 2 * Math.PI;\n                        const phi = Math.acos(2 * Math.random() - 1);\n                        positions[i] = virtualCameraPos.x + r * Math.sin(phi) * Math.cos(theta);\n                        positions[i + 1] = virtualCameraPos.y + r * Math.sin(phi) * Math.sin(theta);\n                        positions[i + 2] = virtualCameraPos.z + r * Math.cos(phi);\n                    }\n                }\n                // geometry.attributes.position.needsUpdate = true; // Already set above\n                // Robust starfield color update to prevent stuck white dots\n                const colArr = geometry.attributes.color.array;\n                for(let i = 0; i < positions.length; i += 3){\n                    const idx = i / 3;\n                    const dx = positions[i] - virtualCameraPos.x;\n                    const dy = positions[i + 1] - virtualCameraPos.y;\n                    const dz = positions[i + 2] - virtualCameraPos.z;\n                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);\n                    if (timers[idx] > 0) {\n                        timers[idx]--;\n                        if (timers[idx] === 0) {\n                            // Timer expired, restore color\n                            sparkColors[i] = originalColors[i];\n                            sparkColors[i + 1] = originalColors[i + 1];\n                            sparkColors[i + 2] = originalColors[i + 2];\n                            colArr[i] = originalColors[i];\n                            colArr[i + 1] = originalColors[i + 1];\n                            colArr[i + 2] = originalColors[i + 2];\n                        } else {\n                            colArr[i] = sparkColors[i];\n                            colArr[i + 1] = sparkColors[i + 1];\n                            colArr[i + 2] = sparkColors[i + 2];\n                        }\n                    } else if (dist > starMaxDistance * 0.3 && Math.random() < 0.05) {\n                        timers[idx] = sparkleDuration;\n                        const c = palette[Math.floor(Math.random() * palette.length)];\n                        sparkColors[i] = c[0];\n                        sparkColors[i + 1] = c[1];\n                        sparkColors[i + 2] = c[2];\n                        colArr[i] = sparkColors[i];\n                        colArr[i + 1] = sparkColors[i + 1];\n                        colArr[i + 2] = sparkColors[i + 2];\n                    } else {\n                        sparkColors[i] = originalColors[i];\n                        sparkColors[i + 1] = originalColors[i + 1];\n                        sparkColors[i + 2] = originalColors[i + 2];\n                        colArr[i] = originalColors[i];\n                        colArr[i + 1] = originalColors[i + 1];\n                        colArr[i + 2] = originalColors[i + 2];\n                    }\n                }\n                geometry.attributes.color.needsUpdate = true;\n                renderer.render(scene, camera);\n            } catch (err) {\n                // Defensive: log error with context\n                console.error(\"Starfield animation error:\", err);\n            }\n        };\n        animate(); // Start the render loop\n        const onResize = ()=>{\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(window.innerWidth, window.innerHeight);\n        };\n        window.addEventListener(\"resize\", onResize);\n        return ()=>{\n            window.removeEventListener(\"scroll\", onScroll);\n            window.removeEventListener(\"resize\", onResize);\n            mount.removeChild(renderer.domElement);\n        };\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: mountRef\n    }, void 0, false, {\n        fileName: \"/home/kayosdev/Websites/Portfolio/components/Starfield.jsx\",\n        lineNumber: 575,\n        columnNumber: 10\n    }, undefined);\n};\n_s(Starfield, \"V9/qkEdV8GfsDZk7lMTA1T8g5Ps=\");\n_c = Starfield;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Starfield);\nvar _c;\n$RefreshReg$(_c, \"Starfield\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFVLEdBQUdELE9BQU9FLFdBQVc7WUFDdERKLE9BQU80USxzQkFBc0I7WUFDN0JwUSxTQUFTSyxPQUFPLENBQUNYLE9BQU9DLFVBQVUsRUFBRUQsT0FBT0UsV0FBVztRQUN4RDtRQUNBRixPQUFPeUUsZ0JBQWdCLENBQUMsVUFBVStMO1FBRWxDLE9BQU87WUFDTHhRLE9BQU8yUSxtQkFBbUIsQ0FBQyxVQUFVeE07WUFDckNuRSxPQUFPMlEsbUJBQW1CLENBQUMsVUFBVUg7WUFDckNwUixNQUFNd1IsV0FBVyxDQUFDdFEsU0FBU1EsVUFBVTtRQUN2QztJQUNGLEdBQUcsRUFBRTtJQUVMLHFCQUFPLDhEQUFDK1A7UUFBSUMsS0FBSzVSOzs7Ozs7QUFDbkI7R0E1akJNRDtLQUFBQTtBQThqQk4sK0RBQWVBLFNBQVNBLEVBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9TdGFyZmllbGQuanN4P2YxYTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuXG5jb25zdCBTdGFyZmllbGQgPSAoKSA9PiB7XG4gIGNvbnN0IG1vdW50UmVmID0gdXNlUmVmKG51bGwpXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBEZWZlbnNpdmU6IGFsd2F5cyB1c2UgLmN1cnJlbnQgZm9yIHJlZnNcbiAgICBpZiAoIW1vdW50UmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICBjb25zdCBtb3VudCA9IG1vdW50UmVmLmN1cnJlbnRcbiAgICBtb3VudC5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCdcbiAgICBtb3VudC5zdHlsZS50b3AgPSAnMCdcbiAgICBtb3VudC5zdHlsZS5sZWZ0ID0gJzAnXG4gICAgbW91bnQuc3R5bGUud2lkdGggPSAnMTAwJSdcbiAgICBtb3VudC5zdHlsZS5oZWlnaHQgPSAnMTAwJSdcbiAgICBtb3VudC5zdHlsZS56SW5kZXggPSAnMCdcblxuICAgIC8vIFNjZW5lICYgUmVuZGVyZXJcbiAgICBjb25zdCBzY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpXG4gICAgY29uc3QgY2FtZXJhID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKDc1LCB3aW5kb3cuaW5uZXJXaWR0aCAvIHdpbmRvdy5pbm5lckhlaWdodCwgMC4xLCA1MDAwKVxuICAgIGNhbWVyYS5wb3NpdGlvbi5zZXQoMCwgMCwgMCk7XG4gICAgLy8gVmlydHVhbCBwb3NpdGlvbiB0byBzaW11bGF0ZSBpbmZpbml0ZSB0cmF2ZWxcbiAgICBsZXQgdmlydHVhbENhbWVyYVBvcyA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDApO1xuICAgIGNvbnN0IHJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoeyBhbnRpYWxpYXM6IHRydWUgfSlcbiAgICByZW5kZXJlci5zZXRQaXhlbFJhdGlvKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKVxuICAgIHJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodClcbiAgICByZW5kZXJlci5zZXRDbGVhckNvbG9yKDB4MDAwMDAwLCAxKTtcbiAgICBtb3VudC5hcHBlbmRDaGlsZChyZW5kZXJlci5kb21FbGVtZW50KVxuXG4gICAgLy8gU3RhcmZpZWxkXG4gICAgY29uc3Qgc3RhckNvdW50ID0gMzAwMFxuICAgIGNvbnN0IHN0YXJNYXhEaXN0YW5jZSA9IDIwMDBcbiAgICBjb25zdCBzdGFyU3BlZWQgPSAxXG4gICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKVxuICAgIGNvbnN0IHBvc2l0aW9ucyA9IFtdO1xuICAgIGxldCBzdGFyc1BsYWNlZCA9IDA7XG4gICAgd2hpbGUgKHN0YXJzUGxhY2VkIDwgc3RhckNvdW50KSB7XG4gICAgICAvLyBXaXRoIDElIGNoYW5jZSwgc3Bhd24gYSBzdGFyIGNsdXN0ZXIgKDEwLTMwIHN0YXJzKVxuICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPCAwLjAxICYmIHN0YXJzUGxhY2VkIDwgc3RhckNvdW50IC0gMTApIHtcbiAgICAgICAgY29uc3QgY2x1c3RlclRoZXRhID0gTWF0aC5yYW5kb20oKSAqIDIgKiBNYXRoLlBJO1xuICAgICAgICBjb25zdCBjbHVzdGVyUGhpID0gTWF0aC5hY29zKDIgKiBNYXRoLnJhbmRvbSgpIC0gMSk7XG4gICAgICAgIGNvbnN0IGNsdXN0ZXJSID0gTWF0aC5yYW5kb20oKSAqIHN0YXJNYXhEaXN0YW5jZTtcbiAgICAgICAgY29uc3QgY2x1c3RlckNlbnRlciA9IFtcbiAgICAgICAgICBjbHVzdGVyUiAqIE1hdGguc2luKGNsdXN0ZXJQaGkpICogTWF0aC5jb3MoY2x1c3RlclRoZXRhKSxcbiAgICAgICAgICBjbHVzdGVyUiAqIE1hdGguc2luKGNsdXN0ZXJQaGkpICogTWF0aC5zaW4oY2x1c3RlclRoZXRhKSxcbiAgICAgICAgICBjbHVzdGVyUiAqIE1hdGguY29zKGNsdXN0ZXJQaGkpXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGNsdXN0ZXJTaXplID0gMTAgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyMCk7IC8vIDEwLTMwIHN0YXJzXG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgY2x1c3RlclNpemUgJiYgc3RhcnNQbGFjZWQgPCBzdGFyQ291bnQ7IGMrKykge1xuICAgICAgICAgIC8vIEVhY2ggc3RhciBpbiBjbHVzdGVyIGlzIHdpdGhpbiAzMCB1bml0cyBvZiBjZW50ZXJcbiAgICAgICAgICBjb25zdCBvZmZzZXRUaGV0YSA9IE1hdGgucmFuZG9tKCkgKiAyICogTWF0aC5QSTtcbiAgICAgICAgICBjb25zdCBvZmZzZXRQaGkgPSBNYXRoLmFjb3MoMiAqIE1hdGgucmFuZG9tKCkgLSAxKTtcbiAgICAgICAgICBjb25zdCBvZmZzZXRSID0gTWF0aC5yYW5kb20oKSAqIDMwOyAvLyBjbHVzdGVyIHJhZGl1c1xuICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKFxuICAgICAgICAgICAgY2x1c3RlckNlbnRlclswXSArIG9mZnNldFIgKiBNYXRoLnNpbihvZmZzZXRQaGkpICogTWF0aC5jb3Mob2Zmc2V0VGhldGEpLFxuICAgICAgICAgICAgY2x1c3RlckNlbnRlclsxXSArIG9mZnNldFIgKiBNYXRoLnNpbihvZmZzZXRQaGkpICogTWF0aC5zaW4ob2Zmc2V0VGhldGEpLFxuICAgICAgICAgICAgY2x1c3RlckNlbnRlclsyXSArIG9mZnNldFIgKiBNYXRoLmNvcyhvZmZzZXRQaGkpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzdGFyc1BsYWNlZCsrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb3JtYWwgc2luZ2xlIHN0YXJcbiAgICAgICAgY29uc3QgdGhldGEgPSBNYXRoLnJhbmRvbSgpICogMiAqIE1hdGguUEk7XG4gICAgICAgIGNvbnN0IHBoaSA9IE1hdGguYWNvcygyICogTWF0aC5yYW5kb20oKSAtIDEpO1xuICAgICAgICBjb25zdCByID0gTWF0aC5yYW5kb20oKSAqIHN0YXJNYXhEaXN0YW5jZTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goXG4gICAgICAgICAgciAqIE1hdGguc2luKHBoaSkgKiBNYXRoLmNvcyh0aGV0YSksXG4gICAgICAgICAgciAqIE1hdGguc2luKHBoaSkgKiBNYXRoLnNpbih0aGV0YSksXG4gICAgICAgICAgciAqIE1hdGguY29zKHBoaSlcbiAgICAgICAgKTtcbiAgICAgICAgc3RhcnNQbGFjZWQrKztcbiAgICAgIH1cbiAgICB9XG4gICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBUSFJFRS5GbG9hdDMyQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9ucywgMykpXG5cbiAgICBjb25zdCBwYWxldHRlID0gW1xuICAgICAgWzEuMCwgMC41LCAwLjVdLFxuICAgICAgWzEuMCwgMC43NSwgMC40XSxcbiAgICAgIFsxLjAsIDEuMCwgMC45XSxcbiAgICAgIFsxLjAsIDEuMCwgMS4wXSxcbiAgICAgIFswLjQsIDAuNSwgMS4wXSxcbiAgICBdXG4gICAgY29uc3QgY29sb3JzID0gW11cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXJDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBjID0gcGFsZXR0ZVtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBwYWxldHRlLmxlbmd0aCldXG4gICAgICBjb2xvcnMucHVzaCguLi5jKVxuICAgIH1cbiAgICBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2NvbG9yJywgbmV3IFRIUkVFLkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoY29sb3JzLCAzKSlcblxuICAgIGNvbnN0IG9yaWdpbmFsQ29sb3JzID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvci5hcnJheS5zbGljZSgpXG4gICAgY29uc3QgdGltZXJzID0gbmV3IEZsb2F0MzJBcnJheShzdGFyQ291bnQpXG4gICAgY29uc3Qgc3BhcmtDb2xvcnMgPSBuZXcgRmxvYXQzMkFycmF5KHN0YXJDb3VudCAqIDMpXG4gICAgY29uc3Qgc3BhcmtsZUR1cmF0aW9uID0gMTgwXG5cbiAgICBjb25zdCBtYXRlcmlhbCA9IG5ldyBUSFJFRS5Qb2ludHNNYXRlcmlhbCh7IHNpemU6IDMuNSwgc2l6ZUF0dGVudWF0aW9uOiB0cnVlLCB2ZXJ0ZXhDb2xvcnM6IHRydWUgfSlcbiAgICBjb25zdCBzdGFycyA9IG5ldyBUSFJFRS5Qb2ludHMoZ2VvbWV0cnksIG1hdGVyaWFsKVxuICAgIHNjZW5lLmFkZChzdGFycylcblxuICAgIGxldCB0YXJnZXRZID0gMFxuICAgIGNvbnN0IGRhbXBpbmcgPSAwLjA1XG4gICAgY29uc3Qgb25TY3JvbGwgPSAoKSA9PiB7XG4gICAgICBjb25zdCBwY3QgPSB3aW5kb3cuc2Nyb2xsWSAvIChkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCAtIHdpbmRvdy5pbm5lckhlaWdodClcbiAgICAgIHRhcmdldFkgPSBwY3QgKiBNYXRoLlBJICogMlxuICAgIH1cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25TY3JvbGwpXG5cbiAgICAvLyAtLS0gTmVidWxhIENsb3VkcyAtLS1cbiAgICAvLyBERVY6IFVzZSBhIHZpc2libGUsIHB1YmxpYyBuZWJ1bGEgaW1hZ2UgZm9yIGRlYnVnZ2luZ1xuICAgIGNvbnN0IG5lYnVsYVRleHR1cmVzID0gW1xuICAgICAgJ2h0dHBzOi8vdXBsb2FkLndpa2ltZWRpYS5vcmcvd2lraXBlZGlhL2NvbW1vbnMvNy83ZC9FYWdsZV9uZWJ1bGFfcGlsbGFycy5wbmcnLFxuICAgICAgJ2h0dHBzOi8vdXBsb2FkLndpa2ltZWRpYS5vcmcvd2lraXBlZGlhL2NvbW1vbnMvNS81Zi9OR0NfNjA0LnBuZycsXG4gICAgICAnaHR0cHM6Ly91cGxvYWQud2lraW1lZGlhLm9yZy93aWtpcGVkaWEvY29tbW9ucy81LzVjL05HQ18yODE4X0h1YmJsZV9XaWtpU2t5LmpwZycsXG4gICAgXTtcbiAgICBjb25zdCBuZWJ1bGFDbG91ZHMgPSBbXTtcbiAgICBmdW5jdGlvbiBzcGF3bk5lYnVsYUNsb3VkKCkge1xuICAgICAgY29uc3QgdGV4dHVyZVVybCA9IG5lYnVsYVRleHR1cmVzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSpuZWJ1bGFUZXh0dXJlcy5sZW5ndGgpXTtcbiAgICAgIGNvbnN0IHRleCA9IG5ldyBUSFJFRS5UZXh0dXJlTG9hZGVyKCkubG9hZCh0ZXh0dXJlVXJsKTtcbiAgICAgIGNvbnN0IGNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCkuc2V0SFNMKE1hdGgucmFuZG9tKCksIDAuNywgMC41KTtcbiAgICAgIGNvbnN0IG1hdCA9IG5ldyBUSFJFRS5TcHJpdGVNYXRlcmlhbCh7IG1hcDogdGV4LCBjb2xvcjogY29sb3IsIHRyYW5zcGFyZW50OiB0cnVlLCBvcGFjaXR5OiAxLjAsIGRlcHRoV3JpdGU6IGZhbHNlLCBibGVuZGluZzogVEhSRUUuQWRkaXRpdmVCbGVuZGluZyB9KTtcbiAgICAgIGNvbnN0IHNwcml0ZSA9IG5ldyBUSFJFRS5TcHJpdGUobWF0KTtcbiAgICAgIC8vIERFQlVHOiBQbGFjZSBuZWJ1bGEgZGlyZWN0bHkgaW4gZnJvbnQgb2YgY2FtZXJhLCBjbG9zZSB1cFxuICAgICAgY29uc3QgY2FtRGlyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgIGNhbWVyYS5nZXRXb3JsZERpcmVjdGlvbihjYW1EaXIpO1xuICAgICAgc3ByaXRlLnBvc2l0aW9uLmNvcHkoY2FtZXJhLnBvc2l0aW9uKS5hZGQoY2FtRGlyLm11bHRpcGx5U2NhbGFyKDMwMCkpO1xuICAgICAgY29uc3Qgc2NhbGUgPSA2MDA7XG4gICAgICBzcHJpdGUuc2NhbGUuc2V0KHNjYWxlLCBzY2FsZSwgMSk7XG4gICAgICBzcHJpdGUubWF0ZXJpYWwub3BhY2l0eSA9IDEuMDtcbiAgICAgIHNjZW5lLmFkZChzcHJpdGUpO1xuICAgICAgY29uc29sZS5sb2coJ1NwYXduaW5nIG5lYnVsYSBhdCcsIHNwcml0ZS5wb3NpdGlvbiwgJ3VzaW5nJywgdGV4dHVyZVVybCk7XG4gICAgICBuZWJ1bGFDbG91ZHMucHVzaCh7IHNwcml0ZSwgYWdlOiAwLCBmYWRlSW46IGZhbHNlLCBmYWRlT3V0OiBmYWxzZSwgbGlmZXRpbWU6IDEyMDAgKyBNYXRoLnJhbmRvbSgpKjEyMDAsIGNvbG9yLCByb3RTcGVlZDogKE1hdGgucmFuZG9tKCktMC41KSowLjAwNSB9KTtcbiAgICB9XG5cbiAgICAvLyAtLS0gU2hvb3RpbmcgU3RhcnMgLS0tXG4gICAgY29uc3QgdGFpbExlbmd0aCA9IDMyOyAvLyBJbmNyZWFzZSBmb3IgbG9uZ2VyIHRhaWxzXG4gICAgY29uc3Qgc2hvb3RpbmdTdGFycyA9IFtdO1xuICAgIGxldCBzaG9vdGluZ1N0YXJDb29sZG93biA9IDA7XG4gICAgLy8gU3Bhd24gYSBzaG9vdGluZyBzdGFyIHdpdGggYSBzdHVubmluZyBnbG93aW5nIHRhaWxcbiAgICBmdW5jdGlvbiBzcGF3blNob290aW5nU3RhcigpIHtcbiAgICAgIC8vIFBpY2sgYSByYW5kb20gZGlyZWN0aW9uIG9uIHRoZSBzcGhlcmUgZm9yIHRoZSBzcGF3biBsb2NhdGlvblxuICAgICAgY29uc3QgZGlyID0gbmV3IFRIUkVFLlZlY3RvcjMoTWF0aC5yYW5kb20oKSoyLTEsIE1hdGgucmFuZG9tKCkqMi0xLCBNYXRoLnJhbmRvbSgpKjItMSkubm9ybWFsaXplKCk7XG4gICAgICAvLyBFbnN1cmUgc2hvb3Rpbmcgc3RhcnMgbmV2ZXIgc3Bhd24gY2xvc2UgdG8gdGhlIGNhbWVyYSAoYXQgbGVhc3QgNzAlIG9mIG1heCBkaXN0YW5jZSlcbiAgICAgIGNvbnN0IG1pbkRpc3QgPSBzdGFyTWF4RGlzdGFuY2UgKiAwLjc7XG4gICAgICBjb25zdCBtYXhEaXN0ID0gc3Rhck1heERpc3RhbmNlICogMS4wO1xuICAgICAgY29uc3QgZGlzdCA9IG1pbkRpc3QgKyBNYXRoLnJhbmRvbSgpICogKG1heERpc3QgLSBtaW5EaXN0KTtcbiAgICAgIGNvbnN0IHNwYXduUG9zID0gZGlyLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoZGlzdCk7XG4gICAgICAvLyBUYW5nZW50aWFsIHZlbG9jaXR5OiBwZXJwZW5kaWN1bGFyIHRvIGRpclxuICAgICAgbGV0IHRhbmdlbnQgPSBuZXcgVEhSRUUuVmVjdG9yMyhNYXRoLnJhbmRvbSgpKjItMSwgTWF0aC5yYW5kb20oKSoyLTEsIE1hdGgucmFuZG9tKCkqMi0xKTtcbiAgICAgIHRhbmdlbnQgPSB0YW5nZW50LnN1Yih0YW5nZW50LmNsb25lKCkucHJvamVjdE9uVmVjdG9yKGRpcikpLm5vcm1hbGl6ZSgpO1xuICAgICAgLy8gTWl4IGluIGEgc21hbGwgcmFkaWFsIGNvbXBvbmVudCAoaW53YXJkIG9yIG91dHdhcmQpXG4gICAgICBjb25zdCB0YW5nZW50aWFsU3BlZWQgPSBzdGFyU3BlZWQgKiAoMi41ICsgTWF0aC5yYW5kb20oKSAqIDIuNSk7IC8vIG11Y2ggZmFzdGVyXG4gICAgICBjb25zdCByYWRpYWxTcGVlZCA9IHN0YXJTcGVlZCAqIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDAuMzsgLy8gbW9yZSBkcmFtYXRpY1xuICAgICAgY29uc3QgdmVsb2NpdHkgPSB0YW5nZW50Lm11bHRpcGx5U2NhbGFyKHRhbmdlbnRpYWxTcGVlZCkuYWRkKGRpci5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKHJhZGlhbFNwZWVkKSk7XG5cbiAgICAgIC8vIFN0dW5uaW5nIGNvbG9yIGdyYWRpZW50IGZvciB0aGUgaGVhZFxuICAgICAgY29uc3QgdmlicmFudENvbG9ycyA9IFsweGZmZTA2NiwgMHhmZjY2Y2MsIDB4NjZjY2ZmLCAweGZmZmZmZiwgMHg4MGZmZWEsIDB4ZmZmMmNjLCAweGZmYzA4MCwgMHg4MGMwZmYsIDB4ZmY4MGIzXTtcbiAgICAgIGNvbnN0IGNvbG9yID0gdmlicmFudENvbG9yc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqdmlicmFudENvbG9ycy5sZW5ndGgpXTtcbiAgICAgIC8vIFN0YXIgYnJpZ2h0bmVzcyBhbmQgc2l6ZSAoYWx3YXlzIHNtYWxsIGFuZCBzdWJ0bGUpXG4gICAgICBjb25zdCBicmlnaHRuZXNzID0gMi41ICsgTWF0aC5yYW5kb20oKSoxLjU7XG4gICAgICBjb25zdCBnZW8gPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoMC43ICsgTWF0aC5yYW5kb20oKSowLjUsIDE2LCAxNik7IC8vIFNtYWxsIHNwaGVyZVxuICAgICAgY29uc3QgbWF0ID0gbmV3IFRIUkVFLk1lc2hQaHlzaWNhbE1hdGVyaWFsKHtcbiAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICBlbWlzc2l2ZTogY29sb3IsXG4gICAgICAgIGVtaXNzaXZlSW50ZW5zaXR5OiAyLjUsXG4gICAgICAgIG1ldGFsbmVzczogMC43LFxuICAgICAgICByb3VnaG5lc3M6IDAuMyxcbiAgICAgICAgdHJhbnNtaXNzaW9uOiAwLjcsXG4gICAgICAgIG9wYWNpdHk6IDAuOTgsXG4gICAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgICAgICBjbGVhcmNvYXQ6IDAuOCxcbiAgICAgICAgY2xlYXJjb2F0Um91Z2huZXNzOiAwLjIsXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHN0YXIgPSBuZXcgVEhSRUUuTWVzaChnZW8sIG1hdCk7XG4gICAgICAvLyBBZGQgYSBnbG93aW5nIHNwcml0ZSBmb3IgZXh0cmEgZ2xvd1xuICAgICAgY29uc3Qgc3ByaXRlTWFwID0gbmV3IFRIUkVFLlRleHR1cmVMb2FkZXIoKS5sb2FkKCdodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vbXJkb29iL3RocmVlLmpzL21hc3Rlci9leGFtcGxlcy90ZXh0dXJlcy9zcHJpdGVzL2dsb3cucG5nJyk7XG4gICAgICBjb25zdCBzcHJpdGVNYXRlcmlhbCA9IG5ldyBUSFJFRS5TcHJpdGVNYXRlcmlhbCh7IG1hcDogc3ByaXRlTWFwLCBjb2xvcjogY29sb3IsIG9wYWNpdHk6IDAuOCwgYmxlbmRpbmc6IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmcgfSk7XG4gICAgICBjb25zdCBzcHJpdGUgPSBuZXcgVEhSRUUuU3ByaXRlKHNwcml0ZU1hdGVyaWFsKTtcbiAgICAgIHNwcml0ZS5zY2FsZS5zZXQoMzAsIDMwLCAxKTtcbiAgICAgIHNwcml0ZS5wb3NpdGlvbi5jb3B5KHN0YXIucG9zaXRpb24pO1xuICAgICAgc3Rhci5hZGQoc3ByaXRlKTtcbiAgICAgIC8vIEFkZCBkeW5hbWljIHNwYXJrIGJ1cnN0IGF0IHRoZSBoZWFkXG4gICAgICBjb25zdCBzcGFya0NvdW50ID0gMTggKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqOCk7XG4gICAgICBjb25zdCBzcGFya0dyb3VwID0gbmV3IFRIUkVFLkdyb3VwKCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwYXJrQ291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBzcGFya01hdCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7IGNvbG9yOiB2aWJyYW50Q29sb3JzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSp2aWJyYW50Q29sb3JzLmxlbmd0aCldLCB0cmFuc3BhcmVudDogdHJ1ZSwgb3BhY2l0eTogMC44IH0pO1xuICAgICAgICBjb25zdCBzcGFya0dlbyA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeSgwLjA3ICsgTWF0aC5yYW5kb20oKSowLjA2LCA4LCA4KTtcbiAgICAgICAgY29uc3Qgc3BhcmsgPSBuZXcgVEhSRUUuTWVzaChzcGFya0dlbywgc3BhcmtNYXQpO1xuICAgICAgICBjb25zdCBhbmdsZSA9IChpIC8gc3BhcmtDb3VudCkgKiBNYXRoLlBJICogMjtcbiAgICAgICAgc3BhcmsucG9zaXRpb24uc2V0KE1hdGguY29zKGFuZ2xlKSoxLjIsIE1hdGguc2luKGFuZ2xlKSoxLjIsIE1hdGgucmFuZG9tKCkqMC40LTAuMik7XG4gICAgICAgIHNwYXJrR3JvdXAuYWRkKHNwYXJrKTtcbiAgICAgIH1cbiAgICAgIHNwYXJrR3JvdXAubmFtZSA9ICdzcGFya0J1cnN0JztcbiAgICAgIHN0YXIuYWRkKHNwYXJrR3JvdXApO1xuICAgICAgc3Rhci5wb3NpdGlvbi5jb3B5KHNwYXduUG9zKTtcbiAgICAgIHN0YXIudmVsb2NpdHkgPSB2ZWxvY2l0eTtcbiAgICAgIHN0YXIubm9ybWFsaXplZExpZmUgPSAwLjA7XG4gICAgICBzdGFyLm5vcm1hbGl6ZWRMaWZldGltZSA9IDgwICsgTWF0aC5yYW5kb20oKSAqIDgwOyAvLyBMb25nZXIsIG1vcmUgZHJhbWF0aWNcbiAgICAgIHN0YXIuYWdlID0gMDtcbiAgICAgIC8vIC0tLSBTdHVubmluZyBNZXRlb3IgVGFpbCAodmVyeSBsb25nLCBtdWx0aS1jb2xvciwgZ2xvd2luZywgZmFkaW5nLCBhbmQgM0QgY3VydmUpIC0tLVxuICAgICAgY29uc3QgdHJhaWxTZWdtZW50cyA9IHRhaWxMZW5ndGggKiAzOyAvLyBFdmVuIGxvbmdlciB0YWlsXG4gICAgICBjb25zdCB0cmFpbFBvaW50cyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFpbFNlZ21lbnRzOyBpKyspIHtcbiAgICAgICAgLy8gQWRkIGEgM0Qgc3BpcmFsL2N1cnZlIGZvciBtb3JlIGRlcHRoXG4gICAgICAgIGNvbnN0IHNwaXJhbCA9IE1hdGguc2luKGkgKiAwLjI1KSAqIDg7XG4gICAgICAgIGNvbnN0IGN1cnZlID0gTWF0aC5jb3MoaSAqIDAuMTUpICogNDtcbiAgICAgICAgY29uc3QgcHQgPSBzdGFyLnBvc2l0aW9uLmNsb25lKCkuYWRkKG5ldyBUSFJFRS5WZWN0b3IzKHNwaXJhbCwgY3VydmUsIC1pICogMykpO1xuICAgICAgICB0cmFpbFBvaW50cy5wdXNoKHB0KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhaWxHZW8gPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKS5zZXRGcm9tUG9pbnRzKHRyYWlsUG9pbnRzKTtcbiAgICAgIC8vIFBlci12ZXJ0ZXggY29sb3IgKG11bHRpLWNvbG9yIHJhaW5ib3cgZ3JhZGllbnQpXG4gICAgICBjb25zdCB0YWlsQ29sb3JzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYWlsU2VnbWVudHM7IGkrKykge1xuICAgICAgICAvLyBBbHBoYSBmYWRlcyBvdXQgYWxvbmcgdGhlIHRhaWxcbiAgICAgICAgY29uc3QgYWxwaGEgPSAoMSAtIGkgLyAodHJhaWxTZWdtZW50cyAtIDEpKSAqIDAuOTk7XG4gICAgICAgIC8vIFJhaW5ib3cgZ3JhZGllbnRcbiAgICAgICAgY29uc3QgcmFpbmJvdyA9IFsweGZmZTA2NiwgMHhmZjY2Y2MsIDB4NjZjY2ZmLCAweGZmZmZmZiwgMHg4MGZmZWEsIDB4ZmZmMmNjLCAweGZmYzA4MCwgMHg4MGMwZmYsIDB4ZmY4MGIzXTtcbiAgICAgICAgY29uc3QgZ3JhZENvbG9yID0gcmFpbmJvd1tNYXRoLmZsb29yKChpIC8gdHJhaWxTZWdtZW50cykgKiByYWluYm93Lmxlbmd0aCldO1xuICAgICAgICB0YWlsQ29sb3JzLnB1c2goKGdyYWRDb2xvciA+PiAxNiAmIDI1NSkgLyAyNTUsIChncmFkQ29sb3IgPj4gOCAmIDI1NSkgLyAyNTUsIChncmFkQ29sb3IgJiAyNTUpIC8gMjU1LCBhbHBoYSk7XG4gICAgICB9XG4gICAgICB0YWlsR2VvLnNldEF0dHJpYnV0ZSgnY29sb3InLCBuZXcgVEhSRUUuRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSh0YWlsQ29sb3JzLCA0KSk7XG4gICAgICAvLyBBZGRpdGl2ZSBibGVuZGluZyBmb3IgZ2xvd1xuICAgICAgY29uc3QgdGFpbE1hdCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCh7IHZlcnRleENvbG9yczogdHJ1ZSwgdHJhbnNwYXJlbnQ6IHRydWUsIG9wYWNpdHk6IDEuMCwgYmxlbmRpbmc6IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmcgfSk7XG4gICAgICBjb25zdCB0YWlsID0gbmV3IFRIUkVFLkxpbmUodGFpbEdlbywgdGFpbE1hdCk7XG4gICAgICB0YWlsLnBvc2l0aW9uLmNvcHkoc3Rhci5wb3NpdGlvbik7XG4gICAgICAvLyBBZGQgdG8gc2NlbmVcbiAgICAgIHNjZW5lLmFkZChzdGFyKTtcbiAgICAgIHNjZW5lLmFkZCh0YWlsKTtcbiAgICAgIHNob290aW5nU3RhcnMucHVzaCh7IG1lc2g6IHN0YXIsIHRhaWwsIHZlbG9jaXR5OiBzdGFyLnZlbG9jaXR5LCBkaXIsIGFnZTogMCwgbm9ybWFsaXplZExpZmV0aW1lOiBzdGFyLm5vcm1hbGl6ZWRMaWZldGltZSwgdHJhaWxQb2ludHMsIGNvbG9yLCBicmlnaHRuZXNzLCBoYXNGcmFnbWVudGVkOiBmYWxzZSB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBhbmltYXRlID0gKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcbiAgICAgIC8vIE9jY2FzaW9uYWxseSBzcGF3biBhIG5lYnVsYSBjbG91ZFxuICAgICAgLy8gREVWOiBTcGF3biBhIGxvdCBvZiBuZWJ1bGFlIGZvciB0ZXN0aW5nXG4gICAgICBpZiAoTWF0aC5yYW5kb20oKSA8IDAuMjUgJiYgbmVidWxhQ2xvdWRzLmxlbmd0aCA8IDMwKSB7XG4gICAgICAgIHNwYXduTmVidWxhQ2xvdWQoKTtcbiAgICAgIH1cbiAgICAgIC8vIEFuaW1hdGUgbmVidWxhIGNsb3Vkc1xuICAgICAgZm9yIChsZXQgaSA9IG5lYnVsYUNsb3Vkcy5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgY2xvdWQgPSBuZWJ1bGFDbG91ZHNbaV07XG4gICAgICAgIGNsb3VkLmFnZSsrO1xuICAgICAgICAvLyBGYWRlIGluXG4gICAgICAgIGlmIChjbG91ZC5mYWRlSW4gJiYgY2xvdWQuc3ByaXRlLm1hdGVyaWFsLm9wYWNpdHkgPCAwLjU1KSB7XG4gICAgICAgICAgY2xvdWQuc3ByaXRlLm1hdGVyaWFsLm9wYWNpdHkgKz0gMC4wMDk7XG4gICAgICAgICAgaWYgKGNsb3VkLnNwcml0ZS5tYXRlcmlhbC5vcGFjaXR5ID49IDAuNTUpIGNsb3VkLmZhZGVJbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZhZGUgb3V0XG4gICAgICAgIGlmIChjbG91ZC5hZ2UgPiBjbG91ZC5saWZldGltZSAqIDAuNykge1xuICAgICAgICAgIGNsb3VkLmZhZGVPdXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbG91ZC5mYWRlT3V0KSB7XG4gICAgICAgICAgY2xvdWQuc3ByaXRlLm1hdGVyaWFsLm9wYWNpdHkgLT0gMC4wMDY7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHdoZW4gZnVsbHkgZmFkZWRcbiAgICAgICAgaWYgKGNsb3VkLnNwcml0ZS5tYXRlcmlhbC5vcGFjaXR5IDw9IDApIHtcbiAgICAgICAgICBzY2VuZS5yZW1vdmUoY2xvdWQuc3ByaXRlKTtcbiAgICAgICAgICBuZWJ1bGFDbG91ZHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNsb3cgZHJpZnQgYW5kIHJvdGF0aW9uXG4gICAgICAgIGNsb3VkLnNwcml0ZS5wb3NpdGlvbi54ICs9IE1hdGguc2luKGNsb3VkLmFnZSowLjAwMSArIGkpICogMC4wOTtcbiAgICAgICAgY2xvdWQuc3ByaXRlLnBvc2l0aW9uLnkgKz0gTWF0aC5jb3MoY2xvdWQuYWdlKjAuMDAxMiAtIGkpICogMC4wNztcbiAgICAgICAgY2xvdWQuc3ByaXRlLm1hdGVyaWFsLnJvdGF0aW9uICs9IGNsb3VkLnJvdFNwZWVkO1xuICAgICAgICAvLyBBbmltYXRlIGNvbG9yIGdlbnRseVxuICAgICAgICBjbG91ZC5zcHJpdGUubWF0ZXJpYWwuY29sb3Iub2Zmc2V0SFNMKDAuMDAwNypNYXRoLnNpbihjbG91ZC5hZ2UqMC4wMDA3K2kpLCAwLCAwKTtcbiAgICAgIH1cbiAgICAgIGNhbWVyYS5yb3RhdGlvbi55ICs9ICh0YXJnZXRZIC0gY2FtZXJhLnJvdGF0aW9uLnkpICogZGFtcGluZztcbiAgICAgIC8vIE1vdmUgdGhlIHZpcnR1YWwgY2FtZXJhIHBvc2l0aW9uIGluIHRoZSBkaXJlY3Rpb24gdGhlIGNhbWVyYSBpcyBmYWNpbmdcbiAgICAgIGNvbnN0IGZvcndhcmQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgY2FtZXJhLmdldFdvcmxkRGlyZWN0aW9uKGZvcndhcmQpO1xuICAgICAgdmlydHVhbENhbWVyYVBvcy5hZGQoZm9yd2FyZC5tdWx0aXBseVNjYWxhcihzdGFyU3BlZWQpKTtcbiAgICAgIC8vIE9mZnNldCBhbGwgc3RhcnMgYnkgLXZpcnR1YWxDYW1lcmFQb3MgKGZsb2F0aW5nIG9yaWdpbilcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXlbaV0gPSBwb3NpdGlvbnNbaV0gLSB2aXJ0dWFsQ2FtZXJhUG9zLng7XG4gICAgICAgIGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXlbaSsxXSA9IHBvc2l0aW9uc1tpKzFdIC0gdmlydHVhbENhbWVyYVBvcy55O1xuICAgICAgICBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5W2krMl0gPSBwb3NpdGlvbnNbaSsyXSAtIHZpcnR1YWxDYW1lcmFQb3MuejtcbiAgICAgIH1cbiAgICAgIGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICAvLyAtLS0gU2hvb3Rpbmcgc3RhciBzcGF3bmluZyAtLS1cbiAgICAgIC8vIERFVjogTWFrZSBzaG9vdGluZyBzdGFycyBzdXBlciBjb21tb24gKHNwYXduIGV2ZXJ5IGZyYW1lIGlmIGNvb2xkb3duIGFsbG93cylcbiAgICAgIGlmIChzaG9vdGluZ1N0YXJDb29sZG93biA8PSAwICYmIE1hdGgucmFuZG9tKCkgPCAwLjEpIHsgLy8gU2hvb3RpbmcgU3RhciBTcGF3biBSYXRlICh0aHJvdHRsZWQpXG4gICAgICAgIHNwYXduU2hvb3RpbmdTdGFyKCk7XG4gICAgICAgIC8vIFN1YnRsZSBjYW1lcmEgc2hha2Ugd2hlbiBhIHNob290aW5nIHN0YXIgYXBwZWFyc1xuICAgICAgICBpZiAoY2FtZXJhKSB7XG4gICAgICAgICAgY29uc3Qgc2hha2VTdHJlbmd0aCA9IDAuMDYgKyBNYXRoLnJhbmRvbSgpKjAuMDQ7XG4gICAgICAgICAgY2FtZXJhLnBvc2l0aW9uLnggKz0gKE1hdGgucmFuZG9tKCktMC41KSpzaGFrZVN0cmVuZ3RoO1xuICAgICAgICAgIGNhbWVyYS5wb3NpdGlvbi55ICs9IChNYXRoLnJhbmRvbSgpLTAuNSkqc2hha2VTdHJlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBzaG9vdGluZ1N0YXJDb29sZG93biA9IDEwICsgTWF0aC5yYW5kb20oKSAqIDEwOyAvLyBMb25nZXIgY29vbGRvd24gZm9yIHBlcmZcbiAgICAgIH0gZWxzZSBpZiAoc2hvb3RpbmdTdGFyQ29vbGRvd24gPiAwKSB7XG4gICAgICAgIHNob290aW5nU3RhckNvb2xkb3duLS07XG4gICAgICB9XG4gICAgICAvLyBBbmltYXRlIGFuZCBjbGVhbiB1cCBzaG9vdGluZyBzdGFyc1xuICAgICAgZm9yIChsZXQgaSA9IHNob290aW5nU3RhcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3Qgb2JqID0gc2hvb3RpbmdTdGFyc1tpXTtcbiAgICAgICAgLy8gQW5pbWF0ZSBzcGFyayBidXJzdCAoZmFkZSBhbmQgZXhwYW5kKVxuICAgICAgICBpZiAob2JqLm1lc2guY2hpbGRyZW4pIHtcbiAgICAgICAgICBjb25zdCBzcGFya3MgPSBvYmoubWVzaC5jaGlsZHJlbi5maW5kKGNoaWxkID0+IGNoaWxkLm5hbWUgPT09ICdzcGFya0J1cnN0Jyk7XG4gICAgICAgICAgaWYgKHNwYXJrcykge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzcGFya3MuY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgY29uc3Qgc3BhcmsgPSBzcGFya3MuY2hpbGRyZW5bal07XG4gICAgICAgICAgICAgIHNwYXJrLm1hdGVyaWFsLm9wYWNpdHkgKj0gMC45NjsgLy8gRmFkZVxuICAgICAgICAgICAgICBzcGFyay5zY2FsZS5tdWx0aXBseVNjYWxhcigxLjAzKTsgLy8gRXhwYW5kXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFuaW1hdGUgdGFpbCBzaGltbWVyIGFuZCBjb2xvciBjeWNsaW5nXG4gICAgICAgIGlmIChvYmoudGFpbCAmJiBvYmoudHJhaWxQb2ludHMpIHtcbiAgICAgICAgICBjb25zdCB0aW1lID0gcGVyZm9ybWFuY2Uubm93KCkgKiAwLjAwMTtcbiAgICAgICAgICBjb25zdCB0YWlsR2VvID0gb2JqLnRhaWwuZ2VvbWV0cnk7XG4gICAgICAgICAgY29uc3QgdGFpbENvbG9ycyA9IHRhaWxHZW8uZ2V0QXR0cmlidXRlKCdjb2xvcicpO1xuICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgdGFpbENvbG9ycy5jb3VudDsgaysrKSB7XG4gICAgICAgICAgICAvLyBDeWNsZSBodWVcbiAgICAgICAgICAgIGxldCByID0gdGFpbENvbG9ycy5nZXRYKGspLCBnID0gdGFpbENvbG9ycy5nZXRZKGspLCBiID0gdGFpbENvbG9ycy5nZXRaKGspO1xuICAgICAgICAgICAgLy8gQ29udmVydCB0byBIU0xcbiAgICAgICAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KHIsZyxiKSwgbWluID0gTWF0aC5taW4ocixnLGIpO1xuICAgICAgICAgICAgbGV0IGgscyxsO1xuICAgICAgICAgICAgbCA9IChtYXgrbWluKS8yO1xuICAgICAgICAgICAgaWYgKG1heCA9PT0gbWluKSB7aCA9IHMgPSAwO30gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnN0IGQgPSBtYXgtbWluO1xuICAgICAgICAgICAgICBzID0gbCA+IDAuNSA/IGQvKDItbWF4LW1pbikgOiBkLyhtYXgrbWluKTtcbiAgICAgICAgICAgICAgc3dpdGNoKG1heCl7XG4gICAgICAgICAgICAgICAgY2FzZSByOiBoID0gKGctYikvZCArIChnPGI/NjowKTsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBnOiBoID0gKGItcikvZCArIDI7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgYjogaCA9IChyLWcpL2QgKyA0OyBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBoLz02O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaCA9IChoICsgMC4yNSpNYXRoLnNpbih0aW1lICsgayowLjIpKSAlIDEuMDsgLy8gQW5pbWF0ZSBodWVcbiAgICAgICAgICAgIC8vIENvbnZlcnQgYmFjayB0byBSR0JcbiAgICAgICAgICAgIGxldCBxID0gbCA8IDAuNSA/IGwqKDErcykgOiBsK3MtbCpzO1xuICAgICAgICAgICAgbGV0IHAgPSAyKmwtcTtcbiAgICAgICAgICAgIGxldCB0ciA9IGgrMS8zLCB0ZyA9IGgsIHRiID0gaC0xLzM7XG4gICAgICAgICAgICBjb25zdCBodWUycmdiID0gKHAscSx0KSA9PiB7XG4gICAgICAgICAgICAgIGlmICh0PDApIHQrPTE7IGlmICh0PjEpIHQtPTE7XG4gICAgICAgICAgICAgIGlmICh0PDEvNikgcmV0dXJuIHArKHEtcCkqNip0O1xuICAgICAgICAgICAgICBpZiAodDwxLzIpIHJldHVybiBxO1xuICAgICAgICAgICAgICBpZiAodDwyLzMpIHJldHVybiBwKyhxLXApKigyLzMtdCkqNjtcbiAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGFpbENvbG9ycy5zZXRYKGssIGh1ZTJyZ2IocCxxLHRyKSk7XG4gICAgICAgICAgICB0YWlsQ29sb3JzLnNldFkoaywgaHVlMnJnYihwLHEsdGcpKTtcbiAgICAgICAgICAgIHRhaWxDb2xvcnMuc2V0WihrLCBodWUycmdiKHAscSx0YikpO1xuICAgICAgICAgICAgLy8gU2hpbW1lcjogbW9kdWxhdGUgYWxwaGFcbiAgICAgICAgICAgIHRhaWxDb2xvcnMuc2V0VyhrLCB0YWlsQ29sb3JzLmdldFcoaykgKiAoMC45NyArIDAuMDMqTWF0aC5zaW4odGltZSo4ICsgaykpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGFpbENvbG9ycy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RyYWlnaHQtbGluZSB0cmFqZWN0b3J5XG4gICAgICAgIG9iai5tZXNoLnBvc2l0aW9uLmFkZChvYmoudmVsb2NpdHkpO1xuICAgICAgICBvYmoudGFpbC5wb3NpdGlvbi5jb3B5KG9iai5tZXNoLnBvc2l0aW9uKTtcbiAgICAgICAgLy8gQW5pbWF0ZSB0YWlsIChubyBsZXJwLCBqdXN0IGRyYWcpXG4gICAgICAgIG9iai5hZ2UrKztcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZExpZmUgPSBvYmouYWdlIC8gb2JqLm5vcm1hbGl6ZWRMaWZldGltZTtcbiAgICAgICAgb2JqLnRyYWlsUG9pbnRzLnVuc2hpZnQob2JqLm1lc2gucG9zaXRpb24uY2xvbmUoKSk7XG4gICAgICAgIGlmIChvYmoudHJhaWxQb2ludHMubGVuZ3RoID4gdGFpbExlbmd0aCAqIDMpIG9iai50cmFpbFBvaW50cy5wb3AoKTtcbiAgICAgICAgbGV0IHRhaWxHcm93ID0gTWF0aC5taW4oMSwgbm9ybWFsaXplZExpZmUgLyAwLjMpO1xuICAgICAgICBsZXQgYWN0aXZlU2VnbWVudHMgPSBNYXRoLmZsb29yKG9iai50cmFpbFBvaW50cy5sZW5ndGggKiB0YWlsR3Jvdyk7XG4gICAgICAgIGlmIChhY3RpdmVTZWdtZW50cyA8IDIpIGFjdGl2ZVNlZ21lbnRzID0gMjtcbiAgICAgICAgY29uc3QgdmlzaWJsZVRyYWlsID0gb2JqLnRyYWlsUG9pbnRzLnNsaWNlKDAsIGFjdGl2ZVNlZ21lbnRzKTtcbiAgICAgICAgb2JqLnRhaWwuZ2VvbWV0cnkuc2V0RnJvbVBvaW50cyh2aXNpYmxlVHJhaWwpO1xuICAgICAgICBjb25zdCB0YWlsQ29sb3JzID0gb2JqLnRhaWwuZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCdjb2xvcicpO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZpc2libGVUcmFpbC5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGxldCBhbHBoYSA9ICgxIC0gaiAvICh2aXNpYmxlVHJhaWwubGVuZ3RoIC0gMSkpICogMC45NTtcbiAgICAgICAgICBhbHBoYSAqPSAwLjkyICsgMC4wOCAqIE1hdGguc2luKERhdGUubm93KCkqMC4wMTUgKyBqKjAuNSk7XG4gICAgICAgICAgbGV0IHJhaW5ib3cgPSBbMHhmZmMwODAsIDB4ZmZlMDgwLCAweGZmZmY4MCwgMHg4MGZmZTYsIDB4ODBjMGZmLCAweGMwODBmZl07XG4gICAgICAgICAgbGV0IGdyYWRDb2xvciA9IHJhaW5ib3dbaiAlIHJhaW5ib3cubGVuZ3RoXTtcbiAgICAgICAgICBpZiAobm9ybWFsaXplZExpZmUgPiAwLjcpIGFscGhhICo9IE1hdGgubWF4KDAsIDEgLSAobm9ybWFsaXplZExpZmUgLSAwLjcgLSAwLjIpIC8gMC4zKTtcbiAgICAgICAgICB0YWlsQ29sb3JzLnNldFhZWlcoaiwgKGdyYWRDb2xvciA+PiAxNiAmIDI1NSkgLyAyNTUsIChncmFkQ29sb3IgPj4gOCAmIDI1NSkgLyAyNTUsIChncmFkQ29sb3IgJiAyNTUpIC8gMjU1LCBhbHBoYSk7XG4gICAgICAgIH1cbiAgICAgICAgdGFpbENvbG9ycy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIC8vIEFuaW1hdGUgaGVhZFxuICAgICAgICBsZXQgaGVhZENvbG9yO1xuICAgICAgICBpZiAobm9ybWFsaXplZExpZmUgPCAwLjUpIHtcbiAgICAgICAgICBoZWFkQ29sb3IgPSBuZXcgVEhSRUUuQ29sb3Iob2JqLmNvbG9yKS5sZXJwKG5ldyBUSFJFRS5Db2xvcigweGZmYzA4MCksIG5vcm1hbGl6ZWRMaWZlKjIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhlYWRDb2xvciA9IG5ldyBUSFJFRS5Db2xvcigweGZmYzA4MCkubGVycChuZXcgVEhSRUUuQ29sb3IoMHhmZjQwMDApLCAobm9ybWFsaXplZExpZmUtMC41KSoyKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZmxpY2tlciA9IDAuOTUgKyAwLjEzICogTWF0aC5zaW4oRGF0ZS5ub3coKSowLjA3ICsgTWF0aC5yYW5kb20oKSoxMCk7XG4gICAgICAgIGhlYWRDb2xvci5tdWx0aXBseVNjYWxhcihmbGlja2VyKTtcbiAgICAgICAgb2JqLm1lc2gubWF0ZXJpYWwuY29sb3IuY29weShoZWFkQ29sb3IpO1xuICAgICAgICBsZXQgc2NhbGUgPSAxICsgMi4yICogTWF0aC5zaW4oTWF0aC5QSSAqIG5vcm1hbGl6ZWRMaWZlKTtcbiAgICAgICAgbGV0IGRpc3RUb0NhbSA9IG9iai5tZXNoLnBvc2l0aW9uLmxlbmd0aCgpO1xuICAgICAgICBsZXQgZG9mQmx1ciA9IGRpc3RUb0NhbSA8IHN0YXJNYXhEaXN0YW5jZSAqIDAuNyA/IDAuNyA6IDEuMDtcbiAgICAgICAgb2JqLm1lc2guc2NhbGUuc2V0KHNjYWxlICogZG9mQmx1ciwgc2NhbGUgKiBkb2ZCbHVyLCBzY2FsZSAqIGRvZkJsdXIpO1xuICAgICAgICAvLyBTcGFya2xlIGJ1cnN0XG4gICAgICAgIGlmIChub3JtYWxpemVkTGlmZSA+PSAxICYmICFvYmouaGFzRnJhZ21lbnRlZCkge1xuICAgICAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgOTsgcysrKSB7XG4gICAgICAgICAgICBjb25zdCBzcGFya2xlR2VvID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KDAuNyArIE1hdGgucmFuZG9tKCkqMC44LCA4LCA4KTtcbiAgICAgICAgICAgIGNvbnN0IHNwYXJrbGVNYXQgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoeyBjb2xvcjogMHhmZmZmZmYsIHRyYW5zcGFyZW50OiB0cnVlLCBvcGFjaXR5OiAwLjcsIGJsZW5kaW5nOiBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nIH0pO1xuICAgICAgICAgICAgY29uc3Qgc3BhcmtsZSA9IG5ldyBUSFJFRS5NZXNoKHNwYXJrbGVHZW8sIHNwYXJrbGVNYXQpO1xuICAgICAgICAgICAgc3BhcmtsZS5wb3NpdGlvbi5jb3B5KG9iai5tZXNoLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IHNwYXJrbGVWZWwgPSBuZXcgVEhSRUUuVmVjdG9yMyhNYXRoLnJhbmRvbSgpLTAuNSwgTWF0aC5yYW5kb20oKS0wLjUsIE1hdGgucmFuZG9tKCktMC41KS5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhcigyK01hdGgucmFuZG9tKCkqMik7XG4gICAgICAgICAgICBzcGFya2xlLnVzZXJEYXRhID0geyB2ZWxvY2l0eTogc3BhcmtsZVZlbCwgYWdlOiAwIH07XG4gICAgICAgICAgICBzY2VuZS5hZGQoc3BhcmtsZSk7XG4gICAgICAgICAgICBpZiAoIXdpbmRvdy5fc3BhcmtsZXMpIHdpbmRvdy5fc3BhcmtsZXMgPSBbXTtcbiAgICAgICAgICAgIHdpbmRvdy5fc3BhcmtsZXMucHVzaChzcGFya2xlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZnJhZ1ZlbCA9IG9iai52ZWxvY2l0eS5jbG9uZSgpLmFwcGx5QXhpc0FuZ2xlKG5ldyBUSFJFRS5WZWN0b3IzKDAsMSwwKSwgKE1hdGgucmFuZG9tKCktMC41KSowLjMpO1xuICAgICAgICAgIGNvbnN0IGZyYWdTdGFyID0gb2JqLm1lc2guY2xvbmUoKTtcbiAgICAgICAgICBmcmFnU3Rhci5wb3NpdGlvbi5jb3B5KG9iai5tZXNoLnBvc2l0aW9uKTtcbiAgICAgICAgICBmcmFnU3Rhci52ZWxvY2l0eSA9IGZyYWdWZWw7XG4gICAgICAgICAgZnJhZ1N0YXIubm9ybWFsaXplZExpZmUgPSBub3JtYWxpemVkTGlmZTtcbiAgICAgICAgICBmcmFnU3Rhci5ub3JtYWxpemVkTGlmZXRpbWUgPSBvYmoubm9ybWFsaXplZExpZmV0aW1lICogKDAuNSArIE1hdGgucmFuZG9tKCkqMC41KTtcbiAgICAgICAgICBmcmFnU3Rhci5hZ2UgPSBvYmouYWdlO1xuICAgICAgICAgIGZyYWdTdGFyLm1hdGVyaWFsID0gb2JqLm1lc2gubWF0ZXJpYWwuY2xvbmUoKTtcbiAgICAgICAgICBjb25zdCBmcmFnVHJhaWxQb2ludHMgPSBvYmoudHJhaWxQb2ludHMuc2xpY2UoKTtcbiAgICAgICAgICBjb25zdCBmcmFnVGFpbEdlbyA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpLnNldEZyb21Qb2ludHMoZnJhZ1RyYWlsUG9pbnRzKTtcbiAgICAgICAgICBmcmFnVGFpbEdlby5zZXRBdHRyaWJ1dGUoJ2NvbG9yJywgb2JqLnRhaWwuZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCdjb2xvcicpLmNsb25lKCkpO1xuICAgICAgICAgIGNvbnN0IGZyYWdUYWlsTWF0ID0gb2JqLnRhaWwubWF0ZXJpYWwuY2xvbmUoKTtcbiAgICAgICAgICBjb25zdCBmcmFnVGFpbCA9IG5ldyBUSFJFRS5MaW5lKGZyYWdUYWlsR2VvLCBmcmFnVGFpbE1hdCk7XG4gICAgICAgICAgZnJhZ1RhaWwucG9zaXRpb24uY29weShmcmFnU3Rhci5wb3NpdGlvbik7XG4gICAgICAgICAgc2NlbmUuYWRkKGZyYWdTdGFyKTtcbiAgICAgICAgICBzY2VuZS5hZGQoZnJhZ1RhaWwpO1xuICAgICAgICAgIHNob290aW5nU3RhcnMucHVzaCh7IG1lc2g6IGZyYWdTdGFyLCB0YWlsOiBmcmFnVGFpbCwgdmVsb2NpdHk6IGZyYWdTdGFyLnZlbG9jaXR5LCBkaXI6IG9iai5kaXIsIGFnZTogZnJhZ1N0YXIuYWdlLCBub3JtYWxpemVkTGlmZXRpbWU6IGZyYWdTdGFyLm5vcm1hbGl6ZWRMaWZldGltZSwgdHJhaWxQb2ludHM6IGZyYWdUcmFpbFBvaW50cywgY29sb3I6IG9iai5jb2xvciwgYnJpZ2h0bmVzczogb2JqLmJyaWdodG5lc3MsIGhhc0ZyYWdtZW50ZWQ6IHRydWUgfSk7XG4gICAgICAgICAgb2JqLmhhc0ZyYWdtZW50ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNwYXJrIGJ1cnN0XG4gICAgICAgIGlmICghb2JqLmhhc1NwYXJrZWQgJiYgbm9ybWFsaXplZExpZmUgPiAwLjk1ICYmIE1hdGgucmFuZG9tKCkgPCAwLjEpIHtcbiAgICAgICAgICBmb3IgKGxldCBzID0gMDsgcyA8IDggKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqOCk7IHMrKykge1xuICAgICAgICAgICAgY29uc3Qgc3BhcmtHZW8gPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoMC41ICsgTWF0aC5yYW5kb20oKSowLjUsIDgsIDgpO1xuICAgICAgICAgICAgY29uc3Qgc3BhcmtNYXQgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoeyBjb2xvcjogMHhmZmY2YzAsIHRyYW5zcGFyZW50OiB0cnVlLCBvcGFjaXR5OiAxLCBibGVuZGluZzogVEhSRUUuQWRkaXRpdmVCbGVuZGluZyB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNwYXJrID0gbmV3IFRIUkVFLk1lc2goc3BhcmtHZW8sIHNwYXJrTWF0KTtcbiAgICAgICAgICAgIHNwYXJrLnBvc2l0aW9uLmNvcHkob2JqLm1lc2gucG9zaXRpb24pO1xuICAgICAgICAgICAgc3Bhcmsuc3BhcmtWZWwgPSBuZXcgVEhSRUUuVmVjdG9yMyhNYXRoLnJhbmRvbSgpLTAuNSwgTWF0aC5yYW5kb20oKS0wLjUsIE1hdGgucmFuZG9tKCktMC41KS5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhcigwLjUgKyBNYXRoLnJhbmRvbSgpKjEuMik7XG4gICAgICAgICAgICBzcGFyay5zcGFya0xpZmUgPSAxMiArIE1hdGgucmFuZG9tKCkqMTA7XG4gICAgICAgICAgICBzcGFyay5zcGFya0FnZSA9IDA7XG4gICAgICAgICAgICBzY2VuZS5hZGQoc3BhcmspO1xuICAgICAgICAgICAgaWYgKCF3aW5kb3cuX3N0YXJTcGFya3MpIHdpbmRvdy5fc3RhclNwYXJrcyA9IFtdO1xuICAgICAgICAgICAgd2luZG93Ll9zdGFyU3BhcmtzLnB1c2goc3BhcmspO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvYmouaGFzU3BhcmtlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmxhc2hcbiAgICAgICAgaWYgKCFvYmouaGFzRmxhc2hlZCAmJiBub3JtYWxpemVkTGlmZSA+IDAuOTggJiYgTWF0aC5yYW5kb20oKSA8IDAuMikge1xuICAgICAgICAgIGNvbnN0IGZsYXNoR2VvID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KDEsIDE2LCAxNik7XG4gICAgICAgICAgY29uc3QgZmxhc2hNYXQgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoeyBjb2xvcjogMHhmZmZmZWUsIHRyYW5zcGFyZW50OiB0cnVlLCBvcGFjaXR5OiAwLjgsIGJsZW5kaW5nOiBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nIH0pO1xuICAgICAgICAgIGNvbnN0IGZsYXNoID0gbmV3IFRIUkVFLk1lc2goZmxhc2hHZW8sIGZsYXNoTWF0KTtcbiAgICAgICAgICBmbGFzaC5wb3NpdGlvbi5jb3B5KG9iai5tZXNoLnBvc2l0aW9uKTtcbiAgICAgICAgICBzY2VuZS5hZGQoZmxhc2gpO1xuICAgICAgICAgIGlmICghd2luZG93Ll9zdGFyRmxhc2hlcykgd2luZG93Ll9zdGFyRmxhc2hlcyA9IFtdO1xuICAgICAgICAgIHdpbmRvdy5fc3RhckZsYXNoZXMucHVzaCh7IG1lc2g6IGZsYXNoLCBhZ2U6IDAgfSk7XG4gICAgICAgICAgb2JqLmhhc0ZsYXNoZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZhZGUgb3V0IGFzIGl0IGdldHMgZmFyIGF3YXlcbiAgICAgICAgY29uc3QgZGlzdCA9IG9iai5tZXNoLnBvc2l0aW9uLmRpc3RhbmNlVG8oY2FtZXJhLnBvc2l0aW9uKTtcbiAgICAgICAgY29uc3QgZmFkZVN0YXJ0ID0gc3Rhck1heERpc3RhbmNlICogMC41O1xuICAgICAgICBpZiAoZGlzdCA+IGZhZGVTdGFydCkge1xuICAgICAgICAgIGNvbnN0IGZhZGUgPSAxIC0gKGRpc3QgLSBmYWRlU3RhcnQpIC8gKHN0YXJNYXhEaXN0YW5jZSAtIGZhZGVTdGFydCk7XG4gICAgICAgICAgb2JqLm1lc2gubWF0ZXJpYWwub3BhY2l0eSA9IE1hdGgubWF4KDAsIGZhZGUpO1xuICAgICAgICAgIG9iai5tZXNoLm1hdGVyaWFsLnRyYW5zcGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgICBvYmoudGFpbC5tYXRlcmlhbC5vcGFjaXR5ID0gTWF0aC5tYXgoMCwgZmFkZSAqIDAuOCk7XG4gICAgICAgICAgb2JqLnRhaWwubWF0ZXJpYWwudHJhbnNwYXJlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSB3aGVuIG91dCBvZiBib3VuZHMgb3IgZnVsbHkgZmFkZWQgb3IgbGlmZSBlbmRlZFxuICAgICAgICBpZiAobm9ybWFsaXplZExpZmUgPj0gMS4wIHx8IGRpc3QgPiBzdGFyTWF4RGlzdGFuY2UgfHwgb2JqLm1lc2gubWF0ZXJpYWwub3BhY2l0eSA8PSAwLjAxKSB7XG4gICAgICAgICAgc2NlbmUucmVtb3ZlKG9iai5tZXNoKTtcbiAgICAgICAgICBzY2VuZS5yZW1vdmUob2JqLnRhaWwpO1xuICAgICAgICAgIHNob290aW5nU3RhcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBBbmltYXRlIHNwYXJrc1xuICAgICAgaWYgKHdpbmRvdy5fc3RhclNwYXJrcykge1xuICAgICAgICBmb3IgKGxldCBpID0gd2luZG93Ll9zdGFyU3BhcmtzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgY29uc3Qgc3BhcmsgPSB3aW5kb3cuX3N0YXJTcGFya3NbaV07XG4gICAgICAgICAgc3BhcmsucG9zaXRpb24uYWRkKHNwYXJrLnNwYXJrVmVsKTtcbiAgICAgICAgICBzcGFyay5zcGFya0FnZSsrO1xuICAgICAgICAgIHNwYXJrLm1hdGVyaWFsLm9wYWNpdHkgKj0gMC44NTtcbiAgICAgICAgICBpZiAoc3Bhcmsuc3BhcmtBZ2UgPiBzcGFyay5zcGFya0xpZmUpIHtcbiAgICAgICAgICAgIHNjZW5lLnJlbW92ZShzcGFyayk7XG4gICAgICAgICAgICB3aW5kb3cuX3N0YXJTcGFya3Muc3BsaWNlKGksIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQW5pbWF0ZSBmbGFzaGVzXG4gICAgICBpZiAod2luZG93Ll9zdGFyRmxhc2hlcykge1xuICAgICAgICBmb3IgKGxldCBpID0gd2luZG93Ll9zdGFyRmxhc2hlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGNvbnN0IGZsYXNoID0gd2luZG93Ll9zdGFyRmxhc2hlc1tpXTtcbiAgICAgICAgICBmbGFzaC5tZXNoLnNjYWxlLm11bHRpcGx5U2NhbGFyKDEuMTUpO1xuICAgICAgICAgIGZsYXNoLm1lc2gubWF0ZXJpYWwub3BhY2l0eSAqPSAwLjg1O1xuICAgICAgICAgIGZsYXNoLmFnZSsrO1xuICAgICAgICAgIGlmIChmbGFzaC5hZ2UgPiAxMCkge1xuICAgICAgICAgICAgc2NlbmUucmVtb3ZlKGZsYXNoLm1lc2gpO1xuICAgICAgICAgICAgd2luZG93Ll9zdGFyRmxhc2hlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIC0tLSBTdGFyZmllbGQgbG9naWMgLS0tXG4gICAgICBjb25zdCBzcURpc3QgPSBzdGFyTWF4RGlzdGFuY2UgKiBzdGFyTWF4RGlzdGFuY2U7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc2l0aW9ucy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICBjb25zdCBkeCA9IHBvc2l0aW9uc1tpXSAtIHZpcnR1YWxDYW1lcmFQb3MueDtcbiAgICAgICAgY29uc3QgZHkgPSBwb3NpdGlvbnNbaSArIDFdIC0gdmlydHVhbENhbWVyYVBvcy55O1xuICAgICAgICBjb25zdCBkeiA9IHBvc2l0aW9uc1tpICsgMl0gLSB2aXJ0dWFsQ2FtZXJhUG9zLno7XG4gICAgICAgIGlmIChkeCpkeCArIGR5KmR5ICsgZHoqZHogPiBzcURpc3QpIHtcbiAgICAgICAgICAvLyBQbGFjZSBpbiBhIHRoaWNrIHNwaGVyaWNhbCBzaGVsbCBhcm91bmQgdGhlIHZpcnR1YWwgY2FtZXJhLCBuZXZlciB0b28gY2xvc2VcbiAgICAgICAgICBjb25zdCBtaW5SYWRpdXMgPSBzdGFyTWF4RGlzdGFuY2UgKiAwLjg7XG4gICAgICAgICAgY29uc3QgbWF4UmFkaXVzID0gc3Rhck1heERpc3RhbmNlO1xuICAgICAgICAgIGNvbnN0IHIgPSBtaW5SYWRpdXMgKyBNYXRoLnJhbmRvbSgpICogKG1heFJhZGl1cyAtIG1pblJhZGl1cyk7XG4gICAgICAgICAgY29uc3QgdGhldGEgPSBNYXRoLnJhbmRvbSgpICogMiAqIE1hdGguUEk7XG4gICAgICAgICAgY29uc3QgcGhpID0gTWF0aC5hY29zKDIgKiBNYXRoLnJhbmRvbSgpIC0gMSk7XG4gICAgICAgICAgcG9zaXRpb25zW2ldID0gdmlydHVhbENhbWVyYVBvcy54ICsgciAqIE1hdGguc2luKHBoaSkgKiBNYXRoLmNvcyh0aGV0YSk7XG4gICAgICAgICAgcG9zaXRpb25zW2krMV0gPSB2aXJ0dWFsQ2FtZXJhUG9zLnkgKyByICogTWF0aC5zaW4ocGhpKSAqIE1hdGguc2luKHRoZXRhKTtcbiAgICAgICAgICBwb3NpdGlvbnNbaSsyXSA9IHZpcnR1YWxDYW1lcmFQb3MueiArIHIgKiBNYXRoLmNvcyhwaGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTsgLy8gQWxyZWFkeSBzZXQgYWJvdmVcblxuICAgICAgLy8gUm9idXN0IHN0YXJmaWVsZCBjb2xvciB1cGRhdGUgdG8gcHJldmVudCBzdHVjayB3aGl0ZSBkb3RzXG4gICAgICBjb25zdCBjb2xBcnIgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLmNvbG9yLmFycmF5O1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3NpdGlvbnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gaSAvIDM7XG4gICAgICAgIGNvbnN0IGR4ID0gcG9zaXRpb25zW2ldIC0gdmlydHVhbENhbWVyYVBvcy54O1xuICAgICAgICBjb25zdCBkeSA9IHBvc2l0aW9uc1tpICsgMV0gLSB2aXJ0dWFsQ2FtZXJhUG9zLnk7XG4gICAgICAgIGNvbnN0IGR6ID0gcG9zaXRpb25zW2kgKyAyXSAtIHZpcnR1YWxDYW1lcmFQb3MuejtcbiAgICAgICAgY29uc3QgZGlzdCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSArIGR6ICogZHopO1xuICAgICAgICBpZiAodGltZXJzW2lkeF0gPiAwKSB7XG4gICAgICAgICAgdGltZXJzW2lkeF0tLTtcbiAgICAgICAgICBpZiAodGltZXJzW2lkeF0gPT09IDApIHtcbiAgICAgICAgICAgIC8vIFRpbWVyIGV4cGlyZWQsIHJlc3RvcmUgY29sb3JcbiAgICAgICAgICAgIHNwYXJrQ29sb3JzW2ldID0gb3JpZ2luYWxDb2xvcnNbaV07XG4gICAgICAgICAgICBzcGFya0NvbG9yc1tpKzFdID0gb3JpZ2luYWxDb2xvcnNbaSsxXTtcbiAgICAgICAgICAgIHNwYXJrQ29sb3JzW2krMl0gPSBvcmlnaW5hbENvbG9yc1tpKzJdO1xuICAgICAgICAgICAgY29sQXJyW2ldID0gb3JpZ2luYWxDb2xvcnNbaV07XG4gICAgICAgICAgICBjb2xBcnJbaSsxXSA9IG9yaWdpbmFsQ29sb3JzW2krMV07XG4gICAgICAgICAgICBjb2xBcnJbaSsyXSA9IG9yaWdpbmFsQ29sb3JzW2krMl07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbEFycltpXSA9IHNwYXJrQ29sb3JzW2ldO1xuICAgICAgICAgICAgY29sQXJyW2krMV0gPSBzcGFya0NvbG9yc1tpKzFdO1xuICAgICAgICAgICAgY29sQXJyW2krMl0gPSBzcGFya0NvbG9yc1tpKzJdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChkaXN0ID4gc3Rhck1heERpc3RhbmNlICogMC4zICYmIE1hdGgucmFuZG9tKCkgPCAwLjA1KSB7XG4gICAgICAgICAgdGltZXJzW2lkeF0gPSBzcGFya2xlRHVyYXRpb247XG4gICAgICAgICAgY29uc3QgYyA9IHBhbGV0dGVbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcGFsZXR0ZS5sZW5ndGgpXTtcbiAgICAgICAgICBzcGFya0NvbG9yc1tpXSA9IGNbMF07XG4gICAgICAgICAgc3BhcmtDb2xvcnNbaSsxXSA9IGNbMV07XG4gICAgICAgICAgc3BhcmtDb2xvcnNbaSsyXSA9IGNbMl07XG4gICAgICAgICAgY29sQXJyW2ldID0gc3BhcmtDb2xvcnNbaV07XG4gICAgICAgICAgY29sQXJyW2krMV0gPSBzcGFya0NvbG9yc1tpKzFdO1xuICAgICAgICAgIGNvbEFycltpKzJdID0gc3BhcmtDb2xvcnNbaSsyXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzcGFya0NvbG9yc1tpXSA9IG9yaWdpbmFsQ29sb3JzW2ldO1xuICAgICAgICAgIHNwYXJrQ29sb3JzW2krMV0gPSBvcmlnaW5hbENvbG9yc1tpKzFdO1xuICAgICAgICAgIHNwYXJrQ29sb3JzW2krMl0gPSBvcmlnaW5hbENvbG9yc1tpKzJdO1xuICAgICAgICAgIGNvbEFycltpXSA9IG9yaWdpbmFsQ29sb3JzW2ldO1xuICAgICAgICAgIGNvbEFycltpKzFdID0gb3JpZ2luYWxDb2xvcnNbaSsxXTtcbiAgICAgICAgICBjb2xBcnJbaSsyXSA9IG9yaWdpbmFsQ29sb3JzW2krMl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3IubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICByZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gRGVmZW5zaXZlOiBsb2cgZXJyb3Igd2l0aCBjb250ZXh0XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1N0YXJmaWVsZCBhbmltYXRpb24gZXJyb3I6JywgZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgYW5pbWF0ZSgpOyAvLyBTdGFydCB0aGUgcmVuZGVyIGxvb3BcblxuICAgIGNvbnN0IG9uUmVzaXplID0gKCkgPT4ge1xuICAgICAgY2FtZXJhLmFzcGVjdCA9IHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAgIHJlbmRlcmVyLnNldFNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25SZXNpemUpXG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIG9uU2Nyb2xsKVxuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uUmVzaXplKVxuICAgICAgbW91bnQucmVtb3ZlQ2hpbGQocmVuZGVyZXIuZG9tRWxlbWVudClcbiAgICB9XG4gIH0sIFtdKVxuXG4gIHJldHVybiA8ZGl2IHJlZj17bW91bnRSZWZ9IC8+XG59XG5cbmV4cG9ydCBkZWZhdWx0IFN0YXJmaWVsZFxuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlRWZmZWN0IiwidXNlUmVmIiwiVEhSRUUiLCJTdGFyZmllbGQiLCJtb3VudFJlZiIsImN1cnJlbnQiLCJtb3VudCIsInN0eWxlIiwicG9zaXRpb24iLCJ0b3AiLCJsZWZ0Iiwid2lkdGgiLCJoZWlnaHQiLCJ6SW5kZXgiLCJzY2VuZSIsIlNjZW5lIiwiY2FtZXJhIiwiUGVyc3BlY3RpdmVDYW1lcmEiLCJ3aW5kb3ciLCJpbm5lcldpZHRoIiwiaW5uZXJIZWlnaHQiLCJzZXQiLCJ2aXJ0dWFsQ2FtZXJhUG9zIiwiVmVjdG9yMyIsInJlbmRlcmVyIiwiV2ViR0xSZW5kZXJlciIsImFudGlhbGlhcyIsInNldFBpeGVsUmF0aW8iLCJkZXZpY2VQaXhlbFJhdGlvIiwic2V0U2l6ZSIsInNldENsZWFyQ29sb3IiLCJhcHBlbmRDaGlsZCIsImRvbUVsZW1lbnQiLCJzdGFyQ291bnQiLCJzdGFyTWF4RGlzdGFuY2UiLCJzdGFyU3BlZWQiLCJnZW9tZXRyeSIsIkJ1ZmZlckdlb21ldHJ5IiwicG9zaXRpb25zIiwic3RhcnNQbGFjZWQiLCJNYXRoIiwicmFuZG9tIiwiY2x1c3RlclRoZXRhIiwiUEkiLCJjbHVzdGVyUGhpIiwiYWNvcyIsImNsdXN0ZXJSIiwiY2x1c3RlckNlbnRlciIsInNpbiIsImNvcyIsImNsdXN0ZXJTaXplIiwiZmxvb3IiLCJjIiwib2Zmc2V0VGhldGEiLCJvZmZzZXRQaGkiLCJvZmZzZXRSIiwicHVzaCIsInRoZXRhIiwicGhpIiwiciIsInNldEF0dHJpYnV0ZSIsIkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUiLCJwYWxldHRlIiwiY29sb3JzIiwiaSIsImxlbmd0aCIsIm9yaWdpbmFsQ29sb3JzIiwiYXR0cmlidXRlcyIsImNvbG9yIiwiYXJyYXkiLCJzbGljZSIsInRpbWVycyIsIkZsb2F0MzJBcnJheSIsInNwYXJrQ29sb3JzIiwic3BhcmtsZUR1cmF0aW9uIiwibWF0ZXJpYWwiLCJQb2ludHNNYXRlcmlhbCIsInNpemUiLCJzaXplQXR0ZW51YXRpb24iLCJ2ZXJ0ZXhDb2xvcnMiLCJzdGFycyIsIlBvaW50cyIsImFkZCIsInRhcmdldFkiLCJkYW1waW5nIiwib25TY3JvbGwiLCJwY3QiLCJzY3JvbGxZIiwiZG9jdW1lbnQiLCJib2R5Iiwic2Nyb2xsSGVpZ2h0IiwiYWRkRXZlbnRMaXN0ZW5lciIsIm5lYnVsYVRleHR1cmVzIiwibmVidWxhQ2xvdWRzIiwic3Bhd25OZWJ1bGFDbG91ZCIsInRleHR1cmVVcmwiLCJ0ZXgiLCJUZXh0dXJlTG9hZGVyIiwibG9hZCIsIkNvbG9yIiwic2V0SFNMIiwibWF0IiwiU3ByaXRlTWF0ZXJpYWwiLCJtYXAiLCJ0cmFuc3BhcmVudCIsIm9wYWNpdHkiLCJkZXB0aFdyaXRlIiwiYmxlbmRpbmciLCJBZGRpdGl2ZUJsZW5kaW5nIiwic3ByaXRlIiwiU3ByaXRlIiwiY2FtRGlyIiwiZ2V0V29ybGREaXJlY3Rpb24iLCJjb3B5IiwibXVsdGlwbHlTY2FsYXIiLCJzY2FsZSIsImNvbnNvbGUiLCJsb2ciLCJhZ2UiLCJmYWRlSW4iLCJmYWRlT3V0IiwibGlmZXRpbWUiLCJyb3RTcGVlZCIsInRhaWxMZW5ndGgiLCJzaG9vdGluZ1N0YXJzIiwic2hvb3RpbmdTdGFyQ29vbGRvd24iLCJzcGF3blNob290aW5nU3RhciIsImRpciIsIm5vcm1hbGl6ZSIsIm1pbkRpc3QiLCJtYXhEaXN0IiwiZGlzdCIsInNwYXduUG9zIiwiY2xvbmUiLCJ0YW5nZW50Iiwic3ViIiwicHJvamVjdE9uVmVjdG9yIiwidGFuZ2VudGlhbFNwZWVkIiwicmFkaWFsU3BlZWQiLCJ2ZWxvY2l0eSIsInZpYnJhbnRDb2xvcnMiLCJicmlnaHRuZXNzIiwiZ2VvIiwiU3BoZXJlR2VvbWV0cnkiLCJNZXNoUGh5c2ljYWxNYXRlcmlhbCIsImVtaXNzaXZlIiwiZW1pc3NpdmVJbnRlbnNpdHkiLCJtZXRhbG5lc3MiLCJyb3VnaG5lc3MiLCJ0cmFuc21pc3Npb24iLCJjbGVhcmNvYXQiLCJjbGVhcmNvYXRSb3VnaG5lc3MiLCJzdGFyIiwiTWVzaCIsInNwcml0ZU1hcCIsInNwcml0ZU1hdGVyaWFsIiwic3BhcmtDb3VudCIsInNwYXJrR3JvdXAiLCJHcm91cCIsInNwYXJrTWF0IiwiTWVzaEJhc2ljTWF0ZXJpYWwiLCJzcGFya0dlbyIsInNwYXJrIiwiYW5nbGUiLCJuYW1lIiwibm9ybWFsaXplZExpZmUiLCJub3JtYWxpemVkTGlmZXRpbWUiLCJ0cmFpbFNlZ21lbnRzIiwidHJhaWxQb2ludHMiLCJzcGlyYWwiLCJjdXJ2ZSIsInB0IiwidGFpbEdlbyIsInNldEZyb21Qb2ludHMiLCJ0YWlsQ29sb3JzIiwiYWxwaGEiLCJyYWluYm93IiwiZ3JhZENvbG9yIiwidGFpbE1hdCIsIkxpbmVCYXNpY01hdGVyaWFsIiwidGFpbCIsIkxpbmUiLCJtZXNoIiwiaGFzRnJhZ21lbnRlZCIsImFuaW1hdGUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjbG91ZCIsInJlbW92ZSIsInNwbGljZSIsIngiLCJ5Iiwicm90YXRpb24iLCJvZmZzZXRIU0wiLCJmb3J3YXJkIiwieiIsIm5lZWRzVXBkYXRlIiwic2hha2VTdHJlbmd0aCIsIm9iaiIsImNoaWxkcmVuIiwic3BhcmtzIiwiZmluZCIsImNoaWxkIiwiaiIsInRpbWUiLCJwZXJmb3JtYW5jZSIsIm5vdyIsImdldEF0dHJpYnV0ZSIsImsiLCJjb3VudCIsImdldFgiLCJnIiwiZ2V0WSIsImIiLCJnZXRaIiwibWF4IiwibWluIiwiaCIsInMiLCJsIiwiZCIsInEiLCJwIiwidHIiLCJ0ZyIsInRiIiwiaHVlMnJnYiIsInQiLCJzZXRYIiwic2V0WSIsInNldFoiLCJzZXRXIiwiZ2V0VyIsInVuc2hpZnQiLCJwb3AiLCJ0YWlsR3JvdyIsImFjdGl2ZVNlZ21lbnRzIiwidmlzaWJsZVRyYWlsIiwiRGF0ZSIsInNldFhZWlciLCJoZWFkQ29sb3IiLCJsZXJwIiwiZmxpY2tlciIsImRpc3RUb0NhbSIsImRvZkJsdXIiLCJzcGFya2xlR2VvIiwic3BhcmtsZU1hdCIsInNwYXJrbGUiLCJzcGFya2xlVmVsIiwidXNlckRhdGEiLCJfc3BhcmtsZXMiLCJmcmFnVmVsIiwiYXBwbHlBeGlzQW5nbGUiLCJmcmFnU3RhciIsImZyYWdUcmFpbFBvaW50cyIsImZyYWdUYWlsR2VvIiwiZnJhZ1RhaWxNYXQiLCJmcmFnVGFpbCIsImhhc1NwYXJrZWQiLCJzcGFya1ZlbCIsInNwYXJrTGlmZSIsInNwYXJrQWdlIiwiX3N0YXJTcGFya3MiLCJoYXNGbGFzaGVkIiwiZmxhc2hHZW8iLCJmbGFzaE1hdCIsImZsYXNoIiwiX3N0YXJGbGFzaGVzIiwiZGlzdGFuY2VUbyIsImZhZGVTdGFydCIsImZhZGUiLCJzcURpc3QiLCJkeCIsImR5IiwiZHoiLCJtaW5SYWRpdXMiLCJtYXhSYWRpdXMiLCJjb2xBcnIiLCJpZHgiLCJzcXJ0IiwicmVuZGVyIiwiZXJyIiwiZXJyb3IiLCJvblJlc2l6ZSIsImFzcGVjdCIsInVwZGF0ZVByb2plY3Rpb25NYXRyaXgiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVtb3ZlQ2hpbGQiLCJkaXYiLCJyZWYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/Starfield.jsx\n"));

/***/ })

});